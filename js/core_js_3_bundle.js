!function(n){var e={};function t(r){if(e[r])return e[r].exports;var a=e[r]={i:r,l:!1,exports:{}};return n[r].call(a.exports,a,a.exports,t),a.l=!0,a.exports}t.m=n,t.c=e,t.d=function(n,e,r){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:r})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var r=Object.create(null);if(t.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)t.d(r,a,function(e){return n[e]}.bind(null,a));return r},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=33)}([function(n,e){n.exports=function(n){function e(n){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",n)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(n):"undefined"!=typeof eval?eval.call(null,n):e("EvalError: No eval function available")}catch(n){e(n)}}},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(n,e,t){"use strict";t.r(e);t(34),t(36),t(38),t(40),t(42),t(44),t(46),t(48),t(50),t(52),t(54),t(56),t(58),t(60),t(62),t(64),t(66),t(68),t(70),t(72),t(74),t(76),t(78),t(80),t(82),t(84),t(86),t(88),t(90),t(92),t(94),t(96),t(98),t(100),t(102),t(104),t(106),t(108),t(110),t(112),t(114),t(116),t(118),t(120),t(122),t(124),t(126),t(128),t(130),t(132),t(134),t(136),t(138),t(140),t(142),t(144),t(146),t(148),t(150),t(152),t(154),t(156),t(158),t(160),t(162),t(164),t(166),t(168),t(170),t(172),t(174)},function(n,e,t){t(0)(t(35))},function(n,e){n.exports="/* globals TEMPLATE_MANANGER, NAVIGATION_SVG_ICONS, Mustache, NavigationProxy */\n\n/**\n * NavigationControl\n * @author Adam Fox\n */\n\nvar global = this;\n\nif (global.$ === undefined) {\n  console.log('ERROR: jQuery not found!');\n}\n// Singleton\nglobal.NavigationControl = (function($, Action) {\n  /**\n  * NavigationControl\n  * @constructor\n  * @param {object} attributes\n  */\n  function NavigationControl(attributes) {\n    var me = this;\n    me.id = '';\n    me.type = '';\n    me.label = '';\n    me.index = 0;\n    me.extra = '';\n    me.link = '';\n    me.partial = '';\n    me.position = 0;\n    me.visible = true;\n    me.defaultItem = false;\n    me.alternative = {\n      partial: '',\n      label: '',\n      svgId: ''\n    };\n    me.additionalData = {};\n    me.actions = [];\n    me.$el = null; // jQuery DOM ref!\n\n    if (typeof attributes === 'object') {\n      me.id = attributes.id || me.id;\n      me.type = attributes.type || me.type;\n      me.label = attributes.label || me.label;\n      me.index = attributes.index || me.index;\n      me.extra = attributes.extra || me.extra;\n      me.link = attributes.link || me.link;\n      me.partial = attributes.partial || me.partial;\n      me.position = attributes.position || me.position;\n      me.visible = attributes.visible === undefined ? me.visible : attributes.visible;\n      me.defaultItem = attributes.defaultItem || me.defaultItem;\n      if (attributes.alternative !== undefined) {\n        me.alternative.partial = attributes.alternative.partial || me.alternative.partial;\n        me.alternative.label = attributes.alternative.label || me.alternative.label;\n        me.alternative.svgId = attributes.alternative.svgId || me.alternative.svgId;\n      }\n\n      me.additionalData = attributes.additionalData || me.additionalData;\n\n      me.$el = attributes.$el || me.$el;\n    }\n  }\n\n  /**\n   * Extend the NavigationControl\n   */\n  NavigationControl.prototype = {\n    render: function() {\n      var me = this;\n      var partial = TEMPLATE_MANANGER.getTemplate(me.partial).htmData;\n\n      if (typeof NAVIGATION_SVG_ICONS !== 'undefined' && NAVIGATION_SVG_ICONS) {\n        var svgUseSpriteSheet = TEMPLATE_MANANGER.getTemplate('navSvgIconC').htmData;\n        var svgUseAlternativeSpriteSheet =\n          TEMPLATE_MANANGER.getTemplate('navAlternativeSvgIconC').htmData;\n        // Replace span tags with SVG. This is to support browsers/apps that crash when they\n        // process an SVG tag\n        svgUseSpriteSheet = svgUseSpriteSheet.replace(/span/gi, 'svg');\n        svgUseAlternativeSpriteSheet = svgUseAlternativeSpriteSheet.replace(/span/gi, 'svg');\n        if (partial.indexOf('SVG_ICON') > -1) {\n          if (partial.indexOf('>XX_SVG_ICON_XX') > -1) {\n            // If we've found a reliable parent end tag match, replace it to implement a title for\n            // accessibility\n            partial = partial.replace(\n              />XX_SVG_ICON_XX/g, ' title=\"{{{label}}}\">'+svgUseSpriteSheet\n            );\n          } else {\n            partial = partial.replace(/XX_SVG_ICON_XX/g, svgUseSpriteSheet);\n          }\n\n          // Check if we have the alternative icon svg and use it if we do\n          var svgIcon = svgUseSpriteSheet;\n          if (NavigationProxy.findIconInSvgSpritesheet(me.alternative.svgId)) {\n            svgIcon = svgUseAlternativeSpriteSheet;\n          }\n\n          if (partial.indexOf('>XX_ALTERNATIVE_SVG_ICON_XX') > -1) {\n            partial = partial.replace(\n              />XX_ALTERNATIVE_SVG_ICON_XX/g,\n              ' title=\"{{{alternative.label}}}\">'+svgIcon\n            );\n          } else {\n            partial = partial.replace(\n              /XX_ALTERNATIVE_SVG_ICON_XX/g, svgIcon\n            );\n          }\n        }\n      } else {\n        partial = partial.replace(/XX_SVG_ICON_XX/g, '');\n        partial = partial.replace(/XX_ALTERNATIVE_SVG_ICON_XX/g, '');\n      }\n      return Mustache.render(partial, me);\n    }\n  };\n\n  // Return NavigationControl\n  return NavigationControl;\n})(global.$, global.Action);\n"},function(n,e,t){t(0)(t(37))},function(n,e){n.exports="/**\n * NavigationGroup\n * @author Adam Fox\n */\n\nvar global = this;\n\nif(global.$ === undefined){\n\tconsole.log('ERROR: jQuery not found!');\n}\n\n// Singleton\nglobal.NavigationGroup = (function($){\n\t\n\t/**\n\t * NavigationGroup\n\t * @constructor\n\t */\n\tfunction NavigationGroup(attributes){\n\t\tvar me = this;\n\t\tme.id = '';\n\t\tme.type = '';\n\t\tme.controls = [];\n\t\tif(typeof attributes === 'object'){\n\t\t\tme.id = attributes.id || me.id;\n\t\t\tme.type = attributes.type || me.type;\n\t\t}\n\t};\n\n\t/**\n\t * Extend the NavigationGroup\n\t */\n\tNavigationGroup.prototype = {\n\n\t\t/**\n\t\t * Add to the controls array\n\t\t * @function\n\t\t */\n\t\taddControl: function(button){\n\t\t\tvar me = this;\n\t\t\tme.controls.push(button);\n\t\t},\n\n\t\t/**\n\t\t * Reset the controls array\n\t\t * @function\n\t\t */\n\t\tresetControls: function(){\n\t\t\tvar me = this;\n\t\t\tif(me.controls && Object.prototype.toString.call(me.controls) == '[object Array]'){\n\t\t\t\tme.controls.length = 0;\n\t\t\t} else {\n\t\t\t\tme.controls = [];\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Sort the controls\n\t\t * @function\n\t\t */\n\t\tsortControls: function(controls){\n\t\t\tvar me = this;\n\t\t\tvar sorted = controls.sort(function(a, b){\n\t\t\t\treturn a.position - b.position;\n\t\t\t});\n\t\t\t// Test for zero based indexing...\n\t\t\tif(sorted.length > 1 && sorted[0].position == 0 && sorted[1].position > 0){\n\t\t\t\tfor(var i in sorted){\n\t\t\t\t\tsorted[i].position++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn sorted;\n\t\t},\n\n\t\t/**\n\t\t * Get the controls array\n\t\t * @function\n\t\t */\n\t\tgetControls: function(){\n\t\t\tvar me = this;\n\t\t\t// Return the controls sorted by position.\n\t\t\treturn me.sortControls(me.controls);\n\t\t},\n\n\t\t/**\n\t\t * Get the controls by type!\n\t\t * @function\n\t\t */\n\t\tgetControlsByType: function(type){\n\t\t\tvar me = this;\n\t\t\tvar result = [];\n\t\t\ttype = (type == undefined ? '*' : type);\n\t\t\t// Loop all controls\n\t\t\tfor(var i in me.controls){\n\t\t\t\t// Find controls with matching type\n\t\t\t\tif(type == '*' || me.controls[i].type == type){\n\t\t\t\t\tresult.push(me.controls[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Return the controls sorted by position.\n\t\t\treturn me.sortControls(result);\n\t\t},\n\n\t\t/**\n\t\t * Render the full control list\n\t\t * @function\n\t\t */\n\t\trenderControls: function(options){\n\t\t\tvar me = this;\n\t\t\treturn me.renderControlList(me.getControls(), options);\n\t\t},\n\n\t\t/**\n\t\t * Render controls with a specific type\n\t\t * @function\n\t\t */\n\t\trenderControlsByType: function(type, options){\n\t\t\tvar me = this;\n\t\t\tvar controls = me.getControlsByType(type);\n\t\t\treturn me.renderControlList(controls, options);\n\t\t},\n\n\t\t/** \n\t\t * Renders a list of controls and compiles the html\n\t\t * with spaces if necessary.\n\t\t * @function\n\t\t */\n\t\trenderControlList: function(controls, options){\n\t\t\tvar me = this;\n\t\t\tvar result = [];\n\n\t\t\toptions = options || {};\n\t\t\toptions.spaces = options.spaces || { number:null, filler:null };\n\t\t\toptions.spaces.number = options.spaces.number || 5;\n\t\t\toptions.spaces.filler = options.spaces.filler || '';\n\n\t\t\t// Loop all of the controls\n\t\t\tfor(var i=0; i < controls.length; i++){\n\t\t\t\t// Check the position the control should be in \n\t\t\t\t// and add spaces if necessary.\n\t\t\t\twhile(controls[i].position > result.length + 1){\n\t\t\t\t\tresult.push(options.spaces.filler);\n\t\t\t\t}\n\t\t\t\t// Render the control\n\t\t\t\tresult.push(controls[i].render());\n\t\t\t}\n\n\t\t\t// Add any missing spaces!\n\t\t\twhile(result.length < options.spaces.number){\n\t\t\t\tresult.push(options.spaces.filler);\n\t\t\t}\n\n\t\t\t// Compile all of the html in to a single string\n\t\t\treturn result.join('');\n\t\t}\n\n\t};\n\n\t// Return NavigationGroup\n\treturn NavigationGroup;\n\n})(global.$);"},function(n,e,t){t(0)(t(39))},function(n,e){n.exports="/**\n * Modified version of Porthole.js\n *\n * Changes made by gomo to main source from: \n * @see {@link https://github.com/ternarylabs/porthole}\n * at commit 0102344b92e4995fcd386b880376f67de5e5423c\n *\n * Changes for legacy mode:\n * - `getTargetFrame()` bug\n * - IE8 `JSON.stringify()` bug for empty DOM attributes\n * - set timeout before triggering resize event\n * - added cache buster property to messages\n */\n\n/*\n    Copyright (c) 2011-2012 Ternary Labs. All Rights Reserved.\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in\n    all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n    THE SOFTWARE.\n*/\n\n/*\n# Websequencediagrams.com\nparticipant abc.com\nparticipant \"iFrame proxy xyz.com\"\nparticipant \"iFrame proxy abc.com\"\nparticipant \"iFrame xyz.com\"\nabc.com->iFrame proxy xyz.com: postMessage(data, targetOrigin)\nnote left of \"iFrame proxy xyz.com\": Set url fragment and change size\niFrame proxy xyz.com->iFrame proxy xyz.com: onResize Event\nnote right of \"iFrame proxy xyz.com\": read url fragment\niFrame proxy xyz.com->iFrame xyz.com: forwardMessageEvent(event)\niFrame xyz.com->iFrame proxy abc.com: postMessage(data, targetOrigin)\nnote right of \"iFrame proxy abc.com\": Set url fragment and change size\niFrame proxy abc.com->iFrame proxy abc.com: onResize Event\nnote right of \"iFrame proxy abc.com\": read url fragment\niFrame proxy abc.com->abc.com: forwardMessageEvent(event)\n*/\n\n/* Simple JavaScript Inheritance\n * By John Resig http://ejohn.org/\n * MIT Licensed.\n */\n// Inspired by base2 and Prototype\n(function(){\n    var initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\\b_super\\b/ : /.*/;\n\n    // The base Class implementation (does nothing)\n    this.PortholeClass = function(){};\n\n    // Create a new Class that inherits from this class\n    PortholeClass.extend = function(prop) {\n        var _super = this.prototype;\n\n        // Instantiate a base class (but only create the instance,\n        // don't run the init constructor)\n        initializing = true;\n        var prototype = new this();\n        initializing = false;\n\n        // Copy the properties over onto the new prototype\n        for (var name in prop) {\n            // Check if we're overwriting an existing function\n            prototype[name] = typeof prop[name] == \"function\" &&\n                typeof _super[name] == \"function\" && fnTest.test(prop[name]) ?\n                (function(name, fn){\n                    return function() {\n                        var tmp = this._super;\n\n                        // Add a new ._super() method that is the same method\n                        // but on the super-class\n                        this._super = _super[name];\n\n                        // The method only need to be bound temporarily, so we\n                        // remove it when we're done executing\n                        var ret = fn.apply(this, arguments);\n                        this._super = tmp;\n\n                        return ret;\n                    };\n                })(name, prop[name]) :\n                prop[name];\n        }\n\n        // The dummy class constructor\n        function Class() {\n            // All construction is actually done in the init method\n            if ( !initializing && this.init )\n                this.init.apply(this, arguments);\n        }\n\n        // Populate our constructed prototype object\n        Class.prototype = prototype;\n\n        // Enforce the constructor to be what we expect\n        Class.prototype.constructor = Class;\n\n        // And make this class extendable\n        Class.extend = arguments.callee;\n\n        return Class;\n    };\n})();\n\n(function (window) {\n    'use strict';\n\n    /**\n     * @overview Porthole, JavaScript Library for Secure Cross Domain iFrame Communication.\n     * @author <a href=\"mailto:georges@ternarylabs.com\">Georges Auberger</a>\n     * @copyright 2011-2012 Ternary Labs, All Rights Reserved.\n     *\n     * Namespace for Porthole\n     * @module Porthole\n     */\n    var Porthole = {\n        debug: false,\n\n        /**\n         * Utility function to trace to console\n         * @private\n         */\n        trace: function(s) {\n            if (this.debug && window.console !== undefined) {\n                window.console.log('Porthole: ' + s);\n            }\n        },\n\n        /**\n         * Utility function to send errors to console\n         * @private\n         */\n        error: function(s) {\n            if (window.console !== undefined) {\n                window.console.error('Porthole: ' + s);\n            }\n        }\n    };\n\n    /**\n     * @class\n     * @classdesc Proxy window object to post message to target window\n     * @param {string} proxyIFrameUrl - Fully qualified url to proxy iframe, or null to create a receiver only window\n     * @param {string} targetWindowName - Name of the proxy iframe window\n     */\n    Porthole.WindowProxy = function(){};\n\n    Porthole.WindowProxy.prototype = {\n        /**\n         * Post a message to the target window only if the content comes from the target origin.\n         * <code>targetOrigin</code> can be a url or *\n         * @public\n         * @param {Object} data - Payload\n         * @param {String} targetOrigin\n         */\n        post: function(data, targetOrigin) {},\n        /**\n         * Add an event listener to receive messages.\n         * @public\n         * @param {Function} eventListenerCallback\n         * @returns {Function} eventListenerCallback\n         */\n        addEventListener: function(f) {},\n        /**\n         * Remove an event listener.\n         * @public\n         * @param {Function} eventListenerCallback\n         */\n        removeEventListener: function(f) {}\n    };\n\n    Porthole.WindowProxyBase = PortholeClass.extend({\n        init: function(targetWindowName) {\n            if (targetWindowName === undefined) {\n                targetWindowName = '';\n            }\n            this.targetWindowName = targetWindowName;\n            this.origin = window.location.protocol + '//' + window.location.host;\n            this.eventListeners = [];\n        },\n\n        getTargetWindowName: function() {\n            return this.targetWindowName;\n        },\n\n        getOrigin: function() {\n            return this.origin;\n        },\n\n        /**\n         * Lookup window object based on target window name\n         * @private\n         * @return {string} targetWindow\n         */\n        getTargetWindow: function() {\n            return Porthole.WindowProxy.getTargetWindow(this.targetWindowName);\n        },\n\n        post: function(data, targetOrigin) {\n            if (targetOrigin === undefined) {\n                targetOrigin = '*';\n            }\n            this.dispatchMessage({\n                'data' : data,\n                'sourceOrigin' : this.getOrigin(),\n                'targetOrigin' : targetOrigin,\n                'sourceWindowName' : window.name,\n                'targetWindowName' : this.getTargetWindowName()\n            });\n        },\n\n        addEventListener: function(f) {\n            this.eventListeners.push(f);\n            return f;\n        },\n\n        removeEventListener: function(f) {\n            var index;\n            try {\n                index = this.eventListeners.indexOf(f);\n                this.eventListeners.splice(index, 1);\n            } catch(e) {\n                this.eventListeners = [];\n            }\n        },\n\n        dispatchEvent: function(event) {\n            var i;\n            for (i = 0; i < this.eventListeners.length; i++) {\n                try {\n                    this.eventListeners[i](event);\n                } catch(e) {\n                }\n            }\n        }\n    });\n\n    /**\n     * Legacy browser implementation of proxy window object to post message to target window\n     *\n     * @private\n     * @constructor\n     * @param {string} proxyIFrameUrl - Fully qualified url to proxy iframe\n     * @param {string} targetWindowName - Name of the proxy iframe window\n     */\n    Porthole.WindowProxyLegacy = Porthole.WindowProxyBase.extend({\n        init: function(proxyIFrameUrl, targetWindowName) {\n            this._super(targetWindowName);\n\n            if (proxyIFrameUrl !== null) {\n                this.proxyIFrameName = this.targetWindowName + 'ProxyIFrame';\n                this.proxyIFrameLocation = proxyIFrameUrl;\n\n                // Create the proxy iFrame and add to dom\n                this.proxyIFrameElement = this.createIFrameProxy();\n            } else {\n                // Won't be able to send messages\n                this.proxyIFrameElement = null;\n                Porthole.trace(\"proxyIFrameUrl is null, window will be a receiver only\");\n                this.post = function(){ throw new Error(\"Receiver only window\");};\n            }\n        },\n\n        /**\n         * Create an iframe and load the proxy\n         *\n         * @private\n         * @returns iframe\n         */\n        createIFrameProxy: function() {\n            var iframe = document.createElement('iframe');\n\n            iframe.setAttribute('id', this.proxyIFrameName);\n            iframe.setAttribute('name', this.proxyIFrameName);\n            iframe.setAttribute('src', this.proxyIFrameLocation);\n            // IE needs this otherwise resize event is not fired\n            iframe.setAttribute('frameBorder', '1');\n            iframe.setAttribute('scrolling', 'auto');\n            // Need a certain size otherwise IE7 does not fire resize event\n            iframe.setAttribute('width', 30);\n            iframe.setAttribute('height', 30);\n            iframe.setAttribute('style', 'position: absolute; left: -100px; top:0px;');\n            // IE needs this because setting style attribute is broken. No really.\n            if (iframe.style.setAttribute) {\n                iframe.style.setAttribute('cssText', 'position: absolute; left: -100px; top:0px;');\n            }\n            document.body.appendChild(iframe);\n            return iframe;\n        },\n\n        dispatchMessage: function(message) {\n            var encode = window.encodeURIComponent;\n\n            /**\n             * gomo fix\n             *\n             * Fallback to literal empty string to fix bug in IE8 `JSON.stringify()` where empty \n             * DOM attribute value gives string `null`.\n             *\n             * @see {@link http://stackoverflow.com/questions/13850170/json-stringfy-function-returns-null-when-serializing-empty-dom-element-in-ie8}\n             */\n            message.sourceWindowName = message.sourceWindowName || '';\n            \n            /**\n             * gomo fix\n             *\n             * Add property as a cache buster\n             */\n             message.__cacheBuster = Math.floor(Math.random() * 10000000000000000);\n\n            if (this.proxyIFrameElement) {\n                var src = this.proxyIFrameLocation + '#' + encode(Porthole.WindowProxy.serialize(message));\n                this.proxyIFrameElement.setAttribute('src', src);\n\n                /**\n                 * gomo fix\n                 *\n                 * Use a timeout before triggering the resize to ensure the updated <iframe> `src`\n                 * is picked up in the event listener. \n                 *\n                 * This was an issue testing in Chrome using the legacy mode - admittedly not a\n                 * situation we should ever encounter for real, but adding just in case this could\n                 * ever occur in IE.\n                 */\n                var me = this;\n                setTimeout(function() {\n                  me.proxyIFrameElement.height = me.proxyIFrameElement.height > 50 ? 50 : 100;\n                }, 0);\n            }\n        }\n    });\n\n    /**\n     * Implementation for modern browsers that supports it\n     */\n    Porthole.WindowProxyHTML5 = Porthole.WindowProxyBase.extend({\n        init: function(proxyIFrameUrl, targetWindowName) {\n            this._super(targetWindowName);\n            this.eventListenerCallback = null;\n        },\n\n        dispatchMessage: function(message) {\n            this.getTargetWindow().postMessage(Porthole.WindowProxy.serialize(message), message.targetOrigin);\n        },\n\n        addEventListener: function(f) {\n            if (this.eventListeners.length === 0) {\n                var self = this;\n                if (window.addEventListener) {\n                    this.eventListenerCallback = function(event) { self.eventListener(self, event); };\n                    window.addEventListener('message', this.eventListenerCallback, false);\n                } else if (window.attachEvent) {\n                    // Make IE8 happy, just not that 1. postMessage only works for IFRAMES/FRAMES http://blogs.msdn.com/b/ieinternals/archive/2009/09/16/bugs-in-ie8-support-for-html5-postmessage-sessionstorage-and-localstorage.aspx\n                    this.eventListenerCallback = function(event) { self.eventListener(self, window.event); };\n                    window.attachEvent(\"onmessage\", this.eventListenerCallback);\n                }\n            }\n            return this._super(f);\n        },\n\n        removeEventListener: function(f) {\n            this._super(f);\n\n            if (this.eventListeners.length === 0) {\n                if (window.removeEventListener) {\n                    window.removeEventListener('message', this.eventListenerCallback);\n                } else if (window.detachEvent) { // Make IE8, happy, see above\n                    // see jquery, detachEvent needed property on element, by name of that event, to properly expose it to GC\n                    if (typeof window.onmessage === 'undefined') window.onmessage = null;\n                    window.detachEvent('onmessage', this.eventListenerCallback);\n                }\n                this.eventListenerCallback = null;\n            }\n        },\n\n        eventListener: function(self, nativeEvent) {\n            var data = Porthole.WindowProxy.unserialize(nativeEvent.data);\n            if (data && (self.targetWindowName === '' || data.sourceWindowName == self.targetWindowName)) {\n                self.dispatchEvent(new Porthole.MessageEvent(data.data, nativeEvent.origin, self));\n            }\n        }\n    });\n\n    if (!window.postMessage) {\n        Porthole.trace('Using legacy browser support');\n        Porthole.WindowProxy = Porthole.WindowProxyLegacy.extend({});\n    } else {\n        Porthole.trace('Using built-in browser support');\n        Porthole.WindowProxy = Porthole.WindowProxyHTML5.extend({});\n    }\n\n    /**\n     * Serialize an object using JSON.stringify\n     *\n     * @param {Object} obj The object to be serialized\n     * @return {String}\n     */\n    Porthole.WindowProxy.serialize = function(obj) {\n        if (typeof JSON === 'undefined') {\n            throw new Error('Porthole serialization depends on JSON!');\n        }\n\n        return JSON.stringify(obj);\n    };\n\n    /**\n     * Unserialize using JSON.parse\n     *\n     * @param {String} text Serialization\n     * @return {Object}\n     */\n    Porthole.WindowProxy.unserialize =  function(text) {\n        if (typeof JSON === 'undefined') {\n            throw new Error('Porthole unserialization dependens on JSON!');\n        }\n        try {\n            var json = JSON.parse(text);\n        } catch (e) {\n            return false;\n        }\n        return json;\n    };\n\n    Porthole.WindowProxy.getTargetWindow = function(targetWindowName) {\n        if (targetWindowName === '') {\n            /**\n             * gomo fix\n             *\n             * In legacy mode the processing window will be the proxy <iframe>\n             * contained in the guest <iframe>. Therefore, to pass a message `up`\n             * to the main window the target is `parent.parent`.\n             */\n            return (window.postMessage) ? parent : parent.parent;\n        } else if (targetWindowName === 'top' || targetWindowName === 'parent') {\n            return window[targetWindowName];\n        }\n        /**\n         * gomo fix\n         *\n         * In legacy mode the processing window will be the proxy <iframe>\n         * contained in the main <iframe>. Therefore, to pass a message `down`\n         * to the named window the target is `parent.frames[targetWindowName]`.\n         */\n        return (window.postMessage) ? window.frames[targetWindowName] : parent.frames[targetWindowName];\n    };\n\n    /**\n     * @classdesc Event object to be passed to registered event handlers\n     * @class\n     * @param {String} data\n     * @param {String} origin - url of window sending the message\n     * @param {Object} source - window object sending the message\n     */\n    Porthole.MessageEvent = function MessageEvent(data, origin, source) {\n        this.data = data;\n        this.origin = origin;\n        this.source = source;\n    };\n\n    /**\n     * @classdesc Dispatcher object to relay messages.\n     * @public\n     * @constructor\n     */\n    Porthole.WindowProxyDispatcher = {\n        /**\n         * Forward a message event to the target window\n         * @private\n         */\n        forwardMessageEvent: function(e) {\n            var message,\n                decode = window.decodeURIComponent,\n                targetWindow,\n                windowProxy;\n\n            if (document.location.hash.length > 0) {\n                // Eat the hash character\n                message = Porthole.WindowProxy.unserialize(decode(document.location.hash.substr(1)));\n\n                targetWindow = Porthole.WindowProxy.getTargetWindow(message.targetWindowName);\n\n                windowProxy =\n                    Porthole.WindowProxyDispatcher.findWindowProxyObjectInWindow(\n                        targetWindow,\n                        message.sourceWindowName\n                    );\n\n                if (windowProxy) {\n                    if (windowProxy.origin === message.targetOrigin || message.targetOrigin === '*') {\n                        windowProxy.dispatchEvent(\n                            new Porthole.MessageEvent(message.data, message.sourceOrigin, windowProxy));\n                    } else {\n                        Porthole.error('Target origin ' +\n                            windowProxy.origin +\n                            ' does not match desired target of ' +\n                            message.targetOrigin);\n                    }\n                } else {\n                    Porthole.error('Could not find window proxy object on the target window');\n                }\n            }\n        },\n\n        /**\n         * Look for a window proxy object in the target window\n         * @private\n         */\n        findWindowProxyObjectInWindow: function(w, sourceWindowName) {\n            var i;\n\n            if (w) {\n                for (i in w) {\n                    if (Object.prototype.hasOwnProperty.call(w, i)) {\n                        try {\n                            // Ensure that we're finding the proxy object\n                            // that is declared to be targetting the window that is calling us\n                            if (w[i] !== null &&\n                                typeof w[i] === 'object' &&\n                                w[i] instanceof w.Porthole.WindowProxy &&\n                                w[i].getTargetWindowName() === sourceWindowName) {\n                                return w[i];\n                            }\n                        } catch(e) {\n                            // Swallow exception in case we access an object we shouldn't\n                        }\n                    }\n                }\n            }\n            return null;\n        },\n\n        /**\n         * Start a proxy to relay messages.\n         * @public\n         */\n        start: function() {\n            if (window.addEventListener) {\n                window.addEventListener('resize',\n                    Porthole.WindowProxyDispatcher.forwardMessageEvent,\n                    false);\n            } else if (window.attachEvent && window.postMessage !== 'undefined') {\n                window.attachEvent('onresize',\n                    Porthole.WindowProxyDispatcher.forwardMessageEvent);\n            } else if (document.body.attachEvent) {\n                window.attachEvent('onresize',\n                    Porthole.WindowProxyDispatcher.forwardMessageEvent);\n            } else {\n                // Should never happen\n                Porthole.error('Cannot attach resize event');\n            }\n        }\n    };\n\n    // Support testing in node.js:\n    if (typeof window.exports !== 'undefined') {\n        window.exports.Porthole = Porthole;\n    } else {\n        window.Porthole = Porthole;\n    }\n})(this);"},function(n,e,t){t(0)(t(41))},function(n,e){n.exports='/**\n* SCORM tracking adapter\n* @author Adam Fox\n*/\n\nvar global = this;\n\n// Extends the SCORM adapter...\nglobal.GOMO_SCORM_PORTHOLE = (function(){\n\t\n\tvar sp;\n\n\t/**\n\t * @constructor\n\t */\n\tvar ScormPorthole = function(){\n\t\t// Constructor\n\t};\n\n\tScormPorthole.prototype = {\n\n\t\tid: \'porthole\',\n\t\tversion: \'1.2\',\n\t\tproxy: null,\n\t\tendpoint: \'\',\n\t\tqueue: {},\n\n\t\t/**\n\t\t * @function init\n\t\t * @param endpoint {String}\n\t\t *\n\t\t * Initialise the ScormPortal - create porthole object etc...\n\t\t */\n\t\tinit: function(callback){\n\t\t\tvar me = this;\n\t\t\t// Has to be set on the window...\n\t\t\tme.proxy = window.portholeProxy = new Porthole.WindowProxy(me.endpoint);\n\t\t\tme.proxy.addEventListener(function(){ me.portholeMessage.apply(me, arguments); });\n\t\t\treturn me.portholePost("init", [], callback);\n\t\t},\n\n\t\tget: function(property, callback){\n\t\t\tvar me = this;\n\t\t\treturn me.portholePost("get", [property], callback);\n\t\t},\n\n\t\tset: function(property, val, callback){\n\t\t\tvar me = this;\n\t\t\treturn me.portholePost("set", [property, val], callback);\n\t\t},\n\n\t\tquit: function(callback){\n\t\t\tvar me = this;\n\t\t\treturn me.portholePost("quit", [], callback);\n\t\t},\n\n\t\tsave: function(callback){\n\t\t\tvar me = this;\n\t\t\treturn me.portholePost("save", [], callback);\n\t\t},\n\n\t\tdebug: {\n\t\t\tgetCode: function(callback){\n\t\t\t\tif(sp && sp !== undefined){\n\t\t\t\t\treturn sp.portholePost("debug.getCode", [], callback);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Generate Id\n\t\t */\n\t\tgenerateId: function(){\n\t\t\tfunction s4() {\n\t\t\t\treturn Math.floor((1 + Math.random()) * 0x10000)\n\t\t\t  \t\t.toString(16)\n\t\t\t  \t\t.substring(1);\n\t\t\t}\n\t\t\treturn s4() + s4() + \'-\' + s4() + \'-\' + s4() + \'-\' +\n\t\t\ts4() + \'-\' + s4() + s4() + s4();\n\t\t},\n\n\t\tportholePost: function(method, args, callback){\n\t\t\tvar me = this;\n\t\t\targs = args || [];\n\t\t\tvar id = me.generateId();\n\t\t\tme.queue[id] = callback;\n\t\t\treturn me.proxy.post({\n\t\t\t\t"id":  id,\n\t\t\t\t"method": method, \n\t\t\t\t"args": args,\n\t\t\t\t"version": me.version,\n\t\t\t\t"type": "scorm"\n\t\t\t});\n\t\t},\n\n\t\t/**\n\t\t * @function portholeMessage\n\t\t * @param message\n\t\t */\n\t\tportholeMessage: function(message){\n\t\t\tvar me = this;\n\t\t\t//console.log(\'Porthole id: \' + message.data.id);\n\t\t\tif(me.queue[message.data.id] && (typeof me.queue[message.data.id] == \'function\')){\n\t\t\t\tme.queue[message.data.id](message.data.result);\n\t\t\t\tdelete me.queue[message.data.id]\n\t\t\t}\n\t\t}\n\t};\n\n\t// Return and instance of the ScormPorthole - singleton\n\tsp = new ScormPorthole();\n\treturn sp;\n\n})();'},function(n,e,t){t(0)(t(43))},function(n,e){n.exports="/* global pipwerks, _ */\n/* eslint-disable new-cap */\n\ndelete pipwerks.debug;\n\npipwerks.SCORM.debugMode = false;\n\npipwerks.SCORM.dataModel = {\n  student_id: {\n    '1.2': 'cmi.core.student_id', //   (CMIString (SPM: 255), RO)             Identifies the student on behalf of whom the SCO was launched\n    '2004': 'cmi.learner_id' //        (long_identifier_type (SPM: 4000), RO) Identifies the learner on behalf of whom the SCO was launched\n  },\n  student_name: {\n    '1.2': 'cmi.core.student_name', // (CMIString (SPM: 255), RO)             Name provided for the student by the LMS\n    '2004': 'cmi.learner_name' //      (localized_string_type (SPM: 250), RO) Name provided for the learner by the LMS\n  },\n  session_time: {\n    '1.2': 'cmi.core.session_time', // (CMITimespan, WO)                      Amount of time that the learner has spent in the current learner session for this SCO\n    '2004': 'cmi.session_time' //      (timeinterval (second,10,2), WO)       Amount of time that the learner has spent in the current learner session for this SCO\n  },\n  location: {\n    '1.2': 'cmi.core.lesson_location',\n    '2004': 'cmi.location'\n  },\n  min: {\n    '1.2': 'cmi.core.score.min',\n    '2004': 'cmi.score.min'\n  },\n  max: {\n    '1.2': 'cmi.core.score.max',\n    '2004': 'cmi.score.max'\n  },\n  score: {\n    '1.2': 'cmi.core.score.raw',\n    '2004': 'cmi.score.raw'\n  },\n  status: {\n    '1.2': 'cmi.core.lesson_status',\n    '2004': {\n      completion: 'cmi.completion_status',\n      success: 'cmi.success_status'\n    }\n  }\n};\n\npipwerks.SCORM.status = function(key, value) {\n  var scorm = pipwerks.SCORM;\n  if (key === 'get') {\n    var completionStatus = scorm.get('status');\n    if (completionStatus.hasOwnProperty('completion')) {\n      completionStatus = completionStatus.completion;\n    }\n    return completionStatus;\n  } else if (key === 'set') {\n    scorm.set('status', value);\n  }\n};\n\npipwerks.SCORM.data.get = function(parameter) {\n  var value = null;\n  var cmi = parameter;\n  var scorm = pipwerks.SCORM;\n  var dataModel = scorm.dataModel;\n  var trace = pipwerks.UTILS.trace;\n  var debug = scorm.debug;\n  var traceMsgPrefix = 'SCORM.data.get(' + parameter + ') ';\n\n  if (scorm.connection.isActive) {\n    var API = scorm.API.getHandle();\n    var errorCode = 0;\n\n    if (API) {\n      if (dataModel.hasOwnProperty(parameter)) {\n        cmi = dataModel[parameter][scorm.version];\n      }\n      switch (scorm.version) {\n        case '1.2':\n          value = API.LMSGetValue(cmi);\n          break;\n        case '2004':\n          if (typeof cmi === 'string') {\n            value = API.GetValue(cmi);\n          } else if (typeof cmi === 'object') {\n            value = {\n              completion: API.GetValue(cmi.completion),\n              success: API.GetValue(cmi.success)\n            };\n          }\n          break;\n      }\n\n      errorCode = debug.getCode();\n\n      // GetValue returns an empty string on errors\n      // If value is an empty string, check errorCode to make sure there are no errors\n      if (value || errorCode === 0) {\n        // GetValue is successful.\n        // If parameter is lesson_status/completion_status or exit status, let's\n        // grab the value and cache it so we can check it during connection.terminate()\n        switch (cmi) {\n          case 'cmi.core.lesson_status':\n          case 'cmi.completion_status':\n            scorm.data.completionStatus = value;\n            break;\n\n          case 'cmi.core.exit':\n          case 'cmi.exit':\n            scorm.data.exitStatus = value;\n            break;\n        }\n        if (cmi.hasOwnProperty('completion')) {\n          scorm.data.completionStatus = value.completion;\n        }\n      } else {\n        trace(\n          traceMsgPrefix +\n            'failed. \\nError code: ' +\n            errorCode +\n            '\\nError info: ' +\n            debug.getInfo(errorCode)\n        );\n      }\n    } else {\n      trace(traceMsgPrefix + 'failed: API is null.');\n    }\n  } else {\n    trace(traceMsgPrefix + 'failed: API connection is inactive.');\n  }\n  trace(traceMsgPrefix + ' value: ' + value);\n  return value;\n};\n\npipwerks.SCORM.data.set = function(parameter, value) {\n  var success = false;\n  var cmi = parameter;\n  var scorm = pipwerks.SCORM;\n  var dataModel = scorm.dataModel;\n  var trace = pipwerks.UTILS.trace;\n  var makeBoolean = pipwerks.UTILS.StringToBoolean;\n  var debug = scorm.debug;\n  var traceMsgPrefix = 'SCORM.data.set(' + parameter + ') ';\n\n  if (scorm.connection.isActive) {\n    var API = scorm.API.getHandle();\n    var errorCode = 0;\n\n    if (API) {\n      var valueObj = false;\n      var cmiObj = false;\n      if (dataModel.hasOwnProperty(parameter)) {\n        cmi = dataModel[parameter][scorm.version];\n        if (parameter === 'status' && scorm.version === '2004') {\n          if (_.isString(value)) {\n            if (value === 'passed' || value === 'failed') {\n              cmi = cmi.success;\n            } else {\n              cmi = cmi.completion;\n            }\n          } else if (_.isObject(value)) {\n            valueObj = value;\n            cmiObj = cmi;\n            if ( value.success &&\n              (value.success === 'passed' || value.success === 'failed')) {\n              cmi = cmi.success;\n              value = value.success;\n            } else {\n              cmi = cmi.completion;\n              value = value.completion;\n            }\n          }\n        }\n      }\n      if (parameter === 'score') {\n        var coreItems;\n        if (scorm.version === '1.2') {\n          coreItems = scorm.get('cmi.core.score._children');\n        } else {\n          // scorm.version === '2004'\n          coreItems = scorm.get('cmi.score._children');\n        }\n        if (coreItems.indexOf('raw') >= 0) {\n          switch (scorm.version) {\n            case '1.2':\n              success = makeBoolean(API.LMSSetValue(cmi, value));\n              break;\n            case '2004':\n              if (_.isObject(valueObj)) {\n                success = makeBoolean(API.SetValue(cmiObj.success, valueObj.success)) &&\n                  makeBoolean(API.SetValue(cmiObj.completion, valueObj.completion));\n              } else {\n                success = makeBoolean(API.SetValue(cmi, value));\n              }\n              var scaled = value / API.GetValue(dataModel['max']['2004']);\n              success = makeBoolean(API.SetValue('cmi.score.scaled', scaled));\n              break;\n          }\n        } else {\n          trace('ERROR: LMS is not SCORM Complaint, it does not support ' + cmi);\n        }\n      } else {\n        switch (scorm.version) {\n          case '1.2':\n            success = makeBoolean(API.LMSSetValue(cmi, value));\n            break;\n          case '2004':\n            if (_.isObject(valueObj)) {\n              success = makeBoolean(API.SetValue(cmiObj.success, valueObj.success)) &&\n                makeBoolean(API.SetValue(cmiObj.completion, valueObj.completion));\n            } else {\n              success = makeBoolean(API.SetValue(cmi, value));\n            }\n            break;\n        }\n      }\n\n      if (success) {\n        if (parameter === 'status') {\n          scorm.data.completionStatus = value;\n        }\n      } else {\n        errorCode = debug.getCode();\n        trace(\n          traceMsgPrefix +\n            'failed. \\nError code: ' +\n            errorCode +\n            '. \\nError info: ' +\n            debug.getInfo(errorCode)\n        );\n      }\n    } else {\n      trace(traceMsgPrefix + 'failed: API is null.');\n    }\n  } else {\n    trace(traceMsgPrefix + 'failed: API connection is inactive.');\n  }\n  trace(traceMsgPrefix + ' value: ' + value);\n  return success;\n};\n\npipwerks.SCORM.connection.terminate = function() {\n  var success = false;\n  var scorm = pipwerks.SCORM;\n  var exitStatus = scorm.data.exitStatus;\n  var completionStatus = scorm.data.completionStatus;\n  var trace = pipwerks.UTILS.trace;\n  var makeBoolean = pipwerks.UTILS.StringToBoolean;\n  var debug = scorm.debug;\n  var traceMsgPrefix = 'SCORM.connection.terminate ';\n\n  if (scorm.connection.isActive) {\n    var API = scorm.API.getHandle();\n    var errorCode = 0;\n\n    if (API) {\n      if (scorm.handleExitMode && !exitStatus) {\n        if (completionStatus !== 'completed' && completionStatus !== 'passed') {\n          switch (scorm.version) {\n            case '1.2':\n              success = scorm.set('cmi.core.exit', 'suspend');\n              break;\n            case '2004':\n              success = scorm.set('cmi.exit', 'suspend');\n              break;\n          }\n        } else {\n          switch (scorm.version) {\n            case '1.2':\n              // Send an empty string instead of 'logout' so the LMS doesn't log out.\n              success = scorm.set('cmi.core.exit', '');\n              break;\n            case '2004':\n              success = scorm.set('cmi.exit', 'normal');\n              break;\n          }\n        }\n      }\n\n      // Ensure we persist the data\n      success = scorm.save();\n\n      if (success) {\n        switch (scorm.version) {\n          case '1.2':\n            success = makeBoolean(API.LMSFinish(''));\n            break;\n          case '2004':\n            success = makeBoolean(API.Terminate(''));\n            break;\n        }\n\n        if (success) {\n          scorm.connection.isActive = false;\n        } else {\n          errorCode = debug.getCode();\n          trace(\n            traceMsgPrefix +\n              'failed. \\nError code: ' +\n              errorCode +\n              ' \\nError info: ' +\n              debug.getInfo(errorCode)\n          );\n        }\n      }\n    } else {\n      trace(traceMsgPrefix + 'failed: API is null.');\n    }\n  } else {\n    trace(traceMsgPrefix + 'aborted: Connection already terminated.');\n  }\n\n  return success;\n};\n\npipwerks.UTILS.trace = function(msg) {\n  if (pipwerks.SCORM.debugMode) {\n    if (window.console && window.console.log) {\n      window.console.log(msg);\n    } else {\n      // alert(msg);\n    }\n  }\n};\n\npipwerks.SCORM.get = pipwerks.SCORM.data.get;\npipwerks.SCORM.set = pipwerks.SCORM.data.set;\npipwerks.SCORM.quit = pipwerks.SCORM.connection.terminate;\n\n/**\n * SCORM wrapper\n * @author Adam Fox\n */\n\nvar global = this;\n\n// Extends the SCORM adapter...\nglobal.GOMO_SCORM_WRAPPER = (function() {\n  /**\n   * @param {function} callback\n   * @return {function}\n   */\n  function validateCallback(callback) {\n    return typeof callback == 'function' ? callback : function() {};\n  }\n\n  /**\n   * @constructor\n   */\n  var ScormWrapper = function() {\n    // Constructor\n  };\n\n  ScormWrapper.prototype = {\n    id: 'scorm',\n    version: '1.2',\n    endpoint: '',\n\n    /**\n     * Initialise the ScormPortal - create porthole object etc...\n     * @param {function} callback\n     */\n    init: function(callback) {\n      var me = this;\n      callback = validateCallback(callback);\n      pipwerks.SCORM.version = me.version;\n      callback(pipwerks.SCORM.init());\n    },\n\n    get: function(property, callback) {\n      callback = validateCallback(callback);\n      callback(pipwerks.SCORM.get(property));\n    },\n\n    set: function(property, val, callback) {\n      callback = validateCallback(callback);\n      callback(pipwerks.SCORM.set(property, val));\n    },\n\n    quit: function(callback) {\n      callback = validateCallback(callback);\n      callback(pipwerks.SCORM.quit());\n    },\n\n    save: function(callback) {\n      callback = validateCallback(callback);\n      callback(pipwerks.SCORM.save());\n    },\n\n    debug: {\n      getCode: function(callback) {\n        callback = validateCallback(callback);\n        callback(pipwerks.SCORM.debug.getCode());\n      }\n    }\n  };\n\n  // Return and instance of the ScormWrapper - singleton\n  return new ScormWrapper();\n})();\n"},function(n,e,t){t(0)(t(45))},function(n,e){n.exports='"0.50.0";\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(e,m){var p={},j=p.lib={},l=function(){},f=j.Base={extend:function(a){l.prototype=this;var c=new l;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nn=j.WordArray=f.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=m?c:4*a.length},toString:function(a){return(a||h).stringify(this)},concat:function(a){var c=this.words,q=a.words,d=this.sigBytes;a=a.sigBytes;this.clamp();if(d%4)for(var b=0;b<a;b++)c[d+b>>>2]|=(q[b>>>2]>>>24-8*(b%4)&255)<<24-8*((d+b)%4);else if(65535<q.length)for(b=0;b<a;b+=4)c[d+b>>>2]=q[b>>>2];else c.push.apply(c,q);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n32-8*(c%4);a.length=e.ceil(c/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],b=0;b<a;b+=4)c.push(4294967296*e.random()|0);return new n.init(c,a)}}),b=p.enc={},h=b.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++){var f=c[d>>>2]>>>24-8*(d%4)&255;b.push((f>>>4).toString(16));b.push((f&15).toString(16))}return b.join("")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d+=2)b[d>>>3]|=parseInt(a.substr(d,\n2),16)<<24-4*(d%8);return new n.init(b,c/2)}},g=b.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++)b.push(String.fromCharCode(c[d>>>2]>>>24-8*(d%4)&255));return b.join("")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d++)b[d>>>2]|=(a.charCodeAt(d)&255)<<24-8*(d%4);return new n.init(b,c)}},r=b.Utf8={stringify:function(a){try{return decodeURIComponent(escape(g.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return g.parse(unescape(encodeURIComponent(a)))}},\nk=j.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new n.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=r.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,b=c.words,d=c.sigBytes,f=this.blockSize,h=d/(4*f),h=a?e.ceil(h):e.max((h|0)-this._minBufferSize,0);a=h*f;d=e.min(4*a,d);if(a){for(var g=0;g<a;g+=f)this._doProcessBlock(b,g);g=b.splice(0,a);c.sigBytes-=d}return new n.init(g,d)},clone:function(){var a=f.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});j.Hasher=k.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){k.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,b){return(new a.init(b)).finalize(c)}},_createHmacHelper:function(a){return function(b,f){return(new s.HMAC.init(a,\nf)).finalize(b)}}});var s=p.algo={};return p}(Math);\n(function(){var e=CryptoJS,m=e.lib,p=m.WordArray,j=m.Hasher,l=[],m=e.algo.SHA1=j.extend({_doReset:function(){this._hash=new p.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(f,n){for(var b=this._hash.words,h=b[0],g=b[1],e=b[2],k=b[3],j=b[4],a=0;80>a;a++){if(16>a)l[a]=f[n+a]|0;else{var c=l[a-3]^l[a-8]^l[a-14]^l[a-16];l[a]=c<<1|c>>>31}c=(h<<5|h>>>27)+j+l[a];c=20>a?c+((g&e|~g&k)+1518500249):40>a?c+((g^e^k)+1859775393):60>a?c+((g&e|g&k|e&k)-1894007588):c+((g^e^\nk)-899497514);j=k;k=e;e=g<<30|g>>>2;g=h;h=c}b[0]=b[0]+h|0;b[1]=b[1]+g|0;b[2]=b[2]+e|0;b[3]=b[3]+k|0;b[4]=b[4]+j|0},_doFinalize:function(){var f=this._data,e=f.words,b=8*this._nDataBytes,h=8*f.sigBytes;e[h>>>5]|=128<<24-h%32;e[(h+64>>>9<<4)+14]=Math.floor(b/4294967296);e[(h+64>>>9<<4)+15]=b;f.sigBytes=4*e.length;this._process();return this._hash},clone:function(){var e=j.clone.call(this);e._hash=this._hash.clone();return e}});e.SHA1=j._createHelper(m);e.HmacSHA1=j._createHmacHelper(m)})();\n\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(h,s){var f={},t=f.lib={},g=function(){},j=t.Base={extend:function(a){g.prototype=this;var c=new g;a&&c.mixIn(a);c.hasOwnProperty("init")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty("toString")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nq=t.WordArray=j.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||u).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=j.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new q.init(c,a)}}),v=f.enc={},u=v.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,\n2),16)<<24-4*(b%8);return new q.init(d,c/2)}},k=v.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join("")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new q.init(d,c)}},l=v.Utf8={stringify:function(a){try{return decodeURIComponent(escape(k.stringify(a)))}catch(c){throw Error("Malformed UTF-8 data");}},parse:function(a){return k.parse(unescape(encodeURIComponent(a)))}},\nx=t.BufferedBlockAlgorithm=j.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(a){"string"==typeof a&&(a=l.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var m=0;m<a;m+=e)this._doProcessBlock(d,m);m=d.splice(0,a);c.sigBytes-=b}return new q.init(m,b)},clone:function(){var a=j.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});t.Hasher=x.extend({cfg:j.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){x.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new w.HMAC.init(a,\nd)).finalize(c)}}});var w=f.algo={};return f}(Math);\n(function(h){for(var s=CryptoJS,f=s.lib,t=f.WordArray,g=f.Hasher,f=s.algo,j=[],q=[],v=function(a){return 4294967296*(a-(a|0))|0},u=2,k=0;64>k;){var l;a:{l=u;for(var x=h.sqrt(l),w=2;w<=x;w++)if(!(l%w)){l=!1;break a}l=!0}l&&(8>k&&(j[k]=v(h.pow(u,0.5))),q[k]=v(h.pow(u,1/3)),k++);u++}var a=[],f=f.SHA256=g.extend({_doReset:function(){this._hash=new t.init(j.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],m=b[2],h=b[3],p=b[4],j=b[5],k=b[6],l=b[7],n=0;64>n;n++){if(16>n)a[n]=\nc[d+n]|0;else{var r=a[n-15],g=a[n-2];a[n]=((r<<25|r>>>7)^(r<<14|r>>>18)^r>>>3)+a[n-7]+((g<<15|g>>>17)^(g<<13|g>>>19)^g>>>10)+a[n-16]}r=l+((p<<26|p>>>6)^(p<<21|p>>>11)^(p<<7|p>>>25))+(p&j^~p&k)+q[n]+a[n];g=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&m^f&m);l=k;k=j;j=p;p=h+r|0;h=m;m=f;f=e;e=r+g|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+m|0;b[3]=b[3]+h|0;b[4]=b[4]+p|0;b[5]=b[5]+j|0;b[6]=b[6]+k|0;b[7]=b[7]+l|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;\nd[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=g.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=g._createHelper(f);s.HmacSHA256=g._createHmacHelper(f)})(Math);\n\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n(function () {\n    // Shortcuts\n    var C = CryptoJS;\n    var C_lib = C.lib;\n    var WordArray = C_lib.WordArray;\n    var C_enc = C.enc;\n\n    /**\n     * Base64 encoding strategy.\n     */\n    var Base64 = C_enc.Base64 = {\n        /**\n         * Converts a word array to a Base64 string.\n         *\n         * @param {WordArray} wordArray The word array.\n         *\n         * @return {string} The Base64 string.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);\n         */\n        stringify: function (wordArray) {\n            // Shortcuts\n            var words = wordArray.words;\n            var sigBytes = wordArray.sigBytes;\n            var map = this._map;\n\n            // Clamp excess bits\n            wordArray.clamp();\n\n            // Convert\n            var base64Chars = [];\n            for (var i = 0; i < sigBytes; i += 3) {\n                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\n                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n                }\n            }\n\n            // Add padding\n            var paddingChar = map.charAt(64);\n            if (paddingChar) {\n                while (base64Chars.length % 4) {\n                    base64Chars.push(paddingChar);\n                }\n            }\n\n            return base64Chars.join(\'\');\n        },\n\n        /**\n         * Converts a Base64 string to a word array.\n         *\n         * @param {string} base64Str The Base64 string.\n         *\n         * @return {WordArray} The word array.\n         *\n         * @static\n         *\n         * @example\n         *\n         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);\n         */\n        parse: function (base64Str) {\n            // Shortcuts\n            var base64StrLength = base64Str.length;\n            var map = this._map;\n\n            // Ignore padding\n            var paddingChar = map.charAt(64);\n            if (paddingChar) {\n                var paddingIndex = base64Str.indexOf(paddingChar);\n                if (paddingIndex != -1) {\n                    base64StrLength = paddingIndex;\n                }\n            }\n\n            // Convert\n            var words = [];\n            var nBytes = 0;\n            for (var i = 0; i < base64StrLength; i++) {\n                if (i % 4) {\n                    var bits1 = map.indexOf(base64Str.charAt(i - 1)) << ((i % 4) * 2);\n                    var bits2 = map.indexOf(base64Str.charAt(i)) >>> (6 - (i % 4) * 2);\n                    words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);\n                    nBytes++;\n                }\n            }\n\n            return WordArray.create(words, nBytes);\n        },\n\n        _map: \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\'\n    };\n}());\n\n/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\n(function () {\n    // Check if typed arrays are supported\n    if (typeof ArrayBuffer != \'function\') {\n        return;\n    }\n\n    // Shortcuts\n    var C = CryptoJS;\n    var C_lib = C.lib;\n    var WordArray = C_lib.WordArray;\n\n    // Reference original init\n    var superInit = WordArray.init;\n\n    // Augment WordArray.init to handle typed arrays\n    var subInit = WordArray.init = function (typedArray) {\n        // Convert buffers to uint8\n        if (typedArray instanceof ArrayBuffer) {\n            typedArray = new Uint8Array(typedArray);\n        }\n\n        // Convert other array views to uint8\n        if (\n            typedArray instanceof Int8Array ||\n            typedArray instanceof Uint8ClampedArray ||\n            typedArray instanceof Int16Array ||\n            typedArray instanceof Uint16Array ||\n            typedArray instanceof Int32Array ||\n            typedArray instanceof Uint32Array ||\n            typedArray instanceof Float32Array ||\n            typedArray instanceof Float64Array\n        ) {\n            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n        }\n\n        // Handle Uint8Array\n        if (typedArray instanceof Uint8Array) {\n            // Shortcut\n            var typedArrayByteLength = typedArray.byteLength;\n\n            // Extract bytes\n            var words = [];\n            for (var i = 0; i < typedArrayByteLength; i++) {\n                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);\n            }\n\n            // Initialize this word array\n            superInit.call(this, words, typedArrayByteLength);\n        } else {\n            // Else call normal init\n            superInit.apply(this, arguments);\n        }\n    };\n\n    subInit.prototype = WordArray;\n}());\n\n/*!\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\nTODO:\n\n* Add statement queueing\n\n@module TinCan\n**/\nvar TinCan;\n\n(function () {\n    "use strict";\n    var _reservedQSParams = {\n        //\n        // these are TC spec reserved words that may end up in queries to the endpoint\n        //\n        statementId:       true,\n        voidedStatementId: true,\n        verb:              true,\n        object:            true,\n        registration:      true,\n        context:           true,\n        actor:             true,\n        since:             true,\n        until:             true,\n        limit:             true,\n        authoritative:     true,\n        sparse:            true,\n        instructor:        true,\n        ascending:         true,\n        continueToken:     true,\n        agent:             true,\n        activityId:        true,\n        stateId:           true,\n        profileId:         true,\n\n        //\n        // these are suggested by the LMS launch spec addition that TinCanJS consumes\n        //\n        activity_platform: true,\n        grouping:          true,\n        "Accept-Language": true\n    };\n\n    /**\n    @class TinCan\n    @constructor\n    @param {Object} [options] Configuration used to initialize.\n        @param {String} [options.url] URL for determining launch provided\n            configuration options\n        @param {Array} [options.recordStores] list of pre-configured LRSes\n        @param {Object|TinCan.Agent} [options.actor] default actor\n        @param {Object|TinCan.Activity} [options.activity] default activity\n        @param {String} [options.registration] default registration\n        @param {Object|TinCan.Context} [options.context] default context\n    **/\n    TinCan = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property recordStores\n        @type Array\n        */\n        this.recordStores = [];\n\n        /**\n        Default actor used when preparing statements that\n        don\'t yet have an actor set, and for saving state, etc.\n\n        @property actor\n        @type Object\n        */\n        this.actor = null;\n\n        /**\n        Default activity, may be used as a statement \'target\'\n        or incorporated into \'context\'\n\n        @property activity\n        @type Object\n        */\n        this.activity = null;\n\n        /**\n        Default registration, included in default context when\n        provided, otherwise used in statement queries\n\n        @property registration\n        @type String\n        */\n        this.registration = null;\n\n        /**\n        Default context used when preparing statements that\n        don\'t yet have a context set, or mixed in when one\n        has been provided, properties do NOT override on mixing\n\n        @property context\n        @type Object\n        */\n        this.context = null;\n\n        this.init(cfg);\n    };\n\n    TinCan.prototype = {\n        LOG_SRC: "TinCan",\n\n        /**\n        Safe version of logging, only displays when .DEBUG is true, and console.log\n        is available\n\n        @method log\n        @param {String} msg Message to output\n        */\n        log: function (msg, src) {\n            /* globals console */\n            if (TinCan.DEBUG && typeof console !== "undefined" && console.log) {\n                src = src || this.LOG_SRC || "TinCan";\n\n                console.log("TinCan." + src + ": " + msg);\n            }\n        },\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize (see TinCan constructor).\n        */\n        init: function (cfg) {\n            this.log("init");\n            var i;\n\n            cfg = cfg || {};\n\n            if (cfg.hasOwnProperty("url") && cfg.url !== "") {\n                this._initFromQueryString(cfg.url);\n            }\n\n            if (cfg.hasOwnProperty("recordStores") && cfg.recordStores !== undefined) {\n                for (i = 0; i < cfg.recordStores.length; i += 1) {\n                    this.addRecordStore(cfg.recordStores[i]);\n                }\n            }\n            if (cfg.hasOwnProperty("activity")) {\n                if (cfg.activity instanceof TinCan.Activity) {\n                    this.activity = cfg.activity;\n                }\n                else {\n                    this.activity = new TinCan.Activity (cfg.activity);\n                }\n            }\n            if (cfg.hasOwnProperty("actor")) {\n                if (cfg.actor instanceof TinCan.Agent) {\n                    this.actor = cfg.actor;\n                }\n                else {\n                    this.actor = new TinCan.Agent (cfg.actor);\n                }\n            }\n            if (cfg.hasOwnProperty("context")) {\n                if (cfg.context instanceof TinCan.Context) {\n                    this.context = cfg.context;\n                }\n                else {\n                    this.context = new TinCan.Context (cfg.context);\n                }\n            }\n            if (cfg.hasOwnProperty("registration")) {\n                this.registration = cfg.registration;\n            }\n        },\n\n        /**\n        @method _initFromQueryString\n        @param {String} url\n        @private\n        */\n        _initFromQueryString: function (url) {\n            this.log("_initFromQueryString");\n\n            var i,\n                prop,\n                qsParams = TinCan.Utils.parseURL(url).params,\n                lrsProps = ["endpoint", "auth"],\n                lrsCfg = {},\n                contextCfg,\n                extended = null\n            ;\n\n            if (qsParams.hasOwnProperty("actor")) {\n                this.log("_initFromQueryString - found actor: " + qsParams.actor);\n                try {\n                    this.actor = TinCan.Agent.fromJSON(qsParams.actor);\n                    delete qsParams.actor;\n                }\n                catch (ex) {\n                    this.log("_initFromQueryString - failed to set actor: " + ex);\n                }\n            }\n\n            if (qsParams.hasOwnProperty("activity_id")) {\n                this.activity = new TinCan.Activity (\n                    {\n                        id: qsParams.activity_id\n                    }\n                );\n                delete qsParams.activity_id;\n            }\n\n            if (\n                qsParams.hasOwnProperty("activity_platform") ||\n                qsParams.hasOwnProperty("registration") ||\n                qsParams.hasOwnProperty("grouping")\n            ) {\n                contextCfg = {};\n\n                if (qsParams.hasOwnProperty("activity_platform")) {\n                    contextCfg.platform = qsParams.activity_platform;\n                    delete qsParams.activity_platform;\n                }\n                if (qsParams.hasOwnProperty("registration")) {\n                    //\n                    // stored in two locations cause we always want it in the default\n                    // context, but we also want to be able to get to it for Statement\n                    // queries\n                    //\n                    contextCfg.registration = this.registration = qsParams.registration;\n                    delete qsParams.registration;\n                }\n                if (qsParams.hasOwnProperty("grouping")) {\n                    contextCfg.contextActivities = {};\n                    contextCfg.contextActivities.grouping = qsParams.grouping;\n                    delete qsParams.grouping;\n                }\n\n                this.context = new TinCan.Context (contextCfg);\n            }\n\n            //\n            // order matters here, process the URL provided LRS last because it gets\n            // all the remaining parameters so that they get passed through\n            //\n            if (qsParams.hasOwnProperty("endpoint")) {\n                for (i = 0; i < lrsProps.length; i += 1) {\n                    prop = lrsProps[i];\n                    if (qsParams.hasOwnProperty(prop)) {\n                        lrsCfg[prop] = qsParams[prop];\n                        delete qsParams[prop];\n                    }\n                }\n\n                // remove our reserved params so they don\'t end up  in the extended object\n                for (i in qsParams) {\n                    if (qsParams.hasOwnProperty(i)) {\n                        if (_reservedQSParams.hasOwnProperty(i)) {\n                            delete qsParams[i];\n                        } else {\n                            extended = extended || {};\n                            extended[i] = qsParams[i];\n                        }\n                    }\n                }\n                if (extended !== null) {\n                    lrsCfg.extended = extended;\n                }\n\n                lrsCfg.allowFail = false;\n\n                this.addRecordStore(lrsCfg);\n            }\n        },\n\n        /**\n        @method addRecordStore\n        @param {Object} Configuration data\n\n         * TODO:\n         * check endpoint for trailing \'/\'\n         * check for unique endpoints\n        */\n        addRecordStore: function (cfg) {\n            this.log("addRecordStore");\n            var lrs;\n            if (cfg instanceof TinCan.LRS) {\n                lrs = cfg;\n            }\n            else {\n                lrs = new TinCan.LRS (cfg);\n            }\n            this.recordStores.push(lrs);\n        },\n\n        /**\n        @method prepareStatement\n        @param {Object|TinCan.Statement} Base statement properties or\n            pre-created TinCan.Statement instance\n        @return {TinCan.Statement}\n        */\n        prepareStatement: function (stmt) {\n            this.log("prepareStatement");\n            if (! (stmt instanceof TinCan.Statement)) {\n                stmt = new TinCan.Statement (stmt);\n            }\n\n            if (stmt.actor === null && this.actor !== null) {\n                stmt.actor = this.actor;\n            }\n            if (stmt.target === null && this.activity !== null) {\n                stmt.target = this.activity;\n            }\n\n            if (this.context !== null) {\n                if (stmt.context === null) {\n                    stmt.context = this.context;\n                }\n                else {\n                    if (stmt.context.registration === null) {\n                        stmt.context.registration = this.context.registration;\n                    }\n                    if (stmt.context.platform === null) {\n                        stmt.context.platform = this.context.platform;\n                    }\n\n                    if (this.context.contextActivities !== null) {\n                        if (stmt.context.contextActivities === null) {\n                            stmt.context.contextActivities = this.context.contextActivities;\n                        }\n                        else {\n                            if (this.context.contextActivities.grouping !== null && stmt.context.contextActivities.grouping === null) {\n                                stmt.context.contextActivities.grouping = this.context.contextActivities.grouping;\n                            }\n                            if (this.context.contextActivities.parent !== null && stmt.context.contextActivities.parent === null) {\n                                stmt.context.contextActivities.parent = this.context.contextActivities.parent;\n                            }\n                            if (this.context.contextActivities.other !== null && stmt.context.contextActivities.other === null) {\n                                stmt.context.contextActivities.other = this.context.contextActivities.other;\n                            }\n                        }\n                    }\n                }\n            }\n\n            return stmt;\n        },\n\n        /**\n        Calls saveStatement on each configured LRS, provide callback to make it asynchronous\n\n        @method sendStatement\n        @param {TinCan.Statement|Object} statement Send statement to LRS\n        @param {Function} [callback] Callback function to execute on completion\n        */\n        sendStatement: function (stmt, callback) {\n            this.log("sendStatement");\n\n            // would prefer to use .bind instead of \'self\'\n            var self = this,\n                lrs,\n                statement = this.prepareStatement(stmt),\n                rsCount = this.recordStores.length,\n                i,\n                results = [],\n                callbackWrapper,\n                callbackResults = []\n            ;\n\n            if (rsCount > 0) {\n                /*\n                   if there is a callback that is a function then we need\n                   to wrap that function with a function that becomes\n                   the new callback that reduces a closure count of the\n                   requests that don\'t have allowFail set to true and\n                   when that number hits zero then the original callback\n                   is executed\n                */\n                if (typeof callback === "function") {\n                    callbackWrapper = function (err, xhr) {\n                        var args;\n\n                        self.log("sendStatement - callbackWrapper: " + rsCount);\n                        if (rsCount > 1) {\n                            rsCount -= 1;\n                            callbackResults.push(\n                                {\n                                    err: err,\n                                    xhr: xhr\n                                }\n                            );\n                        }\n                        else if (rsCount === 1) {\n                            callbackResults.push(\n                                {\n                                    err: err,\n                                    xhr: xhr\n                                }\n                            );\n                            args = [\n                                callbackResults,\n                                statement\n                            ];\n                            callback.apply(this, args);\n                        }\n                        else {\n                            self.log("sendStatement - unexpected record store count: " + rsCount);\n                        }\n                    };\n                }\n\n                for (i = 0; i < rsCount; i += 1) {\n                    lrs = this.recordStores[i];\n\n                    results.push(\n                        lrs.saveStatement(statement, { callback: callbackWrapper })\n                    );\n                }\n            }\n            else {\n                this.log("[warning] sendStatement: No LRSs added yet (statement not sent)");\n                if (typeof callback === "function") {\n                    callback.apply(this, [ null, statement ]);\n                }\n            }\n\n            return {\n                statement: statement,\n                results: results\n            };\n        },\n\n        /**\n        Calls retrieveStatement on the first LRS, provide callback to make it asynchronous\n\n        @method getStatement\n        @param {String} [stmtId] Statement ID to get\n        @param {Function} [callback] Callback function to execute on completion\n        @param {Object} [cfg] Configuration data\n            @param {Object} [params] Query parameters\n                @param {Boolean} [attachments] Include attachments in multipart response or don\'t (defualt: false)\n        @return {Array|Result} Array of results, or single result\n\n        TODO: make TinCan track statements it has seen in a local cache to be returned easily\n        */\n        getStatement: function (stmtId, callback, cfg) {\n            this.log("getStatement");\n\n            var lrs;\n\n            cfg = cfg || {};\n            cfg.params = cfg.params || {};\n\n            if (this.recordStores.length > 0) {\n                //\n                // for statements (for now) we only need to read from the first LRS\n                // in the future it may make sense to get all from all LRSes and\n                // compare to remove duplicates or allow inspection of them for differences?\n                //\n                // TODO: make this the first non-allowFail LRS but for now it should\n                // be good enough to make it the first since we know the LMS provided\n                // LRS is the first\n                //\n                lrs = this.recordStores[0];\n\n                return lrs.retrieveStatement(stmtId, { callback: callback, params: cfg.params });\n            }\n\n            this.log("[warning] getStatement: No LRSs added yet (statement not retrieved)");\n        },\n\n        /**\n        Creates a statement used for voiding the passed statement/statement ID and calls\n        send statement with the voiding statement.\n\n        @method voidStatement\n        @param {TinCan.Statement|String} statement Statement or statement ID to void\n        @param {Function} [callback] Callback function to execute on completion\n        @param {Object} [options] Options used to build voiding statement\n            @param {TinCan.Agent} [options.actor] Agent to be used as \'actor\' in voiding statement\n        */\n        voidStatement: function (stmt, callback, options) {\n            this.log("voidStatement");\n\n            // would prefer to use .bind instead of \'self\'\n            var self = this,\n                lrs,\n                actor,\n                voidingStatement,\n                rsCount = this.recordStores.length,\n                i,\n                results = [],\n                callbackWrapper,\n                callbackResults = []\n            ;\n\n            if (stmt instanceof TinCan.Statement) {\n                stmt = stmt.id;\n            }\n\n            if (typeof options.actor !== "undefined") {\n                actor = options.actor;\n            }\n            else if (this.actor !== null) {\n                actor = this.actor;\n            }\n\n            voidingStatement = new TinCan.Statement(\n                {\n                    actor: actor,\n                    verb: {\n                        id: "http://adlnet.gov/expapi/verbs/voided"\n                    },\n                    target: {\n                        objectType: "StatementRef",\n                        id: stmt\n                    }\n                }\n            );\n\n            if (rsCount > 0) {\n                /*\n                   if there is a callback that is a function then we need\n                   to wrap that function with a function that becomes\n                   the new callback that reduces a closure count of the\n                   requests that don\'t have allowFail set to true and\n                   when that number hits zero then the original callback\n                   is executed\n                */\n                if (typeof callback === "function") {\n                    callbackWrapper = function (err, xhr) {\n                        var args;\n\n                        self.log("voidStatement - callbackWrapper: " + rsCount);\n                        if (rsCount > 1) {\n                            rsCount -= 1;\n                            callbackResults.push(\n                                {\n                                    err: err,\n                                    xhr: xhr\n                                }\n                            );\n                        }\n                        else if (rsCount === 1) {\n                            callbackResults.push(\n                                {\n                                    err: err,\n                                    xhr: xhr\n                                }\n                            );\n                            args = [\n                                callbackResults,\n                                voidingStatement\n                            ];\n                            callback.apply(this, args);\n                        }\n                        else {\n                            self.log("voidStatement - unexpected record store count: " + rsCount);\n                        }\n                    };\n                }\n\n                for (i = 0; i < rsCount; i += 1) {\n                    lrs = this.recordStores[i];\n\n                    results.push(\n                        lrs.saveStatement(voidingStatement, { callback: callbackWrapper })\n                    );\n                }\n            }\n            else {\n                this.log("[warning] voidStatement: No LRSs added yet (statement not sent)");\n                if (typeof callback === "function") {\n                    callback.apply(this, [ null, voidingStatement ]);\n                }\n            }\n\n            return {\n                statement: voidingStatement,\n                results: results\n            };\n        },\n\n        /**\n        Calls retrieveVoidedStatement on the first LRS, provide callback to make it asynchronous\n\n        @method getVoidedStatement\n        @param {String} statement Statement ID to get\n        @param {Function} [callback] Callback function to execute on completion\n        @return {Array|Result} Array of results, or single result\n\n        TODO: make TinCan track voided statements it has seen in a local cache to be returned easily\n        */\n        getVoidedStatement: function (stmtId, callback) {\n            this.log("getVoidedStatement");\n\n            var lrs;\n\n            if (this.recordStores.length > 0) {\n                //\n                // for statements (for now) we only need to read from the first LRS\n                // in the future it may make sense to get all from all LRSes and\n                // compare to remove duplicates or allow inspection of them for differences?\n                //\n                // TODO: make this the first non-allowFail LRS but for now it should\n                // be good enough to make it the first since we know the LMS provided\n                // LRS is the first\n                //\n                lrs = this.recordStores[0];\n\n                return lrs.retrieveVoidedStatement(stmtId, { callback: callback });\n            }\n\n            this.log("[warning] getVoidedStatement: No LRSs added yet (statement not retrieved)");\n        },\n\n        /**\n        Calls saveStatements with list of prepared statements\n\n        @method sendStatements\n        @param {Array} Array of statements to send\n        @param {Function} Callback function to execute on completion\n        */\n        sendStatements: function (stmts, callback) {\n            this.log("sendStatements");\n            var self = this,\n                lrs,\n                statements = [],\n                rsCount = this.recordStores.length,\n                i,\n                results = [],\n                callbackWrapper,\n                callbackResults = []\n            ;\n            if (stmts.length === 0) {\n                if (typeof callback === "function") {\n                    callback.apply(this, [ null, statements ]);\n                }\n            }\n            else {\n                for (i = 0; i < stmts.length; i += 1) {\n                    statements.push(\n                        this.prepareStatement(stmts[i])\n                    );\n                }\n\n                if (rsCount > 0) {\n                    /*\n                       if there is a callback that is a function then we need\n                       to wrap that function with a function that becomes\n                       the new callback that reduces a closure count of the\n                       requests that don\'t have allowFail set to true and\n                       when that number hits zero then the original callback\n                       is executed\n                    */\n\n                    if (typeof callback === "function") {\n                        callbackWrapper = function (err, xhr) {\n                            var args;\n\n                            self.log("sendStatements - callbackWrapper: " + rsCount);\n                            if (rsCount > 1) {\n                                rsCount -= 1;\n                                callbackResults.push(\n                                    {\n                                        err: err,\n                                        xhr: xhr\n                                    }\n                                );\n                            }\n                            else if (rsCount === 1) {\n                                callbackResults.push(\n                                    {\n                                        err: err,\n                                        xhr: xhr\n                                    }\n                                );\n                                args = [\n                                    callbackResults,\n                                    statements\n                                ];\n                                callback.apply(this, args);\n                            }\n                            else {\n                                self.log("sendStatements - unexpected record store count: " + rsCount);\n                            }\n                        };\n                    }\n\n                    for (i = 0; i < rsCount; i += 1) {\n                        lrs = this.recordStores[i];\n\n                        results.push(\n                            lrs.saveStatements(statements, { callback: callbackWrapper })\n                        );\n                    }\n                }\n                else {\n                    this.log("[warning] sendStatements: No LRSs added yet (statements not sent)");\n                    if (typeof callback === "function") {\n                        callback.apply(this, [ null, statements ]);\n                    }\n                }\n            }\n\n            return {\n                statements: statements,\n                results: results\n            };\n        },\n\n        /**\n        @method getStatements\n        @param {Object} [cfg] Configuration for request\n            @param {Boolean} [cfg.sendActor] Include default actor in query params\n            @param {Boolean} [cfg.sendActivity] Include default activity in query params\n            @param {Object} [cfg.params] Parameters used to filter.\n                            These are the same as those accepted by the\n                            <a href="TinCan.LRS.html#method_queryStatements">LRS.queryStatements</a>\n                            method.\n\n            @param {Function} [cfg.callback] Function to run at completion\n\n        TODO: support multiple LRSs and flag to use single\n        */\n        getStatements: function (cfg) {\n            this.log("getStatements");\n            var queryCfg = {},\n                lrs,\n                params\n            ;\n            if (this.recordStores.length > 0) {\n                //\n                // for get (for now) we only get from one (as they should be the same)\n                // but it may make sense to long term try to merge statements, perhaps\n                // by using statementId as unique\n                //\n                // TODO: make this the first non-allowFail LRS but for now it should\n                // be good enough to make it the first since we know the LMS provided\n                // LRS is the first\n                //\n                lrs = this.recordStores[0];\n\n                cfg = cfg || {};\n\n                // TODO: need a clone function?\n                params = cfg.params || {};\n\n                if (cfg.sendActor && this.actor !== null) {\n                    if (lrs.version === "0.9" || lrs.version === "0.95") {\n                        params.actor = this.actor;\n                    }\n                    else {\n                        params.agent = this.actor;\n                    }\n                }\n                if (cfg.sendActivity && this.activity !== null) {\n                    if (lrs.version === "0.9" || lrs.version === "0.95") {\n                        params.target = this.activity;\n                    }\n                    else {\n                        params.activity = this.activity;\n                    }\n                }\n                if (typeof params.registration === "undefined" && this.registration !== null) {\n                    params.registration = this.registration;\n                }\n\n                queryCfg = {\n                    params: params\n                };\n                if (typeof cfg.callback !== "undefined") {\n                    queryCfg.callback = cfg.callback;\n                }\n\n                return lrs.queryStatements(queryCfg);\n            }\n\n            this.log("[warning] getStatements: No LRSs added yet (statements not read)");\n        },\n\n        /**\n        @method getState\n        @param {String} key Key to retrieve from the state\n        @param {Object} [cfg] Configuration for request\n            @param {Object} [cfg.agent] Agent used in query,\n                defaults to \'actor\' property if empty\n            @param {Object} [cfg.activity] Activity used in query,\n                defaults to \'activity\' property if empty\n            @param {Object} [cfg.registration] Registration used in query,\n                defaults to \'registration\' property if empty\n            @param {Function} [cfg.callback] Function to run with state\n        */\n        getState: function (key, cfg) {\n            this.log("getState");\n            var queryCfg,\n                lrs\n            ;\n\n            if (this.recordStores.length > 0) {\n                //\n                // for state (for now) we are only going to store to the first LRS\n                // so only get from there too\n                //\n                // TODO: make this the first non-allowFail LRS but for now it should\n                // be good enough to make it the first since we know the LMS provided\n                // LRS is the first\n                //\n                lrs = this.recordStores[0];\n\n                cfg = cfg || {};\n\n                queryCfg = {\n                    agent: (typeof cfg.agent !== "undefined" ? cfg.agent : this.actor),\n                    activity: (typeof cfg.activity !== "undefined" ? cfg.activity : this.activity)\n                };\n                if (typeof cfg.registration !== "undefined") {\n                    queryCfg.registration = cfg.registration;\n                }\n                else if (this.registration !== null) {\n                    queryCfg.registration = this.registration;\n                }\n                if (typeof cfg.callback !== "undefined") {\n                    queryCfg.callback = cfg.callback;\n                }\n\n                return lrs.retrieveState(key, queryCfg);\n            }\n\n            this.log("[warning] getState: No LRSs added yet (state not retrieved)");\n        },\n\n        /**\n        @method setState\n        @param {String} key Key to store into the state\n        @param {String|Object} val Value to store into the state, objects will be stringified to JSON\n        @param {Object} [cfg] Configuration for request\n            @param {Object} [cfg.agent] Agent used in query,\n                defaults to \'actor\' property if empty\n            @param {Object} [cfg.activity] Activity used in query,\n                defaults to \'activity\' property if empty\n            @param {Object} [cfg.registration] Registration used in query,\n                defaults to \'registration\' property if empty\n            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing state\n            @param {String} [cfg.contentType] Content-Type to specify in headers\n            @param {Boolean} [cfg.overwriteJSON] If the Content-Type is JSON, should a PUT be used? \n            @param {Function} [cfg.callback] Function to run with state\n        */\n        setState: function (key, val, cfg) {\n            this.log("setState");\n            var queryCfg,\n                lrs\n            ;\n\n            if (this.recordStores.length > 0) {\n                //\n                // for state (for now) we are only going to store to the first LRS\n                // so only get from there too\n                //\n                // TODO: make this the first non-allowFail LRS but for now it should\n                // be good enough to make it the first since we know the LMS provided\n                // LRS is the first\n                //\n                lrs = this.recordStores[0];\n\n                cfg = cfg || {};\n\n                queryCfg = {\n                    agent: (typeof cfg.agent !== "undefined" ? cfg.agent : this.actor),\n                    activity: (typeof cfg.activity !== "undefined" ? cfg.activity : this.activity)\n                };\n                if (typeof cfg.registration !== "undefined") {\n                    queryCfg.registration = cfg.registration;\n                }\n                else if (this.registration !== null) {\n                    queryCfg.registration = this.registration;\n                }\n                if (typeof cfg.lastSHA1 !== "undefined") {\n                    queryCfg.lastSHA1 = cfg.lastSHA1;\n                }\n                if (typeof cfg.contentType !== "undefined") {\n                    queryCfg.contentType = cfg.contentType;\n                    if ((typeof cfg.overwriteJSON !== "undefined") && (! cfg.overwriteJSON) && (TinCan.Utils.isApplicationJSON(cfg.contentType))) {\n                        queryCfg.method = "POST";\n                    }\n                }\n                if (typeof cfg.callback !== "undefined") {\n                    queryCfg.callback = cfg.callback;\n                }\n\n                return lrs.saveState(key, val, queryCfg);\n            }\n\n            this.log("[warning] setState: No LRSs added yet (state not saved)");\n        },\n\n        /**\n        @method deleteState\n        @param {String|null} key Key to remove from the state, or null to clear all\n        @param {Object} [cfg] Configuration for request\n            @param {Object} [cfg.agent] Agent used in query,\n                defaults to \'actor\' property if empty\n            @param {Object} [cfg.activity] Activity used in query,\n                defaults to \'activity\' property if empty\n            @param {Object} [cfg.registration] Registration used in query,\n                defaults to \'registration\' property if empty\n            @param {Function} [cfg.callback] Function to run with state\n        */\n        deleteState: function (key, cfg) {\n            this.log("deleteState");\n            var queryCfg,\n                lrs\n            ;\n\n            if (this.recordStores.length > 0) {\n                //\n                // for state (for now) we are only going to store to the first LRS\n                // so only get from there too\n                //\n                // TODO: make this the first non-allowFail LRS but for now it should\n                // be good enough to make it the first since we know the LMS provided\n                // LRS is the first\n                //\n                lrs = this.recordStores[0];\n\n                cfg = cfg || {};\n\n                queryCfg = {\n                    agent: (typeof cfg.agent !== "undefined" ? cfg.agent : this.actor),\n                    activity: (typeof cfg.activity !== "undefined" ? cfg.activity : this.activity)\n                };\n                if (typeof cfg.registration !== "undefined") {\n                    queryCfg.registration = cfg.registration;\n                }\n                else if (this.registration !== null) {\n                    queryCfg.registration = this.registration;\n                }\n                if (typeof cfg.callback !== "undefined") {\n                    queryCfg.callback = cfg.callback;\n                }\n\n                return lrs.dropState(key, queryCfg);\n            }\n\n            this.log("[warning] deleteState: No LRSs added yet (state not deleted)");\n        },\n\n        /**\n        @method getActivityProfile\n        @param {String} key Key to retrieve from the profile\n        @param {Object} [cfg] Configuration for request\n            @param {Object} [cfg.activity] Activity used in query,\n                defaults to \'activity\' property if empty\n            @param {Function} [cfg.callback] Function to run with activity profile\n        */\n        getActivityProfile: function (key, cfg) {\n            this.log("getActivityProfile");\n            var queryCfg,\n                lrs\n            ;\n\n            if (this.recordStores.length > 0) {\n                //\n                // for activity profiles (for now) we are only going to store to the first LRS\n                // so only get from there too\n                //\n                // TODO: make this the first non-allowFail LRS but for now it should\n                // be good enough to make it the first since we know the LMS provided\n                // LRS is the first\n                //\n                lrs = this.recordStores[0];\n\n                cfg = cfg || {};\n\n                queryCfg = {\n                    activity: (typeof cfg.activity !== "undefined" ? cfg.activity : this.activity)\n                };\n                if (typeof cfg.callback !== "undefined") {\n                    queryCfg.callback = cfg.callback;\n                }\n\n                return lrs.retrieveActivityProfile(key, queryCfg);\n            }\n\n            this.log("[warning] getActivityProfile: No LRSs added yet (activity profile not retrieved)");\n        },\n\n        /**\n        @method setActivityProfile\n        @param {String} key Key to store into the activity profile\n        @param {String|Object} val Value to store into the activity profile, objects will be stringified to JSON\n        @param {Object} [cfg] Configuration for request\n            @param {Object} [cfg.activity] Activity used in query,\n                defaults to \'activity\' property if empty\n            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing profile\n            @param {String} [cfg.contentType] Content-Type to specify in headers\n            @param {Boolean} [cfg.overwriteJSON] If the Content-Type is JSON, should a PUT be used?\n            @param {Function} [cfg.callback] Function to run with activity profile\n        */\n        setActivityProfile: function (key, val, cfg) {\n            this.log("setActivityProfile");\n            var queryCfg,\n                lrs\n            ;\n\n            if (this.recordStores.length > 0) {\n                //\n                // for activity profile (for now) we are only going to store to the first LRS\n                // so only get from there too\n                //\n                // TODO: make this the first non-allowFail LRS but for now it should\n                // be good enough to make it the first since we know the LMS provided\n                // LRS is the first\n                //\n                lrs = this.recordStores[0];\n\n                cfg = cfg || {};\n\n                queryCfg = {\n                    activity: (typeof cfg.activity !== "undefined" ? cfg.activity : this.activity)\n                };\n                if (typeof cfg.callback !== "undefined") {\n                    queryCfg.callback = cfg.callback;\n                }\n                if (typeof cfg.lastSHA1 !== "undefined") {\n                    queryCfg.lastSHA1 = cfg.lastSHA1;\n                }\n                if (typeof cfg.contentType !== "undefined") {\n                    queryCfg.contentType = cfg.contentType;\n                    if ((typeof cfg.overwriteJSON !== "undefined") && (! cfg.overwriteJSON) && (TinCan.Utils.isApplicationJSON(cfg.contentType))) {\n                        queryCfg.method = "POST";\n                    }\n                }\n\n                return lrs.saveActivityProfile(key, val, queryCfg);\n            }\n\n            this.log("[warning] setActivityProfile: No LRSs added yet (activity profile not saved)");\n        },\n\n        /**\n        @method deleteActivityProfile\n        @param {String|null} key Key to remove from the activity profile, or null to clear all\n        @param {Object} [cfg] Configuration for request\n            @param {Object} [cfg.activity] Activity used in query,\n                defaults to \'activity\' property if empty\n            @param {Function} [cfg.callback] Function to run with activity profile\n        */\n        deleteActivityProfile: function (key, cfg) {\n            this.log("deleteActivityProfile");\n            var queryCfg,\n                lrs\n            ;\n\n            if (this.recordStores.length > 0) {\n                //\n                // for activity profile (for now) we are only going to store to the first LRS\n                // so only get from there too\n                //\n                // TODO: make this the first non-allowFail LRS but for now it should\n                // be good enough to make it the first since we know the LMS provided\n                // LRS is the first\n                //\n                lrs = this.recordStores[0];\n\n                cfg = cfg || {};\n\n                queryCfg = {\n                    activity: (typeof cfg.activity !== "undefined" ? cfg.activity : this.activity)\n                };\n                if (typeof cfg.callback !== "undefined") {\n                    queryCfg.callback = cfg.callback;\n                }\n\n                return lrs.dropActivityProfile(key, queryCfg);\n            }\n\n            this.log("[warning] deleteActivityProfile: No LRSs added yet (activity profile not deleted)");\n        },\n\n        /**\n        @method getAgentProfile\n        @param {String} key Key to retrieve from the profile\n        @param {Object} [cfg] Configuration for request\n            @param {Object} [cfg.agent] Agent used in query,\n                defaults to \'actor\' property if empty\n            @param {Function} [cfg.callback] Function to run with agent profile\n        */\n        getAgentProfile: function (key, cfg) {\n            this.log("getAgentProfile");\n            var queryCfg,\n                lrs\n            ;\n\n            if (this.recordStores.length > 0) {\n                //\n                // for agent profiles (for now) we are only going to store to the first LRS\n                // so only get from there too\n                //\n                // TODO: make this the first non-allowFail LRS but for now it should\n                // be good enough to make it the first since we know the LMS provided\n                // LRS is the first\n                //\n                lrs = this.recordStores[0];\n\n                cfg = cfg || {};\n\n                queryCfg = {\n                    agent: (typeof cfg.agent !== "undefined" ? cfg.agent : this.actor)\n                };\n                if (typeof cfg.callback !== "undefined") {\n                    queryCfg.callback = cfg.callback;\n                }\n\n                return lrs.retrieveAgentProfile(key, queryCfg);\n            }\n\n            this.log("[warning] getAgentProfile: No LRSs added yet (agent profile not retrieved)");\n        },\n\n        /**\n        @method setAgentProfile\n        @param {String} key Key to store into the agent profile\n        @param {String|Object} val Value to store into the agent profile, objects will be stringified to JSON\n        @param {Object} [cfg] Configuration for request\n            @param {Object} [cfg.agent] Agent used in query,\n                defaults to \'actor\' property if empty\n            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing profile\n            @param {String} [cfg.contentType] Content-Type to specify in headers\n            @param {Boolean} [cfg.overwriteJSON] If the Content-Type is JSON, should a PUT be used?\n            @param {Function} [cfg.callback] Function to run with agent profile\n        */\n        setAgentProfile: function (key, val, cfg) {\n            this.log("setAgentProfile");\n            var queryCfg,\n                lrs\n            ;\n\n            if (this.recordStores.length > 0) {\n                //\n                // for agent profile (for now) we are only going to store to the first LRS\n                // so only get from there too\n                //\n                // TODO: make this the first non-allowFail LRS but for now it should\n                // be good enough to make it the first since we know the LMS provided\n                // LRS is the first\n                //\n                lrs = this.recordStores[0];\n\n                cfg = cfg || {};\n\n                queryCfg = {\n                    agent: (typeof cfg.agent !== "undefined" ? cfg.agent : this.actor)\n                };\n                if (typeof cfg.callback !== "undefined") {\n                    queryCfg.callback = cfg.callback;\n                }\n                if (typeof cfg.lastSHA1 !== "undefined") {\n                    queryCfg.lastSHA1 = cfg.lastSHA1;\n                }\n                if (typeof cfg.contentType !== "undefined") {\n                    queryCfg.contentType = cfg.contentType;\n                    if ((typeof cfg.overwriteJSON !== "undefined") && (! cfg.overwriteJSON) && (TinCan.Utils.isApplicationJSON(cfg.contentType))) {\n                        queryCfg.method = "POST";\n                    }\n                }\n\n                return lrs.saveAgentProfile(key, val, queryCfg);\n            }\n\n            this.log("[warning] setAgentProfile: No LRSs added yet (agent profile not saved)");\n        },\n\n        /**\n        @method deleteAgentProfile\n        @param {String|null} key Key to remove from the agent profile, or null to clear all\n        @param {Object} [cfg] Configuration for request\n            @param {Object} [cfg.agent] Agent used in query,\n                defaults to \'actor\' property if empty\n            @param {Function} [cfg.callback] Function to run with agent profile\n        */\n        deleteAgentProfile: function (key, cfg) {\n            this.log("deleteAgentProfile");\n            var queryCfg,\n                lrs\n            ;\n\n            if (this.recordStores.length > 0) {\n                //\n                // for agent profile (for now) we are only going to store to the first LRS\n                // so only get from there too\n                //\n                // TODO: make this the first non-allowFail LRS but for now it should\n                // be good enough to make it the first since we know the LMS provided\n                // LRS is the first\n                //\n                lrs = this.recordStores[0];\n\n                cfg = cfg || {};\n\n                queryCfg = {\n                    agent: (typeof cfg.agent !== "undefined" ? cfg.agent : this.actor)\n                };\n                if (typeof cfg.callback !== "undefined") {\n                    queryCfg.callback = cfg.callback;\n                }\n\n                return lrs.dropAgentProfile(key, queryCfg);\n            }\n\n            this.log("[warning] deleteAgentProfile: No LRSs added yet (agent profile not deleted)");\n        }\n    };\n\n    /**\n    @property DEBUG\n    @static\n    @default false\n    */\n    TinCan.DEBUG = false;\n\n    /**\n    Turn on debug logging\n\n    @method enableDebug\n    @static\n    */\n    TinCan.enableDebug = function () {\n        TinCan.DEBUG = true;\n    };\n\n    /**\n    Turn off debug logging\n\n    @method disableDebug\n    @static\n    */\n    TinCan.disableDebug = function () {\n        TinCan.DEBUG = false;\n    };\n\n    /**\n    @method versions\n    @return {Array} Array of supported version numbers\n    @static\n    */\n    TinCan.versions = function () {\n        // newest first so we can use the first as the default\n        return [\n            "1.0.2",\n            "1.0.1",\n            "1.0.0",\n            "0.95",\n            "0.9"\n        ];\n    };\n\n    /*global module*/\n    // Support the CommonJS method for exporting our single global\n    if (typeof module === "object") {\n        module.exports = TinCan;\n    }\n}());\n\n/*\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.Utils\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.Utils\n    */\n    TinCan.Utils = {\n        defaultEncoding: "utf8",\n\n        /**\n        Generates a UUIDv4 compliant string that should be reasonably unique\n\n        @method getUUID\n        @return {String} UUID\n        @static\n\n        Excerpt from: http://www.broofa.com/Tools/Math.uuid.js (v1.4)\n        http://www.broofa.com\n        mailto:robert@broofa.com\n        Copyright (c) 2010 Robert Kieffer\n        Dual licensed under the MIT and GPL licenses.\n        */\n        getUUID: function () {\n            /*jslint bitwise: true, eqeq: true */\n            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(\n                /[xy]/g,\n                function (c) {\n                    var r = Math.random() * 16|0, v = c == "x" ? r : (r&0x3|0x8);\n                    return v.toString(16);\n                }\n            );\n        },\n\n        /**\n        @method getISODateString\n        @static\n        @param {Date} date Date to stringify\n        @return {String} ISO date String\n        */\n        getISODateString: function (d) {\n            function pad (val, n) {\n                var padder,\n                    tempVal;\n                if (typeof val === "undefined" || val === null) {\n                    val = 0;\n                }\n                if (typeof n === "undefined" || n === null) {\n                    n = 2;\n                }\n                padder = Math.pow(10, n-1);\n                tempVal = val.toString();\n\n                while (val < padder && padder > 1) {\n                    tempVal = "0" + tempVal;\n                    padder = padder / 10;\n                }\n\n                return tempVal;\n            }\n\n            return d.getUTCFullYear() + "-" +\n                pad(d.getUTCMonth() + 1) + "-" +\n                pad(d.getUTCDate()) + "T" +\n                pad(d.getUTCHours()) + ":" +\n                pad(d.getUTCMinutes()) + ":" +\n                pad(d.getUTCSeconds()) + "." +\n                pad(d.getUTCMilliseconds(), 3) + "Z";\n        },\n\n        /**\n        @method convertISO8601DurationToMilliseconds\n        @static\n        @param {String} ISO8601Duration Duration in ISO8601 format\n        @return {Int} Duration in milliseconds\n\n        Note: does not handle input strings with years, months and days\n        */\n        convertISO8601DurationToMilliseconds: function (ISO8601Duration) {\n            var isValueNegative = (ISO8601Duration.indexOf("-") >= 0),\n                indexOfT = ISO8601Duration.indexOf("T"),\n                indexOfH = ISO8601Duration.indexOf("H"),\n                indexOfM = ISO8601Duration.indexOf("M"),\n                indexOfS = ISO8601Duration.indexOf("S"),\n                hours,\n                minutes,\n                seconds,\n                durationInMilliseconds;\n\n            if ((indexOfT === -1) || ((indexOfM !== -1) && (indexOfM < indexOfT)) || (ISO8601Duration.indexOf("D") !== -1) || (ISO8601Duration.indexOf("Y") !== -1)) {\n                throw new Error("ISO 8601 timestamps including years, months and/or days are not currently supported");\n            }\n\n            if (indexOfH === -1) {\n                indexOfH = indexOfT;\n                hours = 0;\n            }\n            else {\n                hours = parseInt(ISO8601Duration.slice(indexOfT + 1, indexOfH), 10);\n            }\n\n            if (indexOfM === -1) {\n                indexOfM = indexOfT;\n                minutes = 0;\n            }\n            else {\n                minutes = parseInt(ISO8601Duration.slice(indexOfH + 1, indexOfM), 10);\n            }\n\n            seconds = parseFloat(ISO8601Duration.slice(indexOfM + 1, indexOfS));\n\n            durationInMilliseconds = parseInt((((((hours * 60) + minutes) * 60) + seconds) * 1000), 10);\n            if (isNaN(durationInMilliseconds)){\n                durationInMilliseconds = 0;\n            }\n            if (isValueNegative) {\n                durationInMilliseconds = durationInMilliseconds * -1;\n            }\n\n            return durationInMilliseconds;\n        },\n\n        /**\n        @method convertMillisecondsToISO8601Duration\n        @static\n        @param {Int} inputMilliseconds Duration in milliseconds\n        @return {String} Duration in ISO8601 format\n        */\n        convertMillisecondsToISO8601Duration: function (inputMilliseconds) {\n            var hours,\n                minutes,\n                seconds,\n                i_inputMilliseconds = parseInt(inputMilliseconds, 10),\n                i_inputCentiseconds,\n                inputIsNegative = "",\n                rtnStr = "";\n\n            //round to nearest 0.01 seconds\n            i_inputCentiseconds = Math.round(i_inputMilliseconds / 10);\n\n            if (i_inputCentiseconds < 0) {\n                inputIsNegative = "-";\n                i_inputCentiseconds = i_inputCentiseconds * -1;\n            }\n\n            hours = parseInt(((i_inputCentiseconds) / 360000), 10);\n            minutes = parseInt((((i_inputCentiseconds) % 360000) / 6000), 10);\n            seconds = (((i_inputCentiseconds) % 360000) % 6000) / 100;\n\n            rtnStr = inputIsNegative + "PT";\n            if (hours > 0) {\n                rtnStr += hours + "H";\n            }\n\n            if (minutes > 0) {\n                rtnStr += minutes + "M";\n            }\n\n            rtnStr += seconds + "S";\n\n            return rtnStr;\n        },\n\n        /**\n        @method getSHA1String\n        @static\n        @param {String} str Content to hash\n        @return {String} SHA1 for contents\n        */\n        getSHA1String: function (str) {\n            /*global CryptoJS*/\n\n            return CryptoJS.SHA1(str).toString(CryptoJS.enc.Hex);\n        },\n\n        /**\n        @method getSHA256String\n        @static\n        @param {ArrayBuffer|String} content Content to hash\n        @return {String} SHA256 for contents\n        */\n        getSHA256String: function (content) {\n            /*global CryptoJS*/\n\n            if (Object.prototype.toString.call(content) === "[object ArrayBuffer]") {\n                content = CryptoJS.lib.WordArray.create(content);\n            }\n            return CryptoJS.SHA256(content).toString(CryptoJS.enc.Hex);\n        },\n\n        /**\n        @method getBase64String\n        @static\n        @param {String} str Content to encode\n        @return {String} Base64 encoded contents\n        */\n        getBase64String: function (str) {\n            /*global CryptoJS*/\n\n            return CryptoJS.enc.Base64.stringify(\n                CryptoJS.enc.Latin1.parse(str)\n            );\n        },\n\n        /**\n        Intended to be inherited by objects with properties that store\n        display values in a language based "dictionary"\n\n        @method getLangDictionaryValue\n        @param {String} prop Property name storing the dictionary\n        @param {String} [lang] Language to return\n        @return {String}\n        */\n        getLangDictionaryValue: function (prop, lang) {\n            var langDict = this[prop],\n                key;\n\n            if (typeof lang !== "undefined" && typeof langDict[lang] !== "undefined") {\n                return langDict[lang];\n            }\n            if (typeof langDict.und !== "undefined") {\n                return langDict.und;\n            }\n            if (typeof langDict["en-US"] !== "undefined") {\n                return langDict["en-US"];\n            }\n            for (key in langDict) {\n                if (langDict.hasOwnProperty(key)) {\n                    return langDict[key];\n                }\n            }\n\n            return "";\n        },\n\n        /**\n        @method parseURL\n        @param {String} url\n        @param {Object} [options]\n            @param {Boolean} [options.allowRelative] Option to allow relative URLs\n        @return {Object} Object of values\n        @private\n        */\n        parseURL: function (url, cfg) {\n            //\n            // see http://stackoverflow.com/a/21553982\n            // and http://stackoverflow.com/a/2880929\n            //\n            var isRelative = url.charAt(0) === "/",\n                _reURLInformation = [\n                    "(/[^?#]*)", // pathname\n                    "(\\\\?[^#]*|)", // search\n                    "(#.*|)$" // hash\n                ],\n                reURLInformation,\n                match,\n                result,\n                paramMatch,\n                pl     = /\\+/g,  // Regex for replacing addition symbol with a space\n                search = /([^&=]+)=?([^&]*)/g,\n                decode = function (s) { return decodeURIComponent(s); };\n                //decode = function (s) { return decodeURIComponent(s.replace(pl, " ")); };\n            cfg = cfg || {};\n\n            //\n            // this method in an earlier version supported relative URLs, mostly to provide\n            // support to the `LRS.moreStatements` method, that functionality was removed and\n            // subsequently restored but with the addition of the option for allowing relative\n            // URLs to be accepted which is the reason for the "helpful" exception message here\n            //\n            if (! isRelative) {\n                //\n                // not relative so make sure they have a scheme, host, etc.\n                //\n                _reURLInformation.unshift(\n                    "^(https?:)//", // scheme\n                    "(([^:/?#]*)(?::([0-9]+))?)" // host (hostname and port)\n                );\n\n                //\n                // our regex requires there to be a \'/\' for the detection of the start\n                // of the path, we can detect a \'/\' using indexOf beyond the part of the\n                // scheme, since we\'ve restricted scheme to \'http\' or \'https\' and because\n                // a hostname is guaranteed to be there we can detect beyond the \'://\'\n                // based on position, then tack on a trailing \'/\' because it can\'t be\n                // part of the path\n                //\n                if (url.indexOf("/", 8) === -1) {\n                    url = url + "/";\n                }\n            }\n            else {\n                //\n                // relative so make sure they allow that explicitly\n                //\n                if (typeof cfg.allowRelative === "undefined" || ! cfg.allowRelative) {\n                    throw new Error("Refusing to parse relative URL without \'allowRelative\' option");\n                }\n            }\n\n            reURLInformation = new RegExp(_reURLInformation.join(""));\n            match = url.match(reURLInformation);\n            if (match === null) {\n                throw new Error("Unable to parse URL regular expression did not match: \'" + url + "\'");\n            }\n\n            // \'path\' is for backwards compatibility\n            if (isRelative) {\n                result = {\n                    protocol: null,\n                    host: null,\n                    hostname: null,\n                    port: null,\n                    path: null,\n                    pathname: match[1],\n                    search: match[2],\n                    hash: match[3],\n                    params: {}\n                };\n\n                result.path = result.pathname;\n            }\n            else {\n                result = {\n                    protocol: match[1],\n                    host: match[2],\n                    hostname: match[3],\n                    port: match[4],\n                    pathname: match[5],\n                    search: match[6],\n                    hash: match[7],\n                    params: {}\n                };\n\n                result.path = result.protocol + "//" + result.host + result.pathname;\n            }\n\n            if (result.search !== "") {\n                // extra parens to let jshint know this is an expression\n                while ((paramMatch = search.exec(result.search.substring(1)))) {\n                    result.params[decode(paramMatch[1])] = decode(paramMatch[2]);\n                }\n            }\n\n            return result;\n        },\n\n        /**\n        @method getServerRoot\n        @param {String} absoluteUrl\n        @return {String} server root of url\n        @private\n        */\n        getServerRoot: function (absoluteUrl) {\n            var urlParts = absoluteUrl.split("/");\n            return urlParts[0] + "//" + urlParts[2];\n        },\n\n        /**\n        @method getContentTypeFromHeader\n        @static\n        @param {String} header Content-Type header value\n        @return {String} Primary value from Content-Type\n        */\n        getContentTypeFromHeader: function (header) {\n            return (String(header).split(";"))[0];\n        },\n\n        /**\n        @method isApplicationJSON\n        @static\n        @param {String} header Content-Type header value\n        @return {Boolean} whether "application/json" was matched\n        */\n        isApplicationJSON: function (header) {\n            return TinCan.Utils.getContentTypeFromHeader(header).toLowerCase().indexOf("application/json") === 0;\n        },\n\n        /**\n        @method stringToArrayBuffer\n        @static\n        @param {String} content String of content to convert to an ArrayBuffer\n        @param {String} [encoding] Encoding to use for conversion\n        @return {ArrayBuffer} Converted content\n        */\n        stringToArrayBuffer: function () {\n            TinCan.prototype.log("stringToArrayBuffer not overloaded - no environment loaded?");\n        },\n\n        /**\n        @method stringFromArrayBuffer\n        @static\n        @param {ArrayBuffer} content ArrayBuffer of content to convert to a String\n        @param {String} [encoding] Encoding to use for conversion\n        @return {String} Converted content\n        */\n        stringFromArrayBuffer: function () {\n            TinCan.prototype.log("stringFromArrayBuffer not overloaded - no environment loaded?");\n        }\n    };\n}());\n\n/*\n    Copyright 2012-2013 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.LRS\n**/\n(function () {\n    "use strict";\n    /**\n    @class TinCan.LRS\n    @constructor\n    */\n    var LRS = TinCan.LRS = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property endpoint\n        @type String\n        */\n        this.endpoint = null;\n\n        /**\n        @property version\n        @type String\n        */\n        this.version = null;\n\n        /**\n        @property auth\n        @type String\n        */\n        this.auth = null;\n\n        /**\n        @property allowFail\n        @type Boolean\n        @default true\n        */\n        this.allowFail = true;\n\n        /**\n        @property extended\n        @type Object\n        */\n        this.extended = null;\n\n        this.init(cfg);\n    };\n    LRS.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "LRS",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        */\n        init: function (cfg) {\n            this.log("init");\n\n            var versions = TinCan.versions(),\n                versionMatch = false,\n                i\n            ;\n\n            cfg = cfg || {};\n\n            if (cfg.hasOwnProperty("alertOnRequestFailure")) {\n                this.log("\'alertOnRequestFailure\' is deprecated (alerts have been removed) no need to set it now");\n            }\n\n            if (! cfg.hasOwnProperty("endpoint") || cfg.endpoint === null || cfg.endpoint === "") {\n                this.log("[error] LRS invalid: no endpoint");\n                throw {\n                    code: 3,\n                    mesg: "LRS invalid: no endpoint"\n                };\n            }\n\n            this.endpoint = String(cfg.endpoint);\n            if (this.endpoint.slice(-1) !== "/") {\n                this.log("adding trailing slash to endpoint");\n                this.endpoint += "/";\n            }\n\n            if (cfg.hasOwnProperty("allowFail")) {\n                this.allowFail = cfg.allowFail;\n            }\n\n            if (cfg.hasOwnProperty("auth")) {\n                this.auth = cfg.auth;\n            }\n            else if (cfg.hasOwnProperty("username") && cfg.hasOwnProperty("password")) {\n                this.auth = "Basic " + TinCan.Utils.getBase64String(cfg.username + ":" + cfg.password);\n            }\n\n            if (cfg.hasOwnProperty("extended")) {\n                this.extended = cfg.extended;\n            }\n\n            //\n            // provide a hook method that environments can override\n            // to handle anything necessary in the initialization\n            // process that is customized to them, such as cross domain\n            // setup in browsers, default implementation is empty\n            //\n            // this hook must run prior to version detection so that\n            // request handling can be set up before requesting the\n            // LRS version via the /about resource\n            //\n            this._initByEnvironment(cfg);\n\n            if (typeof cfg.version !== "undefined") {\n                this.log("version: " + cfg.version);\n                for (i = 0; i < versions.length; i += 1) {\n                    if (versions[i] === cfg.version) {\n                        versionMatch = true;\n                        break;\n                    }\n                }\n                if (! versionMatch) {\n                    this.log("[error] LRS invalid: version not supported (" + cfg.version + ")");\n                    throw {\n                        code: 5,\n                        mesg: "LRS invalid: version not supported (" + cfg.version + ")"\n                    };\n                }\n                this.version = cfg.version;\n            }\n            else {\n                //\n                // assume max supported when not specified,\n                // TODO: add detection of LRS from call to endpoint\n                //\n                this.version = versions[0];\n            }\n        },\n\n        /**\n        Creates and returns a boundary for separating parts in\n        requests where the statement has an attachment\n\n        @method _getBoundary\n        @private\n        */\n        _getBoundary: function () {\n            return TinCan.Utils.getUUID().replace(/-/g, "");\n        },\n\n        /**\n        Method should be overloaded by an environment to do per\n        environment specifics such that the LRS can make a call\n        to set the version if not provided\n\n        @method _initByEnvironment\n        @private\n        */\n        _initByEnvironment: function () {\n            this.log("_initByEnvironment not overloaded - no environment loaded?");\n        },\n\n        /**\n        Method should be overloaded by an environment to do per\n        environment specifics for sending requests to the LRS\n\n        @method _makeRequest\n        @private\n        */\n        _makeRequest: function () {\n            this.log("_makeRequest not overloaded - no environment loaded?");\n        },\n\n        /**\n        Method should be overloaded by an environment to do per\n        environment specifics for building multipart request data\n\n        @method _getMultipartRequestData\n        @private\n        */\n        _getMultipartRequestData: function () {\n            this.log("_getMultipartRequestData not overloaded - no environment loaded?");\n        },\n\n        /**\n        Method is overloaded by the browser environment in order to test converting an\n        HTTP request that is greater than a defined length\n\n        @method _IEModeConversion\n        @private\n        */\n        _IEModeConversion: function () {\n            this.log("_IEModeConversion not overloaded - browser environment not loaded.");\n        },\n\n        _processGetStatementResult: function (xhr, params) {\n            var boundary,\n                parsedResponse,\n                statement,\n                attachmentMap = {},\n                i;\n\n            if (! params.attachments) {\n                return TinCan.Statement.fromJSON(xhr.responseText);\n            }\n\n            boundary = xhr.getResponseHeader("Content-Type").split("boundary=")[1];\n\n            parsedResponse = this._parseMultipart(boundary, xhr.response);\n            statement = JSON.parse(parsedResponse[0].body);\n            for (i = 1; i < parsedResponse.length; i += 1) {\n                attachmentMap[parsedResponse[i].headers["X-Experience-API-Hash"]] = parsedResponse[i].body;\n            }\n\n            this._assignAttachmentContent([statement], attachmentMap);\n\n            return new TinCan.Statement(statement);\n        },\n\n        /**\n        Method used to send a request via browser objects to the LRS\n\n        @method sendRequest\n        @param {Object} cfg Configuration for request\n            @param {String} cfg.url URL portion to add to endpoint\n            @param {String} [cfg.method] GET, PUT, POST, etc.\n            @param {Object} [cfg.params] Parameters to set on the querystring\n            @param {String|ArrayBuffer} [cfg.data] Body content as a String or ArrayBuffer\n            @param {Object} [cfg.headers] Additional headers to set in the request\n            @param {Function} [cfg.callback] Function to run at completion\n                @param {String|Null} cfg.callback.err If an error occurred, this parameter will contain the HTTP status code.\n                    If the operation succeeded, err will be null.\n                @param {Object} cfg.callback.xhr XHR object\n            @param {Boolean} [cfg.ignore404] Whether 404 status codes should be considered an error\n            @param {Boolean} [cfg.expectMultipart] Whether to expect the response to be a multipart response\n        @return {Object} XHR if called in a synchronous way (in other words no callback)\n        */\n        sendRequest: function (cfg) {\n            this.log("sendRequest");\n            var fullUrl = this.endpoint + cfg.url,\n                headers = {},\n                prop\n            ;\n\n            // respect absolute URLs passed in\n            if (cfg.url.indexOf("http") === 0) {\n                fullUrl = cfg.url;\n            }\n\n            // add extended LMS-specified values to the params\n            if (this.extended !== null) {\n                cfg.params = cfg.params || {};\n\n                for (prop in this.extended) {\n                    if (this.extended.hasOwnProperty(prop)) {\n                        // don\'t overwrite cfg.params values that have already been added to the request with our extended params\n                        if (! cfg.params.hasOwnProperty(prop)) {\n                            if (this.extended[prop] !== null) {\n                                cfg.params[prop] = this.extended[prop];\n                            }\n                        }\n                    }\n                }\n            }\n\n            // consolidate headers\n            headers.Authorization = this.auth;\n            if (this.version !== "0.9") {\n                headers["X-Experience-API-Version"] = this.version;\n            }\n\n            for (prop in cfg.headers) {\n                if (cfg.headers.hasOwnProperty(prop)) {\n                    headers[prop] = cfg.headers[prop];\n                }\n            }\n\n            return this._makeRequest(fullUrl, headers, cfg);\n        },\n\n        /**\n        Method used to determine the LRS version\n\n        @method about\n        @param {Object} cfg Configuration object for the about request\n            @param {Function} [cfg.callback] Callback to execute upon receiving a response\n            @param {Object} [cfg.params] this is needed, but can be empty\n        @return {Object} About which holds the version, or asyncrhonously calls a specified callback\n        */\n        about: function (cfg) {\n            this.log("about");\n            var requestCfg,\n                requestResult,\n                callbackWrapper;\n\n            cfg = cfg || {};\n\n            requestCfg = {\n                url: "about",\n                method: "GET",\n                params: {}\n            };\n            if (typeof cfg.callback !== "undefined") {\n                callbackWrapper = function (err, xhr) {\n                    var result = xhr;\n\n                    if (err === null) {\n                        result = TinCan.About.fromJSON(xhr.responseText);\n                    }\n\n                    cfg.callback(err, result);\n                };\n                requestCfg.callback = callbackWrapper;\n            }\n\n            requestResult = this.sendRequest(requestCfg);\n\n            if (callbackWrapper) {\n                return;\n            }\n\n            if (requestResult.err === null) {\n                requestResult.xhr = TinCan.About.fromJSON(requestResult.xhr.responseText);\n            }\n            return requestResult;\n        },\n\n        /**\n        Save a statement, when used from a browser sends to the endpoint using the RESTful interface.\n        Use a callback to make the call asynchronous.\n\n        @method saveStatement\n        @param {TinCan.Statement} statement to send\n        @param {Object} [cfg] Configuration used when saving\n            @param {Function} [cfg.callback] Callback to execute on completion\n        */\n        saveStatement: function (stmt, cfg) {\n            this.log("saveStatement");\n            var requestCfg = {\n                    url: "statements",\n                    headers: {}\n                },\n                versionedStatement,\n                requestAttachments = [],\n                boundary,\n                i;\n\n            cfg = cfg || {};\n\n            try {\n                versionedStatement = stmt.asVersion( this.version );\n            }\n            catch (ex) {\n                if (this.allowFail) {\n                    this.log("[warning] statement could not be serialized in version (" + this.version + "): " + ex);\n                    if (typeof cfg.callback !== "undefined") {\n                        cfg.callback(null, null);\n                        return;\n                    }\n                    return {\n                        err: null,\n                        xhr: null\n                    };\n                }\n\n                this.log("[error] statement could not be serialized in version (" + this.version + "): " + ex);\n                if (typeof cfg.callback !== "undefined") {\n                    cfg.callback(ex, null);\n                    return;\n                }\n                return {\n                    err: ex,\n                    xhr: null\n                };\n            }\n\n            if (versionedStatement.hasOwnProperty("attachments") && stmt.hasAttachmentWithContent()) {\n                boundary = this._getBoundary();\n\n                requestCfg.headers["Content-Type"] = "multipart/mixed; boundary=" + boundary;\n\n                for (i = 0; i < stmt.attachments.length; i += 1) {\n                    if (stmt.attachments[i].content !== null) {\n                        requestAttachments.push(stmt.attachments[i]);\n                    }\n                }\n\n                try {\n                    requestCfg.data = this._getMultipartRequestData(boundary, versionedStatement, requestAttachments);\n                }\n                catch (ex) {\n                    if (this.allowFail) {\n                        this.log("[warning] multipart request data could not be created (attachments probably not supported): " + ex);\n                        if (typeof cfg.callback !== "undefined") {\n                            cfg.callback(null, null);\n                            return;\n                        }\n                        return {\n                            err: null,\n                            xhr: null\n                        };\n                    }\n\n                    this.log("[error] multipart request data could not be created (attachments probably not supported): " + ex);\n                    if (typeof cfg.callback !== "undefined") {\n                        cfg.callback(ex, null);\n                        return;\n                    }\n                    return {\n                        err: ex,\n                        xhr: null\n                    };\n                }\n            }\n            else {\n                requestCfg.headers["Content-Type"] = "application/json";\n                requestCfg.data = JSON.stringify(versionedStatement);\n            }\n            if (stmt.id !== null) {\n                requestCfg.method = "PUT";\n                requestCfg.params = {\n                    statementId: stmt.id\n                };\n            }\n            else {\n                requestCfg.method = "POST";\n            }\n\n            if (typeof cfg.callback !== "undefined") {\n                requestCfg.callback = cfg.callback;\n            }\n\n            return this.sendRequest(requestCfg);\n        },\n\n        /**\n        Retrieve a statement, when used from a browser sends to the endpoint using the RESTful interface.\n\n        @method retrieveStatement\n        @param {String} ID of statement to retrieve\n        @param {Object} [cfg] Configuration options\n            @param {Object} [cfg.params] Query parameters\n                @param {Boolean} [cfg.params.attachments] Include attachments in multipart response or don\'t (default: false)\n            @param {Function} [cfg.callback] Callback to execute on completion\n        @return {TinCan.Statement} Statement retrieved\n        */\n        retrieveStatement: function (stmtId, cfg) {\n            this.log("retrieveStatement");\n            var requestCfg,\n                requestResult,\n                callbackWrapper,\n                lrs = this;\n\n            cfg = cfg || {};\n            cfg.params = cfg.params || {};\n\n            requestCfg = {\n                url: "statements",\n                method: "GET",\n                params: {\n                    statementId: stmtId\n                }\n            };\n            if (cfg.params.attachments) {\n                requestCfg.params.attachments = true;\n                requestCfg.expectMultipart = true;\n            }\n            if (typeof cfg.callback !== "undefined") {\n                callbackWrapper = function (err, xhr) {\n                    var result = xhr;\n\n                    if (err === null) {\n                        result = lrs._processGetStatementResult(xhr, cfg.params);\n                    }\n\n                    cfg.callback(err, result);\n                };\n                requestCfg.callback = callbackWrapper;\n            }\n\n            requestResult = this.sendRequest(requestCfg);\n            if (! callbackWrapper) {\n                requestResult.statement = null;\n                if (requestResult.err === null) {\n                    requestResult.statement = lrs._processGetStatementResult(requestResult.xhr, cfg.params);\n                }\n            }\n\n            return requestResult;\n        },\n\n        /**\n        Retrieve a voided statement, when used from a browser sends to the endpoint using the RESTful interface.\n\n        @method retrieveVoidedStatement\n        @param {String} ID of voided statement to retrieve\n        @param {Object} [cfg] Configuration options\n            @param {Object} [cfg.params] Query parameters\n                @param {Boolean} [cfg.params.attachments] Include attachments in multipart response or don\'t (default: false)\n            @param {Function} [cfg.callback] Callback to execute on completion\n        @return {TinCan.Statement} Statement retrieved\n        */\n        retrieveVoidedStatement: function (stmtId, cfg) {\n            this.log("retrieveVoidedStatement");\n            var requestCfg,\n                requestResult,\n                callbackWrapper,\n                lrs = this;\n\n            cfg = cfg || {};\n            cfg.params = cfg.params || {};\n\n            requestCfg = {\n                url: "statements",\n                method: "GET",\n                params: {}\n            };\n            if (this.version === "0.9" || this.version === "0.95") {\n                requestCfg.params.statementId = stmtId;\n            }\n            else {\n                requestCfg.params.voidedStatementId = stmtId;\n                if (cfg.params.attachments) {\n                    requestCfg.params.attachments = true;\n                    requestCfg.expectMultipart = true;\n                }\n            }\n\n            if (typeof cfg.callback !== "undefined") {\n                callbackWrapper = function (err, xhr) {\n                    var result = xhr;\n\n                    if (err === null) {\n                        result = lrs._processGetStatementResult(xhr, cfg.params);\n                    }\n\n                    cfg.callback(err, result);\n                };\n                requestCfg.callback = callbackWrapper;\n            }\n\n            requestResult = this.sendRequest(requestCfg);\n            if (! callbackWrapper) {\n                requestResult.statement = null;\n                if (requestResult.err === null) {\n                    requestResult.statement = lrs._processGetStatementResult(requestResult.xhr, cfg.params);\n                }\n            }\n\n            return requestResult;\n        },\n\n        /**\n        Save a set of statements, when used from a browser sends to the endpoint using the RESTful interface.\n        Use a callback to make the call asynchronous.\n\n        @method saveStatements\n        @param {Array} Array of statements or objects convertable to statements\n        @param {Object} [cfg] Configuration used when saving\n            @param {Function} [cfg.callback] Callback to execute on completion\n        */\n        saveStatements: function (stmts, cfg) {\n            this.log("saveStatements");\n            var requestCfg = {\n                    url: "statements",\n                    method: "POST",\n                    headers: {}\n                },\n                versionedStatement,\n                versionedStatements = [],\n                requestAttachments = [],\n                boundary,\n                i,\n                j;\n\n            cfg = cfg || {};\n\n            if (stmts.length === 0) {\n                if (typeof cfg.callback !== "undefined") {\n                    cfg.callback(new Error("no statements"), null);\n                    return;\n                }\n                return {\n                    err: new Error("no statements"),\n                    xhr: null\n                };\n            }\n\n            for (i = 0; i < stmts.length; i += 1) {\n                try {\n                    versionedStatement = stmts[i].asVersion( this.version );\n                }\n                catch (ex) {\n                    if (this.allowFail) {\n                        this.log("[warning] statement could not be serialized in version (" + this.version + "): " + ex);\n                        if (typeof cfg.callback !== "undefined") {\n                            cfg.callback(null, null);\n                            return;\n                        }\n                        return {\n                            err: null,\n                            xhr: null\n                        };\n                    }\n\n                    this.log("[error] statement could not be serialized in version (" + this.version + "): " + ex);\n                    if (typeof cfg.callback !== "undefined") {\n                        cfg.callback(ex, null);\n                        return;\n                    }\n                    return {\n                        err: ex,\n                        xhr: null\n                    };\n                }\n\n                if (stmts[i].hasAttachmentWithContent()) {\n                    for (j = 0; j < stmts[i].attachments.length; j += 1) {\n                        if (stmts[i].attachments[j].content !== null) {\n                            requestAttachments.push(stmts[i].attachments[j]);\n                        }\n                    }\n                }\n\n                versionedStatements.push(versionedStatement);\n            }\n\n            if (requestAttachments.length !== 0) {\n                boundary = this._getBoundary();\n\n                requestCfg.headers["Content-Type"] = "multipart/mixed; boundary=" + boundary;\n\n                try {\n                    requestCfg.data = this._getMultipartRequestData(boundary, versionedStatements, requestAttachments);\n                }\n                catch (ex) {\n                    if (this.allowFail) {\n                        this.log("[warning] multipart request data could not be created (attachments probably not supported): " + ex);\n                        if (typeof cfg.callback !== "undefined") {\n                            cfg.callback(null, null);\n                            return;\n                        }\n                        return {\n                            err: null,\n                            xhr: null\n                        };\n                    }\n\n                    this.log("[error] multipart request data could not be created (attachments probably not supported): " + ex);\n                    if (typeof cfg.callback !== "undefined") {\n                        cfg.callback(ex, null);\n                        return;\n                    }\n                    return {\n                        err: ex,\n                        xhr: null\n                    };\n                }\n            }\n            else {\n                requestCfg.headers["Content-Type"] = "application/json";\n                requestCfg.data = JSON.stringify(versionedStatements);\n            }\n\n            if (typeof cfg.callback !== "undefined") {\n                requestCfg.callback = cfg.callback;\n            }\n\n            return this.sendRequest(requestCfg);\n        },\n\n        /**\n        Fetch a set of statements, when used from a browser sends to the endpoint using the\n        RESTful interface.  Use a callback to make the call asynchronous.\n\n        @method queryStatements\n        @param {Object} [cfg] Configuration used to query\n            @param {Object} [cfg.params] Query parameters\n                @param {TinCan.Agent|TinCan.Group} [cfg.params.agent] Agent matches \'actor\' or \'object\'\n                @param {TinCan.Verb|String} [cfg.params.verb] Verb (or verb ID) to query on\n                @param {TinCan.Activity|String} [cfg.params.activity] Activity (or activity ID) to query on\n                @param {String} [cfg.params.registration] Registration UUID\n                @param {Boolean} [cfg.params.related_activities] Match related activities\n                @param {Boolean} [cfg.params.related_agents] Match related agents\n                @param {String} [cfg.params.since] Match statements stored since specified timestamp\n                @param {String} [cfg.params.until] Match statements stored at or before specified timestamp\n                @param {Integer} [cfg.params.limit] Number of results to retrieve\n                @param {String} [cfg.params.format] One of "ids", "exact", "canonical" (default: "exact")\n                @param {Boolean} [cfg.params.ascending] Return results in ascending order of stored time\n\n                @param {TinCan.Agent} [cfg.params.actor] (Removed in 1.0.0, use \'agent\' instead) Agent matches \'actor\'\n                @param {TinCan.Activity|TinCan.Agent|TinCan.Statement} [cfg.params.target] (Removed in 1.0.0, use \'activity\' or \'agent\' instead) Activity, Agent, or Statement matches \'object\'\n                @param {TinCan.Agent} [cfg.params.instructor] (Removed in 1.0.0, use \'agent\' + \'related_agents\' instead) Agent matches \'context:instructor\'\n                @param {Boolean} [cfg.params.context] (Removed in 1.0.0, use \'activity\' instead) When filtering on target, include statements with matching context\n                @param {Boolean} [cfg.params.authoritative] (Removed in 1.0.0) Get authoritative results\n                @param {Boolean} [cfg.params.sparse] (Removed in 1.0.0, use \'format\' instead) Get sparse results\n\n            @param {Function} [cfg.callback] Callback to execute on completion\n                @param {String|null} cfg.callback.err Error status or null if succcess\n                @param {TinCan.StatementsResult|XHR} cfg.callback.response Receives a StatementsResult argument\n        @return {Object} Request result\n        */\n        queryStatements: function (cfg) {\n            this.log("queryStatements");\n            var requestCfg,\n                requestResult,\n                callbackWrapper,\n                lrs = this;\n\n            cfg = cfg || {};\n            cfg.params = cfg.params || {};\n\n            //\n            // if they misconfigured (possibly due to version mismatches) the\n            // query then don\'t try to send a request at all, rather than give\n            // them invalid results\n            //\n            try {\n                requestCfg = this._queryStatementsRequestCfg(cfg);\n\n                if (cfg.params.attachments) {\n                    requestCfg.expectMultipart = true;\n                }\n            }\n            catch (ex) {\n                this.log("[error] Query statements failed - " + ex);\n                if (typeof cfg.callback !== "undefined") {\n                    cfg.callback(ex, {});\n                }\n\n                return {\n                    err: ex,\n                    statementsResult: null\n                };\n            }\n\n            if (typeof cfg.callback !== "undefined") {\n                callbackWrapper = function (err, xhr) {\n                    var result = xhr,\n                        parsedResponse,\n                        boundary,\n                        statements,\n                        attachmentMap = {},\n                        i;\n\n                    if (err === null) {\n                        if (! cfg.params.attachments) {\n                            result = TinCan.StatementsResult.fromJSON(xhr.responseText);\n                        }\n                        else {\n                            boundary = xhr.getResponseHeader("Content-Type").split("boundary=")[1];\n\n                            parsedResponse = lrs._parseMultipart(boundary, xhr.response);\n                            statements = JSON.parse(parsedResponse[0].body);\n                            for (i = 1; i < parsedResponse.length; i += 1) {\n                                attachmentMap[parsedResponse[i].headers["X-Experience-API-Hash"]] = parsedResponse[i].body;\n                            }\n\n                            lrs._assignAttachmentContent(statements.statements, attachmentMap);\n                            result = new TinCan.StatementsResult({ statements: statements.statements });\n\n                            for (i = 0; i < result.statements.length; i += 1) {\n                                if (! (result.statements[i] instanceof TinCan.Statement)) {\n                                    result.statements[i] = new TinCan.Statement(result.statements[i]);\n                                }\n                            }\n                        }\n                    }\n\n                    cfg.callback(err, result);\n                };\n                requestCfg.callback = callbackWrapper;\n            }\n\n            requestResult = this.sendRequest(requestCfg);\n            requestResult.config = requestCfg;\n\n            if (! callbackWrapper) {\n                requestResult.statementsResult = null;\n                if (requestResult.err === null) {\n                    requestResult.statementsResult = TinCan.StatementsResult.fromJSON(requestResult.xhr.responseText);\n                }\n            }\n\n            return requestResult;\n        },\n\n        /**\n        Build a request config object that can be passed to sendRequest() to make a query request\n\n        @method _queryStatementsRequestCfg\n        @private\n        @param {Object} [cfg] See configuration for {{#crossLink "TinCan.LRS/queryStatements"}}{{/crossLink}}\n        @return {Object} Request configuration object\n        */\n        _queryStatementsRequestCfg: function (cfg) {\n            this.log("_queryStatementsRequestCfg");\n            var params = {},\n                returnCfg = {\n                    url: "statements",\n                    method: "GET",\n                    params: params\n                },\n                jsonProps = [\n                    "agent",\n                    "actor",\n                    "object",\n                    "instructor"\n                ],\n                idProps = [\n                    "verb",\n                    "activity"\n                ],\n                valProps = [\n                    "registration",\n                    "context",\n                    "since",\n                    "until",\n                    "limit",\n                    "authoritative",\n                    "sparse",\n                    "ascending",\n                    "related_activities",\n                    "related_agents",\n                    "format",\n                    "attachments"\n                ],\n                i,\n                prop,\n                //\n                // list of parameters that are supported in all versions (supported by\n                // this library) of the spec\n                //\n                universal = {\n                    verb: true,\n                    registration: true,\n                    since: true,\n                    until: true,\n                    limit: true,\n                    ascending: true\n                },\n                //\n                // future proofing here, "supported" is an object so that\n                // in the future we can support a "deprecated" list to\n                // throw warnings, hopefully the spec uses deprecation phases\n                // for the removal of these things\n                //\n                compatibility = {\n                    "0.9": {\n                        supported: {\n                            actor: true,\n                            instructor: true,\n                            target: true,\n                            object: true,\n                            context: true,\n                            authoritative: true,\n                            sparse: true\n                        }\n                    },\n                    "1.0.0": {\n                        supported: {\n                            agent: true,\n                            activity: true,\n                            related_activities: true,\n                            related_agents: true,\n                            format: true,\n                            attachments: true\n                        }\n                    }\n                };\n\n            compatibility["0.95"] = compatibility["0.9"];\n            compatibility["1.0.1"] = compatibility["1.0.0"];\n            compatibility["1.0.2"] = compatibility["1.0.0"];\n\n            if (cfg.params.hasOwnProperty("target")) {\n                cfg.params.object = cfg.params.target;\n            }\n\n            //\n            // check compatibility tables, either the configured parameter is in\n            // the universal list or the specific version, if not then throw an\n            // error which at least for .queryStatements will prevent the request\n            // and potentially alert the user\n            //\n            for (prop in cfg.params) {\n                if (cfg.params.hasOwnProperty(prop)) {\n                    if (typeof universal[prop] === "undefined" && typeof compatibility[this.version].supported[prop] === "undefined") {\n                        throw "Unrecognized query parameter configured: " + prop;\n                    }\n                }\n            }\n\n            //\n            // getting here means that all parameters are valid for this version\n            // to make handling the output formats easier\n            //\n\n            for (i = 0; i < jsonProps.length; i += 1) {\n                if (typeof cfg.params[jsonProps[i]] !== "undefined") {\n                    params[jsonProps[i]] = JSON.stringify(cfg.params[jsonProps[i]].asVersion(this.version));\n                }\n            }\n\n            for (i = 0; i < idProps.length; i += 1) {\n                if (typeof cfg.params[idProps[i]] !== "undefined") {\n                    if (typeof cfg.params[idProps[i]].id === "undefined") {\n                        params[idProps[i]] = cfg.params[idProps[i]];\n                    }\n                    else {\n                        params[idProps[i]] = cfg.params[idProps[i]].id;\n                    }\n                }\n            }\n\n            for (i = 0; i < valProps.length; i += 1) {\n                if (typeof cfg.params[valProps[i]] !== "undefined" && cfg.params[valProps[i]] !== null) {\n                    params[valProps[i]] = cfg.params[valProps[i]];\n                }\n            }\n\n            return returnCfg;\n        },\n\n        /**\n        Assigns attachment content to the correct attachment to create a StatementsResult object that is sent\n        to the callback of queryStatements()\n\n        @method _assignAttachmentContent\n        @private\n        @param {Array} [stmts] Array of TinCan.Statement JSON objects\n        @param {Object} [attachmentMap] Map of the content to place into its attachment\n        @return {Array} Array of TinCan.Statement JSON objects with correctly assigned attachment content\n        */\n        _assignAttachmentContent: function (stmts, attachmentMap) {\n            var i,\n                j;\n\n            for (i = 0; i < stmts.length; i += 1) {\n                if (stmts[i].hasOwnProperty("attachments") && stmts[i].attachments !== null) {\n                    for (j = 0; j < stmts[i].attachments.length; j += 1) {\n                        if (attachmentMap.hasOwnProperty(stmts[i].attachments[j].sha2)) {\n                            stmts[i].attachments[j].content = attachmentMap[stmts[i].attachments[j].sha2];\n                        }\n                    }\n                }\n            }\n        },\n\n        /**\n        Parses the different sections of a multipart/mixed response\n\n        @method _parseMultipart\n        @private\n        @param {String} [boundary] Boundary used to mark off the sections of the response\n        @param {ArrayBuffer} [response] Body of the response\n        @return {Array} Array of objects containing the parsed headers and body of each part\n        */\n        _parseMultipart: function (boundary, response) {\n            /* global Uint8Array */\n            var __boundary = "--" + boundary,\n                byteArray,\n                bodyEncodedInString,\n                fullBodyEnd,\n                sliceStart,\n                sliceEnd,\n                headerStart,\n                headerEnd,\n                bodyStart,\n                bodyEnd,\n                headers,\n                body,\n                parts = [],\n                CRLF = 2;\n\n            //\n            // treating the reponse as a stream of bytes and assuming that headers\n            // and related mime boundaries are all US-ASCII (which is a safe assumption)\n            // allows us to treat the whole response as a string when looking for offsets\n            // but then slice on the raw array buffer\n            //\n            byteArray = new Uint8Array(response);\n            bodyEncodedInString = this.__uint8ToString(byteArray);\n\n            fullBodyEnd = bodyEncodedInString.indexOf(__boundary + "--");\n\n            sliceStart = bodyEncodedInString.indexOf(__boundary);\n            while (sliceStart !== -1) {\n                sliceEnd = bodyEncodedInString.indexOf(__boundary, sliceStart + __boundary.length);\n\n                headerStart = sliceStart + __boundary.length + CRLF;\n                headerEnd = bodyEncodedInString.indexOf("\\r\\n\\r\\n", sliceStart);\n                bodyStart = headerEnd + CRLF + CRLF;\n                bodyEnd = sliceEnd - 2;\n\n                headers = this._parseHeaders(\n                    this.__uint8ToString(\n                        new Uint8Array( response.slice(headerStart, headerEnd) )\n                    )\n                );\n                body = response.slice(bodyStart, bodyEnd);\n\n                //\n                // we know the first slice is the statement, and we know it is a string in UTF-8 (spec requirement)\n                //\n                if (parts.length === 0) {\n                    body = TinCan.Utils.stringFromArrayBuffer(body);\n                }\n\n                parts.push(\n                    {\n                        headers: headers,\n                        body: body\n                    }\n                );\n\n                if (sliceEnd === fullBodyEnd) {\n                    sliceStart = -1;\n                }\n                else {\n                    sliceStart = sliceEnd;\n                }\n            }\n\n            return parts;\n        },\n\n        //\n        // implemented as a function to avoid \'RangeError: Maximum call stack size exceeded\'\n        // when calling .fromCharCode on the full byteArray which results in a too long\n        // argument list for large arrays\n        //\n        __uint8ToString: function (byteArray) {\n            var result = "",\n                len = byteArray.byteLength,\n                i;\n\n            for (i = 0; i < len; i += 1) {\n                result += String.fromCharCode(byteArray[i]);\n            }\n            return result;\n        },\n\n        /**\n        Parses the headers of a multipart/mixed response section\n\n        @method _parseHeaders\n        @private\n        @param {String} [rawHeaders] String containing all the headers\n        @return {Object} Map of the headers\n        */\n        _parseHeaders: function (rawHeaders) {\n            var headers = {},\n                headerList,\n                key,\n                h,\n                i;\n\n            headerList = rawHeaders.split("\\n");\n            for (i = 0; i < headerList.length; i += 1) {\n                h = headerList[i].split(":", 2);\n\n                if (h[1] !== null) {\n                    headers[h[0]] = h[1].replace(/^\\s+|\\s+$/g, "");\n\n                    key = h[0];\n                }\n                else {\n                    if (h[0].substring(0, 1) === "\\t") {\n                        headers[h[0]] = h[1].replace(/^\\s+|\\s+$/g, "");\n                    }\n                }\n            }\n\n            return headers;\n        },\n\n        /**\n        Fetch more statements from a previous query, when used from a browser sends to the endpoint using the\n        RESTful interface.  Use a callback to make the call asynchronous.\n\n        @method moreStatements\n        @param {Object} [cfg] Configuration used to query\n            @param {String} [cfg.url] More URL\n            @param {Function} [cfg.callback] Callback to execute on completion\n                @param {String|null} cfg.callback.err Error status or null if succcess\n                @param {TinCan.StatementsResult|XHR} cfg.callback.response Receives a StatementsResult argument\n        @return {Object} Request result\n        */\n        moreStatements: function (cfg) {\n            this.log("moreStatements: " + cfg.url);\n            var requestCfg,\n                requestResult,\n                callbackWrapper,\n                parsedURL,\n                serverRoot;\n\n            cfg = cfg || {};\n\n            // to support our interface (to support IE) we need to break apart\n            // the more URL query params so that the request can be made properly later\n            parsedURL = TinCan.Utils.parseURL(cfg.url, { allowRelative: true });\n\n            // Respect a more URL that is relative to either the server root\n            // or endpoint (though only the former is allowed in the spec)\n            serverRoot = TinCan.Utils.getServerRoot(this.endpoint);\n            if (parsedURL.path.indexOf("/statements") === 0){\n                parsedURL.path = this.endpoint.replace(serverRoot, "") + parsedURL.path;\n                this.log("converting non-standard more URL to " + parsedURL.path);\n            }\n\n            // The more relative URL might not start with a slash, add it if not\n            if (parsedURL.path.indexOf("/") !== 0) {\n                parsedURL.path = "/" + parsedURL.path;\n            }\n\n            requestCfg = {\n                method: "GET",\n                // For arbitrary more URLs to work, we need to make the URL absolute here\n                url: serverRoot + parsedURL.path,\n                params: parsedURL.params\n            };\n            if (typeof cfg.callback !== "undefined") {\n                callbackWrapper = function (err, xhr) {\n                    var result = xhr;\n\n                    if (err === null) {\n                        result = TinCan.StatementsResult.fromJSON(xhr.responseText);\n                    }\n\n                    cfg.callback(err, result);\n                };\n                requestCfg.callback = callbackWrapper;\n            }\n\n            requestResult = this.sendRequest(requestCfg);\n            requestResult.config = requestCfg;\n\n            if (! callbackWrapper) {\n                requestResult.statementsResult = null;\n                if (requestResult.err === null) {\n                    requestResult.statementsResult = TinCan.StatementsResult.fromJSON(requestResult.xhr.responseText);\n                }\n            }\n\n            return requestResult;\n        },\n\n        /**\n        Retrieve a state value, when used from a browser sends to the endpoint using the RESTful interface.\n\n        @method retrieveState\n        @param {String} key Key of state to retrieve\n        @param {Object} cfg Configuration options\n            @param {TinCan.Activity} cfg.activity Activity in document identifier\n            @param {TinCan.Agent} cfg.agent Agent in document identifier\n            @param {String} [cfg.registration] Registration\n            @param {Function} [cfg.callback] Callback to execute on completion\n                @param {Object|Null} cfg.callback.error\n                @param {TinCan.State|null} cfg.callback.result null if state is 404\n            @param {Object} [cfg.requestHeaders] Object containing additional headers to add to request\n        @return {TinCan.State|Object} TinCan.State retrieved when synchronous, or result from sendRequest\n        */\n        retrieveState: function (key, cfg) {\n            this.log("retrieveState");\n            var requestParams = {},\n                requestCfg = {},\n                requestResult,\n                callbackWrapper,\n                requestHeaders,\n                self = this;\n\n            requestHeaders = cfg.requestHeaders || {};\n\n            requestParams = {\n                stateId: key,\n                activityId: cfg.activity.id\n            };\n            if (this.version === "0.9") {\n                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));\n            }\n            else {\n                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));\n            }\n            if ((typeof cfg.registration !== "undefined") && (cfg.registration !== null)) {\n                if (this.version === "0.9") {\n                    requestParams.registrationId = cfg.registration;\n                }\n                else {\n                    requestParams.registration = cfg.registration;\n                }\n            }\n\n            requestCfg = {\n                url: "activities/state",\n                method: "GET",\n                params: requestParams,\n                ignore404: true,\n                headers: requestHeaders\n            };\n\n            if (typeof cfg.callback !== "undefined") {\n                callbackWrapper = function (err, xhr) {\n                    var result = xhr;\n\n                    if (err === null) {\n                        if (xhr.status === 404) {\n                            result = null;\n                        }\n                        else {\n                            result = new TinCan.State(\n                                {\n                                    id: key,\n                                    contents: xhr.responseText\n                                }\n                            );\n                            if (typeof xhr.getResponseHeader !== "undefined" && xhr.getResponseHeader("ETag") !== null && xhr.getResponseHeader("ETag") !== "") {\n                                result.etag = xhr.getResponseHeader("ETag");\n                            }\n                            else {\n                                //\n                                // either XHR didn\'t have getResponseHeader (probably cause it is an IE\n                                // XDomainRequest object which doesn\'t) or not populated by LRS so create\n                                // the hash ourselves\n                                //\n                                // the LRS is responsible for quoting the Etag value so we need to mimic\n                                // that behavior here as well\n                                //\n                                result.etag = "\\"" + TinCan.Utils.getSHA1String(xhr.responseText) + "\\"";\n                            }\n\n                            if (typeof xhr.contentType !== "undefined") {\n                                // most likely an XDomainRequest which has .contentType,\n                                // for the ones that it supports\n                                result.contentType = xhr.contentType;\n                            }\n                            else if (typeof xhr.getResponseHeader !== "undefined" && xhr.getResponseHeader("Content-Type") !== null && xhr.getResponseHeader("Content-Type") !== "") {\n                                result.contentType = xhr.getResponseHeader("Content-Type");\n                            }\n\n                            if (TinCan.Utils.isApplicationJSON(result.contentType)) {\n                                try {\n                                    result.contents = JSON.parse(result.contents);\n                                } catch (ex) {\n                                    self.log("retrieveState - failed to deserialize JSON: " + ex);\n                                }\n                            }\n                        }\n                    }\n\n                    cfg.callback(err, result);\n                };\n                requestCfg.callback = callbackWrapper;\n            }\n\n            requestResult = this.sendRequest(requestCfg);\n            if (! callbackWrapper) {\n                requestResult.state = null;\n                if (requestResult.err === null && requestResult.xhr.status !== 404) {\n                    requestResult.state = new TinCan.State(\n                        {\n                            id: key,\n                            contents: requestResult.xhr.responseText\n                        }\n                    );\n                    if (typeof requestResult.xhr.getResponseHeader !== "undefined" && requestResult.xhr.getResponseHeader("ETag") !== null && requestResult.xhr.getResponseHeader("ETag") !== "") {\n                        requestResult.state.etag = requestResult.xhr.getResponseHeader("ETag");\n                    }\n                    else {\n                        //\n                        // either XHR didn\'t have getResponseHeader (probably cause it is an IE\n                        // XDomainRequest object which doesn\'t) or not populated by LRS so create\n                        // the hash ourselves\n                        //\n                        // the LRS is responsible for quoting the Etag value so we need to mimic\n                        // that behavior here as well\n                        //\n                        requestResult.state.etag = "\\"" + TinCan.Utils.getSHA1String(requestResult.xhr.responseText) + "\\"";\n                    }\n                    if (typeof requestResult.xhr.contentType !== "undefined") {\n                        // most likely an XDomainRequest which has .contentType\n                        // for the ones that it supports\n                        requestResult.state.contentType = requestResult.xhr.contentType;\n                    }\n                    else if (typeof requestResult.xhr.getResponseHeader !== "undefined" && requestResult.xhr.getResponseHeader("Content-Type") !== null && requestResult.xhr.getResponseHeader("Content-Type") !== "") {\n                        requestResult.state.contentType = requestResult.xhr.getResponseHeader("Content-Type");\n                    }\n                    if (TinCan.Utils.isApplicationJSON(requestResult.state.contentType)) {\n                        try {\n                            requestResult.state.contents = JSON.parse(requestResult.state.contents);\n                        } catch (ex) {\n                            this.log("retrieveState - failed to deserialize JSON: " + ex);\n                        }\n                    }\n                }\n            }\n\n            return requestResult;\n        },\n\n        /**\n        Retrieve the list of IDs for a state, when used from a browser sends to the endpoint using the RESTful interface.\n\n        @method retrieveStateIds\n        @param {Object} cfg Configuration options\n            @param {TinCan.Activity} cfg.activity Activity in document identifier\n            @param {TinCan.Agent} cfg.agent Agent in document identifier\n            @param {String} [cfg.registration] Registration\n            @param {Function} [cfg.callback] Callback to execute on completion\n            @param {String} [cfg.since] Match activity profiles saved since given timestamp\n            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request\n        @return {Object} requestResult Request result\n        */\n        retrieveStateIds: function (cfg) {\n            this.log("retrieveStateIds");\n            var requestParams = {},\n                requestCfg,\n                requestHeaders,\n                requestResult,\n                callbackWrapper;\n\n            cfg = cfg || {};\n            requestHeaders = cfg.requestHeaders || {};\n\n            requestParams.activityId = cfg.activity.id;\n            if (this.version === "0.9") {\n                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));\n            }\n            else {\n                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));\n            }\n            if ((typeof cfg.registration !== "undefined") && (cfg.registration !== null)) {\n                if (this.version === "0.9") {\n                    requestParams.registrationId = cfg.registration;\n                }\n                else {\n                    requestParams.registration = cfg.registration;\n                }\n            }\n\n            requestCfg = {\n                url: "activities/state",\n                method: "GET",\n                params: requestParams,\n                headers: requestHeaders,\n                ignore404: true\n            };\n            if (typeof cfg.callback !== "undefined") {\n                callbackWrapper = function (err, xhr) {\n                    var result = xhr;\n\n                    if (err !== null) {\n                        cfg.callback(err, result);\n                        return;\n                    }\n\n                    if (xhr.status === 404) {\n                        result = [];\n                    }\n                    else {\n                        try {\n                            result = JSON.parse(xhr.responseText);\n                        }\n                        catch (ex) {\n                            err = "Response JSON parse error: " + ex;\n                        }\n                    }\n\n                    cfg.callback(err, result);\n                };\n                requestCfg.callback = callbackWrapper;\n            }\n            if (typeof cfg.since !== "undefined") {\n                requestCfg.params.since = cfg.since;\n            }\n\n            requestResult = this.sendRequest(requestCfg);\n            if (! callbackWrapper) {\n                requestResult.profileIds = null;\n                if (requestResult.err !== null) {\n                    return requestResult;\n                }\n\n                if (requestResult.xhr.status === 404) {\n                    requestResult.profileIds = [];\n                }\n                else {\n                    try {\n                        requestResult.profileIds = JSON.parse(requestResult.xhr.responseText);\n                    }\n                    catch (ex) {\n                        requestResult.err = "retrieveStateIds - JSON parse error: " + ex;\n                    }\n                }\n            }\n            return requestResult;\n        },\n\n        /**\n        Save a state value, when used from a browser sends to the endpoint using the RESTful interface.\n\n        @method saveState\n        @param {String} key Key of state to save\n        @param val Value to be stored\n        @param {Object} cfg Configuration options\n            @param {TinCan.Activity} cfg.activity Activity in document identifier\n            @param {TinCan.Agent} cfg.agent Agent in document identifier\n            @param {String} [cfg.registration] Registration\n            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing state\n            @param {String} [cfg.contentType] Content-Type to specify in headers (defaults to \'application/octet-stream\')\n            @param {String} [cfg.method] Method to use. Default: PUT\n            @param {Function} [cfg.callback] Callback to execute on completion\n            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request\n        */\n        saveState: function (key, val, cfg) {\n            this.log("saveState");\n            var requestParams,\n                requestCfg,\n                requestHeaders;\n\n            requestHeaders = cfg.requestHeaders || {};\n\n            if (typeof cfg.contentType === "undefined") {\n                cfg.contentType = "application/octet-stream";\n            }\n            requestHeaders["Content-Type"] = cfg.contentType;\n\n            if (typeof val === "object" && TinCan.Utils.isApplicationJSON(cfg.contentType)) {\n                val = JSON.stringify(val);\n            }\n\n            if (typeof cfg.method === "undefined" || cfg.method !== "POST") {\n                cfg.method = "PUT";\n            }\n\n            requestParams = {\n                stateId: key,\n                activityId: cfg.activity.id\n            };\n            if (this.version === "0.9") {\n                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));\n            }\n            else {\n                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));\n            }\n            if ((typeof cfg.registration !== "undefined") && (cfg.registration !== null)) {\n                if (this.version === "0.9") {\n                    requestParams.registrationId = cfg.registration;\n                }\n                else {\n                    requestParams.registration = cfg.registration;\n                }\n            }\n\n            requestCfg = {\n                url: "activities/state",\n                method: cfg.method,\n                params: requestParams,\n                data: val,\n                headers: requestHeaders\n            };\n\n            if (typeof cfg.callback !== "undefined") {\n                requestCfg.callback = cfg.callback;\n            }\n            if (typeof cfg.lastSHA1 !== "undefined" && cfg.lastSHA1 !== null) {\n                requestCfg.headers["If-Match"] = cfg.lastSHA1;\n            }\n\n            return this.sendRequest(requestCfg);\n        },\n\n        /**\n        Drop a state value or all of the state, when used from a browser sends to the endpoint using the RESTful interface.\n\n        @method dropState\n        @param {String|null} key Key of state to delete, or null for all\n        @param {Object} cfg Configuration options\n            @param {TinCan.Activity} cfg.activity Activity in document identifier\n            @param {TinCan.Agent} cfg.agent Agent in document identifier\n            @param {String} [cfg.registration] Registration\n            @param {Function} [cfg.callback] Callback to execute on completion\n            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request\n        */\n        dropState: function (key, cfg) {\n            this.log("dropState");\n            var requestParams,\n                requestCfg,\n                requestHeaders;\n\n            requestHeaders = cfg.requestHeaders || {};\n\n            requestParams = {\n                activityId: cfg.activity.id\n            };\n            if (this.version === "0.9") {\n                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));\n            }\n            else {\n                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));\n            }\n            if (key !== null) {\n                requestParams.stateId = key;\n            }\n            if ((typeof cfg.registration !== "undefined") && (cfg.registration !== null)) {\n                if (this.version === "0.9") {\n                    requestParams.registrationId = cfg.registration;\n                }\n                else {\n                    requestParams.registration = cfg.registration;\n                }\n            }\n\n            requestCfg = {\n                url: "activities/state",\n                method: "DELETE",\n                params: requestParams,\n                headers: requestHeaders\n            };\n\n            if (typeof cfg.callback !== "undefined") {\n                requestCfg.callback = cfg.callback;\n            }\n\n            return this.sendRequest(requestCfg);\n        },\n\n        /**\n        Retrieve an activity, when used from a browser sends to the endpoint using the RESTful interface.\n\n        @method retrieveActivity\n        @param {String} activityId id of the Activity to retrieve\n        @param {Object} cfg Configuration options\n            @param {Function} [cfg.callback] Callback to execute on completion\n            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request\n        @return {Object} Value retrieved\n        */\n        retrieveActivity: function (activityId, cfg) {\n            this.log("retrieveActivity");\n            var requestCfg = {},\n                requestResult,\n                callbackWrapper,\n                requestHeaders;\n\n            requestHeaders = cfg.requestHeaders || {};\n\n            requestCfg = {\n                url: "activities",\n                method: "GET",\n                params: {\n                    activityId: activityId\n                },\n                ignore404: true,\n                headers: requestHeaders\n            };\n\n            if (typeof cfg.callback !== "undefined") {\n                callbackWrapper = function (err, xhr) {\n                    var result = xhr;\n\n                    if (err === null) {\n                        //\n                        // a 404 really shouldn\'t happen because the LRS can dynamically\n                        // build the response based on what has been passed to it, but\n                        // don\'t have the client fail in the condition that it does, because\n                        // we can do the same thing\n                        //\n                        if (xhr.status === 404) {\n                            result = new TinCan.Activity(\n                                {\n                                    id: activityId\n                                }\n                            );\n                        }\n                        else {\n                            result = TinCan.Activity.fromJSON(xhr.responseText);\n                        }\n                    }\n\n                    cfg.callback(err, result);\n                };\n                requestCfg.callback = callbackWrapper;\n            }\n\n            requestResult = this.sendRequest(requestCfg);\n            if (! callbackWrapper) {\n                requestResult.activity = null;\n                if (requestResult.err === null) {\n                    if (requestResult.xhr.status === 404) {\n                        requestResult.activity = new TinCan.Activity(\n                            {\n                                id: activityId\n                            }\n                        );\n                    }\n                    else {\n                        requestResult.activity = TinCan.Activity.fromJSON(requestResult.xhr.responseText);\n                    }\n                }\n            }\n\n            return requestResult;\n        },\n\n        /**\n        Retrieve an activity profile value, when used from a browser sends to the endpoint using the RESTful interface.\n\n        @method retrieveActivityProfile\n        @param {String} key Key of activity profile to retrieve\n        @param {Object} cfg Configuration options\n            @param {TinCan.Activity} cfg.activity Activity in document identifier\n            @param {Function} [cfg.callback] Callback to execute on completion\n            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request\n        @return {Object} Value retrieved\n        */\n        retrieveActivityProfile: function (key, cfg) {\n            this.log("retrieveActivityProfile");\n            var requestCfg = {},\n                requestResult,\n                callbackWrapper,\n                requestHeaders,\n                self = this;\n\n            requestHeaders = cfg.requestHeaders || {};\n\n            requestCfg = {\n                url: "activities/profile",\n                method: "GET",\n                params: {\n                    profileId: key,\n                    activityId: cfg.activity.id\n                },\n                ignore404: true,\n                headers: requestHeaders\n            };\n\n            if (typeof cfg.callback !== "undefined") {\n                callbackWrapper = function (err, xhr) {\n                    var result = xhr;\n\n                    if (err === null) {\n                        if (xhr.status === 404) {\n                            result = null;\n                        }\n                        else {\n                            result = new TinCan.ActivityProfile(\n                                {\n                                    id: key,\n                                    activity: cfg.activity,\n                                    contents: xhr.responseText\n                                }\n                            );\n                            if (typeof xhr.getResponseHeader !== "undefined" && xhr.getResponseHeader("ETag") !== null && xhr.getResponseHeader("ETag") !== "") {\n                                result.etag = xhr.getResponseHeader("ETag");\n                            }\n                            else {\n                                //\n                                // either XHR didn\'t have getResponseHeader (probably cause it is an IE\n                                // XDomainRequest object which doesn\'t) or not populated by LRS so create\n                                // the hash ourselves\n                                //\n                                // the LRS is responsible for quoting the Etag value so we need to mimic\n                                // that behavior here as well\n                                //\n                                result.etag = "\\"" + TinCan.Utils.getSHA1String(xhr.responseText) + "\\"";\n                            }\n                            if (typeof xhr.contentType !== "undefined") {\n                                // most likely an XDomainRequest which has .contentType\n                                // for the ones that it supports\n                                result.contentType = xhr.contentType;\n                            }\n                            else if (typeof xhr.getResponseHeader !== "undefined" && xhr.getResponseHeader("Content-Type") !== null && xhr.getResponseHeader("Content-Type") !== "") {\n                                result.contentType = xhr.getResponseHeader("Content-Type");\n                            }\n                            if (TinCan.Utils.isApplicationJSON(result.contentType)) {\n                                try {\n                                    result.contents = JSON.parse(result.contents);\n                                } catch (ex) {\n                                    self.log("retrieveActivityProfile - failed to deserialize JSON: " + ex);\n                                }\n                            }\n                        }\n                    }\n\n                    cfg.callback(err, result);\n                };\n                requestCfg.callback = callbackWrapper;\n            }\n\n            requestResult = this.sendRequest(requestCfg);\n            if (! callbackWrapper) {\n                requestResult.profile = null;\n                if (requestResult.err === null && requestResult.xhr.status !== 404) {\n                    requestResult.profile = new TinCan.ActivityProfile(\n                        {\n                            id: key,\n                            activity: cfg.activity,\n                            contents: requestResult.xhr.responseText\n                        }\n                    );\n                    if (typeof requestResult.xhr.getResponseHeader !== "undefined" && requestResult.xhr.getResponseHeader("ETag") !== null && requestResult.xhr.getResponseHeader("ETag") !== "") {\n                        requestResult.profile.etag = requestResult.xhr.getResponseHeader("ETag");\n                    }\n                    else {\n                        //\n                        // either XHR didn\'t have getResponseHeader (probably cause it is an IE\n                        // XDomainRequest object which doesn\'t) or not populated by LRS so create\n                        // the hash ourselves\n                        //\n                        // the LRS is responsible for quoting the Etag value so we need to mimic\n                        // that behavior here as well\n                        //\n                        requestResult.profile.etag = "\\"" + TinCan.Utils.getSHA1String(requestResult.xhr.responseText) + "\\"";\n                    }\n                    if (typeof requestResult.xhr.contentType !== "undefined") {\n                        // most likely an XDomainRequest which has .contentType\n                        // for the ones that it supports\n                        requestResult.profile.contentType = requestResult.xhr.contentType;\n                    }\n                    else if (typeof requestResult.xhr.getResponseHeader !== "undefined" && requestResult.xhr.getResponseHeader("Content-Type") !== null && requestResult.xhr.getResponseHeader("Content-Type") !== "") {\n                        requestResult.profile.contentType = requestResult.xhr.getResponseHeader("Content-Type");\n                    }\n                    if (TinCan.Utils.isApplicationJSON(requestResult.profile.contentType)) {\n                        try {\n                            requestResult.profile.contents = JSON.parse(requestResult.profile.contents);\n                        } catch (ex) {\n                            this.log("retrieveActivityProfile - failed to deserialize JSON: " + ex);\n                        }\n                    }\n                }\n            }\n\n            return requestResult;\n        },\n\n        /**\n        Retrieve the list of IDs for an activity profile, when used from a browser sends to the endpoint using the RESTful interface.\n\n        @method retrieveActivityProfileIds\n        @param {Object} cfg Configuration options\n            @param {TinCan.Activity} cfg.activity Activity in document identifier\n            @param {Function} [cfg.callback] Callback to execute on completion\n            @param {String} [cfg.since] Match activity profiles saved since given timestamp\n            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request\n        @return {Array} List of ids for this Activity profile\n        */\n        retrieveActivityProfileIds: function (cfg) {\n            this.log("retrieveActivityProfileIds");\n            var requestCfg,\n                requestHeaders,\n                requestResult,\n                callbackWrapper;\n\n            cfg = cfg || {};\n            requestHeaders = cfg.requestHeaders || {};\n\n            requestCfg = {\n                url: "activities/profile",\n                method: "GET",\n                params: {\n                    activityId: cfg.activity.id\n                },\n                headers: requestHeaders,\n                ignore404: true\n            };\n            if (typeof cfg.callback !== "undefined") {\n                callbackWrapper = function (err, xhr) {\n                    var result = xhr;\n\n                    if (err !== null) {\n                        cfg.callback(err, result);\n                        return;\n                    }\n\n                    if (xhr.status === 404) {\n                        result = [];\n                    }\n                    else {\n                        try {\n                            result = JSON.parse(xhr.responseText);\n                        }\n                        catch (ex) {\n                            err = "Response JSON parse error: " + ex;\n                        }\n                    }\n\n                    cfg.callback(err, result);\n                };\n                requestCfg.callback = callbackWrapper;\n            }\n            if (typeof cfg.since !== "undefined") {\n                requestCfg.params.since = cfg.since;\n            }\n\n            requestResult = this.sendRequest(requestCfg);\n            if (! callbackWrapper) {\n                requestResult.profileIds = null;\n                if (requestResult.err !== null) {\n                    return requestResult;\n                }\n\n                if (requestResult.xhr.status === 404) {\n                    requestResult.profileIds = [];\n                }\n                else {\n                    try {\n                        requestResult.profileIds = JSON.parse(requestResult.xhr.responseText);\n                    }\n                    catch (ex) {\n                        requestResult.err = "retrieveActivityProfileIds - JSON parse error: " + ex;\n                    }\n                }\n            }\n            return requestResult;\n        },\n\n        /**\n        Save an activity profile value, when used from a browser sends to the endpoint using the RESTful interface.\n\n        @method saveActivityProfile\n        @param {String} key Key of activity profile to retrieve\n        @param val Value to be stored\n        @param {Object} cfg Configuration options\n            @param {TinCan.Activity} cfg.activity Activity in document identifier\n            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing profile\n            @param {String} [cfg.contentType] Content-Type to specify in headers (defaults to \'application/octet-stream\')\n            @param {String} [cfg.method] Method to use. Default: PUT\n            @param {Function} [cfg.callback] Callback to execute on completion\n            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request\n        */\n        saveActivityProfile: function (key, val, cfg) {\n            this.log("saveActivityProfile");\n            var requestCfg,\n                requestHeaders;\n\n            requestHeaders = cfg.requestHeaders || {};\n\n            if (typeof cfg.contentType === "undefined") {\n                cfg.contentType = "application/octet-stream";\n            }\n            requestHeaders["Content-Type"] = cfg.contentType;\n\n            if (typeof cfg.method === "undefined" || cfg.method !== "POST") {\n                cfg.method = "PUT";\n            }\n\n            if (typeof val === "object" && TinCan.Utils.isApplicationJSON(cfg.contentType)) {\n                val = JSON.stringify(val);\n            }\n\n            requestCfg = {\n                url: "activities/profile",\n                method: cfg.method,\n                params: {\n                    profileId: key,\n                    activityId: cfg.activity.id\n                },\n                data: val,\n                headers: requestHeaders\n            };\n\n            if (typeof cfg.callback !== "undefined") {\n                requestCfg.callback = cfg.callback;\n            }\n            if (typeof cfg.lastSHA1 !== "undefined" && cfg.lastSHA1 !== null) {\n                requestCfg.headers["If-Match"] = cfg.lastSHA1;\n            }\n            else {\n                requestCfg.headers["If-None-Match"] = "*";\n            }\n\n            return this.sendRequest(requestCfg);\n        },\n\n        /**\n        Drop an activity profile value, when used from a browser sends to the endpoint using the RESTful interface. Full activity profile\n        delete is not supported by the spec.\n\n        @method dropActivityProfile\n        @param {String|null} key Key of activity profile to delete\n        @param {Object} cfg Configuration options\n            @param {TinCan.Activity} cfg.activity Activity in document identifier\n            @param {Function} [cfg.callback] Callback to execute on completion\n            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request\n        */\n        dropActivityProfile: function (key, cfg) {\n            this.log("dropActivityProfile");\n            var requestParams,\n                requestCfg,\n                requestHeaders;\n\n            requestHeaders = cfg.requestHeaders || {};\n\n            requestParams = {\n                profileId: key,\n                activityId: cfg.activity.id\n            };\n\n            requestCfg = {\n                url: "activities/profile",\n                method: "DELETE",\n                params: requestParams,\n                headers: requestHeaders\n            };\n\n            if (typeof cfg.callback !== "undefined") {\n                requestCfg.callback = cfg.callback;\n            }\n\n            return this.sendRequest(requestCfg);\n        },\n\n        /**\n        Retrieve an agent profile value, when used from a browser sends to the endpoint using the RESTful interface.\n\n        @method retrieveAgentProfile\n        @param {String} key Key of agent profile to retrieve\n        @param {Object} cfg Configuration options\n            @param {TinCan.Agent} cfg.agent Agent in document identifier\n            @param {Function} [cfg.callback] Callback to execute on completion\n            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request\n        @return {Object} Value retrieved\n        */\n        retrieveAgentProfile: function (key, cfg) {\n            this.log("retrieveAgentProfile");\n            var requestCfg = {},\n                requestResult,\n                callbackWrapper,\n                requestHeaders,\n                self = this;\n\n            requestHeaders = cfg.requestHeaders || {};\n\n            requestCfg = {\n                method: "GET",\n                params: {\n                    profileId: key\n                },\n                ignore404: true,\n                headers: requestHeaders\n            };\n\n            if (this.version === "0.9") {\n                requestCfg.url = "actors/profile";\n                requestCfg.params.actor = JSON.stringify(cfg.agent.asVersion(this.version));\n            }\n            else {\n                requestCfg.url = "agents/profile";\n                requestCfg.params.agent = JSON.stringify(cfg.agent.asVersion(this.version));\n            }\n            if (typeof cfg.callback !== "undefined") {\n                callbackWrapper = function (err, xhr) {\n                    var result = xhr;\n\n                    if (err === null) {\n                        if (xhr.status === 404) {\n                            result = null;\n                        }\n                        else {\n                            result = new TinCan.AgentProfile(\n                                {\n                                    id: key,\n                                    agent: cfg.agent,\n                                    contents: xhr.responseText\n                                }\n                            );\n                            if (typeof xhr.getResponseHeader !== "undefined" && xhr.getResponseHeader("ETag") !== null && xhr.getResponseHeader("ETag") !== "") {\n                                result.etag = xhr.getResponseHeader("ETag");\n                            }\n                            else {\n                                //\n                                // either XHR didn\'t have getResponseHeader (probably cause it is an IE\n                                // XDomainRequest object which doesn\'t) or not populated by LRS so create\n                                // the hash ourselves\n                                //\n                                // the LRS is responsible for quoting the Etag value so we need to mimic\n                                // that behavior here as well\n                                //\n                                result.etag = "\\"" + TinCan.Utils.getSHA1String(xhr.responseText) + "\\"";\n                            }\n                            if (typeof xhr.contentType !== "undefined") {\n                                // most likely an XDomainRequest which has .contentType\n                                // for the ones that it supports\n                                result.contentType = xhr.contentType;\n                            }\n                            else if (typeof xhr.getResponseHeader !== "undefined" && xhr.getResponseHeader("Content-Type") !== null && xhr.getResponseHeader("Content-Type") !== "") {\n                                result.contentType = xhr.getResponseHeader("Content-Type");\n                            }\n                            if (TinCan.Utils.isApplicationJSON(result.contentType)) {\n                                try {\n                                    result.contents = JSON.parse(result.contents);\n                                } catch (ex) {\n                                    self.log("retrieveAgentProfile - failed to deserialize JSON: " + ex);\n                                }\n                            }\n                        }\n                    }\n\n                    cfg.callback(err, result);\n                };\n                requestCfg.callback = callbackWrapper;\n            }\n\n            requestResult = this.sendRequest(requestCfg);\n            if (! callbackWrapper) {\n                requestResult.profile = null;\n                if (requestResult.err === null && requestResult.xhr.status !== 404) {\n                    requestResult.profile = new TinCan.AgentProfile(\n                        {\n                            id: key,\n                            agent: cfg.agent,\n                            contents: requestResult.xhr.responseText\n                        }\n                    );\n                    if (typeof requestResult.xhr.getResponseHeader !== "undefined" && requestResult.xhr.getResponseHeader("ETag") !== null && requestResult.xhr.getResponseHeader("ETag") !== "") {\n                        requestResult.profile.etag = requestResult.xhr.getResponseHeader("ETag");\n                    }\n                    else {\n                        //\n                        // either XHR didn\'t have getResponseHeader (probably cause it is an IE\n                        // XDomainRequest object which doesn\'t) or not populated by LRS so create\n                        // the hash ourselves\n                        //\n                        // the LRS is responsible for quoting the Etag value so we need to mimic\n                        // that behavior here as well\n                        //\n                        requestResult.profile.etag = "\\"" + TinCan.Utils.getSHA1String(requestResult.xhr.responseText) + "\\"";\n                    }\n                    if (typeof requestResult.xhr.contentType !== "undefined") {\n                        // most likely an XDomainRequest which has .contentType\n                        // for the ones that it supports\n                        requestResult.profile.contentType = requestResult.xhr.contentType;\n                    }\n                    else if (typeof requestResult.xhr.getResponseHeader !== "undefined" && requestResult.xhr.getResponseHeader("Content-Type") !== null && requestResult.xhr.getResponseHeader("Content-Type") !== "") {\n                        requestResult.profile.contentType = requestResult.xhr.getResponseHeader("Content-Type");\n                    }\n                    if (TinCan.Utils.isApplicationJSON(requestResult.profile.contentType)) {\n                        try {\n                            requestResult.profile.contents = JSON.parse(requestResult.profile.contents);\n                        } catch (ex) {\n                            this.log("retrieveAgentProfile - failed to deserialize JSON: " + ex);\n                        }\n                    }\n                }\n            }\n\n            return requestResult;\n        },\n\n        /**\n        Retrieve the list of profileIds for an agent profile, when used from a browser sends to the endpoint using the RESTful interface.\n\n        @method retrieveAgentProfileIds\n        @param {Object} cfg Configuration options\n            @param {TinCan.Agent} cfg.agent Agent in document identifier\n            @param {Function} [cfg.callback] Callback to execute on completion\n            @param {String} [cfg.since] Match activity profiles saved since given timestamp\n            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request\n        @return {Array} List of profileIds for this Agent\n\n        */\n        retrieveAgentProfileIds: function (cfg) {\n            this.log("retrieveAgentProfileIds");\n            var requestParams = {},\n                requestCfg,\n                requestHeaders,\n                requestResult,\n                callbackWrapper;\n\n            cfg = cfg || {};\n            requestHeaders = cfg.requestHeaders || {};\n\n            requestCfg = {\n                method: "GET",\n                params: requestParams,\n                headers: requestHeaders,\n                ignore404: true\n            };\n\n            if (this.version === "0.9") {\n                requestCfg.url = "actors/profile";\n                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));\n            }\n            else {\n                requestCfg.url = "agents/profile";\n                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));\n            }\n            if (typeof cfg.callback !== "undefined") {\n                callbackWrapper = function (err, xhr) {\n                    var result = xhr;\n\n                    if (err !== null) {\n                        cfg.callback(err, result);\n                        return;\n                    }\n\n                    if (xhr.status === 404) {\n                        result = [];\n                    }\n                    else {\n                        try {\n                            result = JSON.parse(xhr.responseText);\n                        }\n                        catch (ex) {\n                            err = "Response JSON parse error: " + ex;\n                        }\n                    }\n\n                    cfg.callback(err, result);\n                };\n                requestCfg.callback = callbackWrapper;\n            }\n            if (typeof cfg.since !== "undefined") {\n                requestCfg.params.since = cfg.since;\n            }\n\n            requestResult = this.sendRequest(requestCfg);\n            if (! callbackWrapper) {\n                requestResult.profileIds = null;\n                if (requestResult.err !== null) {\n                    return requestResult;\n                }\n\n                if (requestResult.xhr.status === 404) {\n                    requestResult.profileIds = [];\n                }\n                else {\n                    try {\n                        requestResult.profileIds = JSON.parse(requestResult.xhr.responseText);\n                    }\n                    catch (ex) {\n                        requestResult.err = "retrieveAgentProfileIds - JSON parse error: " + ex;\n                    }\n                }\n            }\n            return requestResult;\n        },\n\n        /**\n        Save an agent profile value, when used from a browser sends to the endpoint using the RESTful interface.\n\n        @method saveAgentProfile\n        @param {String} key Key of agent profile to retrieve\n        @param val Value to be stored\n        @param {Object} cfg Configuration options\n            @param {TinCan.Agent} cfg.agent Agent in document identifier\n            @param {String} [cfg.lastSHA1] SHA1 of the previously seen existing profile\n            @param {String} [cfg.contentType] Content-Type to specify in headers (defaults to \'application/octet-stream\')\n            @param {String} [cfg.method] Method to use. Default: PUT\n            @param {Function} [cfg.callback] Callback to execute on completion\n            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request\n        */\n        saveAgentProfile: function (key, val, cfg) {\n            this.log("saveAgentProfile");\n            var requestCfg,\n                requestHeaders;\n\n            requestHeaders = cfg.requestHeaders || {};\n\n            if (typeof cfg.contentType === "undefined") {\n                cfg.contentType = "application/octet-stream";\n            }\n            requestHeaders["Content-Type"] = cfg.contentType;\n\n            if (typeof cfg.method === "undefined" || cfg.method !== "POST") {\n                cfg.method = "PUT";\n            }\n\n            if (typeof val === "object" && TinCan.Utils.isApplicationJSON(cfg.contentType)) {\n                val = JSON.stringify(val);\n            }\n\n            requestCfg = {\n                method: cfg.method,\n                params: {\n                    profileId: key\n                },\n                data: val,\n                headers: requestHeaders\n            };\n\n            if (this.version === "0.9") {\n                requestCfg.url = "actors/profile";\n                requestCfg.params.actor = JSON.stringify(cfg.agent.asVersion(this.version));\n            }\n            else {\n                requestCfg.url = "agents/profile";\n                requestCfg.params.agent = JSON.stringify(cfg.agent.asVersion(this.version));\n            }\n            if (typeof cfg.callback !== "undefined") {\n                requestCfg.callback = cfg.callback;\n            }\n            if (typeof cfg.lastSHA1 !== "undefined" && cfg.lastSHA1 !== null) {\n                requestCfg.headers["If-Match"] = cfg.lastSHA1;\n            }\n            else {\n                requestCfg.headers["If-None-Match"] = "*";\n            }\n\n            return this.sendRequest(requestCfg);\n        },\n\n        /**\n        Drop an agent profile value, when used from a browser sends to the endpoint using the RESTful interface. Full agent profile\n        delete is not supported by the spec.\n\n        @method dropAgentProfile\n        @param {String|null} key Key of agent profile to delete\n        @param {Object} cfg Configuration options\n            @param {TinCan.Agent} cfg.agent Agent in document identifier\n            @param {Function} [cfg.callback] Callback to execute on completion\n            @param {Object} [cfg.requestHeaders] Optional object containing additional headers to add to request\n        */\n        dropAgentProfile: function (key, cfg) {\n            this.log("dropAgentProfile");\n            var requestParams,\n                requestCfg,\n                requestHeaders;\n\n            requestHeaders = cfg.requestHeaders || {};\n\n            requestParams = {\n                profileId: key\n            };\n            requestCfg = {\n                method: "DELETE",\n                params: requestParams,\n                headers: requestHeaders\n            };\n\n            if (this.version === "0.9") {\n                requestCfg.url = "actors/profile";\n                requestParams.actor = JSON.stringify(cfg.agent.asVersion(this.version));\n            }\n            else {\n                requestCfg.url = "agents/profile";\n                requestParams.agent = JSON.stringify(cfg.agent.asVersion(this.version));\n            }\n            if (typeof cfg.callback !== "undefined") {\n                requestCfg.callback = cfg.callback;\n            }\n\n            return this.sendRequest(requestCfg);\n        }\n    };\n\n    /**\n    Allows client code to determine whether their environment supports synchronous xhr handling\n    @static this is a static property, set by the environment\n    */\n    LRS.syncEnabled = null;\n}());\n\n/*\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.AgentAccount\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.AgentAccount\n    @constructor\n    */\n    var AgentAccount = TinCan.AgentAccount = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property homePage\n        @type String\n        */\n        this.homePage = null;\n\n        /**\n        @property name\n        @type String\n        */\n        this.name = null;\n\n        this.init(cfg);\n    };\n    AgentAccount.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "AgentAccount",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n            var i,\n                directProps = [\n                    "name",\n                    "homePage"\n                ];\n\n            cfg = cfg || {};\n\n            // handle .9 name changes\n            if (typeof cfg.accountServiceHomePage !== "undefined") {\n                cfg.homePage = cfg.accountServiceHomePage;\n            }\n            if (typeof cfg.accountName !== "undefined") {\n                cfg.name = cfg.accountName;\n            }\n\n            for (i = 0; i < directProps.length; i += 1) {\n                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {\n                    this[directProps[i]] = cfg[directProps[i]];\n                }\n            }\n        },\n\n        toString: function () {\n            this.log("toString");\n            var result = "";\n\n            if (this.name !== null || this.homePage !== null) {\n                result += this.name !== null ? this.name : "-";\n                result += ":";\n                result += this.homePage !== null ? this.homePage : "-";\n            }\n            else {\n                result = "AgentAccount: unidentified";\n            }\n\n            return result;\n        },\n\n        /**\n        @method asVersion\n        @param {String} [version] Version to return (defaults to newest supported)\n        */\n        asVersion: function (version) {\n            this.log("asVersion: " + version);\n            var result = {};\n\n            version = version || TinCan.versions()[0];\n\n            if (version === "0.9") {\n                result.accountName = this.name;\n                result.accountServiceHomePage = this.homePage;\n            } else {\n                result.name = this.name;\n                result.homePage = this.homePage;\n            }\n\n            return result;\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} AgentAccount\n    @static\n    */\n    AgentAccount.fromJSON = function (acctJSON) {\n        AgentAccount.prototype.log("fromJSON");\n        var _acct = JSON.parse(acctJSON);\n\n        return new AgentAccount(_acct);\n    };\n}());\n\n/*\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.Agent\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.Agent\n    @constructor\n    */\n    var Agent = TinCan.Agent = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property name\n        @type String\n        */\n        this.name = null;\n\n        /**\n        @property mbox\n        @type String\n        */\n        this.mbox = null;\n\n        /**\n        @property mbox_sha1sum\n        @type String\n        */\n        this.mbox_sha1sum = null;\n\n        /**\n        @property openid\n        @type String\n        */\n        this.openid = null;\n\n        /**\n        @property account\n        @type TinCan.AgentAccount\n        */\n        this.account = null;\n\n        /**\n        @property degraded\n        @type Boolean\n        @default false\n        */\n        this.degraded = false;\n\n        this.init(cfg);\n    };\n    Agent.prototype = {\n        /**\n        @property objectType\n        @type String\n        @default Agent\n        */\n        objectType: "Agent",\n\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "Agent",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n            var i,\n                directProps = [\n                    "name",\n                    "mbox",\n                    "mbox_sha1sum",\n                    "openid"\n                ],\n                val\n            ;\n\n            cfg = cfg || {};\n\n            // handle .9 split names and array properties into single interface\n            if (typeof cfg.lastName !== "undefined" || typeof cfg.firstName !== "undefined") {\n                cfg.name = "";\n                if (typeof cfg.firstName !== "undefined" && cfg.firstName.length > 0) {\n                    cfg.name = cfg.firstName[0];\n                    if (cfg.firstName.length > 1) {\n                        this.degraded = true;\n                    }\n                }\n\n                if (cfg.name !== "") {\n                    cfg.name += " ";\n                }\n\n                if (typeof cfg.lastName !== "undefined" && cfg.lastName.length > 0) {\n                    cfg.name += cfg.lastName[0];\n                    if (cfg.lastName.length > 1) {\n                        this.degraded = true;\n                    }\n                }\n            } else if (typeof cfg.familyName !== "undefined" || typeof cfg.givenName !== "undefined") {\n                cfg.name = "";\n                if (typeof cfg.givenName !== "undefined" && cfg.givenName.length > 0) {\n                    cfg.name = cfg.givenName[0];\n                    if (cfg.givenName.length > 1) {\n                        this.degraded = true;\n                    }\n                }\n\n                if (cfg.name !== "") {\n                    cfg.name += " ";\n                }\n\n                if (typeof cfg.familyName !== "undefined" && cfg.familyName.length > 0) {\n                    cfg.name += cfg.familyName[0];\n                    if (cfg.familyName.length > 1) {\n                        this.degraded = true;\n                    }\n                }\n            }\n\n            if (typeof cfg.name === "object" && cfg.name !== null) {\n                if (cfg.name.length > 1) {\n                    this.degraded = true;\n                }\n                cfg.name = cfg.name[0];\n            }\n            if (typeof cfg.mbox === "object" && cfg.mbox !== null) {\n                if (cfg.mbox.length > 1) {\n                    this.degraded = true;\n                }\n                cfg.mbox = cfg.mbox[0];\n            }\n            if (typeof cfg.mbox_sha1sum === "object" && cfg.mbox_sha1sum !== null) {\n                if (cfg.mbox_sha1sum.length > 1) {\n                    this.degraded = true;\n                }\n                cfg.mbox_sha1sum = cfg.mbox_sha1sum[0];\n            }\n            if (typeof cfg.openid === "object" && cfg.openid !== null) {\n                if (cfg.openid.length > 1) {\n                    this.degraded = true;\n                }\n                cfg.openid = cfg.openid[0];\n            }\n            if (typeof cfg.account === "object" && cfg.account !== null && typeof cfg.account.homePage === "undefined" && typeof cfg.account.name === "undefined") {\n                if (cfg.account.length === 0) {\n                    delete cfg.account;\n                }\n                else {\n                    if (cfg.account.length > 1) {\n                        this.degraded = true;\n                    }\n                    cfg.account = cfg.account[0];\n                }\n            }\n\n            if (cfg.hasOwnProperty("account")) {\n                if (cfg.account instanceof TinCan.AgentAccount) {\n                    this.account = cfg.account;\n                }\n                else {\n                    this.account = new TinCan.AgentAccount (cfg.account);\n                }\n            }\n\n            for (i = 0; i < directProps.length; i += 1) {\n                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {\n                    val = cfg[directProps[i]];\n                    if (directProps[i] === "mbox" && val.indexOf("mailto:") === -1) {\n                        val = "mailto:" + val;\n                    }\n                    this[directProps[i]] = val;\n                }\n            }\n        },\n\n        toString: function () {\n            this.log("toString");\n\n            if (this.name !== null) {\n                return this.name;\n            }\n            if (this.mbox !== null) {\n                return this.mbox.replace("mailto:", "");\n            }\n            if (this.mbox_sha1sum !== null) {\n                return this.mbox_sha1sum;\n            }\n            if (this.openid !== null) {\n                return this.openid;\n            }\n            if (this.account !== null) {\n                return this.account.toString();\n            }\n\n            return this.objectType + ": unidentified";\n        },\n\n        /**\n        While a TinCan.Agent instance can store more than one inverse functional identifier\n        this method will always only output one to be compliant with the statement sending\n        specification. Order of preference is: mbox, mbox_sha1sum, openid, account\n\n        @method asVersion\n        @param {String} [version] Version to return (defaults to newest supported)\n        */\n        asVersion: function (version) {\n            this.log("asVersion: " + version);\n            var result = {\n                objectType: this.objectType\n            };\n\n            version = version || TinCan.versions()[0];\n\n            if (version === "0.9") {\n                if (this.mbox !== null) {\n                    result.mbox = [ this.mbox ];\n                }\n                else if (this.mbox_sha1sum !== null) {\n                    result.mbox_sha1sum = [ this.mbox_sha1sum ];\n                }\n                else if (this.openid !== null) {\n                    result.openid = [ this.openid ];\n                }\n                else if (this.account !== null) {\n                    result.account = [ this.account.asVersion(version) ];\n                }\n\n                if (this.name !== null) {\n                    result.name = [ this.name ];\n                }\n            } else {\n                if (this.mbox !== null) {\n                    result.mbox = this.mbox;\n                }\n                else if (this.mbox_sha1sum !== null) {\n                    result.mbox_sha1sum = this.mbox_sha1sum;\n                }\n                else if (this.openid !== null) {\n                    result.openid = this.openid;\n                }\n                else if (this.account !== null) {\n                    result.account = this.account.asVersion(version);\n                }\n\n                if (this.name !== null) {\n                    result.name = this.name;\n                }\n            }\n\n            return result;\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} Agent\n    @static\n    */\n    Agent.fromJSON = function (agentJSON) {\n        Agent.prototype.log("fromJSON");\n        var _agent = JSON.parse(agentJSON);\n\n        return new Agent(_agent);\n    };\n}());\n\n/*\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.Group\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.Group\n    @constructor\n    */\n    var Group = TinCan.Group = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property name\n        @type String\n        */\n        this.name = null;\n\n        /**\n        @property mbox\n        @type String\n        */\n        this.mbox = null;\n\n        /**\n        @property mbox_sha1sum\n        @type String\n        */\n        this.mbox_sha1sum = null;\n\n        /**\n        @property openid\n        @type String\n        */\n        this.openid = null;\n\n        /**\n        @property account\n        @type TinCan.AgentAccount\n        */\n        this.account = null;\n\n        /**\n        @property member\n        @type Array\n        */\n        this.member = [];\n\n        this.init(cfg);\n    };\n    Group.prototype = {\n        /**\n        @property objectType\n        @type String\n        @default "Group"\n        @static\n        */\n        objectType: "Group",\n\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "Group",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n            var i;\n\n            cfg = cfg || {};\n\n            TinCan.Agent.prototype.init.call(this, cfg);\n\n            if (typeof cfg.member !== "undefined") {\n                for (i = 0; i < cfg.member.length; i += 1) {\n                    if (cfg.member[i] instanceof TinCan.Agent) {\n                        this.member.push(cfg.member[i]);\n                    }\n                    else {\n                        this.member.push(new TinCan.Agent (cfg.member[i]));\n                    }\n                }\n            }\n        },\n\n        toString: function (lang) {\n            this.log("toString");\n\n            var result = TinCan.Agent.prototype.toString.call(this, lang);\n            if (result !== this.objectType + ": unidentified") {\n                result = this.objectType + ": " + result;\n            }\n\n            return result;\n        },\n\n        /**\n        @method asVersion\n        @param {String} [version] Version to return (defaults to newest supported)\n        */\n        asVersion: function (version) {\n            this.log("asVersion: " + version);\n            var result,\n                i\n            ;\n\n            version = version || TinCan.versions()[0];\n\n            result = TinCan.Agent.prototype.asVersion.call(this, version);\n\n            if (this.member.length > 0) {\n                result.member = [];\n                for (i = 0; i < this.member.length; i += 1) {\n                    result.member.push(this.member[i].asVersion(version));\n                }\n            }\n\n            return result;\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} Group\n    @static\n    */\n    Group.fromJSON = function (groupJSON) {\n        Group.prototype.log("fromJSON");\n        var _group = JSON.parse(groupJSON);\n\n        return new Group(_group);\n    };\n}());\n\n/*\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.Verb\n*/\n(function () {\n    "use strict";\n\n    //\n    // this represents the full set of verb values that were\n    // allowed by the .9 spec version, if an object is created with one of\n    // the short forms it will be upconverted to the matching long form,\n    // for local storage and use and if an object is needed in .9 version\n    // consequently down converted\n    //\n    // hopefully this list will never grow (or change) and only the exact\n    // ADL compatible URLs should be matched\n    //\n    var _downConvertMap = {\n        "http://adlnet.gov/expapi/verbs/experienced": "experienced",\n        "http://adlnet.gov/expapi/verbs/attended":    "attended",\n        "http://adlnet.gov/expapi/verbs/attempted":   "attempted",\n        "http://adlnet.gov/expapi/verbs/completed":   "completed",\n        "http://adlnet.gov/expapi/verbs/passed":      "passed",\n        "http://adlnet.gov/expapi/verbs/failed":      "failed",\n        "http://adlnet.gov/expapi/verbs/answered":    "answered",\n        "http://adlnet.gov/expapi/verbs/interacted":  "interacted",\n        "http://adlnet.gov/expapi/verbs/imported":    "imported",\n        "http://adlnet.gov/expapi/verbs/created":     "created",\n        "http://adlnet.gov/expapi/verbs/shared":      "shared",\n        "http://adlnet.gov/expapi/verbs/voided":      "voided"\n    },\n\n    /**\n    @class TinCan.Verb\n    @constructor\n    */\n    Verb = TinCan.Verb = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property id\n        @type String\n        */\n        this.id = null;\n\n        /**\n        @property display\n        @type Object\n        */\n        this.display = null;\n\n        this.init(cfg);\n    };\n    Verb.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "Verb",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n            var i,\n                directProps = [\n                    "id",\n                    "display"\n                ],\n                prop\n            ;\n\n            if (typeof cfg === "string") {\n                this.id = cfg;\n                this.display = {\n                    und: this.id\n                };\n\n                //If simple string like "attempted" was passed in (0.9 verbs), \n                //upconvert the ID to the 0.95 ADL version\n                for (prop in _downConvertMap) {\n                    if (_downConvertMap.hasOwnProperty(prop) && _downConvertMap[prop] === cfg) {\n                        this.id = prop;\n                        break;\n                    }\n                }\n            }\n            else {\n                cfg = cfg || {};\n\n                for (i = 0; i < directProps.length; i += 1) {\n                    if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {\n                        this[directProps[i]] = cfg[directProps[i]];\n                    }\n                }\n\n                if (this.display === null && typeof _downConvertMap[this.id] !== "undefined") {\n                    this.display = {\n                        "und": _downConvertMap[this.id]\n                    };\n                }\n            }\n        },\n\n        /**\n        @method toString\n        @return {String} String representation of the verb\n        */\n        toString: function (lang) {\n            this.log("toString");\n\n            if (this.display !== null) {\n                return this.getLangDictionaryValue("display", lang);\n            }\n\n            return this.id;\n        },\n\n        /**\n        @method asVersion\n        @param {String} [version] Version to return (defaults to newest supported)\n        */\n        asVersion: function (version) {\n            this.log("asVersion");\n            var result;\n\n            version = version || TinCan.versions()[0];\n\n            if (version === "0.9") {\n                result = _downConvertMap[this.id];\n            }\n            else {\n                result = {\n                    id: this.id\n                };\n                if (this.display !== null) {\n                    result.display = this.display;\n                }\n            }\n\n            return result;\n        },\n\n        /**\n        See {{#crossLink "TinCan.Utils/getLangDictionaryValue"}}{{/crossLink}}\n\n        @method getLangDictionaryValue\n        */\n        getLangDictionaryValue: TinCan.Utils.getLangDictionaryValue\n    };\n\n    /**\n    @method fromJSON\n    @param {String} verbJSON String of JSON representing the verb\n    @return {Object} Verb\n    @static\n    */\n    Verb.fromJSON = function (verbJSON) {\n        Verb.prototype.log("fromJSON");\n        var _verb = JSON.parse(verbJSON);\n\n        return new Verb(_verb);\n    };\n}());\n\n/*\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.Result\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.Result\n    @constructor\n    */\n    var Result = TinCan.Result = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property score\n        @type TinCan.Score|null\n        */\n        this.score = null;\n\n        /**\n        @property success\n        @type Boolean|null\n        */\n        this.success = null;\n\n        /**\n        @property completion\n        @type Boolean|null\n        */\n        this.completion = null;\n\n        /**\n        @property duration\n        @type String|null\n        */\n        this.duration = null;\n\n        /**\n        @property response\n        @type String|null\n        */\n        this.response = null;\n\n        /**\n        @property extensions\n        @type Object|null\n        */\n        this.extensions = null;\n\n        this.init(cfg);\n    };\n    Result.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "Result",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n\n            var i,\n                directProps = [\n                    "completion",\n                    "duration",\n                    "extensions",\n                    "response",\n                    "success"\n                ]\n            ;\n\n            cfg = cfg || {};\n\n            if (cfg.hasOwnProperty("score") && cfg.score !== null) {\n                if (cfg.score instanceof TinCan.Score) {\n                    this.score = cfg.score;\n                }\n                else {\n                    this.score = new TinCan.Score (cfg.score);\n                }\n            }\n\n            for (i = 0; i < directProps.length; i += 1) {\n                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {\n                    this[directProps[i]] = cfg[directProps[i]];\n                }\n            }\n\n            // 0.9 used a string, store it internally as a bool\n            if (this.completion === "Completed") {\n                this.completion = true;\n            }\n        },\n\n        /**\n        @method asVersion\n        @param {String} [version] Version to return (defaults to newest supported)\n        */\n        asVersion: function (version) {\n            this.log("asVersion");\n            var result = {},\n                optionalDirectProps = [\n                    "success",\n                    "duration",\n                    "response",\n                    "extensions"\n                ],\n                optionalObjProps = [\n                    "score"\n                ],\n                i;\n\n            version = version || TinCan.versions()[0];\n\n            for (i = 0; i < optionalDirectProps.length; i += 1) {\n                if (this[optionalDirectProps[i]] !== null) {\n                    result[optionalDirectProps[i]] = this[optionalDirectProps[i]];\n                }\n            }\n            for (i = 0; i < optionalObjProps.length; i += 1) {\n                if (this[optionalObjProps[i]] !== null) {\n                    result[optionalObjProps[i]] = this[optionalObjProps[i]].asVersion(version);\n                }\n            }\n            if (this.completion !== null) {\n                if (version === "0.9") {\n                    if (this.completion) {\n                        result.completion = "Completed";\n                    }\n                }\n                else {\n                    result.completion = this.completion;\n                }\n            }\n\n            return result;\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} Result\n    @static\n    */\n    Result.fromJSON = function (resultJSON) {\n        Result.prototype.log("fromJSON");\n        var _result = JSON.parse(resultJSON);\n\n        return new Result(_result);\n    };\n}());\n\n/*\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.Score\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.Score\n    @constructor\n    */\n    var Score = TinCan.Score = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property scaled\n        @type String\n        */\n        this.scaled = null;\n\n        /**\n        @property raw\n        @type String\n        */\n        this.raw = null;\n\n        /**\n        @property min\n        @type String\n        */\n        this.min = null;\n\n        /**\n        @property max\n        @type String\n        */\n        this.max = null;\n\n        this.init(cfg);\n    };\n    Score.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "Score",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n\n            var i,\n                directProps = [\n                    "scaled",\n                    "raw",\n                    "min",\n                    "max"\n                ]\n            ;\n\n            cfg = cfg || {};\n\n            for (i = 0; i < directProps.length; i += 1) {\n                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {\n                    this[directProps[i]] = cfg[directProps[i]];\n                }\n            }\n        },\n\n        /**\n        @method asVersion\n        @param {String} [version] Version to return (defaults to newest supported)\n        */\n        asVersion: function (version) {\n            this.log("asVersion");\n            var result = {},\n                optionalDirectProps = [\n                    "scaled",\n                    "raw",\n                    "min",\n                    "max"\n                ],\n                i;\n\n            version = version || TinCan.versions()[0];\n\n            for (i = 0; i < optionalDirectProps.length; i += 1) {\n                if (this[optionalDirectProps[i]] !== null) {\n                    result[optionalDirectProps[i]] = this[optionalDirectProps[i]];\n                }\n            }\n\n            return result;\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} Score\n    @static\n    */\n    Score.fromJSON = function (scoreJSON) {\n        Score.prototype.log("fromJSON");\n        var _score = JSON.parse(scoreJSON);\n\n        return new Score(_score);\n    };\n}());\n\n/*\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.InteractionComponent\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.InteractionComponent\n    @constructor\n    */\n    var InteractionComponent = TinCan.InteractionComponent = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property id\n        @type String\n        */\n        this.id = null;\n\n        /**\n        @property description\n        @type Object\n        */\n        this.description = null;\n\n        this.init(cfg);\n    };\n    InteractionComponent.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "InteractionComponent",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n            var i,\n                directProps = [\n                    "id",\n                    "description"\n                ]\n            ;\n\n            cfg = cfg || {};\n\n            for (i = 0; i < directProps.length; i += 1) {\n                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {\n                    this[directProps[i]] = cfg[directProps[i]];\n                }\n            }\n        },\n\n        /**\n        @method asVersion\n        @param {String} [version] Version to return (defaults to newest supported)\n        */\n        asVersion: function (version) {\n            this.log("asVersion");\n            var result = {\n                    id: this.id\n                },\n                optionalDirectProps = [\n                    "description"\n                ],\n                i,\n                prop;\n\n            version = version || TinCan.versions()[0];\n\n            for (i = 0; i < optionalDirectProps.length; i += 1) {\n                prop = optionalDirectProps[i];\n                if (this[prop] !== null) {\n                    result[prop] = this[prop];\n                }\n            }\n\n            return result;\n        },\n\n        /**\n        See {{#crossLink "TinCan.Utils/getLangDictionaryValue"}}{{/crossLink}}\n\n        @method getLangDictionaryValue\n        */\n        getLangDictionaryValue: TinCan.Utils.getLangDictionaryValue\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} InteractionComponent\n    @static\n    */\n    InteractionComponent.fromJSON = function (icJSON) {\n        InteractionComponent.prototype.log("fromJSON");\n        var _ic = JSON.parse(icJSON);\n\n        return new InteractionComponent(_ic);\n    };\n}());\n\n/*\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.ActivityDefinition\n**/\n(function () {\n    "use strict";\n\n    //\n    // this represents the full set of activity definition types that were\n    // allowed by the .9 spec version, if an object is created with one of\n    // the short forms it will be upconverted to the matching long form,\n    // for local storage and use and if an object is needed in .9 version\n    // consequently down converted\n    //\n    // hopefully this list will never grow (or change) and only the exact\n    // ADL compatible URLs should be matched\n    //\n    var _downConvertMap = {\n        "http://adlnet.gov/expapi/activities/course": "course",\n        "http://adlnet.gov/expapi/activities/module": "module",\n        "http://adlnet.gov/expapi/activities/meeting": "meeting",\n        "http://adlnet.gov/expapi/activities/media": "media",\n        "http://adlnet.gov/expapi/activities/performance": "performance",\n        "http://adlnet.gov/expapi/activities/simulation": "simulation",\n        "http://adlnet.gov/expapi/activities/assessment": "assessment",\n        "http://adlnet.gov/expapi/activities/interaction": "interaction",\n        "http://adlnet.gov/expapi/activities/cmi.interaction": "cmi.interaction",\n        "http://adlnet.gov/expapi/activities/question": "question",\n        "http://adlnet.gov/expapi/activities/objective": "objective",\n        "http://adlnet.gov/expapi/activities/link": "link"\n    },\n\n    /**\n    @class TinCan.ActivityDefinition\n    @constructor\n    */\n    ActivityDefinition = TinCan.ActivityDefinition = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property name\n        @type Object\n        */\n        this.name = null;\n\n        /**\n        @property description\n        @type Object\n        */\n        this.description = null;\n\n        /**\n        @property type\n        @type String\n        */\n        this.type = null;\n\n        /**\n        @property moreInfo\n        @type String\n        */\n        this.moreInfo = null;\n\n        /**\n        @property extensions\n        @type Object\n        */\n        this.extensions = null;\n\n        /**\n        @property interactionType\n        @type String\n        */\n        this.interactionType = null;\n\n        /**\n        @property correctResponsesPattern\n        @type Array\n        */\n        this.correctResponsesPattern = null;\n\n        /**\n        @property choices\n        @type Array\n        */\n        this.choices = null;\n\n        /**\n        @property scale\n        @type Array\n        */\n        this.scale = null;\n\n        /**\n        @property source\n        @type Array\n        */\n        this.source = null;\n\n        /**\n        @property target\n        @type Array\n        */\n        this.target = null;\n\n        /**\n        @property steps\n        @type Array\n        */\n        this.steps = null;\n\n        this.init(cfg);\n    };\n    ActivityDefinition.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "ActivityDefinition",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n\n            var i,\n                j,\n                prop,\n                directProps = [\n                    "name",\n                    "description",\n                    "moreInfo",\n                    "extensions",\n                    "correctResponsesPattern"\n                ],\n                interactionComponentProps = []\n            ;\n\n            cfg = cfg || {};\n\n            if (cfg.hasOwnProperty("type") && cfg.type !== null) {\n                // TODO: verify type is URI?\n                for (prop in _downConvertMap) {\n                    if (_downConvertMap.hasOwnProperty(prop) && _downConvertMap[prop] === cfg.type) {\n                        cfg.type = _downConvertMap[prop];\n                    }\n                }\n                this.type = cfg.type;\n            }\n\n            if (cfg.hasOwnProperty("interactionType") && cfg.interactionType !== null) {\n                // TODO: verify interaction type in acceptable set?\n                this.interactionType = cfg.interactionType;\n                if (cfg.interactionType === "choice" || cfg.interactionType === "sequencing") {\n                    interactionComponentProps.push("choices");\n                }\n                else if (cfg.interactionType === "likert") {\n                    interactionComponentProps.push("scale");\n                }\n                else if (cfg.interactionType === "matching") {\n                    interactionComponentProps.push("source");\n                    interactionComponentProps.push("target");\n                }\n                else if (cfg.interactionType === "performance") {\n                    interactionComponentProps.push("steps");\n                }\n\n                if (interactionComponentProps.length > 0) {\n                    for (i = 0; i < interactionComponentProps.length; i += 1) {\n                        prop = interactionComponentProps[i];\n                        if (cfg.hasOwnProperty(prop) && cfg[prop] !== null) {\n                            this[prop] = [];\n                            for (j = 0; j < cfg[prop].length; j += 1) {\n                                if (cfg[prop][j] instanceof TinCan.InteractionComponent) {\n                                    this[prop].push(cfg[prop][j]);\n                                } else {\n                                    this[prop].push(\n                                        new TinCan.InteractionComponent (\n                                            cfg[prop][j]\n                                        )\n                                    );\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            for (i = 0; i < directProps.length; i += 1) {\n                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {\n                    this[directProps[i]] = cfg[directProps[i]];\n                }\n            }\n        },\n\n        /**\n        @method toString\n        @return {String} String representation of the definition\n        */\n        toString: function (lang) {\n            this.log("toString");\n\n            if (this.name !== null) {\n                return this.getLangDictionaryValue("name", lang);\n            }\n\n            if (this.description !== null) {\n                return this.getLangDictionaryValue("description", lang);\n            }\n\n            return "";\n        },\n\n        /**\n        @method asVersion\n        @param {String} [version] Version to return (defaults to newest supported)\n        */\n        asVersion: function (version) {\n            this.log("asVersion");\n            var result = {},\n                directProps = [\n                    "name",\n                    "description",\n                    "interactionType",\n                    "correctResponsesPattern",\n                    "extensions"\n                ],\n                interactionComponentProps = [\n                    "choices",\n                    "scale",\n                    "source",\n                    "target",\n                    "steps"\n                ],\n                i,\n                j,\n                prop\n            ;\n\n            version = version || TinCan.versions()[0];\n\n            if (this.type !== null) {\n                if (version === "0.9") {\n                    result.type = _downConvertMap[this.type];\n                }\n                else {\n                    result.type = this.type;\n                }\n            }\n\n            for (i = 0; i < directProps.length; i += 1) {\n                prop = directProps[i];\n                if (this[prop] !== null) {\n                    result[prop] = this[prop];\n                }\n            }\n\n            for (i = 0; i < interactionComponentProps.length; i += 1) {\n                prop = interactionComponentProps[i];\n                if (this[prop] !== null) {\n                    result[prop] = [];\n                    for (j = 0; j < this[prop].length; j += 1) {\n                        result[prop].push(\n                            this[prop][j].asVersion(version)\n                        );\n                    }\n                }\n            }\n\n            if (version.indexOf("0.9") !== 0) {\n                if (this.moreInfo !== null) {\n                    result.moreInfo = this.moreInfo;\n                }\n            }\n\n            return result;\n        },\n\n        /**\n        See {{#crossLink "TinCan.Utils/getLangDictionaryValue"}}{{/crossLink}}\n\n        @method getLangDictionaryValue\n        */\n        getLangDictionaryValue: TinCan.Utils.getLangDictionaryValue\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} ActivityDefinition\n    @static\n    */\n    ActivityDefinition.fromJSON = function (definitionJSON) {\n        ActivityDefinition.prototype.log("fromJSON");\n        var _definition = JSON.parse(definitionJSON);\n\n        return new ActivityDefinition(_definition);\n    };\n}());\n\n/*\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.Activity\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.Activity\n    @constructor\n    */\n    var Activity = TinCan.Activity = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property objectType\n        @type String\n        @default Activity\n        */\n        this.objectType = "Activity";\n\n        /**\n        @property id\n        @type String\n        */\n        this.id = null;\n\n        /**\n        @property definition\n        @type TinCan.ActivityDefinition\n        */\n        this.definition = null;\n\n        this.init(cfg);\n    };\n    Activity.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "Activity",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n\n            var i,\n                directProps = [\n                    "id"\n                ]\n            ;\n\n            cfg = cfg || {};\n\n            if (cfg.hasOwnProperty("definition")) {\n                if (cfg.definition instanceof TinCan.ActivityDefinition) {\n                    this.definition = cfg.definition;\n                } else {\n                    this.definition = new TinCan.ActivityDefinition (cfg.definition);\n                }\n            }\n\n            for (i = 0; i < directProps.length; i += 1) {\n                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {\n                    this[directProps[i]] = cfg[directProps[i]];\n                }\n            }\n        },\n\n        /**\n        @method toString\n        @return {String} String representation of the activity\n        */\n        toString: function (lang) {\n            this.log("toString");\n            var defString = "";\n\n            if (this.definition !== null) {\n                defString = this.definition.toString(lang);\n                if (defString !== "") {\n                    return defString;\n                }\n            }\n\n            if (this.id !== null) {\n                return this.id;\n            }\n\n            return "Activity: unidentified";\n        },\n\n        /**\n        @method asVersion\n        @param {String} [version] Version to return (defaults to newest supported)\n        */\n        asVersion: function (version) {\n            this.log("asVersion");\n            var result = {\n                id: this.id,\n                objectType: this.objectType\n            };\n\n            version = version || TinCan.versions()[0];\n\n            if (this.definition !== null) {\n                result.definition = this.definition.asVersion(version);\n            }\n\n            return result;\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} Activity\n    @static\n    */\n    Activity.fromJSON = function (activityJSON) {\n        Activity.prototype.log("fromJSON");\n        var _activity = JSON.parse(activityJSON);\n\n        return new Activity(_activity);\n    };\n}());\n\n/*\n    Copyright 2013 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.ContextActivities\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.ContextActivities\n    @constructor\n    */\n    var ContextActivities = TinCan.ContextActivities = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property category\n        @type Array\n        */\n        this.category = null;\n\n        /**\n        @property parent\n        @type Array\n        */\n        this.parent = null;\n\n        /**\n        @property grouping\n        @type Array\n        */\n        this.grouping = null;\n\n        /**\n        @property other\n        @type Array\n        */\n        this.other = null;\n\n        this.init(cfg);\n    };\n    ContextActivities.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "ContextActivities",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n\n            var i,\n                j,\n                objProps = [\n                    "category",\n                    "parent",\n                    "grouping",\n                    "other"\n                ],\n                prop,\n                val\n            ;\n\n            cfg = cfg || {};\n\n            for (i = 0; i < objProps.length; i += 1) {\n                prop = objProps[i];\n                if (cfg.hasOwnProperty(prop) && cfg[prop] !== null) {\n                    if (Object.prototype.toString.call(cfg[prop]) === "[object Array]") {\n                        for (j = 0; j < cfg[prop].length; j += 1) {\n                            this.add(prop, cfg[prop][j]);\n                        }\n                    }\n                    else {\n                        val = cfg[prop];\n\n                        this.add(prop, val);\n                    }\n                }\n            }\n        },\n\n        /**\n        @method add\n        @param String key Property to add value to one of "category", "parent", "grouping", "other"\n        @return Number index where the value was added\n        */\n        add: function (key, val) {\n            if (key !== "category" && key !== "parent" && key !== "grouping" && key !== "other") {\n                return;\n            }\n\n            if (this[key] === null) {\n                this[key] = [];\n            }\n\n            if (! (val instanceof TinCan.Activity)) {\n                val = typeof val === "string" ? { id: val } : val;\n                val = new TinCan.Activity (val);\n            }\n\n            this[key].push(val);\n\n            return this[key].length - 1;\n        },\n\n        /**\n        @method asVersion\n        @param {String} [version] Version to return (defaults to newest supported)\n        */\n        asVersion: function (version) {\n            this.log("asVersion");\n            var result = {},\n                optionalObjProps = [\n                    "parent",\n                    "grouping",\n                    "other"\n                ],\n                i,\n                j;\n\n            version = version || TinCan.versions()[0];\n\n            for (i = 0; i < optionalObjProps.length; i += 1) {\n                if (this[optionalObjProps[i]] !== null && this[optionalObjProps[i]].length > 0) {\n                    if (version === "0.9" || version === "0.95") {\n                        if (this[optionalObjProps[i]].length > 1) {\n                            // TODO: exception?\n                            this.log("[warning] version does not support multiple values in: " + optionalObjProps[i]);\n                        }\n\n                        result[optionalObjProps[i]] = this[optionalObjProps[i]][0].asVersion(version);\n                    }\n                    else {\n                        result[optionalObjProps[i]] = [];\n                        for (j = 0; j < this[optionalObjProps[i]].length; j += 1) {\n                            result[optionalObjProps[i]].push(\n                                this[optionalObjProps[i]][j].asVersion(version)\n                            );\n                        }\n                    }\n                }\n            }\n            if (this.category !== null && this.category.length > 0) {\n                if (version === "0.9" || version === "0.95") {\n                    this.log("[error] version does not support the \'category\' property: " + version);\n                    throw new Error(version + " does not support the \'category\' property");\n                }\n                else {\n                    result.category = [];\n                    for (i = 0; i < this.category.length; i += 1) {\n                        result.category.push(this.category[i].asVersion(version));\n                    }\n                }\n            }\n\n            return result;\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} ContextActivities\n    @static\n    */\n    ContextActivities.fromJSON = function (contextActivitiesJSON) {\n        ContextActivities.prototype.log("fromJSON");\n        var _contextActivities = JSON.parse(contextActivitiesJSON);\n\n        return new ContextActivities(_contextActivities);\n    };\n}());\n\n/*\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.Context\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.Context\n    @constructor\n    */\n    var Context = TinCan.Context = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property registration\n        @type String|null\n        */\n        this.registration = null;\n\n        /**\n        @property instructor\n        @type TinCan.Agent|TinCan.Group|null\n        */\n        this.instructor = null;\n\n        /**\n        @property team\n        @type TinCan.Agent|TinCan.Group|null\n        */\n        this.team = null;\n\n        /**\n        @property contextActivities\n        @type ContextActivities|null\n        */\n        this.contextActivities = null;\n\n        /**\n        @property revision\n        @type String|null\n        */\n        this.revision = null;\n\n        /**\n        @property platform\n        @type Object|null\n        */\n        this.platform = null;\n\n        /**\n        @property language\n        @type String|null\n        */\n        this.language = null;\n\n        /**\n        @property statement\n        @type StatementRef|null\n        */\n        this.statement = null;\n\n        /**\n        @property extensions\n        @type String\n        */\n        this.extensions = null;\n\n        this.init(cfg);\n    };\n    Context.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "Context",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n\n            var i,\n                directProps = [\n                    "registration",\n                    "revision",\n                    "platform",\n                    "language",\n                    "extensions"\n                ],\n                agentGroupProps = [\n                    "instructor",\n                    "team"\n                ],\n                prop,\n                val\n            ;\n\n            cfg = cfg || {};\n\n            for (i = 0; i < directProps.length; i += 1) {\n                prop = directProps[i];\n                if (cfg.hasOwnProperty(prop) && cfg[prop] !== null) {\n                    this[prop] = cfg[prop];\n                }\n            }\n            for (i = 0; i < agentGroupProps.length; i += 1) {\n                prop = agentGroupProps[i];\n                if (cfg.hasOwnProperty(prop) && cfg[prop] !== null) {\n                    val = cfg[prop];\n\n                    if (typeof val.objectType === "undefined" || val.objectType === "Person") {\n                        val.objectType = "Agent";\n                    }\n\n                    if (val.objectType === "Agent" && ! (val instanceof TinCan.Agent)) {\n                        val = new TinCan.Agent (val);\n                    } else if (val.objectType === "Group" && ! (val instanceof TinCan.Group)) {\n                        val = new TinCan.Group (val);\n                    }\n\n                    this[prop] = val;\n                }\n            }\n\n            if (cfg.hasOwnProperty("contextActivities") && cfg.contextActivities !== null) {\n                if (cfg.contextActivities instanceof TinCan.ContextActivities) {\n                    this.contextActivities = cfg.contextActivities;\n                }\n                else {\n                    this.contextActivities = new TinCan.ContextActivities(cfg.contextActivities);\n                }\n            }\n\n            if (cfg.hasOwnProperty("statement") && cfg.statement !== null) {\n                if (cfg.statement instanceof TinCan.StatementRef) {\n                    this.statement = cfg.statement;\n                }\n                else if (cfg.statement instanceof TinCan.SubStatement) {\n                    this.statement = cfg.statement;\n                }\n                else if (cfg.statement.objectType === "StatementRef") {\n                    this.statement = new TinCan.StatementRef(cfg.statement);\n                }\n                else if (cfg.statement.objectType === "SubStatement") {\n                    this.statement = new TinCan.SubStatement(cfg.statement);\n                }\n                else {\n                    this.log("Unable to parse statement.context.statement property.");\n                }\n            }\n        },\n\n        /**\n        @method asVersion\n        @param {String} [version] Version to return (defaults to newest supported)\n        */\n        asVersion: function (version) {\n            this.log("asVersion");\n            var result = {},\n                optionalDirectProps = [\n                    "registration",\n                    "revision",\n                    "platform",\n                    "language",\n                    "extensions"\n                ],\n                optionalObjProps = [\n                    "instructor",\n                    "team",\n                    "contextActivities",\n                    "statement"\n                ],\n                i;\n\n            version = version || TinCan.versions()[0];\n\n            if (this.statement instanceof TinCan.SubStatement && version !== "0.9" && version !== "0.95") {\n                this.log("[error] version does not support SubStatements in the \'statement\' property: " + version);\n                throw new Error(version + " does not support SubStatements in the \'statement\' property");\n            }\n\n            for (i = 0; i < optionalDirectProps.length; i += 1) {\n                if (this[optionalDirectProps[i]] !== null) {\n                    result[optionalDirectProps[i]] = this[optionalDirectProps[i]];\n                }\n            }\n            for (i = 0; i < optionalObjProps.length; i += 1) {\n                if (this[optionalObjProps[i]] !== null) {\n                    result[optionalObjProps[i]] = this[optionalObjProps[i]].asVersion(version);\n                }\n            }\n\n            return result;\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} Context\n    @static\n    */\n    Context.fromJSON = function (contextJSON) {\n        Context.prototype.log("fromJSON");\n        var _context = JSON.parse(contextJSON);\n\n        return new Context(_context);\n    };\n}());\n\n/*\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.StatementRef\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.StatementRef\n    @constructor\n    @param {Object} [cfg] Configuration used to initialize.\n        @param {Object} [cfg.id] ID of statement to reference\n    **/\n    var StatementRef = TinCan.StatementRef = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property id\n        @type String\n        */\n        this.id = null;\n\n        this.init(cfg);\n    };\n\n    StatementRef.prototype = {\n        /**\n        @property objectType\n        @type String\n        @default Agent\n        */\n        objectType: "StatementRef",\n\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "StatementRef",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize (see constructor)\n        */\n        init: function (cfg) {\n            this.log("init");\n            var i,\n                directProps = [\n                    "id"\n                ];\n\n            cfg = cfg || {};\n\n            for (i = 0; i < directProps.length; i += 1) {\n                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {\n                    this[directProps[i]] = cfg[directProps[i]];\n                }\n            }\n        },\n\n        /**\n        @method toString\n        @return {String} String representation of the statement\n        */\n        toString: function () {\n            this.log("toString");\n            return this.id;\n        },\n\n        /**\n        @method asVersion\n        @param {String} [version] Version to return (defaults to newest supported)\n        */\n        asVersion: function (version) {\n            this.log("asVersion");\n            var result = {\n                objectType: this.objectType,\n                id: this.id\n            };\n\n            if (version === "0.9") {\n                result.objectType = "Statement";\n            }\n\n            return result;\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} StatementRef\n    @static\n    */\n    StatementRef.fromJSON = function (stRefJSON) {\n        StatementRef.prototype.log("fromJSON");\n        var _stRef = JSON.parse(stRefJSON);\n\n        return new StatementRef(_stRef);\n    };\n}());\n\n/*\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.SubStatement\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.SubStatement\n    @constructor\n    @param {Object} [cfg] Configuration used to initialize.\n        @param {TinCan.Agent} [cfg.actor] Actor of statement\n        @param {TinCan.Verb} [cfg.verb] Verb of statement\n        @param {TinCan.Activity|TinCan.Agent} [cfg.object] Alias for \'target\'\n        @param {TinCan.Activity|TinCan.Agent} [cfg.target] Object of statement\n        @param {TinCan.Result} [cfg.result] Statement Result\n        @param {TinCan.Context} [cfg.context] Statement Context\n    **/\n    var SubStatement = TinCan.SubStatement = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property actor\n        @type Object\n        */\n        this.actor = null;\n\n        /**\n        @property verb\n        @type Object\n        */\n        this.verb = null;\n\n        /**\n        @property target\n        @type Object\n        */\n        this.target = null;\n\n        /**\n        @property result\n        @type Object\n        */\n        this.result = null;\n\n        /**\n        @property context\n        @type Object\n        */\n        this.context = null;\n\n        /**\n        @property timestamp\n        @type Date\n        */\n        this.timestamp = null;\n\n        this.init(cfg);\n    };\n\n    SubStatement.prototype = {\n        /**\n        @property objectType\n        @type String\n        @default Agent\n        */\n        objectType: "SubStatement",\n\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "SubStatement",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize (see constructor)\n        */\n        init: function (cfg) {\n            this.log("init");\n            var i,\n                directProps = [\n                    "timestamp"\n                ];\n\n            cfg = cfg || {};\n\n            if (cfg.hasOwnProperty("object")) {\n                cfg.target = cfg.object;\n            }\n\n            if (cfg.hasOwnProperty("actor")) {\n                if (typeof cfg.actor.objectType === "undefined" || cfg.actor.objectType === "Person") {\n                    cfg.actor.objectType = "Agent";\n                }\n\n                if (cfg.actor.objectType === "Agent") {\n                    if (cfg.actor instanceof TinCan.Agent) {\n                        this.actor = cfg.actor;\n                    } else {\n                        this.actor = new TinCan.Agent (cfg.actor);\n                    }\n                } else if (cfg.actor.objectType === "Group") {\n                    if (cfg.actor instanceof TinCan.Group) {\n                        this.actor = cfg.actor;\n                    } else {\n                        this.actor = new TinCan.Group (cfg.actor);\n                    }\n                }\n            }\n            if (cfg.hasOwnProperty("verb")) {\n                if (cfg.verb instanceof TinCan.Verb) {\n                    this.verb = cfg.verb;\n                } else {\n                    this.verb = new TinCan.Verb (cfg.verb);\n                }\n            }\n            if (cfg.hasOwnProperty("target")) {\n                if (cfg.target instanceof TinCan.Activity ||\n                    cfg.target instanceof TinCan.Agent ||\n                    cfg.target instanceof TinCan.Group ||\n                    cfg.target instanceof TinCan.SubStatement ||\n                    cfg.target instanceof TinCan.StatementRef\n                ) {\n                    this.target = cfg.target;\n                } else {\n                    if (typeof cfg.target.objectType === "undefined") {\n                        cfg.target.objectType = "Activity";\n                    }\n\n                    if (cfg.target.objectType === "Activity") {\n                        this.target = new TinCan.Activity (cfg.target);\n                    } else if (cfg.target.objectType === "Agent") {\n                        this.target = new TinCan.Agent (cfg.target);\n                    } else if (cfg.target.objectType === "Group") {\n                        this.target = new TinCan.Group (cfg.target);\n                    } else if (cfg.target.objectType === "SubStatement") {\n                        this.target = new TinCan.SubStatement (cfg.target);\n                    } else if (cfg.target.objectType === "StatementRef") {\n                        this.target = new TinCan.StatementRef (cfg.target);\n                    } else {\n                        this.log("Unrecognized target type: " + cfg.target.objectType);\n                    }\n                }\n            }\n            if (cfg.hasOwnProperty("result")) {\n                if (cfg.result instanceof TinCan.Result) {\n                    this.result = cfg.result;\n                } else {\n                    this.result = new TinCan.Result (cfg.result);\n                }\n            }\n            if (cfg.hasOwnProperty("context")) {\n                if (cfg.context instanceof TinCan.Context) {\n                    this.context = cfg.context;\n                } else {\n                    this.context = new TinCan.Context (cfg.context);\n                }\n            }\n\n            for (i = 0; i < directProps.length; i += 1) {\n                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {\n                    this[directProps[i]] = cfg[directProps[i]];\n                }\n            }\n        },\n\n        /**\n        @method toString\n        @return {String} String representation of the statement\n        */\n        toString: function (lang) {\n            this.log("toString");\n            return (this.actor !== null ? this.actor.toString(lang) : "") +\n                    " " +\n                    (this.verb !== null ? this.verb.toString(lang) : "") +\n                    " " +\n                    (this.target !== null ? this.target.toString(lang) : "");\n        },\n\n        /**\n        @method asVersion\n        @param {String} [version] Version to return (defaults to newest supported)\n        */\n        asVersion: function (version) {\n            this.log("asVersion");\n            var result,\n                optionalDirectProps = [\n                    "timestamp"\n                ],\n                optionalObjProps = [\n                    "actor",\n                    "verb",\n                    "result",\n                    "context"\n                ],\n                i;\n\n            result = {\n                objectType: this.objectType\n            };\n            version = version || TinCan.versions()[0];\n\n            for (i = 0; i < optionalDirectProps.length; i += 1) {\n                if (this[optionalDirectProps[i]] !== null) {\n                    result[optionalDirectProps[i]] = this[optionalDirectProps[i]];\n                }\n            }\n            for (i = 0; i < optionalObjProps.length; i += 1) {\n                if (this[optionalObjProps[i]] !== null) {\n                    result[optionalObjProps[i]] = this[optionalObjProps[i]].asVersion(version);\n                }\n            }\n            if (this.target !== null) {\n                result.object = this.target.asVersion(version);\n            }\n\n            if (version === "0.9") {\n                result.objectType = "Statement";\n            }\n\n            return result;\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} SubStatement\n    @static\n    */\n    SubStatement.fromJSON = function (subStJSON) {\n        SubStatement.prototype.log("fromJSON");\n        var _subSt = JSON.parse(subStJSON);\n\n        return new SubStatement(_subSt);\n    };\n}());\n\n/*\n    Copyright 2012-3 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.Statement\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.Statement\n    @constructor\n    @param {Object} [cfg] Values to set in properties\n        @param {String} [cfg.id] Statement ID (UUID)\n        @param {TinCan.Agent} [cfg.actor] Actor of statement\n        @param {TinCan.Verb} [cfg.verb] Verb of statement\n        @param {TinCan.Activity|TinCan.Agent|TinCan.Group|TinCan.StatementRef|TinCan.SubStatement} [cfg.object] Alias for \'target\'\n        @param {TinCan.Activity|TinCan.Agent|TinCan.Group|TinCan.StatementRef|TinCan.SubStatement} [cfg.target] Object of statement\n        @param {TinCan.Result} [cfg.result] Statement Result\n        @param {TinCan.Context} [cfg.context] Statement Context\n        @param {TinCan.Agent} [cfg.authority] Statement Authority\n        @param {TinCan.Attachment} [cfg.attachments] Statement Attachments\n        @param {String} [cfg.timestamp] ISO8601 Date/time value\n        @param {String} [cfg.stored] ISO8601 Date/time value\n        @param {String} [cfg.version] Version of the statement (post 0.95)\n    @param {Object} [initCfg] Configuration of initialization process\n        @param {Integer} [initCfg.storeOriginal] Whether to store a JSON stringified version\n            of the original options object, pass number of spaces used for indent\n        @param {Boolean} [initCfg.doStamp] Whether to automatically set the \'id\' and \'timestamp\'\n            properties (default: true)\n    **/\n    var Statement = TinCan.Statement = function (cfg, initCfg) {\n        this.log("constructor");\n\n        // check for true value for API backwards compat\n        if (typeof initCfg === "number") {\n            initCfg = {\n                storeOriginal: initCfg\n            };\n        } else {\n            initCfg = initCfg || {};\n        }\n        if (typeof initCfg.storeOriginal === "undefined") {\n            initCfg.storeOriginal = null;\n        }\n        if (typeof initCfg.doStamp === "undefined") {\n            initCfg.doStamp = true;\n        }\n\n        /**\n        @property id\n        @type String\n        */\n        this.id = null;\n\n        /**\n        @property actor\n        @type TinCan.Agent|TinCan.Group|null\n        */\n        this.actor = null;\n\n        /**\n        @property verb\n        @type TinCan.Verb|null\n        */\n        this.verb = null;\n\n        /**\n        @property target\n        @type TinCan.Activity|TinCan.Agent|TinCan.Group|TinCan.StatementRef|TinCan.SubStatement|null\n        */\n        this.target = null;\n\n        /**\n        @property result\n        @type Object\n        */\n        this.result = null;\n\n        /**\n        @property context\n        @type Object\n        */\n        this.context = null;\n\n        /**\n        @property timestamp\n        @type String\n        */\n        this.timestamp = null;\n\n        /**\n        @property stored\n        @type String\n        */\n        this.stored = null;\n\n        /**\n        @property authority\n        @type TinCan.Agent|null\n        */\n        this.authority = null;\n\n        /**\n        @property attachments\n        @type Array of TinCan.Attachment\n        */\n        this.attachments = null;\n\n        /**\n        @property version\n        @type String\n        */\n        this.version = null;\n\n        /**\n        @property degraded\n        @type Boolean\n        @default false\n        */\n        this.degraded = false;\n\n        /**\n        @property voided\n        @type Boolean\n        @default null\n        @deprecated\n        */\n        this.voided = null;\n\n        /**\n        @property inProgress\n        @type Boolean\n        @deprecated\n        */\n        this.inProgress = null;\n\n        /**\n        @property originalJSON\n        @type String\n        */\n        this.originalJSON = null;\n\n        this.init(cfg, initCfg);\n    };\n\n    Statement.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "Statement",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [properties] Configuration used to set properties (see constructor)\n        @param {Object} [cfg] Configuration used to initialize (see constructor)\n        */\n        init: function (cfg, initCfg) {\n            this.log("init");\n            var i,\n                directProps = [\n                    "id",\n                    "stored",\n                    "timestamp",\n                    "version",\n                    "inProgress",\n                    "voided"\n                ];\n\n            cfg = cfg || {};\n\n            if (initCfg.storeOriginal) {\n                this.originalJSON = JSON.stringify(cfg, null, initCfg.storeOriginal);\n            }\n\n            if (cfg.hasOwnProperty("object")) {\n                cfg.target = cfg.object;\n            }\n\n            if (cfg.hasOwnProperty("actor")) {\n                if (typeof cfg.actor.objectType === "undefined" || cfg.actor.objectType === "Person") {\n                    cfg.actor.objectType = "Agent";\n                }\n\n                if (cfg.actor.objectType === "Agent") {\n                    if (cfg.actor instanceof TinCan.Agent) {\n                        this.actor = cfg.actor;\n                    } else {\n                        this.actor = new TinCan.Agent (cfg.actor);\n                    }\n                } else if (cfg.actor.objectType === "Group") {\n                    if (cfg.actor instanceof TinCan.Group) {\n                        this.actor = cfg.actor;\n                    } else {\n                        this.actor = new TinCan.Group (cfg.actor);\n                    }\n                }\n            }\n            if (cfg.hasOwnProperty("authority")) {\n                if (typeof cfg.authority.objectType === "undefined" || cfg.authority.objectType === "Person") {\n                    cfg.authority.objectType = "Agent";\n                }\n\n                if (cfg.authority.objectType === "Agent") {\n                    if (cfg.authority instanceof TinCan.Agent) {\n                        this.authority = cfg.authority;\n                    } else {\n                        this.authority = new TinCan.Agent (cfg.authority);\n                    }\n                } else if (cfg.authority.objectType === "Group") {\n                    if (cfg.actor instanceof TinCan.Group) {\n                        this.authority = cfg.authority;\n                    } else {\n                        this.authority = new TinCan.Group (cfg.authority);\n                    }\n                }\n            }\n            if (cfg.hasOwnProperty("verb")) {\n                if (cfg.verb instanceof TinCan.Verb) {\n                    this.verb = cfg.verb;\n                } else {\n                    this.verb = new TinCan.Verb (cfg.verb);\n                }\n            }\n            if (cfg.hasOwnProperty("target")) {\n                if (cfg.target instanceof TinCan.Activity ||\n                    cfg.target instanceof TinCan.Agent ||\n                    cfg.target instanceof TinCan.Group ||\n                    cfg.target instanceof TinCan.SubStatement ||\n                    cfg.target instanceof TinCan.StatementRef\n                ) {\n                    this.target = cfg.target;\n                } else {\n                    if (typeof cfg.target.objectType === "undefined") {\n                        cfg.target.objectType = "Activity";\n                    }\n\n                    if (cfg.target.objectType === "Activity") {\n                        this.target = new TinCan.Activity (cfg.target);\n                    } else if (cfg.target.objectType === "Agent") {\n                        this.target = new TinCan.Agent (cfg.target);\n                    } else if (cfg.target.objectType === "Group") {\n                        this.target = new TinCan.Group (cfg.target);\n                    } else if (cfg.target.objectType === "SubStatement") {\n                        this.target = new TinCan.SubStatement (cfg.target);\n                    } else if (cfg.target.objectType === "StatementRef") {\n                        this.target = new TinCan.StatementRef (cfg.target);\n                    } else {\n                        this.log("Unrecognized target type: " + cfg.target.objectType);\n                    }\n                }\n            }\n            if (cfg.hasOwnProperty("result")) {\n                if (cfg.result instanceof TinCan.Result) {\n                    this.result = cfg.result;\n                } else {\n                    this.result = new TinCan.Result (cfg.result);\n                }\n            }\n            if (cfg.hasOwnProperty("context")) {\n                if (cfg.context instanceof TinCan.Context) {\n                    this.context = cfg.context;\n                } else {\n                    this.context = new TinCan.Context (cfg.context);\n                }\n            }\n            if (cfg.hasOwnProperty("attachments") && cfg.attachments !== null) {\n                this.attachments = [];\n                for (i = 0; i < cfg.attachments.length; i += 1) {\n                    if (! (cfg.attachments[i] instanceof TinCan.Attachment)) {\n                        this.attachments.push(new TinCan.Attachment (cfg.attachments[i]));\n                    }\n                    else {\n                        this.attachments.push(cfg.attachments[i]);\n                    }\n                }\n            }\n\n            for (i = 0; i < directProps.length; i += 1) {\n                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {\n                    this[directProps[i]] = cfg[directProps[i]];\n                }\n            }\n\n            if (initCfg.doStamp) {\n                this.stamp();\n            }\n        },\n\n        /**\n        @method toString\n        @return {String} String representation of the statement\n        */\n        toString: function (lang) {\n            this.log("toString");\n            return (this.actor !== null ? this.actor.toString(lang) : "") +\n                    " " +\n                    (this.verb !== null ? this.verb.toString(lang) : "") +\n                    " " +\n                    (this.target !== null ? this.target.toString(lang) : "");\n        },\n\n        /**\n        @method asVersion\n        @param {String} [version] Version to return (defaults to newest supported)\n        */\n        asVersion: function (version) {\n            this.log("asVersion");\n            var result = {},\n                optionalDirectProps = [\n                    "id",\n                    "timestamp"\n                ],\n                optionalObjProps = [\n                    "actor",\n                    "verb",\n                    "result",\n                    "context",\n                    "authority"\n                ],\n                i;\n\n            version = version || TinCan.versions()[0];\n\n            for (i = 0; i < optionalDirectProps.length; i += 1) {\n                if (this[optionalDirectProps[i]] !== null) {\n                    result[optionalDirectProps[i]] = this[optionalDirectProps[i]];\n                }\n            }\n            for (i = 0; i < optionalObjProps.length; i += 1) {\n                if (this[optionalObjProps[i]] !== null) {\n                    result[optionalObjProps[i]] = this[optionalObjProps[i]].asVersion(version);\n                }\n            }\n            if (this.target !== null) {\n                result.object = this.target.asVersion(version);\n            }\n\n            if (version === "0.9" || version === "0.95") {\n                if (this.voided !== null) {\n                    result.voided = this.voided;\n                }\n            }\n            if (version === "0.9" && this.inProgress !== null) {\n                result.inProgress = this.inProgress;\n            }\n            if (this.attachments !== null) {\n                if (! (version === "0.9" || version === "0.95")) {\n                    result.attachments = [];\n                    for (i = 0; i < this.attachments.length; i += 1) {\n                        if (this.attachments[i] instanceof TinCan.Attachment) {\n                            result.attachments.push(this.attachments[i].asVersion(version));\n                        }\n                        else {\n                            result.attachments.push(new TinCan.Attachment(this.attachments[i]).asVersion(version));\n                        }\n                    }\n                }\n            }\n\n            return result;\n        },\n\n        /**\n        Sets \'id\' and \'timestamp\' properties if not already set\n\n        @method stamp\n        */\n        stamp: function () {\n            this.log("stamp");\n            if (this.id === null) {\n                this.id = TinCan.Utils.getUUID();\n            }\n            if (this.timestamp === null) {\n                this.timestamp = TinCan.Utils.getISODateString(new Date());\n            }\n        },\n\n        /**\n        Checks if the Statement has at least one attachment with content\n\n        @method hasAttachmentsWithContent\n        */\n        hasAttachmentWithContent: function () {\n            this.log("hasAttachmentWithContent");\n            var i;\n\n            if (this.attachments === null) {\n                return false;\n            }\n\n            for (i = 0; i < this.attachments.length; i += 1) {\n                if (this.attachments[i].content !== null) {\n                    return true;\n                }\n            }\n\n            return false;\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} Statement\n    @static\n    */\n    Statement.fromJSON = function (stJSON) {\n        Statement.prototype.log("fromJSON");\n        var _st = JSON.parse(stJSON);\n\n        return new Statement(_st);\n    };\n}());\n\n/*\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.StatementsResult\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.StatementsResult\n    @constructor\n    @param {Object} options Configuration used to initialize.\n        @param {Array} options.statements Actor of statement\n        @param {String} options.more URL to fetch more data\n    **/\n    var StatementsResult = TinCan.StatementsResult = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property statements\n        @type Array\n        */\n        this.statements = null;\n\n        /**\n        @property more\n        @type String\n        */\n        this.more = null;\n\n        this.init(cfg);\n    };\n\n    StatementsResult.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "StatementsResult",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n\n            cfg = cfg || {};\n\n            if (cfg.hasOwnProperty("statements")) {\n                this.statements = cfg.statements;\n            }\n            if (cfg.hasOwnProperty("more")) {\n                this.more = cfg.more;\n            }\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} Agent\n    @static\n    */\n    StatementsResult.fromJSON = function (resultJSON) {\n        StatementsResult.prototype.log("fromJSON");\n        var _result,\n            stmts = [],\n            stmt,\n            i\n        ;\n\n        try {\n            _result = JSON.parse(resultJSON);\n        } catch (parseError) {\n            StatementsResult.prototype.log("fromJSON - JSON.parse error: " + parseError);\n        }\n\n        if (_result) {\n            for (i = 0; i < _result.statements.length; i += 1) {\n                try {\n                    stmt = new TinCan.Statement (_result.statements[i], 4);\n                } catch (error) {\n                    StatementsResult.prototype.log("fromJSON - statement instantiation failed: " + error + " (" + JSON.stringify(_result.statements[i]) + ")");\n\n                    stmt = new TinCan.Statement (\n                        {\n                            id: _result.statements[i].id\n                        },\n                        4\n                    );\n                }\n\n                stmts.push(stmt);\n            }\n            _result.statements = stmts;\n        }\n\n        return new StatementsResult (_result);\n    };\n}());\n\n/*\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.State\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.State\n    @constructor\n    */\n    var State = TinCan.State = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property id\n        @type String\n        */\n        this.id = null;\n\n        /**\n        @property updated\n        @type Boolean\n        */\n        this.updated = null;\n\n        /**\n        @property contents\n        @type String\n        */\n        this.contents = null;\n\n        /**\n        @property etag\n        @type String\n        */\n        this.etag = null;\n\n        /**\n        @property contentType\n        @type String\n        */\n        this.contentType = null;\n\n        this.init(cfg);\n    };\n    State.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "State",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n            var i,\n                directProps = [\n                    "id",\n                    "contents",\n                    "etag",\n                    "contentType"\n                ];\n\n            cfg = cfg || {};\n\n            for (i = 0; i < directProps.length; i += 1) {\n                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {\n                    this[directProps[i]] = cfg[directProps[i]];\n                }\n            }\n\n            this.updated = false;\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} State\n    @static\n    */\n    State.fromJSON = function (stateJSON) {\n        State.prototype.log("fromJSON");\n        var _state = JSON.parse(stateJSON);\n\n        return new State(_state);\n    };\n}());\n\n/*\n    Copyright 2012 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.ActivityProfile\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.ActivityProfile\n    @constructor\n    */\n    var ActivityProfile = TinCan.ActivityProfile = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property id\n        @type String\n        */\n        this.id = null;\n\n        /**\n        @property activity\n        @type TinCan.Activity\n        */\n        this.activity = null;\n\n        /**\n        @property updated\n        @type String\n        */\n        this.updated = null;\n\n        /**\n        @property contents\n        @type String\n        */\n        this.contents = null;\n\n        /**\n        SHA1 of contents as provided by the server during last fetch,\n        this should be passed through to saveActivityProfile\n\n        @property etag\n        @type String\n        */\n        this.etag = null;\n\n        /**\n        @property contentType\n        @type String\n        */\n        this.contentType = null;\n\n        this.init(cfg);\n    };\n    ActivityProfile.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "ActivityProfile",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n            var i,\n                directProps = [\n                    "id",\n                    "contents",\n                    "etag",\n                    "contentType"\n                ];\n\n            cfg = cfg || {};\n\n            if (cfg.hasOwnProperty("activity")) {\n                if (cfg.activity instanceof TinCan.Activity) {\n                    this.activity = cfg.activity;\n                }\n                else {\n                    this.activity = new TinCan.Activity (cfg.activity);\n                }\n            }\n\n            for (i = 0; i < directProps.length; i += 1) {\n                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {\n                    this[directProps[i]] = cfg[directProps[i]];\n                }\n            }\n\n            this.updated = false;\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} ActivityProfile\n    @static\n    */\n    ActivityProfile.fromJSON = function (stateJSON) {\n        ActivityProfile.prototype.log("fromJSON");\n        var _state = JSON.parse(stateJSON);\n\n        return new ActivityProfile(_state);\n    };\n}());\n\n/*\n    Copyright 2013 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.AgentProfile\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.AgentProfile\n    @constructor\n    */\n    var AgentProfile = TinCan.AgentProfile = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property id\n        @type String\n        */\n        this.id = null;\n\n        /**\n        @property agent\n        @type TinCan.Agent\n        */\n        this.agent = null;\n\n        /**\n        @property updated\n        @type String\n        */\n        this.updated = null;\n\n        /**\n        @property contents\n        @type String\n        */\n        this.contents = null;\n\n        /**\n        SHA1 of contents as provided by the server during last fetch,\n        this should be passed through to saveAgentProfile\n\n        @property etag\n        @type String\n        */\n        this.etag = null;\n\n        /**\n        @property contentType\n        @type String\n        */\n        this.contentType = null;\n\n        this.init(cfg);\n    };\n    AgentProfile.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "AgentProfile",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n            var i,\n                directProps = [\n                    "id",\n                    "contents",\n                    "etag",\n                    "contentType"\n                ];\n\n            cfg = cfg || {};\n\n            if (cfg.hasOwnProperty("agent")) {\n                if (cfg.agent instanceof TinCan.Agent) {\n                    this.agent = cfg.agent;\n                }\n                else {\n                    this.agent = new TinCan.Agent (cfg.agent);\n                }\n            }\n\n            for (i = 0; i < directProps.length; i += 1) {\n                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {\n                    this[directProps[i]] = cfg[directProps[i]];\n                }\n            }\n\n            this.updated = false;\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} AgentProfile\n    @static\n    */\n    AgentProfile.fromJSON = function (stateJSON) {\n        AgentProfile.prototype.log("fromJSON");\n        var _state = JSON.parse(stateJSON);\n\n        return new AgentProfile(_state);\n    };\n}());\n\n/*\n    Copyright 2014 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.About\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.About\n    @constructor\n    */\n    var About = TinCan.About = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property version\n        @type {String[]}\n        */\n        this.version = null;\n\n        this.init(cfg);\n    };\n    About.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "About",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n            var i,\n                directProps = [\n                    "version"\n                ];\n\n            cfg = cfg || {};\n\n            for (i = 0; i < directProps.length; i += 1) {\n                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {\n                    this[directProps[i]] = cfg[directProps[i]];\n                }\n            }\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} About\n    @static\n    */\n    About.fromJSON = function (aboutJSON) {\n        About.prototype.log("fromJSON");\n        var _about = JSON.parse(aboutJSON);\n\n        return new About(_about);\n    };\n}());\n\n/*\n    Copyright 2016 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.Attachment\n**/\n(function () {\n    "use strict";\n\n    /**\n    @class TinCan.Attachment\n    @constructor\n    */\n    var Attachment = TinCan.Attachment = function (cfg) {\n        this.log("constructor");\n\n        /**\n        @property usageType\n        @type String\n        */\n        this.usageType = null;\n\n        /**\n        @property display\n        @type Object\n        */\n        this.display = null;\n\n        /**\n        @property contentType\n        @type String\n        */\n        this.contentType = null;\n\n        /**\n        @property length\n        @type int\n        */\n        this.length = null;\n\n        /**\n        @property sha2\n        @type String\n        */\n        this.sha2 = null;\n\n        /**\n        @property description\n        @type Object\n        */\n        this.description = null;\n\n        /**\n        @property fileUrl\n        @type String\n        */\n        this.fileUrl = null;\n\n        /**\n        @property content\n        @type ArrayBuffer\n        */\n        this.content = null;\n\n        this.init(cfg);\n    };\n    Attachment.prototype = {\n        /**\n        @property LOG_SRC\n        */\n        LOG_SRC: "Attachment",\n\n        /**\n        @method log\n        */\n        log: TinCan.prototype.log,\n\n        /**\n        @method init\n        @param {Object} [options] Configuration used to initialize\n        */\n        init: function (cfg) {\n            this.log("init");\n            var i,\n                directProps = [\n                    "contentType",\n                    "length",\n                    "sha2",\n                    "usageType",\n                    "display",\n                    "description",\n                    "fileUrl"\n                ]\n            ;\n\n            cfg = cfg || {};\n\n            for (i = 0; i < directProps.length; i += 1) {\n                if (cfg.hasOwnProperty(directProps[i]) && cfg[directProps[i]] !== null) {\n                    this[directProps[i]] = cfg[directProps[i]];\n                }\n            }\n\n            if (cfg.hasOwnProperty("content") && cfg.content !== null) {\n                if (typeof cfg.content === "string") {\n                    this.setContentFromString(cfg.content);\n                }\n                else {\n                    this.setContent(cfg.content);\n                }\n            }\n        },\n\n        /**\n        @method asVersion\n        @param {String} [version] Version to return (defaults to newest supported)\n        */\n        asVersion: function (version) {\n            this.log("asVersion");\n            var result;\n\n            version = version || TinCan.versions()[0];\n\n            if (version === "0.9" || version === "0.95") {\n                result = null;\n            }\n            else {\n                result = {\n                    contentType: this.contentType,\n                    display: this.display,\n                    length: this.length,\n                    sha2: this.sha2,\n                    usageType: this.usageType\n                };\n\n                if (this.fileUrl !== null) {\n                    result.fileUrl = this.fileUrl;\n                }\n                if (this.description !== null) {\n                    result.description = this.description;\n                }\n            }\n\n            return result;\n        },\n\n        /**\n        See {{#crossLink "TinCan.Utils/getLangDictionaryValue"}}{{/crossLink}}\n\n        @method getLangDictionaryValue\n        */\n        getLangDictionaryValue: TinCan.Utils.getLangDictionaryValue,\n\n        /**\n        @method setContent\n        @param {ArrayBuffer} content Sets content from ArrayBuffer\n        */\n        setContent: function (content) {\n            this.content = content;\n            this.length = content.byteLength;\n            this.sha2 = TinCan.Utils.getSHA256String(content);\n        },\n\n        /**\n        @method setContentFromString\n        @param {String} content Sets the content property of the attachment from a string\n        */\n        setContentFromString: function (content) {\n            var _content = content;\n\n            _content = TinCan.Utils.stringToArrayBuffer(content);\n\n            this.setContent(_content);\n        },\n\n        /**\n        @method getContentAsString\n        @return {String} Value of content property as a string\n        */\n        getContentAsString: function () {\n            return TinCan.Utils.stringFromArrayBuffer(this.content);\n        }\n    };\n\n    /**\n    @method fromJSON\n    @return {Object} Attachment\n    @static\n    */\n    Attachment.fromJSON = function (attachmentJSON) {\n        Attachment.prototype.log("fromJSON");\n        var _attachment = JSON.parse(attachmentJSON);\n\n        return new Attachment(_attachment);\n    };\n\n    Attachment._defaultEncoding = "utf-8";\n}());\n\n/*\n    Copyright 2012-2013 Rustici Software\n\n    Licensed under the Apache License, Version 2.0 (the "License");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an "AS IS" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n*/\n\n/**\nTinCan client library\n\n@module TinCan\n@submodule TinCan.Environment.Browser\n**/\n(function () {\n    /* globals window, XMLHttpRequest, XDomainRequest, Blob */\n    "use strict";\n    var LOG_SRC = "Environment.Browser",\n        requestComplete,\n        __IEModeConversion,\n        nativeRequest,\n        xdrRequest,\n        __createJSONSegment,\n        __createAttachmentSegment,\n        __delay,\n        env = {},\n        log = TinCan.prototype.log;\n\n    if (typeof window === "undefined") {\n        log("\'window\' not defined", LOG_SRC);\n        return;\n    }\n\n    /* Shims for browsers not supporting our needs, mainly IE */\n\n    //\n    // Make JSON safe for IE6\n    // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/JSON#Browser_compatibility\n    //\n    if (!window.JSON) {\n        window.JSON = {\n            parse: function (sJSON) {\n                /*jslint evil: true */\n                return eval("(" + sJSON + ")");\n            },\n            stringify: function (vContent) {\n                var sOutput = "",\n                    nId,\n                    sProp\n                ;\n                if (vContent instanceof Object) {\n                    if (vContent.constructor === Array) {\n                        for (nId = 0; nId < vContent.length; nId += 1) {\n                            sOutput += this.stringify(vContent[nId]) + ",";\n                        }\n                        return "[" + sOutput.substr(0, sOutput.length - 1) + "]";\n                    }\n                    if (vContent.toString !== Object.prototype.toString) { return "\\"" + vContent.toString().replace(/"/g, "\\\\$&") + "\\""; }\n                    for (sProp in vContent) {\n                        if (vContent.hasOwnProperty(sProp)) {\n                            sOutput += "\\"" + sProp.replace(/"/g, "\\\\$&") + "\\":" + this.stringify(vContent[sProp]) + ",";\n                        }\n                    }\n                    return "{" + sOutput.substr(0, sOutput.length - 1) + "}";\n                }\n                return typeof vContent === "string" ? "\\"" + vContent.replace(/"/g, "\\\\$&") + "\\"" : String(vContent);\n            }\n        };\n    }\n\n    //\n    // Make Date.now safe for IE < 9\n    // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Date/now\n    //\n    if (!Date.now) {\n        Date.now = function () {\n            return +(new Date ());\n        };\n    }\n\n    //\n    // Add .forEach implementation for supporting our string encoding polyfill\n    // imported from js-polyfills to avoid bringing in the whole es5 shim\n    // for now, a rewrite probably moves all shims out of the main build or at\n    // least Environment file and leverages more of them\n    //\n\n    // ES5 15.4.4.18 Array.prototype.forEach ( callbackfn [ , thisArg ] )\n    // From https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach\n    if (!Array.prototype.forEach) {\n      /* jshint freeze:false,bitwise:false */\n      Array.prototype.forEach = function (fun /*, thisp */) {\n        if (this === void 0 || this === null) { throw new TypeError(); }\n\n        var t = Object(this);\n        var len = t.length >>> 0;\n        if (typeof fun !== "function") { throw new TypeError(); }\n\n        var thisp = arguments[1], i;\n        for (i = 0; i < len; i += 1) {\n          if (i in t) {\n            fun.call(thisp, t[i], i, t);\n          }\n        }\n      };\n    }\n\n    /* Detect CORS and XDR support */\n    env.hasCORS = false;\n    env.useXDR = false;\n\n    if (typeof XMLHttpRequest !== "undefined" && typeof (new XMLHttpRequest()).withCredentials !== "undefined") {\n        env.hasCORS = true;\n    }\n    else if (typeof XDomainRequest !== "undefined") {\n        env.hasCORS = true;\n        env.useXDR = true;\n    }\n\n    // TODO: should we have our own internal "Request" object\n    //       that replaces the need for "control"?\n\n    //\n    // Setup request callback\n    //\n    requestComplete = function (xhr, cfg, control) {\n        log("requestComplete: " + control.finished + ", xhr.status: " + xhr.status, LOG_SRC);\n        var requestCompleteResult,\n            notFoundOk,\n            httpStatus;\n\n        //\n        // XDomainRequest doesn\'t give us a way to get the status,\n        // so allow passing in a forged one\n        //\n        if (typeof xhr.status === "undefined") {\n            httpStatus = control.fakeStatus;\n        }\n        else {\n            //\n            // older versions of IE don\'t properly handle 204 status codes\n            // so correct when receiving a 1223 to be 204 locally\n            // http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n            //\n            httpStatus = (xhr.status === 1223) ? 204 : xhr.status;\n        }\n\n        if (! control.finished) {\n            // may be in sync or async mode, using XMLHttpRequest or IE XDomainRequest, onreadystatechange or\n            // onload or both might fire depending upon browser, just covering all bases with event hooks and\n            // using \'finished\' flag to avoid triggering events multiple times\n            control.finished = true;\n\n            notFoundOk = (cfg.ignore404 && httpStatus === 404);\n            if ((httpStatus >= 200 && httpStatus < 400) || notFoundOk) {\n                if (cfg.callback) {\n                    cfg.callback(null, xhr);\n                }\n                else {\n                    requestCompleteResult = {\n                        err: null,\n                        xhr: xhr\n                    };\n                    return requestCompleteResult;\n                }\n            }\n            else {\n                requestCompleteResult = {\n                    err: httpStatus,\n                    xhr: xhr\n                };\n                if (httpStatus === 0) {\n                    log("[warning] There was a problem communicating with the Learning Record Store. Aborted, offline, or invalid CORS endpoint (" + httpStatus + ")", LOG_SRC);\n                }\n                else {\n                    log("[warning] There was a problem communicating with the Learning Record Store. (" + httpStatus + " | " + xhr.responseText+ ")", LOG_SRC);\n                }\n                if (cfg.callback) {\n                    cfg.callback(httpStatus, xhr);\n                }\n                return requestCompleteResult;\n            }\n        }\n        else {\n            return requestCompleteResult;\n        }\n    };\n\n    //\n    // Converts an HTTP request cfg of above a set length (//MAX_REQUEST_LENGTH) to a post\n    // request cfg, with the original request as the form data.\n    //\n    __IEModeConversion = function (fullUrl, headers, pairs, cfg) {\n        var prop;\n\n        // \'pairs\' already holds the original cfg params, now needs headers and data\n        // from the original cfg to add as the form data to the POST request\n        for (prop in headers) {\n            if (headers.hasOwnProperty(prop)) {\n                pairs.push(prop + "=" + encodeURIComponent(headers[prop]));\n            }\n        }\n\n        if (typeof cfg.data !== "undefined") {\n            pairs.push("content=" + encodeURIComponent(cfg.data));\n        }\n\n        // the Authorization and xAPI version headers need to still be present, but\n        // the content type must exist and be of type application/x-www-form-urlencoded\n        headers["Content-Type"] = "application/x-www-form-urlencoded";\n        fullUrl += "?method=" + cfg.method;\n        cfg.method = "POST";\n        cfg.params = {};\n        if (pairs.length > 0) {\n            cfg.data = pairs.join("&");\n        }\n        return fullUrl;\n    };\n\n    //\n    // one of the two of these is stuffed into the LRS\' instance\n    // as ._makeRequest\n    //\n    nativeRequest = function (fullUrl, headers, cfg) {\n        /*global ActiveXObject*/\n        log("sendRequest using XMLHttpRequest", LOG_SRC);\n        var self = this,\n            xhr,\n            prop,\n            pairs = [],\n            data,\n            control = {\n                finished: false,\n                fakeStatus: null\n            },\n            async = typeof cfg.callback !== "undefined",\n            fullRequest = fullUrl,\n            err,\n            MAX_REQUEST_LENGTH = 2048\n        ;\n        log("sendRequest using XMLHttpRequest - async: " + async, LOG_SRC);\n\n        for (prop in cfg.params) {\n            if (cfg.params.hasOwnProperty(prop)) {\n                pairs.push(prop + "=" + encodeURIComponent(cfg.params[prop]));\n            }\n        }\n\n        if (pairs.length > 0) {\n            fullRequest += "?" + pairs.join("&");\n        }\n\n        if (fullRequest.length >= MAX_REQUEST_LENGTH) {\n            if (typeof cfg.method === "undefined") {\n                err = new Error("method must not be undefined for an IE Mode Request conversion");\n                if (typeof cfg.callback !== "undefined") {\n                    cfg.callback(err, null);\n                }\n                return {\n                    err: err,\n                    xhr: null\n                };\n            }\n\n            fullUrl = __IEModeConversion(fullUrl, headers, pairs, cfg);\n        }\n        else {\n            fullUrl = fullRequest;\n        }\n\n        if (typeof XMLHttpRequest !== "undefined") {\n            xhr = new XMLHttpRequest();\n        }\n        else {\n            //\n            // IE6 implements XMLHttpRequest through ActiveX control\n            // http://blogs.msdn.com/b/ie/archive/2006/01/23/516393.aspx\n            //\n            xhr = new ActiveXObject("Microsoft.XMLHTTP");\n\n            if (cfg.expectMultipart) {\n                err = new Error("Attachment support not available");\n                if (typeof cfg.callback !== "undefined") {\n                    cfg.callback(err, null);\n                }\n                return {\n                    err: err,\n                    xhr: null\n                };\n            }\n        }\n\n        xhr.open(cfg.method, fullUrl, async);\n\n        //\n        // setting the .responseType before .open was causing IE to fail\n        // with a StateError, so moved it to here\n        //\n        if (cfg.expectMultipart) {\n            xhr.responseType = "arraybuffer";\n        }\n\n        for (prop in headers) {\n            if (headers.hasOwnProperty(prop)) {\n                xhr.setRequestHeader(prop, headers[prop]);\n            }\n        }\n\n        data = cfg.data;\n\n        if (async) {\n            xhr.onreadystatechange = function () {\n                log("xhr.onreadystatechange - xhr.readyState: " + xhr.readyState, LOG_SRC);\n                if (xhr.readyState === 4) {\n                    requestComplete.call(self, xhr, cfg, control);\n                }\n            };\n        }\n\n        //\n        // research indicates that IE is known to just throw exceptions\n        // on .send and it seems everyone pretty much just ignores them\n        // including jQuery (https://github.com/jquery/jquery/blob/1.10.2/src/ajax.js#L549\n        // https://github.com/jquery/jquery/blob/1.10.2/src/ajax/xhr.js#L97)\n        //\n        try {\n            xhr.send(data);\n        }\n        catch (ex) {\n            log("sendRequest caught send exception: " + ex, LOG_SRC);\n        }\n\n        if (async) {\n            //\n            // for async requests give them the XHR object directly\n            // as the return value, the actual stuff they should be\n            // caring about is params to the callback, for sync\n            // requests they got the return value above\n            //\n            return xhr;\n        }\n\n        return requestComplete.call(this, xhr, cfg, control);\n    };\n    xdrRequest = function (fullUrl, headers, cfg) {\n        log("sendRequest using XDomainRequest", LOG_SRC);\n        var self = this,\n            xhr,\n            pairs = [],\n            data,\n            prop,\n            until,\n            control = {\n                finished: false,\n                fakeStatus: null\n            },\n            err;\n\n        if (cfg.expectMultipart) {\n            err = new Error("Attachment support not available");\n            if (typeof cfg.callback !== "undefined") {\n                cfg.callback(err, null);\n            }\n            return {\n                err: err,\n                xhr: null\n            };\n        }\n\n        // method has to go on querystring, and nothing else,\n        // and the actual method is then always POST\n        fullUrl += "?method=" + cfg.method;\n\n        // params end up in the body\n        for (prop in cfg.params) {\n            if (cfg.params.hasOwnProperty(prop)) {\n                pairs.push(prop + "=" + encodeURIComponent(cfg.params[prop]));\n            }\n        }\n\n        // headers go into form data\n        for (prop in headers) {\n            if (headers.hasOwnProperty(prop)) {\n                pairs.push(prop + "=" + encodeURIComponent(headers[prop]));\n            }\n        }\n\n        // the original data is repackaged as "content" form var\n        if (typeof cfg.data !== "undefined") {\n            pairs.push("content=" + encodeURIComponent(cfg.data));\n        }\n\n        data = pairs.join("&");\n\n        xhr = new XDomainRequest ();\n        xhr.open("POST", fullUrl);\n\n        if (! cfg.callback) {\n            xhr.onload = function () {\n                control.fakeStatus = 200;\n            };\n            xhr.onerror = function () {\n                control.fakeStatus = 400;\n            };\n            xhr.ontimeout = function () {\n                control.fakeStatus = 0;\n            };\n        }\n        else {\n            xhr.onload = function () {\n                control.fakeStatus = 200;\n                requestComplete.call(self, xhr, cfg, control);\n            };\n            xhr.onerror = function () {\n                control.fakeStatus = 400;\n                requestComplete.call(self, xhr, cfg, control);\n            };\n            xhr.ontimeout = function () {\n                control.fakeStatus = 0;\n                requestComplete.call(self, xhr, cfg, control);\n            };\n        }\n\n        // IE likes to randomly abort requests when some handlers\n        // aren\'t defined, so define them with no-ops, see:\n        //\n        // http://cypressnorth.com/programming/internet-explorer-aborting-ajax-requests-fixed/\n        // http://social.msdn.microsoft.com/Forums/ie/en-US/30ef3add-767c-4436-b8a9-f1ca19b4812e/ie9-rtm-xdomainrequest-issued-requests-may-abort-if-all-event-handlers-not-specified\n        //\n        xhr.onprogress = function () {};\n        xhr.timeout = 0;\n\n        //\n        // research indicates that IE is known to just throw exceptions\n        // on .send and it seems everyone pretty much just ignores them\n        // including jQuery (https://github.com/jquery/jquery/blob/1.10.2/src/ajax.js#L549\n        // https://github.com/jquery/jquery/blob/1.10.2/src/ajax/xhr.js#L97)\n        //\n        try {\n            xhr.send(data);\n        }\n        catch (ex) {\n            log("sendRequest caught send exception: " + ex, LOG_SRC);\n        }\n\n        if (! cfg.callback) {\n            // synchronous call in IE, with no synchronous mode available\n            until = 10000 + Date.now();\n            log("sendRequest - until: " + until + ", finished: " + control.finished, LOG_SRC);\n\n            while (Date.now() < until && control.fakeStatus === null) {\n                //log("calling __delay", LOG_SRC);\n                __delay();\n            }\n            return requestComplete.call(self, xhr, cfg, control);\n        }\n\n        //\n        // for async requests give them the XHR object directly\n        // as the return value, the actual stuff they should be\n        // caring about is params to the callback, for sync\n        // requests they got the return value above\n        //\n        return xhr;\n    };\n\n    //\n    // Override LRS\' init method to set up our request handling\n    // capabilities\n    //\n    TinCan.LRS.prototype._initByEnvironment = function (cfg) {\n        /*jslint regexp: true, laxbreak: true */\n        /* globals location */\n        log("_initByEnvironment", LOG_SRC);\n        var urlParts,\n            schemeMatches,\n            locationPort,\n            isXD\n        ;\n\n        cfg = cfg || {};\n\n        //\n        // default to native request mode\n        //\n        this._makeRequest = nativeRequest;\n\n        //\n        // overload LRS ._IEModeConversion to be able to test this method,\n        // which only applies in a browser setting\n        //\n        this._IEModeConversion = __IEModeConversion;\n\n        urlParts = this.endpoint.toLowerCase().match(/([A-Za-z]+:)\\/\\/([^:\\/]+):?(\\d+)?(\\/.*)?$/);\n        if (urlParts === null) {\n            log("[error] LRS invalid: failed to divide URL parts", LOG_SRC);\n            throw {\n                code: 4,\n                mesg: "LRS invalid: failed to divide URL parts"\n            };\n        }\n\n        //\n        // determine whether this is a cross domain request,\n        // whether our browser has CORS support at all, and then\n        // if it does then if we are in IE with XDR only check that\n        // the schemes match to see if we should be able to talk to\n        // the LRS\n        //\n        locationPort = location.port;\n        schemeMatches = location.protocol.toLowerCase() === urlParts[1];\n\n        //\n        // normalize the location.port cause it appears to be "" when 80/443\n        // but our endpoint may have provided it\n        //\n        if (locationPort === "") {\n            locationPort = (location.protocol.toLowerCase() === "http:" ? "80" : (location.protocol.toLowerCase() === "https:" ? "443" : ""));\n        }\n\n        isXD = (\n            // is same scheme?\n            ! schemeMatches\n\n            // is same host?\n            || location.hostname.toLowerCase() !== urlParts[2]\n\n            // is same port?\n            || locationPort !== (\n                (urlParts[3] !== null && typeof urlParts[3] !== "undefined" && urlParts[3] !== "") ? urlParts[3] : (urlParts[1] === "http:" ? "80" : (urlParts[1] === "https:" ? "443" : ""))\n            )\n        );\n        if (isXD) {\n            if (env.hasCORS) {\n                if (env.useXDR && schemeMatches) {\n                    this._makeRequest = xdrRequest;\n                }\n                else if (env.useXDR && ! schemeMatches) {\n                    if (cfg.allowFail) {\n                        log("[warning] LRS invalid: cross domain request for differing scheme in IE with XDR (allowed to fail)", LOG_SRC);\n                    }\n                    else {\n                        log("[error] LRS invalid: cross domain request for differing scheme in IE with XDR", LOG_SRC);\n                        throw {\n                            code: 2,\n                            mesg: "LRS invalid: cross domain request for differing scheme in IE with XDR"\n                        };\n                    }\n                }\n            }\n            else {\n                if (cfg.allowFail) {\n                    log("[warning] LRS invalid: cross domain requests not supported in this browser (allowed to fail)", LOG_SRC);\n                }\n                else {\n                    log("[error] LRS invalid: cross domain requests not supported in this browser", LOG_SRC);\n                    throw {\n                        code: 1,\n                        mesg: "LRS invalid: cross domain requests not supported in this browser"\n                    };\n                }\n            }\n        }\n    };\n\n    /**\n    Non-environment safe method used to create a delay to give impression\n    of synchronous response (for IE, shocker)\n\n    @method __delay\n    @private\n    */\n    __delay = function () {\n        //\n        // use a synchronous request to the current location to allow the browser\n        // to yield to the asynchronous request\'s events but still block in the\n        // outer loop to make it seem synchronous to the end user\n        //\n        // removing this made the while loop too tight to allow the asynchronous\n        // events through to get handled so that the response was correctly handled\n        //\n        var xhr = new XMLHttpRequest (),\n            url = window.location + "?forcenocache=" + TinCan.Utils.getUUID()\n        ;\n        xhr.open("GET", url, false);\n        xhr.send(null);\n    };\n\n    //\n    // Synchronous xhr handling is accepted in the browser environment\n    //\n    TinCan.LRS.syncEnabled = true;\n\n    TinCan.LRS.prototype._getMultipartRequestData = function (boundary, jsonContent, requestAttachments) {\n        var parts = [],\n            i;\n\n        parts.push(\n            __createJSONSegment(\n                boundary,\n                jsonContent\n            )\n        );\n        for (i = 0; i < requestAttachments.length; i += 1) {\n            if (requestAttachments[i].content !== null) {\n                parts.push(\n                    __createAttachmentSegment(\n                        boundary,\n                        requestAttachments[i].content,\n                        requestAttachments[i].sha2,\n                        requestAttachments[i].contentType\n                    )\n                );\n            }\n        }\n        parts.push("\\r\\n--" + boundary + "--\\r\\n");\n\n        return new Blob(parts);\n    };\n\n    __createJSONSegment = function (boundary, jsonContent) {\n        var content = [\n                "--" + boundary,\n                "Content-Type: application/json",\n                "",\n                JSON.stringify(jsonContent)\n            ].join("\\r\\n");\n\n        content += "\\r\\n";\n\n        return content;\n    };\n\n    __createAttachmentSegment = function (boundary, content, sha2, contentType) {\n        var blobParts = [],\n            header = [\n                "--" + boundary,\n                "Content-Type: " + contentType,\n                "Content-Transfer-Encoding: binary",\n                "X-Experience-API-Hash: " + sha2\n            ].join("\\r\\n");\n\n        header += "\\r\\n\\r\\n";\n\n        blobParts.push(header);\n        blobParts.push(content);\n\n        return new Blob(blobParts);\n    };\n\n    TinCan.Utils.stringToArrayBuffer = function (content, encoding) {\n        /* global TextEncoder */\n        var encoder;\n\n        if (! encoding) {\n            encoding = TinCan.Utils.defaultEncoding;\n        }\n\n        encoder = new TextEncoder(encoding);\n\n        return encoder.encode(content).buffer;\n    };\n\n    TinCan.Utils.stringFromArrayBuffer = function (content, encoding) {\n        /* global TextDecoder */\n        var decoder;\n\n        if (! encoding) {\n            encoding = TinCan.Utils.defaultEncoding;\n        }\n\n        decoder = new TextDecoder(encoding);\n\n        return decoder.decode(content);\n    };\n}());\n\n/*\n Copyright (c) 2010, Linden Research, Inc.\n Copyright (c) 2014, Joshua Bell\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the "Software"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n $/LicenseInfo$\n */\n\n// Original can be found at:\n//   https://bitbucket.org/lindenlab/llsd\n// Modifications by Joshua Bell inexorabletash@gmail.com\n//   https://github.com/inexorabletash/polyfill\n\n// ES3/ES5 implementation of the Krhonos Typed Array Specification\n//   Ref: http://www.khronos.org/registry/typedarray/specs/latest/\n//   Date: 2011-02-01\n//\n// Variations:\n//  * Allows typed_array.get/set() as alias for subscripts (typed_array[])\n//  * Gradually migrating structure from Khronos spec to ES2015 spec\n//\n// Caveats:\n//  * Beyond 10000 or so entries, polyfilled array accessors (ta[0],\n//    etc) become memory-prohibitive, so array creation will fail. Set\n//    self.TYPED_ARRAY_POLYFILL_NO_ARRAY_ACCESSORS=true to disable\n//    creation of accessors. Your code will need to use the\n//    non-standard get()/set() instead, and will need to add those to\n//    native arrays for interop.\n(function(global) {\n  \'use strict\';\n  var undefined = (void 0); // Paranoia\n\n  // Beyond this value, index getters/setters (i.e. array[0], array[1]) are so slow to\n  // create, and consume so much memory, that the browser appears frozen.\n  var MAX_ARRAY_LENGTH = 1e5;\n\n  // Approximations of internal ECMAScript conversion functions\n  function Type(v) {\n    switch(typeof v) {\n    case \'undefined\': return \'undefined\';\n    case \'boolean\': return \'boolean\';\n    case \'number\': return \'number\';\n    case \'string\': return \'string\';\n    default: return v === null ? \'null\' : \'object\';\n    }\n  }\n\n  // Class returns internal [[Class]] property, used to avoid cross-frame instanceof issues:\n  function Class(v) { return Object.prototype.toString.call(v).replace(/^\\[object *|\\]$/g, \'\'); }\n  function IsCallable(o) { return typeof o === \'function\'; }\n  function ToObject(v) {\n    if (v === null || v === undefined) throw TypeError();\n    return Object(v);\n  }\n  function ToInt32(v) { return v >> 0; }\n  function ToUint32(v) { return v >>> 0; }\n\n  // Snapshot intrinsics\n  var LN2 = Math.LN2,\n      abs = Math.abs,\n      floor = Math.floor,\n      log = Math.log,\n      max = Math.max,\n      min = Math.min,\n      pow = Math.pow,\n      round = Math.round;\n\n  // emulate ES5 getter/setter API using legacy APIs\n  // http://blogs.msdn.com/b/ie/archive/2010/09/07/transitioning-existing-code-to-the-es5-getter-setter-apis.aspx\n  // (second clause tests for Object.defineProperty() in IE<9 that only supports extending DOM prototypes, but\n  // note that IE<9 does not support __defineGetter__ or __defineSetter__ so it just renders the method harmless)\n\n  (function() {\n    var orig = Object.defineProperty;\n    var dom_only = !(function(){try{return Object.defineProperty({},\'x\',{});}catch(_){return false;}}());\n\n    if (!orig || dom_only) {\n      Object.defineProperty = function (o, prop, desc) {\n        // In IE8 try built-in implementation for defining properties on DOM prototypes.\n        if (orig)\n          try { return orig(o, prop, desc); } catch (_) {}\n        if (o !== Object(o))\n          throw TypeError(\'Object.defineProperty called on non-object\');\n        if (Object.prototype.__defineGetter__ && (\'get\' in desc))\n          Object.prototype.__defineGetter__.call(o, prop, desc.get);\n        if (Object.prototype.__defineSetter__ && (\'set\' in desc))\n          Object.prototype.__defineSetter__.call(o, prop, desc.set);\n        if (\'value\' in desc)\n          o[prop] = desc.value;\n        return o;\n      };\n    }\n  }());\n\n  // ES5: Make obj[index] an alias for obj._getter(index)/obj._setter(index, value)\n  // for index in 0 ... obj.length\n  function makeArrayAccessors(obj) {\n    if (\'TYPED_ARRAY_POLYFILL_NO_ARRAY_ACCESSORS\' in global)\n      return;\n\n    if (obj.length > MAX_ARRAY_LENGTH) throw RangeError(\'Array too large for polyfill\');\n\n    function makeArrayAccessor(index) {\n      Object.defineProperty(obj, index, {\n        \'get\': function() { return obj._getter(index); },\n        \'set\': function(v) { obj._setter(index, v); },\n        enumerable: true,\n        configurable: false\n      });\n    }\n\n    var i;\n    for (i = 0; i < obj.length; i += 1) {\n      makeArrayAccessor(i);\n    }\n  }\n\n  // Internal conversion functions:\n  //    pack<Type>()   - take a number (interpreted as Type), output a byte array\n  //    unpack<Type>() - take a byte array, output a Type-like number\n\n  function as_signed(value, bits) { var s = 32 - bits; return (value << s) >> s; }\n  function as_unsigned(value, bits) { var s = 32 - bits; return (value << s) >>> s; }\n\n  function packI8(n) { return [n & 0xff]; }\n  function unpackI8(bytes) { return as_signed(bytes[0], 8); }\n\n  function packU8(n) { return [n & 0xff]; }\n  function unpackU8(bytes) { return as_unsigned(bytes[0], 8); }\n\n  function packU8Clamped(n) { n = round(Number(n)); return [n < 0 ? 0 : n > 0xff ? 0xff : n & 0xff]; }\n\n  function packI16(n) { return [n & 0xff, (n >> 8) & 0xff]; }\n  function unpackI16(bytes) { return as_signed(bytes[1] << 8 | bytes[0], 16); }\n\n  function packU16(n) { return [n & 0xff, (n >> 8) & 0xff]; }\n  function unpackU16(bytes) { return as_unsigned(bytes[1] << 8 | bytes[0], 16); }\n\n  function packI32(n) { return [n & 0xff, (n >> 8) & 0xff, (n >> 16) & 0xff, (n >> 24) & 0xff]; }\n  function unpackI32(bytes) { return as_signed(bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0], 32); }\n\n  function packU32(n) { return [n & 0xff, (n >> 8) & 0xff, (n >> 16) & 0xff, (n >> 24) & 0xff]; }\n  function unpackU32(bytes) { return as_unsigned(bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0], 32); }\n\n  function packIEEE754(v, ebits, fbits) {\n\n    var bias = (1 << (ebits - 1)) - 1;\n\n    function roundToEven(n) {\n      var w = floor(n), f = n - w;\n      if (f < 0.5)\n        return w;\n      if (f > 0.5)\n        return w + 1;\n      return w % 2 ? w + 1 : w;\n    }\n\n    // Compute sign, exponent, fraction\n    var s, e, f;\n    if (v !== v) {\n      // NaN\n      // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping\n      e = (1 << ebits) - 1; f = pow(2, fbits - 1); s = 0;\n    } else if (v === Infinity || v === -Infinity) {\n      e = (1 << ebits) - 1; f = 0; s = (v < 0) ? 1 : 0;\n    } else if (v === 0) {\n      e = 0; f = 0; s = (1 / v === -Infinity) ? 1 : 0;\n    } else {\n      s = v < 0;\n      v = abs(v);\n\n      if (v >= pow(2, 1 - bias)) {\n        // Normalized\n        e = min(floor(log(v) / LN2), 1023);\n        var significand = v / pow(2, e);\n        if (significand < 1) {\n          e -= 1;\n          significand *= 2;\n        }\n        if (significand >= 2) {\n          e += 1;\n          significand /= 2;\n        }\n        var d = pow(2, fbits);\n        f = roundToEven(significand * d) - d;\n        e += bias;\n        if (f / d >= 1) {\n          e += 1;\n          f = 0;\n        }\n        if (e > 2 * bias) {\n          // Overflow\n          e = (1 << ebits) - 1;\n          f = 0;\n        }\n      } else {\n        // Denormalized\n        e = 0;\n        f = roundToEven(v / pow(2, 1 - bias - fbits));\n      }\n    }\n\n    // Pack sign, exponent, fraction\n    var bits = [], i;\n    for (i = fbits; i; i -= 1) { bits.push(f % 2 ? 1 : 0); f = floor(f / 2); }\n    for (i = ebits; i; i -= 1) { bits.push(e % 2 ? 1 : 0); e = floor(e / 2); }\n    bits.push(s ? 1 : 0);\n    bits.reverse();\n    var str = bits.join(\'\');\n\n    // Bits to bytes\n    var bytes = [];\n    while (str.length) {\n      bytes.unshift(parseInt(str.substring(0, 8), 2));\n      str = str.substring(8);\n    }\n    return bytes;\n  }\n\n  function unpackIEEE754(bytes, ebits, fbits) {\n    // Bytes to bits\n    var bits = [], i, j, b, str,\n        bias, s, e, f;\n\n    for (i = 0; i < bytes.length; ++i) {\n      b = bytes[i];\n      for (j = 8; j; j -= 1) {\n        bits.push(b % 2 ? 1 : 0); b = b >> 1;\n      }\n    }\n    bits.reverse();\n    str = bits.join(\'\');\n\n    // Unpack sign, exponent, fraction\n    bias = (1 << (ebits - 1)) - 1;\n    s = parseInt(str.substring(0, 1), 2) ? -1 : 1;\n    e = parseInt(str.substring(1, 1 + ebits), 2);\n    f = parseInt(str.substring(1 + ebits), 2);\n\n    // Produce number\n    if (e === (1 << ebits) - 1) {\n      return f !== 0 ? NaN : s * Infinity;\n    } else if (e > 0) {\n      // Normalized\n      return s * pow(2, e - bias) * (1 + f / pow(2, fbits));\n    } else if (f !== 0) {\n      // Denormalized\n      return s * pow(2, -(bias - 1)) * (f / pow(2, fbits));\n    } else {\n      return s < 0 ? -0 : 0;\n    }\n  }\n\n  function unpackF64(b) { return unpackIEEE754(b, 11, 52); }\n  function packF64(v) { return packIEEE754(v, 11, 52); }\n  function unpackF32(b) { return unpackIEEE754(b, 8, 23); }\n  function packF32(v) { return packIEEE754(v, 8, 23); }\n\n  //\n  // 3 The ArrayBuffer Type\n  //\n\n  (function() {\n\n    function ArrayBuffer(length) {\n      length = ToInt32(length);\n      if (length < 0) throw RangeError(\'ArrayBuffer size is not a small enough positive integer.\');\n      Object.defineProperty(this, \'byteLength\', {value: length});\n      Object.defineProperty(this, \'_bytes\', {value: Array(length)});\n\n      for (var i = 0; i < length; i += 1)\n        this._bytes[i] = 0;\n    }\n\n    global.ArrayBuffer = global.ArrayBuffer || ArrayBuffer;\n\n    //\n    // 5 The Typed Array View Types\n    //\n\n    function $TypedArray$() {\n\n      // %TypedArray% ( length )\n      if (!arguments.length || typeof arguments[0] !== \'object\') {\n        return (function(length) {\n          length = ToInt32(length);\n          if (length < 0) throw RangeError(\'length is not a small enough positive integer.\');\n          Object.defineProperty(this, \'length\', {value: length});\n          Object.defineProperty(this, \'byteLength\', {value: length * this.BYTES_PER_ELEMENT});\n          Object.defineProperty(this, \'buffer\', {value: new ArrayBuffer(this.byteLength)});\n          Object.defineProperty(this, \'byteOffset\', {value: 0});\n\n         }).apply(this, arguments);\n      }\n\n      // %TypedArray% ( typedArray )\n      if (arguments.length >= 1 &&\n          Type(arguments[0]) === \'object\' &&\n          arguments[0] instanceof $TypedArray$) {\n        return (function(typedArray){\n          if (this.constructor !== typedArray.constructor) throw TypeError();\n\n          var byteLength = typedArray.length * this.BYTES_PER_ELEMENT;\n          Object.defineProperty(this, \'buffer\', {value: new ArrayBuffer(byteLength)});\n          Object.defineProperty(this, \'byteLength\', {value: byteLength});\n          Object.defineProperty(this, \'byteOffset\', {value: 0});\n          Object.defineProperty(this, \'length\', {value: typedArray.length});\n\n          for (var i = 0; i < this.length; i += 1)\n            this._setter(i, typedArray._getter(i));\n\n        }).apply(this, arguments);\n      }\n\n      // %TypedArray% ( array )\n      if (arguments.length >= 1 &&\n          Type(arguments[0]) === \'object\' &&\n          !(arguments[0] instanceof $TypedArray$) &&\n          !(arguments[0] instanceof ArrayBuffer || Class(arguments[0]) === \'ArrayBuffer\')) {\n        return (function(array) {\n\n          var byteLength = array.length * this.BYTES_PER_ELEMENT;\n          Object.defineProperty(this, \'buffer\', {value: new ArrayBuffer(byteLength)});\n          Object.defineProperty(this, \'byteLength\', {value: byteLength});\n          Object.defineProperty(this, \'byteOffset\', {value: 0});\n          Object.defineProperty(this, \'length\', {value: array.length});\n\n          for (var i = 0; i < this.length; i += 1) {\n            var s = array[i];\n            this._setter(i, Number(s));\n          }\n        }).apply(this, arguments);\n      }\n\n      // %TypedArray% ( buffer, byteOffset=0, length=undefined )\n      if (arguments.length >= 1 &&\n          Type(arguments[0]) === \'object\' &&\n          (arguments[0] instanceof ArrayBuffer || Class(arguments[0]) === \'ArrayBuffer\')) {\n        return (function(buffer, byteOffset, length) {\n\n          byteOffset = ToUint32(byteOffset);\n          if (byteOffset > buffer.byteLength)\n            throw RangeError(\'byteOffset out of range\');\n\n          // The given byteOffset must be a multiple of the element\n          // size of the specific type, otherwise an exception is raised.\n          if (byteOffset % this.BYTES_PER_ELEMENT)\n            throw RangeError(\'buffer length minus the byteOffset is not a multiple of the element size.\');\n\n          if (length === undefined) {\n            var byteLength = buffer.byteLength - byteOffset;\n            if (byteLength % this.BYTES_PER_ELEMENT)\n              throw RangeError(\'length of buffer minus byteOffset not a multiple of the element size\');\n            length = byteLength / this.BYTES_PER_ELEMENT;\n\n          } else {\n            length = ToUint32(length);\n            byteLength = length * this.BYTES_PER_ELEMENT;\n          }\n\n          if ((byteOffset + byteLength) > buffer.byteLength)\n            throw RangeError(\'byteOffset and length reference an area beyond the end of the buffer\');\n\n          Object.defineProperty(this, \'buffer\', {value: buffer});\n          Object.defineProperty(this, \'byteLength\', {value: byteLength});\n          Object.defineProperty(this, \'byteOffset\', {value: byteOffset});\n          Object.defineProperty(this, \'length\', {value: length});\n\n        }).apply(this, arguments);\n      }\n\n      // %TypedArray% ( all other argument combinations )\n      throw TypeError();\n    }\n\n    // Properties of the %TypedArray Instrinsic Object\n\n    // %TypedArray%.from ( source , mapfn=undefined, thisArg=undefined )\n    Object.defineProperty($TypedArray$, \'from\', {value: function(iterable) {\n      return new this(iterable);\n    }});\n\n    // %TypedArray%.of ( ...items )\n    Object.defineProperty($TypedArray$, \'of\', {value: function(/*...items*/) {\n      return new this(arguments);\n    }});\n\n    // %TypedArray%.prototype\n    var $TypedArrayPrototype$ = {};\n    $TypedArray$.prototype = $TypedArrayPrototype$;\n\n    // WebIDL: getter type (unsigned long index);\n    Object.defineProperty($TypedArray$.prototype, \'_getter\', {value: function(index) {\n      if (arguments.length < 1) throw SyntaxError(\'Not enough arguments\');\n\n      index = ToUint32(index);\n      if (index >= this.length)\n        return undefined;\n\n      var bytes = [], i, o;\n      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;\n           i < this.BYTES_PER_ELEMENT;\n           i += 1, o += 1) {\n        bytes.push(this.buffer._bytes[o]);\n      }\n      return this._unpack(bytes);\n    }});\n\n    // NONSTANDARD: convenience alias for getter: type get(unsigned long index);\n    Object.defineProperty($TypedArray$.prototype, \'get\', {value: $TypedArray$.prototype._getter});\n\n    // WebIDL: setter void (unsigned long index, type value);\n    Object.defineProperty($TypedArray$.prototype, \'_setter\', {value: function(index, value) {\n      if (arguments.length < 2) throw SyntaxError(\'Not enough arguments\');\n\n      index = ToUint32(index);\n      if (index >= this.length)\n        return;\n\n      var bytes = this._pack(value), i, o;\n      for (i = 0, o = this.byteOffset + index * this.BYTES_PER_ELEMENT;\n           i < this.BYTES_PER_ELEMENT;\n           i += 1, o += 1) {\n        this.buffer._bytes[o] = bytes[i];\n      }\n    }});\n\n    // get %TypedArray%.prototype.buffer\n    // get %TypedArray%.prototype.byteLength\n    // get %TypedArray%.prototype.byteOffset\n    // -- applied directly to the object in the constructor\n\n    // %TypedArray%.prototype.constructor\n    Object.defineProperty($TypedArray$.prototype, \'constructor\', {value: $TypedArray$});\n\n    // %TypedArray%.prototype.copyWithin (target, start, end = this.length )\n    Object.defineProperty($TypedArray$.prototype, \'copyWithin\', {value: function(target, start) {\n      var end = arguments[2];\n\n      var o = ToObject(this);\n      var lenVal = o.length;\n      var len = ToUint32(lenVal);\n      len = max(len, 0);\n      var relativeTarget = ToInt32(target);\n      var to;\n      if (relativeTarget < 0)\n        to = max(len + relativeTarget, 0);\n      else\n        to = min(relativeTarget, len);\n      var relativeStart = ToInt32(start);\n      var from;\n      if (relativeStart < 0)\n        from = max(len + relativeStart, 0);\n      else\n        from = min(relativeStart, len);\n      var relativeEnd;\n      if (end === undefined)\n        relativeEnd = len;\n      else\n        relativeEnd = ToInt32(end);\n      var final;\n      if (relativeEnd < 0)\n        final = max(len + relativeEnd, 0);\n      else\n        final = min(relativeEnd, len);\n      var count = min(final - from, len - to);\n      var direction;\n      if (from < to && to < from + count) {\n        direction = -1;\n        from = from + count - 1;\n        to = to + count - 1;\n      } else {\n        direction = 1;\n      }\n      while (count > 0) {\n        o._setter(to, o._getter(from));\n        from = from + direction;\n        to = to + direction;\n        count = count - 1;\n      }\n      return o;\n    }});\n\n    // %TypedArray%.prototype.entries ( )\n    // -- defined in es6.js to shim browsers w/ native TypedArrays\n\n    // %TypedArray%.prototype.every ( callbackfn, thisArg = undefined )\n    Object.defineProperty($TypedArray$.prototype, \'every\', {value: function(callbackfn) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (!IsCallable(callbackfn)) throw TypeError();\n      var thisArg = arguments[1];\n      for (var i = 0; i < len; i++) {\n        if (!callbackfn.call(thisArg, t._getter(i), i, t))\n          return false;\n      }\n      return true;\n    }});\n\n    // %TypedArray%.prototype.fill (value, start = 0, end = this.length )\n    Object.defineProperty($TypedArray$.prototype, \'fill\', {value: function(value) {\n      var start = arguments[1],\n          end = arguments[2];\n\n      var o = ToObject(this);\n      var lenVal = o.length;\n      var len = ToUint32(lenVal);\n      len = max(len, 0);\n      var relativeStart = ToInt32(start);\n      var k;\n      if (relativeStart < 0)\n        k = max((len + relativeStart), 0);\n      else\n        k = min(relativeStart, len);\n      var relativeEnd;\n      if (end === undefined)\n        relativeEnd = len;\n      else\n        relativeEnd = ToInt32(end);\n      var final;\n      if (relativeEnd < 0)\n        final = max((len + relativeEnd), 0);\n      else\n        final = min(relativeEnd, len);\n      while (k < final) {\n        o._setter(k, value);\n        k += 1;\n      }\n      return o;\n    }});\n\n    // %TypedArray%.prototype.filter ( callbackfn, thisArg = undefined )\n    Object.defineProperty($TypedArray$.prototype, \'filter\', {value: function(callbackfn) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (!IsCallable(callbackfn)) throw TypeError();\n      var res = [];\n      var thisp = arguments[1];\n      for (var i = 0; i < len; i++) {\n        var val = t._getter(i); // in case fun mutates this\n        if (callbackfn.call(thisp, val, i, t))\n          res.push(val);\n      }\n      return new this.constructor(res);\n    }});\n\n    // %TypedArray%.prototype.find (predicate, thisArg = undefined)\n    Object.defineProperty($TypedArray$.prototype, \'find\', {value: function(predicate) {\n      var o = ToObject(this);\n      var lenValue = o.length;\n      var len = ToUint32(lenValue);\n      if (!IsCallable(predicate)) throw TypeError();\n      var t = arguments.length > 1 ? arguments[1] : undefined;\n      var k = 0;\n      while (k < len) {\n        var kValue = o._getter(k);\n        var testResult = predicate.call(t, kValue, k, o);\n        if (Boolean(testResult))\n          return kValue;\n        ++k;\n      }\n      return undefined;\n    }});\n\n    // %TypedArray%.prototype.findIndex ( predicate, thisArg = undefined )\n    Object.defineProperty($TypedArray$.prototype, \'findIndex\', {value: function(predicate) {\n      var o = ToObject(this);\n      var lenValue = o.length;\n      var len = ToUint32(lenValue);\n      if (!IsCallable(predicate)) throw TypeError();\n      var t = arguments.length > 1 ? arguments[1] : undefined;\n      var k = 0;\n      while (k < len) {\n        var kValue = o._getter(k);\n        var testResult = predicate.call(t, kValue, k, o);\n        if (Boolean(testResult))\n          return k;\n        ++k;\n      }\n      return -1;\n    }});\n\n    // %TypedArray%.prototype.forEach ( callbackfn, thisArg = undefined )\n    Object.defineProperty($TypedArray$.prototype, \'forEach\', {value: function(callbackfn) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (!IsCallable(callbackfn)) throw TypeError();\n      var thisp = arguments[1];\n      for (var i = 0; i < len; i++)\n        callbackfn.call(thisp, t._getter(i), i, t);\n    }});\n\n    // %TypedArray%.prototype.indexOf (searchElement, fromIndex = 0 )\n    Object.defineProperty($TypedArray$.prototype, \'indexOf\', {value: function(searchElement) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (len === 0) return -1;\n      var n = 0;\n      if (arguments.length > 0) {\n        n = Number(arguments[1]);\n        if (n !== n) {\n          n = 0;\n        } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {\n          n = (n > 0 || -1) * floor(abs(n));\n        }\n      }\n      if (n >= len) return -1;\n      var k = n >= 0 ? n : max(len - abs(n), 0);\n      for (; k < len; k++) {\n        if (t._getter(k) === searchElement) {\n          return k;\n        }\n      }\n      return -1;\n    }});\n\n    // %TypedArray%.prototype.join ( separator )\n    Object.defineProperty($TypedArray$.prototype, \'join\', {value: function(separator) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      var tmp = Array(len);\n      for (var i = 0; i < len; ++i)\n        tmp[i] = t._getter(i);\n      return tmp.join(separator === undefined ? \',\' : separator); // Hack for IE7\n    }});\n\n    // %TypedArray%.prototype.keys ( )\n    // -- defined in es6.js to shim browsers w/ native TypedArrays\n\n    // %TypedArray%.prototype.lastIndexOf ( searchElement, fromIndex = this.length-1 )\n    Object.defineProperty($TypedArray$.prototype, \'lastIndexOf\', {value: function(searchElement) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (len === 0) return -1;\n      var n = len;\n      if (arguments.length > 1) {\n        n = Number(arguments[1]);\n        if (n !== n) {\n          n = 0;\n        } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {\n          n = (n > 0 || -1) * floor(abs(n));\n        }\n      }\n      var k = n >= 0 ? min(n, len - 1) : len - abs(n);\n      for (; k >= 0; k--) {\n        if (t._getter(k) === searchElement)\n          return k;\n      }\n      return -1;\n    }});\n\n    // get %TypedArray%.prototype.length\n    // -- applied directly to the object in the constructor\n\n    // %TypedArray%.prototype.map ( callbackfn, thisArg = undefined )\n    Object.defineProperty($TypedArray$.prototype, \'map\', {value: function(callbackfn) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (!IsCallable(callbackfn)) throw TypeError();\n      var res = []; res.length = len;\n      var thisp = arguments[1];\n      for (var i = 0; i < len; i++)\n        res[i] = callbackfn.call(thisp, t._getter(i), i, t);\n      return new this.constructor(res);\n    }});\n\n    // %TypedArray%.prototype.reduce ( callbackfn [, initialValue] )\n    Object.defineProperty($TypedArray$.prototype, \'reduce\', {value: function(callbackfn) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (!IsCallable(callbackfn)) throw TypeError();\n      // no value to return if no initial value and an empty array\n      if (len === 0 && arguments.length === 1) throw TypeError();\n      var k = 0;\n      var accumulator;\n      if (arguments.length >= 2) {\n        accumulator = arguments[1];\n      } else {\n        accumulator = t._getter(k++);\n      }\n      while (k < len) {\n        accumulator = callbackfn.call(undefined, accumulator, t._getter(k), k, t);\n        k++;\n      }\n      return accumulator;\n    }});\n\n    // %TypedArray%.prototype.reduceRight ( callbackfn [, initialValue] )\n    Object.defineProperty($TypedArray$.prototype, \'reduceRight\', {value: function(callbackfn) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (!IsCallable(callbackfn)) throw TypeError();\n      // no value to return if no initial value, empty array\n      if (len === 0 && arguments.length === 1) throw TypeError();\n      var k = len - 1;\n      var accumulator;\n      if (arguments.length >= 2) {\n        accumulator = arguments[1];\n      } else {\n        accumulator = t._getter(k--);\n      }\n      while (k >= 0) {\n        accumulator = callbackfn.call(undefined, accumulator, t._getter(k), k, t);\n        k--;\n      }\n      return accumulator;\n    }});\n\n    // %TypedArray%.prototype.reverse ( )\n    Object.defineProperty($TypedArray$.prototype, \'reverse\', {value: function() {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      var half = floor(len / 2);\n      for (var i = 0, j = len - 1; i < half; ++i, --j) {\n        var tmp = t._getter(i);\n        t._setter(i, t._getter(j));\n        t._setter(j, tmp);\n      }\n      return t;\n    }});\n\n    // %TypedArray%.prototype.set(array, offset = 0 )\n    // %TypedArray%.prototype.set(typedArray, offset = 0 )\n    // WebIDL: void set(TypedArray array, optional unsigned long offset);\n    // WebIDL: void set(sequence<type> array, optional unsigned long offset);\n    Object.defineProperty($TypedArray$.prototype, \'set\', {value: function(index, value) {\n      if (arguments.length < 1) throw SyntaxError(\'Not enough arguments\');\n      var array, sequence, offset, len,\n          i, s, d,\n          byteOffset, byteLength, tmp;\n\n      if (typeof arguments[0] === \'object\' && arguments[0].constructor === this.constructor) {\n        // void set(TypedArray array, optional unsigned long offset);\n        array = arguments[0];\n        offset = ToUint32(arguments[1]);\n\n        if (offset + array.length > this.length) {\n          throw RangeError(\'Offset plus length of array is out of range\');\n        }\n\n        byteOffset = this.byteOffset + offset * this.BYTES_PER_ELEMENT;\n        byteLength = array.length * this.BYTES_PER_ELEMENT;\n\n        if (array.buffer === this.buffer) {\n          tmp = [];\n          for (i = 0, s = array.byteOffset; i < byteLength; i += 1, s += 1) {\n            tmp[i] = array.buffer._bytes[s];\n          }\n          for (i = 0, d = byteOffset; i < byteLength; i += 1, d += 1) {\n            this.buffer._bytes[d] = tmp[i];\n          }\n        } else {\n          for (i = 0, s = array.byteOffset, d = byteOffset;\n               i < byteLength; i += 1, s += 1, d += 1) {\n            this.buffer._bytes[d] = array.buffer._bytes[s];\n          }\n        }\n      } else if (typeof arguments[0] === \'object\' && typeof arguments[0].length !== \'undefined\') {\n        // void set(sequence<type> array, optional unsigned long offset);\n        sequence = arguments[0];\n        len = ToUint32(sequence.length);\n        offset = ToUint32(arguments[1]);\n\n        if (offset + len > this.length) {\n          throw RangeError(\'Offset plus length of array is out of range\');\n        }\n\n        for (i = 0; i < len; i += 1) {\n          s = sequence[i];\n          this._setter(offset + i, Number(s));\n        }\n      } else {\n        throw TypeError(\'Unexpected argument type(s)\');\n      }\n    }});\n\n    // %TypedArray%.prototype.slice ( start, end )\n    Object.defineProperty($TypedArray$.prototype, \'slice\', {value: function(start, end) {\n      var o = ToObject(this);\n      var lenVal = o.length;\n      var len = ToUint32(lenVal);\n      var relativeStart = ToInt32(start);\n      var k = (relativeStart < 0) ? max(len + relativeStart, 0) : min(relativeStart, len);\n      var relativeEnd = (end === undefined) ? len : ToInt32(end);\n      var final = (relativeEnd < 0) ? max(len + relativeEnd, 0) : min(relativeEnd, len);\n      var count = final - k;\n      var c = o.constructor;\n      var a = new c(count);\n      var n = 0;\n      while (k < final) {\n        var kValue = o._getter(k);\n        a._setter(n, kValue);\n        ++k;\n        ++n;\n      }\n      return a;\n    }});\n\n    // %TypedArray%.prototype.some ( callbackfn, thisArg = undefined )\n    Object.defineProperty($TypedArray$.prototype, \'some\', {value: function(callbackfn) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      if (!IsCallable(callbackfn)) throw TypeError();\n      var thisp = arguments[1];\n      for (var i = 0; i < len; i++) {\n        if (callbackfn.call(thisp, t._getter(i), i, t)) {\n          return true;\n        }\n      }\n      return false;\n    }});\n\n    // %TypedArray%.prototype.sort ( comparefn )\n    Object.defineProperty($TypedArray$.prototype, \'sort\', {value: function(comparefn) {\n      if (this === undefined || this === null) throw TypeError();\n      var t = Object(this);\n      var len = ToUint32(t.length);\n      var tmp = Array(len);\n      for (var i = 0; i < len; ++i)\n        tmp[i] = t._getter(i);\n      if (comparefn) tmp.sort(comparefn); else tmp.sort(); // Hack for IE8/9\n      for (i = 0; i < len; ++i)\n        t._setter(i, tmp[i]);\n      return t;\n    }});\n\n    // %TypedArray%.prototype.subarray(begin = 0, end = this.length )\n    // WebIDL: TypedArray subarray(long begin, optional long end);\n    Object.defineProperty($TypedArray$.prototype, \'subarray\', {value: function(start, end) {\n      function clamp(v, min, max) { return v < min ? min : v > max ? max : v; }\n\n      start = ToInt32(start);\n      end = ToInt32(end);\n\n      if (arguments.length < 1) { start = 0; }\n      if (arguments.length < 2) { end = this.length; }\n\n      if (start < 0) { start = this.length + start; }\n      if (end < 0) { end = this.length + end; }\n\n      start = clamp(start, 0, this.length);\n      end = clamp(end, 0, this.length);\n\n      var len = end - start;\n      if (len < 0) {\n        len = 0;\n      }\n\n      return new this.constructor(\n        this.buffer, this.byteOffset + start * this.BYTES_PER_ELEMENT, len);\n    }});\n\n    // %TypedArray%.prototype.toLocaleString ( )\n    // %TypedArray%.prototype.toString ( )\n    // %TypedArray%.prototype.values ( )\n    // %TypedArray%.prototype [ @@iterator ] ( )\n    // get %TypedArray%.prototype [ @@toStringTag ]\n    // -- defined in es6.js to shim browsers w/ native TypedArrays\n\n    function makeTypedArray(elementSize, pack, unpack) {\n      // Each TypedArray type requires a distinct constructor instance with\n      // identical logic, which this produces.\n      var TypedArray = function() {\n        Object.defineProperty(this, \'constructor\', {value: TypedArray});\n        $TypedArray$.apply(this, arguments);\n        makeArrayAccessors(this);\n      };\n      if (\'__proto__\' in TypedArray) {\n        TypedArray.__proto__ = $TypedArray$;\n      } else {\n        TypedArray.from = $TypedArray$.from;\n        TypedArray.of = $TypedArray$.of;\n      }\n\n      TypedArray.BYTES_PER_ELEMENT = elementSize;\n\n      var TypedArrayPrototype = function() {};\n      TypedArrayPrototype.prototype = $TypedArrayPrototype$;\n\n      TypedArray.prototype = new TypedArrayPrototype();\n\n      Object.defineProperty(TypedArray.prototype, \'BYTES_PER_ELEMENT\', {value: elementSize});\n      Object.defineProperty(TypedArray.prototype, \'_pack\', {value: pack});\n      Object.defineProperty(TypedArray.prototype, \'_unpack\', {value: unpack});\n\n      return TypedArray;\n    }\n\n    var Int8Array = makeTypedArray(1, packI8, unpackI8);\n    var Uint8Array = makeTypedArray(1, packU8, unpackU8);\n    var Uint8ClampedArray = makeTypedArray(1, packU8Clamped, unpackU8);\n    var Int16Array = makeTypedArray(2, packI16, unpackI16);\n    var Uint16Array = makeTypedArray(2, packU16, unpackU16);\n    var Int32Array = makeTypedArray(4, packI32, unpackI32);\n    var Uint32Array = makeTypedArray(4, packU32, unpackU32);\n    var Float32Array = makeTypedArray(4, packF32, unpackF32);\n    var Float64Array = makeTypedArray(8, packF64, unpackF64);\n\n    global.Int8Array = global.Int8Array || Int8Array;\n    global.Uint8Array = global.Uint8Array || Uint8Array;\n    global.Uint8ClampedArray = global.Uint8ClampedArray || Uint8ClampedArray;\n    global.Int16Array = global.Int16Array || Int16Array;\n    global.Uint16Array = global.Uint16Array || Uint16Array;\n    global.Int32Array = global.Int32Array || Int32Array;\n    global.Uint32Array = global.Uint32Array || Uint32Array;\n    global.Float32Array = global.Float32Array || Float32Array;\n    global.Float64Array = global.Float64Array || Float64Array;\n  }());\n\n  //\n  // 6 The DataView View Type\n  //\n\n  (function() {\n    function r(array, index) {\n      return IsCallable(array.get) ? array.get(index) : array[index];\n    }\n\n    var IS_BIG_ENDIAN = (function() {\n      var u16array = new Uint16Array([0x1234]),\n          u8array = new Uint8Array(u16array.buffer);\n      return r(u8array, 0) === 0x12;\n    }());\n\n    // DataView(buffer, byteOffset=0, byteLength=undefined)\n    // WebIDL: Constructor(ArrayBuffer buffer,\n    //                     optional unsigned long byteOffset,\n    //                     optional unsigned long byteLength)\n    function DataView(buffer, byteOffset, byteLength) {\n      if (!(buffer instanceof ArrayBuffer || Class(buffer) === \'ArrayBuffer\')) throw TypeError();\n\n      byteOffset = ToUint32(byteOffset);\n      if (byteOffset > buffer.byteLength)\n        throw RangeError(\'byteOffset out of range\');\n\n      if (byteLength === undefined)\n        byteLength = buffer.byteLength - byteOffset;\n      else\n        byteLength = ToUint32(byteLength);\n\n      if ((byteOffset + byteLength) > buffer.byteLength)\n        throw RangeError(\'byteOffset and length reference an area beyond the end of the buffer\');\n\n      Object.defineProperty(this, \'buffer\', {value: buffer});\n      Object.defineProperty(this, \'byteLength\', {value: byteLength});\n      Object.defineProperty(this, \'byteOffset\', {value: byteOffset});\n    };\n\n    // get DataView.prototype.buffer\n    // get DataView.prototype.byteLength\n    // get DataView.prototype.byteOffset\n    // -- applied directly to instances by the constructor\n\n    function makeGetter(arrayType) {\n      return function GetViewValue(byteOffset, littleEndian) {\n        byteOffset = ToUint32(byteOffset);\n\n        if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength)\n          throw RangeError(\'Array index out of range\');\n\n        byteOffset += this.byteOffset;\n\n        var uint8Array = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT),\n            bytes = [];\n        for (var i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1)\n          bytes.push(r(uint8Array, i));\n\n        if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN))\n          bytes.reverse();\n\n        return r(new arrayType(new Uint8Array(bytes).buffer), 0);\n      };\n    }\n\n    Object.defineProperty(DataView.prototype, \'getUint8\', {value: makeGetter(Uint8Array)});\n    Object.defineProperty(DataView.prototype, \'getInt8\', {value: makeGetter(Int8Array)});\n    Object.defineProperty(DataView.prototype, \'getUint16\', {value: makeGetter(Uint16Array)});\n    Object.defineProperty(DataView.prototype, \'getInt16\', {value: makeGetter(Int16Array)});\n    Object.defineProperty(DataView.prototype, \'getUint32\', {value: makeGetter(Uint32Array)});\n    Object.defineProperty(DataView.prototype, \'getInt32\', {value: makeGetter(Int32Array)});\n    Object.defineProperty(DataView.prototype, \'getFloat32\', {value: makeGetter(Float32Array)});\n    Object.defineProperty(DataView.prototype, \'getFloat64\', {value: makeGetter(Float64Array)});\n\n    function makeSetter(arrayType) {\n      return function SetViewValue(byteOffset, value, littleEndian) {\n        byteOffset = ToUint32(byteOffset);\n        if (byteOffset + arrayType.BYTES_PER_ELEMENT > this.byteLength)\n          throw RangeError(\'Array index out of range\');\n\n        // Get bytes\n        var typeArray = new arrayType([value]),\n            byteArray = new Uint8Array(typeArray.buffer),\n            bytes = [], i, byteView;\n\n        for (i = 0; i < arrayType.BYTES_PER_ELEMENT; i += 1)\n          bytes.push(r(byteArray, i));\n\n        // Flip if necessary\n        if (Boolean(littleEndian) === Boolean(IS_BIG_ENDIAN))\n          bytes.reverse();\n\n        // Write them\n        byteView = new Uint8Array(this.buffer, byteOffset, arrayType.BYTES_PER_ELEMENT);\n        byteView.set(bytes);\n      };\n    }\n\n    Object.defineProperty(DataView.prototype, \'setUint8\', {value: makeSetter(Uint8Array)});\n    Object.defineProperty(DataView.prototype, \'setInt8\', {value: makeSetter(Int8Array)});\n    Object.defineProperty(DataView.prototype, \'setUint16\', {value: makeSetter(Uint16Array)});\n    Object.defineProperty(DataView.prototype, \'setInt16\', {value: makeSetter(Int16Array)});\n    Object.defineProperty(DataView.prototype, \'setUint32\', {value: makeSetter(Uint32Array)});\n    Object.defineProperty(DataView.prototype, \'setInt32\', {value: makeSetter(Int32Array)});\n    Object.defineProperty(DataView.prototype, \'setFloat32\', {value: makeSetter(Float32Array)});\n    Object.defineProperty(DataView.prototype, \'setFloat64\', {value: makeSetter(Float64Array)});\n\n    global.DataView = global.DataView || DataView;\n\n  }());\n\n}(self));\n\n// https://github.com/ttaubert/node-arraybuffer-slice\n// (c) 2014 Tim Taubert <tim@timtaubert.de>\n// arraybuffer-slice may be freely distributed under the MIT license.\n\n(function (undefined) {\n  "use strict";\n\n  function clamp(val, length) {\n    val = (val|0) || 0;\n\n    if (val < 0) {\n      return Math.max(val + length, 0);\n    }\n\n    return Math.min(val, length);\n  }\n\n  if (!ArrayBuffer.prototype.slice) {\n    ArrayBuffer.prototype.slice = function (from, to) {\n      var length = this.byteLength;\n      var begin = clamp(from, length);\n      var end = length;\n\n      if (to !== undefined) {\n        end = clamp(to, length);\n      }\n\n      if (begin > end) {\n        return new ArrayBuffer(0);\n      }\n\n      var num = end - begin;\n      var target = new ArrayBuffer(num);\n      var targetArray = new Uint8Array(target);\n\n      var sourceArray = new Uint8Array(this, begin, num);\n      targetArray.set(sourceArray);\n\n      return target;\n    };\n  }\n})();\n\n// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n// If we\'re in node require encoding-indexes and attach it to the global.\n/**\n * @fileoverview Global |this| required for resolving indexes in node.\n * @suppress {globalThis}\n */\nif (typeof module !== "undefined" && module.exports) {\n  this["encoding-indexes"] =\n    require("./encoding-indexes.js")["encoding-indexes"];\n}\n\n(function(global) {\n  \'use strict\';\n\n  //\n  // Utilities\n  //\n\n  /**\n   * @param {number} a The number to test.\n   * @param {number} min The minimum value in the range, inclusive.\n   * @param {number} max The maximum value in the range, inclusive.\n   * @return {boolean} True if a >= min and a <= max.\n   */\n  function inRange(a, min, max) {\n    return min <= a && a <= max;\n  }\n\n  /**\n   * @param {!Array.<*>} array The array to check.\n   * @param {*} item The item to look for in the array.\n   * @return {boolean} True if the item appears in the array.\n   */\n  function includes(array, item) {\n    return array.indexOf(item) !== -1;\n  }\n\n  var floor = Math.floor;\n\n  /**\n   * @param {*} o\n   * @return {Object}\n   */\n  function ToDictionary(o) {\n    if (o === undefined) return {};\n    if (o === Object(o)) return o;\n    throw TypeError(\'Could not convert argument to dictionary\');\n  }\n\n  /**\n   * @param {string} string Input string of UTF-16 code units.\n   * @return {!Array.<number>} Code points.\n   */\n  function stringToCodePoints(string) {\n    // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n    // 1. Let S be the DOMString value.\n    var s = String(string);\n\n    // 2. Let n be the length of S.\n    var n = s.length;\n\n    // 3. Initialize i to 0.\n    var i = 0;\n\n    // 4. Initialize U to be an empty sequence of Unicode characters.\n    var u = [];\n\n    // 5. While i < n:\n    while (i < n) {\n\n      // 1. Let c be the code unit in S at index i.\n      var c = s.charCodeAt(i);\n\n      // 2. Depending on the value of c:\n\n      // c < 0xD800 or c > 0xDFFF\n      if (c < 0xD800 || c > 0xDFFF) {\n        // Append to U the Unicode character with code point c.\n        u.push(c);\n      }\n\n      // 0xDC00  c  0xDFFF\n      else if (0xDC00 <= c && c <= 0xDFFF) {\n        // Append to U a U+FFFD REPLACEMENT CHARACTER.\n        u.push(0xFFFD);\n      }\n\n      // 0xD800  c  0xDBFF\n      else if (0xD800 <= c && c <= 0xDBFF) {\n        // 1. If i = n1, then append to U a U+FFFD REPLACEMENT\n        // CHARACTER.\n        if (i === n - 1) {\n          u.push(0xFFFD);\n        }\n        // 2. Otherwise, i < n1:\n        else {\n          // 1. Let d be the code unit in S at index i+1.\n          var d = string.charCodeAt(i + 1);\n\n          // 2. If 0xDC00  d  0xDFFF, then:\n          if (0xDC00 <= d && d <= 0xDFFF) {\n            // 1. Let a be c & 0x3FF.\n            var a = c & 0x3FF;\n\n            // 2. Let b be d & 0x3FF.\n            var b = d & 0x3FF;\n\n            // 3. Append to U the Unicode character with code point\n            // 2^16+2^10*a+b.\n            u.push(0x10000 + (a << 10) + b);\n\n            // 4. Set i to i+1.\n            i += 1;\n          }\n\n          // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n          // U+FFFD REPLACEMENT CHARACTER.\n          else  {\n            u.push(0xFFFD);\n          }\n        }\n      }\n\n      // 3. Set i to i+1.\n      i += 1;\n    }\n\n    // 6. Return U.\n    return u;\n  }\n\n  /**\n   * @param {!Array.<number>} code_points Array of code points.\n   * @return {string} string String of UTF-16 code units.\n   */\n  function codePointsToString(code_points) {\n    var s = \'\';\n    for (var i = 0; i < code_points.length; ++i) {\n      var cp = code_points[i];\n      if (cp <= 0xFFFF) {\n        s += String.fromCharCode(cp);\n      } else {\n        cp -= 0x10000;\n        s += String.fromCharCode((cp >> 10) + 0xD800,\n                                 (cp & 0x3FF) + 0xDC00);\n      }\n    }\n    return s;\n  }\n\n\n  //\n  // Implementation of Encoding specification\n  // https://encoding.spec.whatwg.org/\n  //\n\n  //\n  // 4. Terminology\n  //\n\n  /**\n   * An ASCII byte is a byte in the range 0x00 to 0x7F, inclusive.\n   * @param {number} a The number to test.\n   * @return {boolean} True if a is in the range 0x00 to 0x7F, inclusive.\n   */\n  function isASCIIByte(a) {\n    return 0x00 <= a && a <= 0x7F;\n  }\n\n  /**\n   * An ASCII code point is a code point in the range U+0000 to\n   * U+007F, inclusive.\n   */\n  var isASCIICodePoint = isASCIIByte;\n\n\n  /**\n   * End-of-stream is a special token that signifies no more tokens\n   * are in the stream.\n   * @const\n   */ var end_of_stream = -1;\n\n  /**\n   * A stream represents an ordered sequence of tokens.\n   *\n   * @constructor\n   * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide\n   * the stream.\n   */\n  function Stream(tokens) {\n    /** @type {!Array.<number>} */\n    this.tokens = [].slice.call(tokens);\n    // Reversed as push/pop is more efficient than shift/unshift.\n    this.tokens.reverse();\n  }\n\n  Stream.prototype = {\n    /**\n     * @return {boolean} True if end-of-stream has been hit.\n     */\n    endOfStream: function() {\n      return !this.tokens.length;\n    },\n\n    /**\n     * When a token is read from a stream, the first token in the\n     * stream must be returned and subsequently removed, and\n     * end-of-stream must be returned otherwise.\n     *\n     * @return {number} Get the next token from the stream, or\n     * end_of_stream.\n     */\n     read: function() {\n      if (!this.tokens.length)\n        return end_of_stream;\n       return this.tokens.pop();\n     },\n\n    /**\n     * When one or more tokens are prepended to a stream, those tokens\n     * must be inserted, in given order, before the first token in the\n     * stream.\n     *\n     * @param {(number|!Array.<number>)} token The token(s) to prepend to the\n     * stream.\n     */\n    prepend: function(token) {\n      if (Array.isArray(token)) {\n        var tokens = /**@type {!Array.<number>}*/(token);\n        while (tokens.length)\n          this.tokens.push(tokens.pop());\n      } else {\n        this.tokens.push(token);\n      }\n    },\n\n    /**\n     * When one or more tokens are pushed to a stream, those tokens\n     * must be inserted, in given order, after the last token in the\n     * stream.\n     *\n     * @param {(number|!Array.<number>)} token The tokens(s) to push to the\n     * stream.\n     */\n    push: function(token) {\n      if (Array.isArray(token)) {\n        var tokens = /**@type {!Array.<number>}*/(token);\n        while (tokens.length)\n          this.tokens.unshift(tokens.shift());\n      } else {\n        this.tokens.unshift(token);\n      }\n    }\n  };\n\n  //\n  // 5. Encodings\n  //\n\n  // 5.1 Encoders and decoders\n\n  /** @const */\n  var finished = -1;\n\n  /**\n   * @param {boolean} fatal If true, decoding errors raise an exception.\n   * @param {number=} opt_code_point Override the standard fallback code point.\n   * @return {number} The code point to insert on a decoding error.\n   */\n  function decoderError(fatal, opt_code_point) {\n    if (fatal)\n      throw TypeError(\'Decoder error\');\n    return opt_code_point || 0xFFFD;\n  }\n\n  /**\n   * @param {number} code_point The code point that could not be encoded.\n   * @return {number} Always throws, no value is actually returned.\n   */\n  function encoderError(code_point) {\n    throw TypeError(\'The code point \' + code_point + \' could not be encoded.\');\n  }\n\n  /** @interface */\n  function Decoder() {}\n  Decoder.prototype = {\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point, or |finished|.\n     */\n    handler: function(stream, bite) {}\n  };\n\n  /** @interface */\n  function Encoder() {}\n  Encoder.prototype = {\n    /**\n     * @param {Stream} stream The stream of code points being encoded.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n     */\n    handler: function(stream, code_point) {}\n  };\n\n  // 5.2 Names and labels\n\n  // TODO: Define @typedef for Encoding: {name:string,labels:Array.<string>}\n  // https://github.com/google/closure-compiler/issues/247\n\n  /**\n   * @param {string} label The encoding label.\n   * @return {?{name:string,labels:Array.<string>}}\n   */\n  function getEncoding(label) {\n    // 1. Remove any leading and trailing ASCII whitespace from label.\n    label = String(label).trim().toLowerCase();\n\n    // 2. If label is an ASCII case-insensitive match for any of the\n    // labels listed in the table below, return the corresponding\n    // encoding, and failure otherwise.\n    if (Object.prototype.hasOwnProperty.call(label_to_encoding, label)) {\n      return label_to_encoding[label];\n    }\n    return null;\n  }\n\n  /**\n   * Encodings table: https://encoding.spec.whatwg.org/encodings.json\n   * @const\n   * @type {!Array.<{\n   *          heading: string,\n   *          encodings: Array.<{name:string,labels:Array.<string>}>\n   *        }>}\n   */\n  var encodings = [\n    {\n      "encodings": [\n        {\n          "labels": [\n            "unicode-1-1-utf-8",\n            "utf-8",\n            "utf8"\n          ],\n          "name": "UTF-8"\n        }\n      ],\n      "heading": "The Encoding"\n    },\n    {\n      "encodings": [\n        {\n          "labels": [\n            "866",\n            "cp866",\n            "csibm866",\n            "ibm866"\n          ],\n          "name": "IBM866"\n        },\n        {\n          "labels": [\n            "csisolatin2",\n            "iso-8859-2",\n            "iso-ir-101",\n            "iso8859-2",\n            "iso88592",\n            "iso_8859-2",\n            "iso_8859-2:1987",\n            "l2",\n            "latin2"\n          ],\n          "name": "ISO-8859-2"\n        },\n        {\n          "labels": [\n            "csisolatin3",\n            "iso-8859-3",\n            "iso-ir-109",\n            "iso8859-3",\n            "iso88593",\n            "iso_8859-3",\n            "iso_8859-3:1988",\n            "l3",\n            "latin3"\n          ],\n          "name": "ISO-8859-3"\n        },\n        {\n          "labels": [\n            "csisolatin4",\n            "iso-8859-4",\n            "iso-ir-110",\n            "iso8859-4",\n            "iso88594",\n            "iso_8859-4",\n            "iso_8859-4:1988",\n            "l4",\n            "latin4"\n          ],\n          "name": "ISO-8859-4"\n        },\n        {\n          "labels": [\n            "csisolatincyrillic",\n            "cyrillic",\n            "iso-8859-5",\n            "iso-ir-144",\n            "iso8859-5",\n            "iso88595",\n            "iso_8859-5",\n            "iso_8859-5:1988"\n          ],\n          "name": "ISO-8859-5"\n        },\n        {\n          "labels": [\n            "arabic",\n            "asmo-708",\n            "csiso88596e",\n            "csiso88596i",\n            "csisolatinarabic",\n            "ecma-114",\n            "iso-8859-6",\n            "iso-8859-6-e",\n            "iso-8859-6-i",\n            "iso-ir-127",\n            "iso8859-6",\n            "iso88596",\n            "iso_8859-6",\n            "iso_8859-6:1987"\n          ],\n          "name": "ISO-8859-6"\n        },\n        {\n          "labels": [\n            "csisolatingreek",\n            "ecma-118",\n            "elot_928",\n            "greek",\n            "greek8",\n            "iso-8859-7",\n            "iso-ir-126",\n            "iso8859-7",\n            "iso88597",\n            "iso_8859-7",\n            "iso_8859-7:1987",\n            "sun_eu_greek"\n          ],\n          "name": "ISO-8859-7"\n        },\n        {\n          "labels": [\n            "csiso88598e",\n            "csisolatinhebrew",\n            "hebrew",\n            "iso-8859-8",\n            "iso-8859-8-e",\n            "iso-ir-138",\n            "iso8859-8",\n            "iso88598",\n            "iso_8859-8",\n            "iso_8859-8:1988",\n            "visual"\n          ],\n          "name": "ISO-8859-8"\n        },\n        {\n          "labels": [\n            "csiso88598i",\n            "iso-8859-8-i",\n            "logical"\n          ],\n          "name": "ISO-8859-8-I"\n        },\n        {\n          "labels": [\n            "csisolatin6",\n            "iso-8859-10",\n            "iso-ir-157",\n            "iso8859-10",\n            "iso885910",\n            "l6",\n            "latin6"\n          ],\n          "name": "ISO-8859-10"\n        },\n        {\n          "labels": [\n            "iso-8859-13",\n            "iso8859-13",\n            "iso885913"\n          ],\n          "name": "ISO-8859-13"\n        },\n        {\n          "labels": [\n            "iso-8859-14",\n            "iso8859-14",\n            "iso885914"\n          ],\n          "name": "ISO-8859-14"\n        },\n        {\n          "labels": [\n            "csisolatin9",\n            "iso-8859-15",\n            "iso8859-15",\n            "iso885915",\n            "iso_8859-15",\n            "l9"\n          ],\n          "name": "ISO-8859-15"\n        },\n        {\n          "labels": [\n            "iso-8859-16"\n          ],\n          "name": "ISO-8859-16"\n        },\n        {\n          "labels": [\n            "cskoi8r",\n            "koi",\n            "koi8",\n            "koi8-r",\n            "koi8_r"\n          ],\n          "name": "KOI8-R"\n        },\n        {\n          "labels": [\n            "koi8-ru",\n            "koi8-u"\n          ],\n          "name": "KOI8-U"\n        },\n        {\n          "labels": [\n            "csmacintosh",\n            "mac",\n            "macintosh",\n            "x-mac-roman"\n          ],\n          "name": "macintosh"\n        },\n        {\n          "labels": [\n            "dos-874",\n            "iso-8859-11",\n            "iso8859-11",\n            "iso885911",\n            "tis-620",\n            "windows-874"\n          ],\n          "name": "windows-874"\n        },\n        {\n          "labels": [\n            "cp1250",\n            "windows-1250",\n            "x-cp1250"\n          ],\n          "name": "windows-1250"\n        },\n        {\n          "labels": [\n            "cp1251",\n            "windows-1251",\n            "x-cp1251"\n          ],\n          "name": "windows-1251"\n        },\n        {\n          "labels": [\n            "ansi_x3.4-1968",\n            "ascii",\n            "cp1252",\n            "cp819",\n            "csisolatin1",\n            "ibm819",\n            "iso-8859-1",\n            "iso-ir-100",\n            "iso8859-1",\n            "iso88591",\n            "iso_8859-1",\n            "iso_8859-1:1987",\n            "l1",\n            "latin1",\n            "us-ascii",\n            "windows-1252",\n            "x-cp1252"\n          ],\n          "name": "windows-1252"\n        },\n        {\n          "labels": [\n            "cp1253",\n            "windows-1253",\n            "x-cp1253"\n          ],\n          "name": "windows-1253"\n        },\n        {\n          "labels": [\n            "cp1254",\n            "csisolatin5",\n            "iso-8859-9",\n            "iso-ir-148",\n            "iso8859-9",\n            "iso88599",\n            "iso_8859-9",\n            "iso_8859-9:1989",\n            "l5",\n            "latin5",\n            "windows-1254",\n            "x-cp1254"\n          ],\n          "name": "windows-1254"\n        },\n        {\n          "labels": [\n            "cp1255",\n            "windows-1255",\n            "x-cp1255"\n          ],\n          "name": "windows-1255"\n        },\n        {\n          "labels": [\n            "cp1256",\n            "windows-1256",\n            "x-cp1256"\n          ],\n          "name": "windows-1256"\n        },\n        {\n          "labels": [\n            "cp1257",\n            "windows-1257",\n            "x-cp1257"\n          ],\n          "name": "windows-1257"\n        },\n        {\n          "labels": [\n            "cp1258",\n            "windows-1258",\n            "x-cp1258"\n          ],\n          "name": "windows-1258"\n        },\n        {\n          "labels": [\n            "x-mac-cyrillic",\n            "x-mac-ukrainian"\n          ],\n          "name": "x-mac-cyrillic"\n        }\n      ],\n      "heading": "Legacy single-byte encodings"\n    },\n    {\n      "encodings": [\n        {\n          "labels": [\n            "chinese",\n            "csgb2312",\n            "csiso58gb231280",\n            "gb2312",\n            "gb_2312",\n            "gb_2312-80",\n            "gbk",\n            "iso-ir-58",\n            "x-gbk"\n          ],\n          "name": "GBK"\n        },\n        {\n          "labels": [\n            "gb18030"\n          ],\n          "name": "gb18030"\n        }\n      ],\n      "heading": "Legacy multi-byte Chinese (simplified) encodings"\n    },\n    {\n      "encodings": [\n        {\n          "labels": [\n            "big5",\n            "big5-hkscs",\n            "cn-big5",\n            "csbig5",\n            "x-x-big5"\n          ],\n          "name": "Big5"\n        }\n      ],\n      "heading": "Legacy multi-byte Chinese (traditional) encodings"\n    },\n    {\n      "encodings": [\n        {\n          "labels": [\n            "cseucpkdfmtjapanese",\n            "euc-jp",\n            "x-euc-jp"\n          ],\n          "name": "EUC-JP"\n        },\n        {\n          "labels": [\n            "csiso2022jp",\n            "iso-2022-jp"\n          ],\n          "name": "ISO-2022-JP"\n        },\n        {\n          "labels": [\n            "csshiftjis",\n            "ms932",\n            "ms_kanji",\n            "shift-jis",\n            "shift_jis",\n            "sjis",\n            "windows-31j",\n            "x-sjis"\n          ],\n          "name": "Shift_JIS"\n        }\n      ],\n      "heading": "Legacy multi-byte Japanese encodings"\n    },\n    {\n      "encodings": [\n        {\n          "labels": [\n            "cseuckr",\n            "csksc56011987",\n            "euc-kr",\n            "iso-ir-149",\n            "korean",\n            "ks_c_5601-1987",\n            "ks_c_5601-1989",\n            "ksc5601",\n            "ksc_5601",\n            "windows-949"\n          ],\n          "name": "EUC-KR"\n        }\n      ],\n      "heading": "Legacy multi-byte Korean encodings"\n    },\n    {\n      "encodings": [\n        {\n          "labels": [\n            "csiso2022kr",\n            "hz-gb-2312",\n            "iso-2022-cn",\n            "iso-2022-cn-ext",\n            "iso-2022-kr"\n          ],\n          "name": "replacement"\n        },\n        {\n          "labels": [\n            "utf-16be"\n          ],\n          "name": "UTF-16BE"\n        },\n        {\n          "labels": [\n            "utf-16",\n            "utf-16le"\n          ],\n          "name": "UTF-16LE"\n        },\n        {\n          "labels": [\n            "x-user-defined"\n          ],\n          "name": "x-user-defined"\n        }\n      ],\n      "heading": "Legacy miscellaneous encodings"\n    }\n  ];\n\n  // Label to encoding registry.\n  /** @type {Object.<string,{name:string,labels:Array.<string>}>} */\n  var label_to_encoding = {};\n  encodings.forEach(function(category) {\n    category.encodings.forEach(function(encoding) {\n      encoding.labels.forEach(function(label) {\n        label_to_encoding[label] = encoding;\n      });\n    });\n  });\n\n  // Registry of of encoder/decoder factories, by encoding name.\n  /** @type {Object.<string, function({fatal:boolean}): Encoder>} */\n  var encoders = {};\n  /** @type {Object.<string, function({fatal:boolean}): Decoder>} */\n  var decoders = {};\n\n  //\n  // 6. Indexes\n  //\n\n  /**\n   * @param {number} pointer The |pointer| to search for.\n   * @param {(!Array.<?number>|undefined)} index The |index| to search within.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in |index|.\n   */\n  function indexCodePointFor(pointer, index) {\n    if (!index) return null;\n    return index[pointer] || null;\n  }\n\n  /**\n   * @param {number} code_point The |code point| to search for.\n   * @param {!Array.<?number>} index The |index| to search within.\n   * @return {?number} The first pointer corresponding to |code point| in\n   *     |index|, or null if |code point| is not in |index|.\n   */\n  function indexPointerFor(code_point, index) {\n    var pointer = index.indexOf(code_point);\n    return pointer === -1 ? null : pointer;\n  }\n\n  /**\n   * @param {string} name Name of the index.\n   * @return {(!Array.<number>|!Array.<Array.<number>>)}\n   *  */\n  function index(name) {\n    if (!(\'encoding-indexes\' in global)) {\n      throw Error("Indexes missing." +\n                  " Did you forget to include encoding-indexes.js?");\n    }\n    return global[\'encoding-indexes\'][name];\n  }\n\n  /**\n   * @param {number} pointer The |pointer| to search for in the gb18030 index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the gb18030 index.\n   */\n  function indexGB18030RangesCodePointFor(pointer) {\n    // 1. If pointer is greater than 39419 and less than 189000, or\n    // pointer is greater than 1237575, return null.\n    if ((pointer > 39419 && pointer < 189000) || (pointer > 1237575))\n      return null;\n\n    // 2. If pointer is 7457, return code point U+E7C7.\n    if (pointer === 7457) return 0xE7C7;\n\n    // 3. Let offset be the last pointer in index gb18030 ranges that\n    // is equal to or less than pointer and let code point offset be\n    // its corresponding code point.\n    var offset = 0;\n    var code_point_offset = 0;\n    var idx = index(\'gb18030\');\n    var i;\n    for (i = 0; i < idx.length; ++i) {\n      /** @type {!Array.<number>} */\n      var entry = idx[i];\n      if (entry[0] <= pointer) {\n        offset = entry[0];\n        code_point_offset = entry[1];\n      } else {\n        break;\n      }\n    }\n\n    // 4. Return a code point whose value is code point offset +\n    // pointer  offset.\n    return code_point_offset + pointer - offset;\n  }\n\n  /**\n   * @param {number} code_point The |code point| to locate in the gb18030 index.\n   * @return {number} The first pointer corresponding to |code point| in the\n   *     gb18030 index.\n   */\n  function indexGB18030RangesPointerFor(code_point) {\n    // 1. If code point is U+E7C7, return pointer 7457.\n    if (code_point === 0xE7C7) return 7457;\n\n    // 2. Let offset be the last code point in index gb18030 ranges\n    // that is equal to or less than code point and let pointer offset\n    // be its corresponding pointer.\n    var offset = 0;\n    var pointer_offset = 0;\n    var idx = index(\'gb18030\');\n    var i;\n    for (i = 0; i < idx.length; ++i) {\n      /** @type {!Array.<number>} */\n      var entry = idx[i];\n      if (entry[1] <= code_point) {\n        offset = entry[1];\n        pointer_offset = entry[0];\n      } else {\n        break;\n      }\n    }\n\n    // 3. Return a pointer whose value is pointer offset + code point\n    //  offset.\n    return pointer_offset + code_point - offset;\n  }\n\n  /**\n   * @param {number} code_point The |code_point| to search for in the shift_jis\n   *     index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the shift_jis index.\n   */\n  function indexShiftJISPointerFor(code_point) {\n    // 1. Let index be index jis0208 excluding all pointers in the\n    // range 8272 to 8835.\n    var pointer = indexPointerFor(code_point, index(\'jis0208\'));\n    if (pointer === null || inRange(pointer, 8272, 8835))\n      return null;\n\n    // 2. Return the index pointer for code point in index.\n    return pointer;\n  }\n\n  /**\n   * @param {number} code_point The |code_point| to search for in the big5\n   *     index.\n   * @return {?number} The code point corresponding to |pointer| in |index|,\n   *     or null if |code point| is not in the big5 index.\n   */\n  function indexBig5PointerFor(code_point) {\n\n    // 1. Let index be index big5.\n    var index_ = index(\'big5\');\n\n    // 2. If code point is U+2550, U+255E, U+2561, U+256A, U+5341, or\n    // U+5345, return the last pointer corresponding to code point in\n    // index.\n    if (code_point === 0x2550 || code_point === 0x255E ||\n        code_point === 0x2561 || code_point === 0x256A ||\n        code_point === 0x5341 || code_point === 0x5345) {\n      return index_.lastIndexOf(code_point);\n    }\n\n    // 3. Return the index pointer for code point in index.\n    return indexPointerFor(code_point, index_);\n  }\n\n  //\n  // 8. API\n  //\n\n  /** @const */ var DEFAULT_ENCODING = \'utf-8\';\n\n  // 8.1 Interface TextDecoder\n\n  /**\n   * @constructor\n   * @param {string=} label The label of the encoding;\n   *     defaults to \'utf-8\'.\n   * @param {Object=} options\n   */\n  function TextDecoder(label, options) {\n    // Web IDL conventions\n    if (!(this instanceof TextDecoder))\n      throw TypeError(\'Called as a function. Did you forget \\\'new\\\'?\');\n    label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n    options = ToDictionary(options);\n\n    // A TextDecoder object has an associated encoding, decoder,\n    // stream, ignore BOM flag (initially unset), BOM seen flag\n    // (initially unset), error mode (initially replacement), and do\n    // not flush flag (initially unset).\n\n    /** @private */\n    this._encoding = null;\n    /** @private @type {?Decoder} */\n    this._decoder = null;\n    /** @private @type {boolean} */\n    this._ignoreBOM = false;\n    /** @private @type {boolean} */\n    this._BOMseen = false;\n    /** @private @type {string} */\n    this._error_mode = \'replacement\';\n    /** @private @type {boolean} */\n    this._do_not_flush = false;\n\n\n    // 1. Let encoding be the result of getting an encoding from\n    // label.\n    var encoding = getEncoding(label);\n\n    // 2. If encoding is failure or replacement, throw a RangeError.\n    if (encoding === null || encoding.name === \'replacement\')\n      throw RangeError(\'Unknown encoding: \' + label);\n    if (!decoders[encoding.name]) {\n      throw Error(\'Decoder not present.\' +\n                  \' Did you forget to include encoding-indexes.js?\');\n    }\n\n    // 3. Let dec be a new TextDecoder object.\n    var dec = this;\n\n    // 4. Set dec\'s encoding to encoding.\n    dec._encoding = encoding;\n\n    // 5. If options\'s fatal member is true, set dec\'s error mode to\n    // fatal.\n    if (Boolean(options[\'fatal\']))\n      dec._error_mode = \'fatal\';\n\n    // 6. If options\'s ignoreBOM member is true, set dec\'s ignore BOM\n    // flag.\n    if (Boolean(options[\'ignoreBOM\']))\n      dec._ignoreBOM = true;\n\n    // For pre-ES5 runtimes:\n    if (!Object.defineProperty) {\n      this.encoding = dec._encoding.name.toLowerCase();\n      this.fatal = dec._error_mode === \'fatal\';\n      this.ignoreBOM = dec._ignoreBOM;\n    }\n\n    // 7. Return dec.\n    return dec;\n  }\n\n  if (Object.defineProperty) {\n    // The encoding attribute\'s getter must return encoding\'s name.\n    Object.defineProperty(TextDecoder.prototype, \'encoding\', {\n      /** @this {TextDecoder} */\n      get: function() { return this._encoding.name.toLowerCase(); }\n    });\n\n    // The fatal attribute\'s getter must return true if error mode\n    // is fatal, and false otherwise.\n    Object.defineProperty(TextDecoder.prototype, \'fatal\', {\n      /** @this {TextDecoder} */\n      get: function() { return this._error_mode === \'fatal\'; }\n    });\n\n    // The ignoreBOM attribute\'s getter must return true if ignore\n    // BOM flag is set, and false otherwise.\n    Object.defineProperty(TextDecoder.prototype, \'ignoreBOM\', {\n      /** @this {TextDecoder} */\n      get: function() { return this._ignoreBOM; }\n    });\n  }\n\n  /**\n   * @param {BufferSource=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n  TextDecoder.prototype.decode = function decode(input, options) {\n    var bytes;\n    if (typeof input === \'object\' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === \'object\' && \'buffer\' in input &&\n               input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer,\n                             input.byteOffset,\n                             input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n\n    options = ToDictionary(options);\n\n    // 1. If the do not flush flag is unset, set decoder to a new\n    // encoding\'s decoder, set stream to a new stream, and unset the\n    // BOM seen flag.\n    if (!this._do_not_flush) {\n      this._decoder = decoders[this._encoding.name]({\n        fatal: this._error_mode === \'fatal\'});\n      this._BOMseen = false;\n    }\n\n    // 2. If options\'s stream is true, set the do not flush flag, and\n    // unset the do not flush flag otherwise.\n    this._do_not_flush = Boolean(options[\'stream\']);\n\n    // 3. If input is given, push a copy of input to stream.\n    // TODO: Align with spec algorithm - maintain stream on instance.\n    var input_stream = new Stream(bytes);\n\n    // 4. Let output be a new stream.\n    var output = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n\n    // 5. While true:\n    while (true) {\n      // 1. Let token be the result of reading from stream.\n      var token = input_stream.read();\n\n      // 2. If token is end-of-stream and the do not flush flag is\n      // set, return output, serialized.\n      // TODO: Align with spec algorithm.\n      if (token === end_of_stream)\n        break;\n\n      // 3. Otherwise, run these subsubsteps:\n\n      // 1. Let result be the result of processing token for decoder,\n      // stream, output, and error mode.\n      result = this._decoder.handler(input_stream, token);\n\n      // 2. If result is finished, return output, serialized.\n      if (result === finished)\n        break;\n\n      if (result !== null) {\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\n        else\n          output.push(result);\n      }\n\n      // 3. Otherwise, if result is error, throw a TypeError.\n      // (Thrown in handler)\n\n      // 4. Otherwise, do nothing.\n    }\n    // TODO: Align with spec algorithm.\n    if (!this._do_not_flush) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (result === null)\n          continue;\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\n        else\n          output.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n\n    // A TextDecoder object also has an associated serialize stream\n    // algorithm...\n    /**\n     * @param {!Array.<number>} stream\n     * @return {string}\n     * @this {TextDecoder}\n     */\n    function serializeStream(stream) {\n      // 1. Let token be the result of reading from stream.\n      // (Done in-place on array, rather than as a stream)\n\n      // 2. If encoding is UTF-8, UTF-16BE, or UTF-16LE, and ignore\n      // BOM flag and BOM seen flag are unset, run these subsubsteps:\n      if (includes([\'UTF-8\', \'UTF-16LE\', \'UTF-16BE\'], this._encoding.name) &&\n          !this._ignoreBOM && !this._BOMseen) {\n        if (stream.length > 0 && stream[0] === 0xFEFF) {\n          // 1. If token is U+FEFF, set BOM seen flag.\n          this._BOMseen = true;\n          stream.shift();\n        } else if (stream.length > 0) {\n          // 2. Otherwise, if token is not end-of-stream, set BOM seen\n          // flag and append token to stream.\n          this._BOMseen = true;\n        } else {\n          // 3. Otherwise, if token is not end-of-stream, append token\n          // to output.\n          // (no-op)\n        }\n      }\n      // 4. Otherwise, return output.\n      return codePointsToString(stream);\n    }\n\n    return serializeStream.call(this, output);\n  };\n\n  // 8.2 Interface TextEncoder\n\n  /**\n   * @constructor\n   * @param {string=} label The label of the encoding. NONSTANDARD.\n   * @param {Object=} options NONSTANDARD.\n   */\n  function TextEncoder(label, options) {\n    // Web IDL conventions\n    if (!(this instanceof TextEncoder))\n      throw TypeError(\'Called as a function. Did you forget \\\'new\\\'?\');\n    options = ToDictionary(options);\n\n    // A TextEncoder object has an associated encoding and encoder.\n\n    /** @private */\n    this._encoding = null;\n    /** @private @type {?Encoder} */\n    this._encoder = null;\n\n    // Non-standard\n    /** @private @type {boolean} */\n    this._do_not_flush = false;\n    /** @private @type {string} */\n    this._fatal = Boolean(options[\'fatal\']) ? \'fatal\' : \'replacement\';\n\n    // 1. Let enc be a new TextEncoder object.\n    var enc = this;\n\n    // 2. Set enc\'s encoding to UTF-8\'s encoder.\n    if (Boolean(options[\'NONSTANDARD_allowLegacyEncoding\'])) {\n      // NONSTANDARD behavior.\n      label = label !== undefined ? String(label) : DEFAULT_ENCODING;\n      var encoding = getEncoding(label);\n      if (encoding === null || encoding.name === \'replacement\')\n        throw RangeError(\'Unknown encoding: \' + label);\n      if (!encoders[encoding.name]) {\n        throw Error(\'Encoder not present.\' +\n                    \' Did you forget to include encoding-indexes.js?\');\n      }\n      enc._encoding = encoding;\n    } else {\n      // Standard behavior.\n      enc._encoding = getEncoding(\'utf-8\');\n\n      if (label !== undefined && \'console\' in global) {\n        console.warn(\'TextEncoder constructor called with encoding label, \'\n                     + \'which is ignored.\');\n      }\n    }\n\n    // For pre-ES5 runtimes:\n    if (!Object.defineProperty)\n      this.encoding = enc._encoding.name.toLowerCase();\n\n    // 3. Return enc.\n    return enc;\n  }\n\n  if (Object.defineProperty) {\n    // The encoding attribute\'s getter must return encoding\'s name.\n    Object.defineProperty(TextEncoder.prototype, \'encoding\', {\n      /** @this {TextEncoder} */\n      get: function() { return this._encoding.name.toLowerCase(); }\n    });\n  }\n\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {!Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n  TextEncoder.prototype.encode = function encode(opt_string, options) {\n    opt_string = opt_string ? String(opt_string) : \'\';\n    options = ToDictionary(options);\n\n    // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful when\n    // the input is a USVString so streaming is not necessary.\n    if (!this._do_not_flush)\n      this._encoder = encoders[this._encoding.name]({\n        fatal: this._fatal === \'fatal\'});\n    this._do_not_flush = Boolean(options[\'stream\']);\n\n    // 1. Convert input to a stream.\n    var input = new Stream(stringToCodePoints(opt_string));\n\n    // 2. Let output be a new stream\n    var output = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n    // 3. While true, run these substeps:\n    while (true) {\n      // 1. Let token be the result of reading from input.\n      var token = input.read();\n      if (token === end_of_stream)\n        break;\n      // 2. Let result be the result of processing token for encoder,\n      // input, output.\n      result = this._encoder.handler(input, token);\n      if (result === finished)\n        break;\n      if (Array.isArray(result))\n        output.push.apply(output, /**@type {!Array.<number>}*/(result));\n      else\n        output.push(result);\n    }\n    // TODO: Align with spec algorithm.\n    if (!this._do_not_flush) {\n      while (true) {\n        result = this._encoder.handler(input, input.read());\n        if (result === finished)\n          break;\n        if (Array.isArray(result))\n          output.push.apply(output, /**@type {!Array.<number>}*/(result));\n        else\n          output.push(result);\n      }\n      this._encoder = null;\n    }\n    // 3. If result is finished, convert output into a byte sequence,\n    // and then return a Uint8Array object wrapping an ArrayBuffer\n    // containing output.\n    return new Uint8Array(output);\n  };\n\n\n  //\n  // 9. The encoding\n  //\n\n  // 9.1 utf-8\n\n  // 9.1.1 utf-8 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function UTF8Decoder(options) {\n    var fatal = options.fatal;\n\n    // utf-8\'s decoder\'s has an associated utf-8 code point, utf-8\n    // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n    // lower boundary (initially 0x80), and a utf-8 upper boundary\n    // (initially 0xBF).\n    var /** @type {number} */ utf8_code_point = 0,\n        /** @type {number} */ utf8_bytes_seen = 0,\n        /** @type {number} */ utf8_bytes_needed = 0,\n        /** @type {number} */ utf8_lower_boundary = 0x80,\n        /** @type {number} */ utf8_upper_boundary = 0xBF;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n      // set utf-8 bytes needed to 0 and return error.\n      if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n        utf8_bytes_needed = 0;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished;\n\n      // 3. If utf-8 bytes needed is 0, based on byte:\n      if (utf8_bytes_needed === 0) {\n\n        // 0x00 to 0x7F\n        if (inRange(bite, 0x00, 0x7F)) {\n          // Return a code point whose value is byte.\n          return bite;\n        }\n\n        // 0xC2 to 0xDF\n        if (inRange(bite, 0xC2, 0xDF)) {\n          // Set utf-8 bytes needed to 1 and utf-8 code point to byte\n          //  0xC0.\n          utf8_bytes_needed = 1;\n          utf8_code_point = bite - 0xC0;\n        }\n\n        // 0xE0 to 0xEF\n        else if (inRange(bite, 0xE0, 0xEF)) {\n          // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n          if (bite === 0xE0)\n            utf8_lower_boundary = 0xA0;\n          // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n          if (bite === 0xED)\n            utf8_upper_boundary = 0x9F;\n          // 3. Set utf-8 bytes needed to 2 and utf-8 code point to\n          // byte  0xE0.\n          utf8_bytes_needed = 2;\n          utf8_code_point = bite - 0xE0;\n        }\n\n        // 0xF0 to 0xF4\n        else if (inRange(bite, 0xF0, 0xF4)) {\n          // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n          if (bite === 0xF0)\n            utf8_lower_boundary = 0x90;\n          // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n          if (bite === 0xF4)\n            utf8_upper_boundary = 0x8F;\n          // 3. Set utf-8 bytes needed to 3 and utf-8 code point to\n          // byte  0xF0.\n          utf8_bytes_needed = 3;\n          utf8_code_point = bite - 0xF0;\n        }\n\n        // Otherwise\n        else {\n          // Return error.\n          return decoderError(fatal);\n        }\n\n        // Then (byte is in the range 0xC2 to 0xF4, inclusive) set\n        // utf-8 code point to utf-8 code point << (6  utf-8 bytes\n        // needed) and return continue.\n        utf8_code_point = utf8_code_point << (6 * utf8_bytes_needed);\n        return null;\n      }\n\n      // 4. If byte is not in the range utf-8 lower boundary to utf-8\n      // upper boundary, inclusive, run these substeps:\n      if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n\n        // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n        // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n        // utf-8 upper boundary to 0xBF.\n        utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n        utf8_lower_boundary = 0x80;\n        utf8_upper_boundary = 0xBF;\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Return error.\n        return decoderError(fatal);\n      }\n\n      // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n      // to 0xBF.\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF;\n\n      // 6. Increase utf-8 bytes seen by one and set utf-8 code point\n      // to utf-8 code point + (byte  0x80) << (6  (utf-8 bytes\n      // needed  utf-8 bytes seen)).\n      utf8_bytes_seen += 1;\n      utf8_code_point += (bite - 0x80) << (6 * (utf8_bytes_needed -\n                                                utf8_bytes_seen));\n\n      // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n      // continue.\n      if (utf8_bytes_seen !== utf8_bytes_needed)\n        return null;\n\n      // 8. Let code point be utf-8 code point.\n      var code_point = utf8_code_point;\n\n      // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n      // seen to 0.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n      // 10. Return a code point whose value is code point.\n      return code_point;\n    };\n  }\n\n  // 9.1.2 utf-8 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function UTF8Encoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is in the range U+0000 to U+007F, return a\n      // byte whose value is code point.\n      if (inRange(code_point, 0x0000, 0x007f))\n        return code_point;\n\n      // 3. Set count and offset based on the range code point is in:\n      var count, offset;\n      // U+0080 to U+07FF, inclusive:\n      if (inRange(code_point, 0x0080, 0x07FF)) {\n        // 1 and 0xC0\n        count = 1;\n        offset = 0xC0;\n      }\n      // U+0800 to U+FFFF, inclusive:\n      else if (inRange(code_point, 0x0800, 0xFFFF)) {\n        // 2 and 0xE0\n        count = 2;\n        offset = 0xE0;\n      }\n      // U+10000 to U+10FFFF, inclusive:\n      else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n        // 3 and 0xF0\n        count = 3;\n        offset = 0xF0;\n      }\n\n      // 4.Let bytes be a byte sequence whose first byte is (code\n      // point >> (6  count)) + offset.\n      var bytes = [(code_point >> (6 * count)) + offset];\n\n      // 5. Run these substeps while count is greater than 0:\n      while (count > 0) {\n\n        // 1. Set temp to code point >> (6  (count  1)).\n        var temp = code_point >> (6 * (count - 1));\n\n        // 2. Append to bytes 0x80 | (temp & 0x3F).\n        bytes.push(0x80 | (temp & 0x3F));\n\n        // 3. Decrease count by one.\n        count -= 1;\n      }\n\n      // 6. Return bytes bytes, in order.\n      return bytes;\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders[\'UTF-8\'] = function(options) {\n    return new UTF8Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders[\'UTF-8\'] = function(options) {\n    return new UTF8Decoder(options);\n  };\n\n  //\n  // 10. Legacy single-byte encodings\n  //\n\n  // 10.1 single-byte decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {!Array.<number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n  function SingleByteDecoder(index, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished;\n\n      // 2. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 3. Let code point be the index code point for byte  0x80 in\n      // index single-byte.\n      var code_point = index[bite - 0x80];\n\n      // 4. If code point is null, return error.\n      if (code_point === null)\n        return decoderError(fatal);\n\n      // 5. Return a code point whose value is code point.\n      return code_point;\n    };\n  }\n\n  // 10.2 single-byte encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {!Array.<?number>} index The encoding index.\n   * @param {{fatal: boolean}} options\n   */\n  function SingleByteEncoder(index, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Let pointer be the index pointer for code point in index\n      // single-byte.\n      var pointer = indexPointerFor(code_point, index);\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        encoderError(code_point);\n\n      // 5. Return a byte whose value is pointer + 0x80.\n      return pointer + 0x80;\n    };\n  }\n\n  (function() {\n    if (!(\'encoding-indexes\' in global))\n      return;\n    encodings.forEach(function(category) {\n      if (category.heading !== \'Legacy single-byte encodings\')\n        return;\n      category.encodings.forEach(function(encoding) {\n        var name = encoding.name;\n        var idx = index(name.toLowerCase());\n        /** @param {{fatal: boolean}} options */\n        decoders[name] = function(options) {\n          return new SingleByteDecoder(idx, options);\n        };\n        /** @param {{fatal: boolean}} options */\n        encoders[name] = function(options) {\n          return new SingleByteEncoder(idx, options);\n        };\n      });\n    });\n  }());\n\n  //\n  // 11. Legacy multi-byte Chinese (simplified) encodings\n  //\n\n  // 11.1 gbk\n\n  // 11.1.1 gbk decoder\n  // gbk\'s decoder is gb18030\'s decoder.\n  /** @param {{fatal: boolean}} options */\n  decoders[\'GBK\'] = function(options) {\n    return new GB18030Decoder(options);\n  };\n\n  // 11.1.2 gbk encoder\n  // gbk\'s encoder is gb18030\'s encoder with its gbk flag set.\n  /** @param {{fatal: boolean}} options */\n  encoders[\'GBK\'] = function(options) {\n    return new GB18030Encoder(options, true);\n  };\n\n  // 11.2 gb18030\n\n  // 11.2.1 gb18030 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function GB18030Decoder(options) {\n    var fatal = options.fatal;\n    // gb18030\'s decoder has an associated gb18030 first, gb18030\n    // second, and gb18030 third (all initially 0x00).\n    var /** @type {number} */ gb18030_first = 0x00,\n        /** @type {number} */ gb18030_second = 0x00,\n        /** @type {number} */ gb18030_third = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and gb18030 first, gb18030\n      // second, and gb18030 third are 0x00, return finished.\n      if (bite === end_of_stream && gb18030_first === 0x00 &&\n          gb18030_second === 0x00 && gb18030_third === 0x00) {\n        return finished;\n      }\n      // 2. If byte is end-of-stream, and gb18030 first, gb18030\n      // second, or gb18030 third is not 0x00, set gb18030 first,\n      // gb18030 second, and gb18030 third to 0x00, and return error.\n      if (bite === end_of_stream &&\n          (gb18030_first !== 0x00 || gb18030_second !== 0x00 ||\n           gb18030_third !== 0x00)) {\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00;\n        decoderError(fatal);\n      }\n      var code_point;\n      // 3. If gb18030 third is not 0x00, run these substeps:\n      if (gb18030_third !== 0x00) {\n        // 1. Let code point be null.\n        code_point = null;\n        // 2. If byte is in the range 0x30 to 0x39, set code point to\n        // the index gb18030 ranges code point for (((gb18030 first \n        // 0x81)  10 + gb18030 second  0x30)  126 + gb18030 third \n        // 0x81)  10 + byte  0x30.\n        if (inRange(bite, 0x30, 0x39)) {\n          code_point = indexGB18030RangesCodePointFor(\n              (((gb18030_first - 0x81) * 10 + (gb18030_second - 0x30)) * 126 +\n               (gb18030_third - 0x81)) * 10 + bite - 0x30);\n        }\n\n        // 3. Let buffer be a byte sequence consisting of gb18030\n        // second, gb18030 third, and byte, in order.\n        var buffer = [gb18030_second, gb18030_third, bite];\n\n        // 4. Set gb18030 first, gb18030 second, and gb18030 third to\n        // 0x00.\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        gb18030_third = 0x00;\n\n        // 5. If code point is null, prepend buffer to stream and\n        // return error.\n        if (code_point === null) {\n          stream.prepend(buffer);\n          return decoderError(fatal);\n        }\n\n        // 6. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If gb18030 second is not 0x00, run these substeps:\n      if (gb18030_second !== 0x00) {\n\n        // 1. If byte is in the range 0x81 to 0xFE, set gb18030 third\n        // to byte and return continue.\n        if (inRange(bite, 0x81, 0xFE)) {\n          gb18030_third = bite;\n          return null;\n        }\n\n        // 2. Prepend gb18030 second followed by byte to stream, set\n        // gb18030 first and gb18030 second to 0x00, and return error.\n        stream.prepend([gb18030_second, bite]);\n        gb18030_first = 0x00;\n        gb18030_second = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 5. If gb18030 first is not 0x00, run these substeps:\n      if (gb18030_first !== 0x00) {\n\n        // 1. If byte is in the range 0x30 to 0x39, set gb18030 second\n        // to byte and return continue.\n        if (inRange(bite, 0x30, 0x39)) {\n          gb18030_second = bite;\n          return null;\n        }\n\n        // 2. Let lead be gb18030 first, let pointer be null, and set\n        // gb18030 first to 0x00.\n        var lead = gb18030_first;\n        var pointer = null;\n        gb18030_first = 0x00;\n\n        // 3. Let offset be 0x40 if byte is less than 0x7F and 0x41\n        // otherwise.\n        var offset = bite < 0x7F ? 0x40 : 0x41;\n\n        // 4. If byte is in the range 0x40 to 0x7E or 0x80 to 0xFE,\n        // set pointer to (lead  0x81)  190 + (byte  offset).\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFE))\n          pointer = (lead - 0x81) * 190 + (bite - offset);\n\n        // 5. Let code point be null if pointer is null and the index\n        // code point for pointer in index gb18030 otherwise.\n        code_point = pointer === null ? null :\n            indexCodePointFor(pointer, index(\'gb18030\'));\n\n        // 6. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 7. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 8. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 6. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 7. If byte is 0x80, return code point U+20AC.\n      if (bite === 0x80)\n        return 0x20AC;\n\n      // 8. If byte is in the range 0x81 to 0xFE, set gb18030 first to\n      // byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        gb18030_first = bite;\n        return null;\n      }\n\n      // 9. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 11.2.2 gb18030 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   * @param {boolean=} gbk_flag\n   */\n  function GB18030Encoder(options, gbk_flag) {\n    var fatal = options.fatal;\n    // gb18030\'s decoder has an associated gbk flag (initially unset).\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. If code point is U+E5E5, return error with code point.\n      if (code_point === 0xE5E5)\n        return encoderError(code_point);\n\n      // 4. If the gbk flag is set and code point is U+20AC, return\n      // byte 0x80.\n      if (gbk_flag && code_point === 0x20AC)\n        return 0x80;\n\n      // 5. Let pointer be the index pointer for code point in index\n      // gb18030.\n      var pointer = indexPointerFor(code_point, index(\'gb18030\'));\n\n      // 6. If pointer is not null, run these substeps:\n      if (pointer !== null) {\n\n        // 1. Let lead be floor(pointer / 190) + 0x81.\n        var lead = floor(pointer / 190) + 0x81;\n\n        // 2. Let trail be pointer % 190.\n        var trail = pointer % 190;\n\n        // 3. Let offset be 0x40 if trail is less than 0x3F and 0x41 otherwise.\n        var offset = trail < 0x3F ? 0x40 : 0x41;\n\n        // 4. Return two bytes whose values are lead and trail + offset.\n        return [lead, trail + offset];\n      }\n\n      // 7. If gbk flag is set, return error with code point.\n      if (gbk_flag)\n        return encoderError(code_point);\n\n      // 8. Set pointer to the index gb18030 ranges pointer for code\n      // point.\n      pointer = indexGB18030RangesPointerFor(code_point);\n\n      // 9. Let byte1 be floor(pointer / 10 / 126 / 10).\n      var byte1 = floor(pointer / 10 / 126 / 10);\n\n      // 10. Set pointer to pointer  byte1  10  126  10.\n      pointer = pointer - byte1 * 10 * 126 * 10;\n\n      // 11. Let byte2 be floor(pointer / 10 / 126).\n      var byte2 = floor(pointer / 10 / 126);\n\n      // 12. Set pointer to pointer  byte2  10  126.\n      pointer = pointer - byte2 * 10 * 126;\n\n      // 13. Let byte3 be floor(pointer / 10).\n      var byte3 = floor(pointer / 10);\n\n      // 14. Let byte4 be pointer  byte3  10.\n      var byte4 = pointer - byte3 * 10;\n\n      // 15. Return four bytes whose values are byte1 + 0x81, byte2 +\n      // 0x30, byte3 + 0x81, byte4 + 0x30.\n      return [byte1 + 0x81,\n              byte2 + 0x30,\n              byte3 + 0x81,\n              byte4 + 0x30];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders[\'gb18030\'] = function(options) {\n    return new GB18030Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders[\'gb18030\'] = function(options) {\n    return new GB18030Decoder(options);\n  };\n\n\n  //\n  // 12. Legacy multi-byte Chinese (traditional) encodings\n  //\n\n  // 12.1 big5\n\n  // 12.1.1 big5 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function Big5Decoder(options) {\n    var fatal = options.fatal;\n    // big5\'s decoder has an associated big5 lead (initially 0x00).\n    var /** @type {number} */ big5_lead = 0x00;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and big5 lead is not 0x00, set\n      // big5 lead to 0x00 and return error.\n      if (bite === end_of_stream && big5_lead !== 0x00) {\n        big5_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and big5 lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && big5_lead === 0x00)\n        return finished;\n\n      // 3. If big5 lead is not 0x00, let lead be big5 lead, let\n      // pointer be null, set big5 lead to 0x00, and then run these\n      // substeps:\n      if (big5_lead !== 0x00) {\n        var lead = big5_lead;\n        var pointer = null;\n        big5_lead = 0x00;\n\n        // 1. Let offset be 0x40 if byte is less than 0x7F and 0x62\n        // otherwise.\n        var offset = bite < 0x7F ? 0x40 : 0x62;\n\n        // 2. If byte is in the range 0x40 to 0x7E or 0xA1 to 0xFE,\n        // set pointer to (lead  0x81)  157 + (byte  offset).\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0xA1, 0xFE))\n          pointer = (lead - 0x81) * 157 + (bite - offset);\n\n        // 3. If there is a row in the table below whose first column\n        // is pointer, return the two code points listed in its second\n        // column\n        // Pointer | Code points\n        // --------+--------------\n        // 1133    | U+00CA U+0304\n        // 1135    | U+00CA U+030C\n        // 1164    | U+00EA U+0304\n        // 1166    | U+00EA U+030C\n        switch (pointer) {\n          case 1133: return [0x00CA, 0x0304];\n          case 1135: return [0x00CA, 0x030C];\n          case 1164: return [0x00EA, 0x0304];\n          case 1166: return [0x00EA, 0x030C];\n        }\n\n        // 4. Let code point be null if pointer is null and the index\n        // code point for pointer in index big5 otherwise.\n        var code_point = (pointer === null) ? null :\n            indexCodePointFor(pointer, index(\'big5\'));\n\n        // 5. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 6. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 7. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 5. If byte is in the range 0x81 to 0xFE, set big5 lead to\n      // byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        big5_lead = bite;\n        return null;\n      }\n\n      // 6. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 12.1.2 big5 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function Big5Encoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Let pointer be the index big5 pointer for code point.\n      var pointer = indexBig5PointerFor(code_point);\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 5. Let lead be floor(pointer / 157) + 0x81.\n      var lead = floor(pointer / 157) + 0x81;\n\n      // 6. If lead is less than 0xA1, return error with code point.\n      if (lead < 0xA1)\n        return encoderError(code_point);\n\n      // 7. Let trail be pointer % 157.\n      var trail = pointer % 157;\n\n      // 8. Let offset be 0x40 if trail is less than 0x3F and 0x62\n      // otherwise.\n      var offset = trail < 0x3F ? 0x40 : 0x62;\n\n      // Return two bytes whose values are lead and trail + offset.\n      return [lead, trail + offset];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders[\'Big5\'] = function(options) {\n    return new Big5Encoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders[\'Big5\'] = function(options) {\n    return new Big5Decoder(options);\n  };\n\n\n  //\n  // 13. Legacy multi-byte Japanese encodings\n  //\n\n  // 13.1 euc-jp\n\n  // 13.1.1 euc-jp decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCJPDecoder(options) {\n    var fatal = options.fatal;\n\n    // euc-jp\'s decoder has an associated euc-jp jis0212 flag\n    // (initially unset) and euc-jp lead (initially 0x00).\n    var /** @type {boolean} */ eucjp_jis0212_flag = false,\n        /** @type {number} */ eucjp_lead = 0x00;\n\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and euc-jp lead is not 0x00, set\n      // euc-jp lead to 0x00, and return error.\n      if (bite === end_of_stream && eucjp_lead !== 0x00) {\n        eucjp_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and euc-jp lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && eucjp_lead === 0x00)\n        return finished;\n\n      // 3. If euc-jp lead is 0x8E and byte is in the range 0xA1 to\n      // 0xDF, set euc-jp lead to 0x00 and return a code point whose\n      // value is 0xFF61 + byte  0xA1.\n      if (eucjp_lead === 0x8E && inRange(bite, 0xA1, 0xDF)) {\n        eucjp_lead = 0x00;\n        return 0xFF61 + bite - 0xA1;\n      }\n\n      // 4. If euc-jp lead is 0x8F and byte is in the range 0xA1 to\n      // 0xFE, set the euc-jp jis0212 flag, set euc-jp lead to byte,\n      // and return continue.\n      if (eucjp_lead === 0x8F && inRange(bite, 0xA1, 0xFE)) {\n        eucjp_jis0212_flag = true;\n        eucjp_lead = bite;\n        return null;\n      }\n\n      // 5. If euc-jp lead is not 0x00, let lead be euc-jp lead, set\n      // euc-jp lead to 0x00, and run these substeps:\n      if (eucjp_lead !== 0x00) {\n        var lead = eucjp_lead;\n        eucjp_lead = 0x00;\n\n        // 1. Let code point be null.\n        var code_point = null;\n\n        // 2. If lead and byte are both in the range 0xA1 to 0xFE, set\n        // code point to the index code point for (lead  0xA1)  94 +\n        // byte  0xA1 in index jis0208 if the euc-jp jis0212 flag is\n        // unset and in index jis0212 otherwise.\n        if (inRange(lead, 0xA1, 0xFE) && inRange(bite, 0xA1, 0xFE)) {\n          code_point = indexCodePointFor(\n            (lead - 0xA1) * 94 + (bite - 0xA1),\n            index(!eucjp_jis0212_flag ? \'jis0208\' : \'jis0212\'));\n        }\n\n        // 3. Unset the euc-jp jis0212 flag.\n        eucjp_jis0212_flag = false;\n\n        // 4. If byte is not in the range 0xA1 to 0xFE, prepend byte\n        // to stream.\n        if (!inRange(bite, 0xA1, 0xFE))\n          stream.prepend(bite);\n\n        // 5. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 6. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 6. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 7. If byte is 0x8E, 0x8F, or in the range 0xA1 to 0xFE, set\n      // euc-jp lead to byte and return continue.\n      if (bite === 0x8E || bite === 0x8F || inRange(bite, 0xA1, 0xFE)) {\n        eucjp_lead = bite;\n        return null;\n      }\n\n      // 8. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 13.1.2 euc-jp encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCJPEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00A5)\n        return 0x5C;\n\n      // 4. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203E)\n        return 0x7E;\n\n      // 5. If code point is in the range U+FF61 to U+FF9F, return two\n      // bytes whose values are 0x8E and code point  0xFF61 + 0xA1.\n      if (inRange(code_point, 0xFF61, 0xFF9F))\n        return [0x8E, code_point - 0xFF61 + 0xA1];\n\n      // 6. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n\n      // 7. Let pointer be the index pointer for code point in index\n      // jis0208.\n      var pointer = indexPointerFor(code_point, index(\'jis0208\'));\n\n      // 8. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 9. Let lead be floor(pointer / 94) + 0xA1.\n      var lead = floor(pointer / 94) + 0xA1;\n\n      // 10. Let trail be pointer % 94 + 0xA1.\n      var trail = pointer % 94 + 0xA1;\n\n      // 11. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders[\'EUC-JP\'] = function(options) {\n    return new EUCJPEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders[\'EUC-JP\'] = function(options) {\n    return new EUCJPDecoder(options);\n  };\n\n  // 13.2 iso-2022-jp\n\n  // 13.2.1 iso-2022-jp decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ISO2022JPDecoder(options) {\n    var fatal = options.fatal;\n    /** @enum */\n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      Katakana: 2,\n      LeadByte: 3,\n      TrailByte: 4,\n      EscapeStart: 5,\n      Escape: 6\n    };\n    // iso-2022-jp\'s decoder has an associated iso-2022-jp decoder\n    // state (initially ASCII), iso-2022-jp decoder output state\n    // (initially ASCII), iso-2022-jp lead (initially 0x00), and\n    // iso-2022-jp output flag (initially unset).\n    var /** @type {number} */ iso2022jp_decoder_state = states.ASCII,\n        /** @type {number} */ iso2022jp_decoder_output_state = states.ASCII,\n        /** @type {number} */ iso2022jp_lead = 0x00,\n        /** @type {boolean} */ iso2022jp_output_flag = false;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // switching on iso-2022-jp decoder state:\n      switch (iso2022jp_decoder_state) {\n      default:\n      case states.ASCII:\n        // ASCII\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, and 0x1B\n        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E\n            && bite !== 0x0F && bite !== 0x1B) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.Roman:\n        // Roman\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x5C\n        if (bite === 0x5C) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+00A5.\n          iso2022jp_output_flag = false;\n          return 0x00A5;\n        }\n\n        // 0x7E\n        if (bite === 0x7E) {\n          // Unset the iso-2022-jp output flag and return code point\n          // U+203E.\n          iso2022jp_output_flag = false;\n          return 0x203E;\n        }\n\n        // 0x00 to 0x7F, excluding 0x0E, 0x0F, 0x1B, 0x5C, and 0x7E\n        if (inRange(bite, 0x00, 0x7F) && bite !== 0x0E && bite !== 0x0F\n            && bite !== 0x1B && bite !== 0x5C && bite !== 0x7E) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is byte.\n          iso2022jp_output_flag = false;\n          return bite;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.Katakana:\n        // Katakana\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x5F\n        if (inRange(bite, 0x21, 0x5F)) {\n          // Unset the iso-2022-jp output flag and return a code point\n          // whose value is 0xFF61 + byte  0x21.\n          iso2022jp_output_flag = false;\n          return 0xFF61 + bite - 0x21;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.LeadByte:\n        // Lead byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return null;\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7E)) {\n          // Unset the iso-2022-jp output flag, set iso-2022-jp lead\n          // to byte, iso-2022-jp decoder state to trail byte, and\n          // return continue.\n          iso2022jp_output_flag = false;\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.TrailByte;\n          return null;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Return finished.\n          return finished;\n        }\n\n        // Otherwise\n        // Unset the iso-2022-jp output flag and return error.\n        iso2022jp_output_flag = false;\n        return decoderError(fatal);\n\n      case states.TrailByte:\n        // Trail byte\n        // Based on byte:\n\n        // 0x1B\n        if (bite === 0x1B) {\n          // Set iso-2022-jp decoder state to escape start and return\n          // continue.\n          iso2022jp_decoder_state = states.EscapeStart;\n          return decoderError(fatal);\n        }\n\n        // 0x21 to 0x7E\n        if (inRange(bite, 0x21, 0x7E)) {\n          // 1. Set the iso-2022-jp decoder state to lead byte.\n          iso2022jp_decoder_state = states.LeadByte;\n\n          // 2. Let pointer be (iso-2022-jp lead  0x21)  94 + byte  0x21.\n          var pointer = (iso2022jp_lead - 0x21) * 94 + bite - 0x21;\n\n          // 3. Let code point be the index code point for pointer in\n          // index jis0208.\n          var code_point = indexCodePointFor(pointer, index(\'jis0208\'));\n\n          // 4. If code point is null, return error.\n          if (code_point === null)\n            return decoderError(fatal);\n\n          // 5. Return a code point whose value is code point.\n          return code_point;\n        }\n\n        // end-of-stream\n        if (bite === end_of_stream) {\n          // Set the iso-2022-jp decoder state to lead byte, prepend\n          // byte to stream, and return error.\n          iso2022jp_decoder_state = states.LeadByte;\n          stream.prepend(bite);\n          return decoderError(fatal);\n        }\n\n        // Otherwise\n        // Set iso-2022-jp decoder state to lead byte and return\n        // error.\n        iso2022jp_decoder_state = states.LeadByte;\n        return decoderError(fatal);\n\n      case states.EscapeStart:\n        // Escape start\n\n        // 1. If byte is either 0x24 or 0x28, set iso-2022-jp lead to\n        // byte, iso-2022-jp decoder state to escape, and return\n        // continue.\n        if (bite === 0x24 || bite === 0x28) {\n          iso2022jp_lead = bite;\n          iso2022jp_decoder_state = states.Escape;\n          return null;\n        }\n\n        // 2. Prepend byte to stream.\n        stream.prepend(bite);\n\n        // 3. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state, and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n\n      case states.Escape:\n        // Escape\n\n        // 1. Let lead be iso-2022-jp lead and set iso-2022-jp lead to\n        // 0x00.\n        var lead = iso2022jp_lead;\n        iso2022jp_lead = 0x00;\n\n        // 2. Let state be null.\n        var state = null;\n\n        // 3. If lead is 0x28 and byte is 0x42, set state to ASCII.\n        if (lead === 0x28 && bite === 0x42)\n          state = states.ASCII;\n\n        // 4. If lead is 0x28 and byte is 0x4A, set state to Roman.\n        if (lead === 0x28 && bite === 0x4A)\n          state = states.Roman;\n\n        // 5. If lead is 0x28 and byte is 0x49, set state to Katakana.\n        if (lead === 0x28 && bite === 0x49)\n          state = states.Katakana;\n\n        // 6. If lead is 0x24 and byte is either 0x40 or 0x42, set\n        // state to lead byte.\n        if (lead === 0x24 && (bite === 0x40 || bite === 0x42))\n          state = states.LeadByte;\n\n        // 7. If state is non-null, run these substeps:\n        if (state !== null) {\n          // 1. Set iso-2022-jp decoder state and iso-2022-jp decoder\n          // output state to states.\n          iso2022jp_decoder_state = iso2022jp_decoder_state = state;\n\n          // 2. Let output flag be the iso-2022-jp output flag.\n          var output_flag = iso2022jp_output_flag;\n\n          // 3. Set the iso-2022-jp output flag.\n          iso2022jp_output_flag = true;\n\n          // 4. Return continue, if output flag is unset, and error\n          // otherwise.\n          return !output_flag ? null : decoderError(fatal);\n        }\n\n        // 8. Prepend lead and byte to stream.\n        stream.prepend([lead, bite]);\n\n        // 9. Unset the iso-2022-jp output flag, set iso-2022-jp\n        // decoder state to iso-2022-jp decoder output state and\n        // return error.\n        iso2022jp_output_flag = false;\n        iso2022jp_decoder_state = iso2022jp_decoder_output_state;\n        return decoderError(fatal);\n      }\n    };\n  }\n\n  // 13.2.2 iso-2022-jp encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ISO2022JPEncoder(options) {\n    var fatal = options.fatal;\n    // iso-2022-jp\'s encoder has an associated iso-2022-jp encoder\n    // state which is one of ASCII, Roman, and jis0208 (initially\n    // ASCII).\n    /** @enum */\n    var states = {\n      ASCII: 0,\n      Roman: 1,\n      jis0208: 2\n    };\n    var /** @type {number} */ iso2022jp_state = states.ASCII;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream and iso-2022-jp encoder\n      // state is not ASCII, prepend code point to stream, set\n      // iso-2022-jp encoder state to ASCII, and return three bytes\n      // 0x1B 0x28 0x42.\n      if (code_point === end_of_stream &&\n          iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      }\n\n      // 2. If code point is end-of-stream and iso-2022-jp encoder\n      // state is ASCII, return finished.\n      if (code_point === end_of_stream && iso2022jp_state === states.ASCII)\n        return finished;\n\n      // 3. If ISO-2022-JP encoder state is ASCII or Roman, and code\n      // point is U+000E, U+000F, or U+001B, return error with U+FFFD.\n      if ((iso2022jp_state === states.ASCII ||\n           iso2022jp_state === states.Roman) &&\n          (code_point === 0x000E || code_point === 0x000F ||\n           code_point === 0x001B)) {\n        return encoderError(0xFFFD);\n      }\n\n      // 4. If iso-2022-jp encoder state is ASCII and code point is an\n      // ASCII code point, return a byte whose value is code point.\n      if (iso2022jp_state === states.ASCII &&\n          isASCIICodePoint(code_point))\n        return code_point;\n\n      // 5. If iso-2022-jp encoder state is Roman and code point is an\n      // ASCII code point, excluding U+005C and U+007E, or is U+00A5\n      // or U+203E, run these substeps:\n      if (iso2022jp_state === states.Roman &&\n          ((isASCIICodePoint(code_point) &&\n           code_point !== 0x005C && code_point !== 0x007E) ||\n          (code_point == 0x00A5 || code_point == 0x203E))) {\n\n        // 1. If code point is an ASCII code point, return a byte\n        // whose value is code point.\n        if (isASCIICodePoint(code_point))\n          return code_point;\n\n        // 2. If code point is U+00A5, return byte 0x5C.\n        if (code_point === 0x00A5)\n          return 0x5C;\n\n        // 3. If code point is U+203E, return byte 0x7E.\n        if (code_point === 0x203E)\n          return 0x7E;\n      }\n\n      // 6. If code point is an ASCII code point, and iso-2022-jp\n      // encoder state is not ASCII, prepend code point to stream, set\n      // iso-2022-jp encoder state to ASCII, and return three bytes\n      // 0x1B 0x28 0x42.\n      if (isASCIICodePoint(code_point) &&\n          iso2022jp_state !== states.ASCII) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.ASCII;\n        return [0x1B, 0x28, 0x42];\n      }\n\n      // 7. If code point is either U+00A5 or U+203E, and iso-2022-jp\n      // encoder state is not Roman, prepend code point to stream, set\n      // iso-2022-jp encoder state to Roman, and return three bytes\n      // 0x1B 0x28 0x4A.\n      if ((code_point === 0x00A5 || code_point === 0x203E) &&\n          iso2022jp_state !== states.Roman) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.Roman;\n        return [0x1B, 0x28, 0x4A];\n      }\n\n      // 8. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n\n      // 9. Let pointer be the index pointer for code point in index\n      // jis0208.\n      var pointer = indexPointerFor(code_point, index(\'jis0208\'));\n\n      // 10. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 11. If iso-2022-jp encoder state is not jis0208, prepend code\n      // point to stream, set iso-2022-jp encoder state to jis0208,\n      // and return three bytes 0x1B 0x24 0x42.\n      if (iso2022jp_state !== states.jis0208) {\n        stream.prepend(code_point);\n        iso2022jp_state = states.jis0208;\n        return [0x1B, 0x24, 0x42];\n      }\n\n      // 12. Let lead be floor(pointer / 94) + 0x21.\n      var lead = floor(pointer / 94) + 0x21;\n\n      // 13. Let trail be pointer % 94 + 0x21.\n      var trail = pointer % 94 + 0x21;\n\n      // 14. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders[\'ISO-2022-JP\'] = function(options) {\n    return new ISO2022JPEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders[\'ISO-2022-JP\'] = function(options) {\n    return new ISO2022JPDecoder(options);\n  };\n\n  // 13.3 shift_jis\n\n  // 13.3.1 shift_jis decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ShiftJISDecoder(options) {\n    var fatal = options.fatal;\n    // shift_jis\'s decoder has an associated shift_jis lead (initially\n    // 0x00).\n    var /** @type {number} */ shiftjis_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and shift_jis lead is not 0x00,\n      // set shift_jis lead to 0x00 and return error.\n      if (bite === end_of_stream && shiftjis_lead !== 0x00) {\n        shiftjis_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and shift_jis lead is 0x00,\n      // return finished.\n      if (bite === end_of_stream && shiftjis_lead === 0x00)\n        return finished;\n\n      // 3. If shift_jis lead is not 0x00, let lead be shift_jis lead,\n      // let pointer be null, set shift_jis lead to 0x00, and then run\n      // these substeps:\n      if (shiftjis_lead !== 0x00) {\n        var lead = shiftjis_lead;\n        var pointer = null;\n        shiftjis_lead = 0x00;\n\n        // 1. Let offset be 0x40, if byte is less than 0x7F, and 0x41\n        // otherwise.\n        var offset = (bite < 0x7F) ? 0x40 : 0x41;\n\n        // 2. Let lead offset be 0x81, if lead is less than 0xA0, and\n        // 0xC1 otherwise.\n        var lead_offset = (lead < 0xA0) ? 0x81 : 0xC1;\n\n        // 3. If byte is in the range 0x40 to 0x7E or 0x80 to 0xFC,\n        // set pointer to (lead  lead offset)  188 + byte  offset.\n        if (inRange(bite, 0x40, 0x7E) || inRange(bite, 0x80, 0xFC))\n          pointer = (lead - lead_offset) * 188 + bite - offset;\n\n        // 4. Let code point be null, if pointer is null, and the\n        // index code point for pointer in index jis0208 otherwise.\n        var code_point = (pointer === null) ? null :\n              indexCodePointFor(pointer, index(\'jis0208\'));\n\n        // 5. If code point is null and pointer is in the range 8836\n        // to 10528, return a code point whose value is 0xE000 +\n        // pointer  8836.\n        if (code_point === null && pointer !== null &&\n            inRange(pointer, 8836, 10528))\n          return 0xE000 + pointer - 8836;\n\n        // 6. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (code_point === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 7. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 8. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte or 0x80, return a code point\n      // whose value is byte.\n      if (isASCIIByte(bite) || bite === 0x80)\n        return bite;\n\n      // 5. If byte is in the range 0xA1 to 0xDF, return a code point\n      // whose value is 0xFF61 + byte  0xA1.\n      if (inRange(bite, 0xA1, 0xDF))\n        return 0xFF61 + bite - 0xA1;\n\n      // 6. If byte is in the range 0x81 to 0x9F or 0xE0 to 0xFC, set\n      // shift_jis lead to byte and return continue.\n      if (inRange(bite, 0x81, 0x9F) || inRange(bite, 0xE0, 0xFC)) {\n        shiftjis_lead = bite;\n        return null;\n      }\n\n      // 7. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 13.3.2 shift_jis encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function ShiftJISEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point or U+0080, return a\n      // byte whose value is code point.\n      if (isASCIICodePoint(code_point) || code_point === 0x0080)\n        return code_point;\n\n      // 3. If code point is U+00A5, return byte 0x5C.\n      if (code_point === 0x00A5)\n        return 0x5C;\n\n      // 4. If code point is U+203E, return byte 0x7E.\n      if (code_point === 0x203E)\n        return 0x7E;\n\n      // 5. If code point is in the range U+FF61 to U+FF9F, return a\n      // byte whose value is code point  0xFF61 + 0xA1.\n      if (inRange(code_point, 0xFF61, 0xFF9F))\n        return code_point - 0xFF61 + 0xA1;\n\n      // 6. If code point is U+2212, set it to U+FF0D.\n      if (code_point === 0x2212)\n        code_point = 0xFF0D;\n\n      // 7. Let pointer be the index shift_jis pointer for code point.\n      var pointer = indexShiftJISPointerFor(code_point);\n\n      // 8. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 9. Let lead be floor(pointer / 188).\n      var lead = floor(pointer / 188);\n\n      // 10. Let lead offset be 0x81, if lead is less than 0x1F, and\n      // 0xC1 otherwise.\n      var lead_offset = (lead < 0x1F) ? 0x81 : 0xC1;\n\n      // 11. Let trail be pointer % 188.\n      var trail = pointer % 188;\n\n      // 12. Let offset be 0x40, if trail is less than 0x3F, and 0x41\n      // otherwise.\n      var offset = (trail < 0x3F) ? 0x40 : 0x41;\n\n      // 13. Return two bytes whose values are lead + lead offset and\n      // trail + offset.\n      return [lead + lead_offset, trail + offset];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders[\'Shift_JIS\'] = function(options) {\n    return new ShiftJISEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders[\'Shift_JIS\'] = function(options) {\n    return new ShiftJISDecoder(options);\n  };\n\n  //\n  // 14. Legacy multi-byte Korean encodings\n  //\n\n  // 14.1 euc-kr\n\n  // 14.1.1 euc-kr decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCKRDecoder(options) {\n    var fatal = options.fatal;\n\n    // euc-kr\'s decoder has an associated euc-kr lead (initially 0x00).\n    var /** @type {number} */ euckr_lead = 0x00;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and euc-kr lead is not 0x00, set\n      // euc-kr lead to 0x00 and return error.\n      if (bite === end_of_stream && euckr_lead !== 0) {\n        euckr_lead = 0x00;\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and euc-kr lead is 0x00, return\n      // finished.\n      if (bite === end_of_stream && euckr_lead === 0)\n        return finished;\n\n      // 3. If euc-kr lead is not 0x00, let lead be euc-kr lead, let\n      // pointer be null, set euc-kr lead to 0x00, and then run these\n      // substeps:\n      if (euckr_lead !== 0x00) {\n        var lead = euckr_lead;\n        var pointer = null;\n        euckr_lead = 0x00;\n\n        // 1. If byte is in the range 0x41 to 0xFE, set pointer to\n        // (lead  0x81)  190 + (byte  0x41).\n        if (inRange(bite, 0x41, 0xFE))\n          pointer = (lead - 0x81) * 190 + (bite - 0x41);\n\n        // 2. Let code point be null, if pointer is null, and the\n        // index code point for pointer in index euc-kr otherwise.\n        var code_point = (pointer === null)\n              ? null : indexCodePointFor(pointer, index(\'euc-kr\'));\n\n        // 3. If code point is null and byte is an ASCII byte, prepend\n        // byte to stream.\n        if (pointer === null && isASCIIByte(bite))\n          stream.prepend(bite);\n\n        // 4. If code point is null, return error.\n        if (code_point === null)\n          return decoderError(fatal);\n\n        // 5. Return a code point whose value is code point.\n        return code_point;\n      }\n\n      // 4. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 5. If byte is in the range 0x81 to 0xFE, set euc-kr lead to\n      // byte and return continue.\n      if (inRange(bite, 0x81, 0xFE)) {\n        euckr_lead = bite;\n        return null;\n      }\n\n      // 6. Return error.\n      return decoderError(fatal);\n    };\n  }\n\n  // 14.1.2 euc-kr encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function EUCKREncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. Let pointer be the index pointer for code point in index\n      // euc-kr.\n      var pointer = indexPointerFor(code_point, index(\'euc-kr\'));\n\n      // 4. If pointer is null, return error with code point.\n      if (pointer === null)\n        return encoderError(code_point);\n\n      // 5. Let lead be floor(pointer / 190) + 0x81.\n      var lead = floor(pointer / 190) + 0x81;\n\n      // 6. Let trail be pointer % 190 + 0x41.\n      var trail = (pointer % 190) + 0x41;\n\n      // 7. Return two bytes whose values are lead and trail.\n      return [lead, trail];\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders[\'EUC-KR\'] = function(options) {\n    return new EUCKREncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders[\'EUC-KR\'] = function(options) {\n    return new EUCKRDecoder(options);\n  };\n\n\n  //\n  // 15. Legacy miscellaneous encodings\n  //\n\n  // 15.1 replacement\n\n  // Not needed - API throws RangeError\n\n  // 15.2 Common infrastructure for utf-16be and utf-16le\n\n  /**\n   * @param {number} code_unit\n   * @param {boolean} utf16be\n   * @return {!Array.<number>} bytes\n   */\n  function convertCodeUnitToBytes(code_unit, utf16be) {\n    // 1. Let byte1 be code unit >> 8.\n    var byte1 = code_unit >> 8;\n\n    // 2. Let byte2 be code unit & 0x00FF.\n    var byte2 = code_unit & 0x00FF;\n\n    // 3. Then return the bytes in order:\n        // utf-16be flag is set: byte1, then byte2.\n    if (utf16be)\n      return [byte1, byte2];\n    // utf-16be flag is unset: byte2, then byte1.\n    return [byte2, byte1];\n  }\n\n  // 15.2.1 shared utf-16 decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n  function UTF16Decoder(utf16_be, options) {\n    var fatal = options.fatal;\n    var /** @type {?number} */ utf16_lead_byte = null,\n        /** @type {?number} */ utf16_lead_surrogate = null;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream and either utf-16 lead byte or\n      // utf-16 lead surrogate is not null, set utf-16 lead byte and\n      // utf-16 lead surrogate to null, and return error.\n      if (bite === end_of_stream && (utf16_lead_byte !== null ||\n                                utf16_lead_surrogate !== null)) {\n        return decoderError(fatal);\n      }\n\n      // 2. If byte is end-of-stream and utf-16 lead byte and utf-16\n      // lead surrogate are null, return finished.\n      if (bite === end_of_stream && utf16_lead_byte === null &&\n          utf16_lead_surrogate === null) {\n        return finished;\n      }\n\n      // 3. If utf-16 lead byte is null, set utf-16 lead byte to byte\n      // and return continue.\n      if (utf16_lead_byte === null) {\n        utf16_lead_byte = bite;\n        return null;\n      }\n\n      // 4. Let code unit be the result of:\n      var code_unit;\n      if (utf16_be) {\n        // utf-16be decoder flag is set\n        //   (utf-16 lead byte << 8) + byte.\n        code_unit = (utf16_lead_byte << 8) + bite;\n      } else {\n        // utf-16be decoder flag is unset\n        //   (byte << 8) + utf-16 lead byte.\n        code_unit = (bite << 8) + utf16_lead_byte;\n      }\n      // Then set utf-16 lead byte to null.\n      utf16_lead_byte = null;\n\n      // 5. If utf-16 lead surrogate is not null, let lead surrogate\n      // be utf-16 lead surrogate, set utf-16 lead surrogate to null,\n      // and then run these substeps:\n      if (utf16_lead_surrogate !== null) {\n        var lead_surrogate = utf16_lead_surrogate;\n        utf16_lead_surrogate = null;\n\n        // 1. If code unit is in the range U+DC00 to U+DFFF, return a\n        // code point whose value is 0x10000 + ((lead surrogate \n        // 0xD800) << 10) + (code unit  0xDC00).\n        if (inRange(code_unit, 0xDC00, 0xDFFF)) {\n          return 0x10000 + (lead_surrogate - 0xD800) * 0x400 +\n              (code_unit - 0xDC00);\n        }\n\n        // 2. Prepend the sequence resulting of converting code unit\n        // to bytes using utf-16be decoder flag to stream and return\n        // error.\n        stream.prepend(convertCodeUnitToBytes(code_unit, utf16_be));\n        return decoderError(fatal);\n      }\n\n      // 6. If code unit is in the range U+D800 to U+DBFF, set utf-16\n      // lead surrogate to code unit and return continue.\n      if (inRange(code_unit, 0xD800, 0xDBFF)) {\n        utf16_lead_surrogate = code_unit;\n        return null;\n      }\n\n      // 7. If code unit is in the range U+DC00 to U+DFFF, return\n      // error.\n      if (inRange(code_unit, 0xDC00, 0xDFFF))\n        return decoderError(fatal);\n\n      // 8. Return code point code unit.\n      return code_unit;\n    };\n  }\n\n  // 15.2.2 shared utf-16 encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {boolean} utf16_be True if big-endian, false if little-endian.\n   * @param {{fatal: boolean}} options\n   */\n  function UTF16Encoder(utf16_be, options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1. If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is in the range U+0000 to U+FFFF, return the\n      // sequence resulting of converting code point to bytes using\n      // utf-16be encoder flag.\n      if (inRange(code_point, 0x0000, 0xFFFF))\n        return convertCodeUnitToBytes(code_point, utf16_be);\n\n      // 3. Let lead be ((code point  0x10000) >> 10) + 0xD800,\n      // converted to bytes using utf-16be encoder flag.\n      var lead = convertCodeUnitToBytes(\n        ((code_point - 0x10000) >> 10) + 0xD800, utf16_be);\n\n      // 4. Let trail be ((code point  0x10000) & 0x3FF) + 0xDC00,\n      // converted to bytes using utf-16be encoder flag.\n      var trail = convertCodeUnitToBytes(\n        ((code_point - 0x10000) & 0x3FF) + 0xDC00, utf16_be);\n\n      // 5. Return a byte sequence of lead followed by trail.\n      return lead.concat(trail);\n    };\n  }\n\n  // 15.3 utf-16be\n  // 15.3.1 utf-16be decoder\n  /** @param {{fatal: boolean}} options */\n  encoders[\'UTF-16BE\'] = function(options) {\n    return new UTF16Encoder(true, options);\n  };\n  // 15.3.2 utf-16be encoder\n  /** @param {{fatal: boolean}} options */\n  decoders[\'UTF-16BE\'] = function(options) {\n    return new UTF16Decoder(true, options);\n  };\n\n  // 15.4 utf-16le\n  // 15.4.1 utf-16le decoder\n  /** @param {{fatal: boolean}} options */\n  encoders[\'UTF-16LE\'] = function(options) {\n    return new UTF16Encoder(false, options);\n  };\n  // 15.4.2 utf-16le encoder\n  /** @param {{fatal: boolean}} options */\n  decoders[\'UTF-16LE\'] = function(options) {\n    return new UTF16Decoder(false, options);\n  };\n\n  // 15.5 x-user-defined\n\n  // 15.5.1 x-user-defined decoder\n  /**\n   * @constructor\n   * @implements {Decoder}\n   * @param {{fatal: boolean}} options\n   */\n  function XUserDefinedDecoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream The stream of bytes being decoded.\n     * @param {number} bite The next byte read from the stream.\n     * @return {?(number|!Array.<number>)} The next code point(s)\n     *     decoded, or null if not enough data exists in the input\n     *     stream to decode a complete code point.\n     */\n    this.handler = function(stream, bite) {\n      // 1. If byte is end-of-stream, return finished.\n      if (bite === end_of_stream)\n        return finished;\n\n      // 2. If byte is an ASCII byte, return a code point whose value\n      // is byte.\n      if (isASCIIByte(bite))\n        return bite;\n\n      // 3. Return a code point whose value is 0xF780 + byte  0x80.\n      return 0xF780 + bite - 0x80;\n    };\n  }\n\n  // 15.5.2 x-user-defined encoder\n  /**\n   * @constructor\n   * @implements {Encoder}\n   * @param {{fatal: boolean}} options\n   */\n  function XUserDefinedEncoder(options) {\n    var fatal = options.fatal;\n    /**\n     * @param {Stream} stream Input stream.\n     * @param {number} code_point Next code point read from the stream.\n     * @return {(number|!Array.<number>)} Byte(s) to emit.\n     */\n    this.handler = function(stream, code_point) {\n      // 1.If code point is end-of-stream, return finished.\n      if (code_point === end_of_stream)\n        return finished;\n\n      // 2. If code point is an ASCII code point, return a byte whose\n      // value is code point.\n      if (isASCIICodePoint(code_point))\n        return code_point;\n\n      // 3. If code point is in the range U+F780 to U+F7FF, return a\n      // byte whose value is code point  0xF780 + 0x80.\n      if (inRange(code_point, 0xF780, 0xF7FF))\n        return code_point - 0xF780 + 0x80;\n\n      // 4. Return error with code point.\n      return encoderError(code_point);\n    };\n  }\n\n  /** @param {{fatal: boolean}} options */\n  encoders[\'x-user-defined\'] = function(options) {\n    return new XUserDefinedEncoder(options);\n  };\n  /** @param {{fatal: boolean}} options */\n  decoders[\'x-user-defined\'] = function(options) {\n    return new XUserDefinedDecoder(options);\n  };\n\n  if (!global[\'TextEncoder\'])\n    global[\'TextEncoder\'] = TextEncoder;\n  if (!global[\'TextDecoder\'])\n    global[\'TextDecoder\'] = TextDecoder;\n\n  if (typeof module !== "undefined" && module.exports) {\n    module.exports = {\n      TextEncoder: global[\'TextEncoder\'],\n      TextDecoder: global[\'TextDecoder\'],\n      EncodingIndexes: global["encoding-indexes"]\n    };\n  }\n}(this));\n'},function(n,e,t){t(0)(t(47))},function(n,e){n.exports="/* eslint-disable no-unused-vars */\n/**\n * TinCan Registry\n * @author Adam Fox\n */\nvar GOMO_TINCAN_REGISTRY = {\n  'activities': {\n    'assessment': {\n      'name': 'Assessment',\n      'id': 'http://adlnet.gov/expapi/activities/assessment'\n    },\n    'course': {\n      'name': '',\n      'id': 'http://adlnet.gov/expapi/activities/course'\n    },\n    'file': {\n      'name': 'File',\n      'id': 'http://adlnet.gov/expapi/activities/file'\n    },\n    'interaction': {\n      'name': 'Interaction',\n      'id': 'http://adlnet.gov/expapi/activities/interaction'\n    },\n    'lesson': {\n      'name': 'Lesson',\n      'id': 'http://adlnet.gov/expapi/activities/lesson'\n    },\n    'link': {\n      'name': 'Link',\n      'id': 'http://adlnet.gov/expapi/activities/link'\n    },\n    'media': {\n      'name': 'Media',\n      'id': 'http://adlnet.gov/expapi/activities/media'\n    },\n    'meeting': {\n      'name': 'Meeting',\n      'id': 'http://adlnet.gov/expapi/activities/meeting'\n    },\n    'module': {\n      'name': '',\n      'id': 'http://adlnet.gov/expapi/activities/module'\n    },\n    'objective': {\n      'name': 'Objective',\n      'id': 'http://adlnet.gov/expapi/activities/objective'\n    },\n    'page': {\n      'name': '',\n      'id': 'http://id.tincanapi.com/activitytype/slide'\n    },\n    'performance': {\n      'name': 'Performance',\n      'id': 'http://adlnet.gov/expapi/activities/performance'\n    },\n    'question': {\n      'name': 'Question',\n      'id': 'http://adlnet.gov/expapi/activities/question'\n    },\n    'search': {\n      'name': 'Search',\n      'id': 'https://watershedlrs.com/xapi/activity-types/search-page'\n    },\n    'simulation': {\n      'name': 'Simulation',\n      'id': 'http://adlnet.gov/expapi/activities/simulation'\n    },\n    'slide': {\n      'name': 'slide',\n      'id': 'http://id.tincanapi.com/activitytype/slide'\n    }\n  },\n  'verbs': {\n    'answered': {\n      'name': 'answered',\n      'id': 'http://adlnet.gov/expapi/verbs/answered'\n    },\n    'asked': {\n      'name': 'asked',\n      'id': 'http://adlnet.gov/expapi/verbs/asked'\n    },\n    'attempted': {\n      'name': 'attempted',\n      'id': 'http://adlnet.gov/expapi/verbs/attempted'\n    },\n    'attended': {\n      'name': 'attended',\n      'id': 'http://adlnet.gov/expapi/verbs/attended'\n    },\n    'commented': {\n      'name': 'commented',\n      'id': 'http://adlnet.gov/expapi/verbs/commented'\n    },\n    'completed': {\n      'name': 'completed',\n      'id': 'http://adlnet.gov/expapi/verbs/completed'\n    },\n    'exited': {\n      'name': 'exited',\n      'id': 'http://adlnet.gov/expapi/verbs/exited'\n    },\n    'experienced': {\n      'name': 'experienced',\n      'id': 'http://adlnet.gov/expapi/verbs/experienced'\n    },\n    'failed': {\n      'name': 'failed',\n      'id': 'http://adlnet.gov/expapi/verbs/failed'\n    },\n    'imported': {\n      'name': 'imported',\n      'id': 'http://adlnet.gov/expapi/verbs/imported'\n    },\n    'initialise': {\n      'name': 'initialized',\n      'id': 'http://adlnet.gov/expapi/verbs/initialized'\n    },\n    'initialized': {\n      'name': 'initialized',\n      'id': 'http://adlnet.gov/expapi/verbs/initialized'\n    },\n    'interacted': {\n      'name': 'interacted',\n      'id': 'http://adlnet.gov/expapi/verbs/interacted'\n    },\n    'launched': {\n      'name': 'launched',\n      'id': 'http://adlnet.gov/expapi/verbs/launched'\n    },\n    'left': {\n      'name': 'left',\n      'id': 'http://activitystrea.ms/schema/1.0/leave'\n    },\n    'mastered': {\n      'name': 'mastered',\n      'id': 'http://adlnet.gov/expapi/verbs/mastered'\n    },\n    'passed': {\n      'name': 'passed',\n      'id': 'http://adlnet.gov/expapi/verbs/passed'\n    },\n    'preferred': {\n      'name': 'preferred',\n      'id': 'http://adlnet.gov/expapi/verbs/preferred'\n    },\n    'progressed': {\n      'name': 'progressed',\n      'id': 'http://adlnet.gov/expapi/verbs/progressed'\n    },\n    'registered': {\n      'name': 'registered',\n      'id': 'http://adlnet.gov/expapi/verbs/registered'\n    },\n    'responded': {\n      'name': 'responded',\n      'id': 'http://adlnet.gov/expapi/verbs/responded'\n    },\n    'resumed': {\n      'name': 'resumed',\n      'id': 'http://adlnet.gov/expapi/verbs/resumed'\n    },\n    'scored': {\n      'name': 'scored',\n      'id': 'http://adlnet.gov/expapi/verbs/scored'\n    },\n    'searched': {\n      'name': 'searched',\n      'id': 'http://activitystrea.ms/schema/1.0/searched'\n    },\n    'shared': {\n      'name': 'shared',\n      'id': 'http://adlnet.gov/expapi/verbs/shared'\n    },\n    'suspended': {\n      'name': 'suspended',\n      'id': 'http://adlnet.gov/expapi/verbs/suspended'\n    },\n    'terminated': {\n      'name': 'terminated',\n      'id': 'http://adlnet.gov/expapi/verbs/terminated'\n    },\n    'voided': {\n      'name': 'voided',\n      'id': 'http://adlnet.gov/expapi/verbs/voided'\n    },\n    'logged-in': {\n      'name': 'logged-in',\n      'id': 'https://w3id.org/xapi/adl/verbs/logged-in'\n    }\n  },\n  'extensions': {\n    'browser-info': {\n      'name': 'browser information',\n      'id': 'http://id.tincanapi.com/extension/browser-info'\n    },\n    'duration': {\n      'name': 'duration',\n      'id': 'http://id.tincanapi.com/extension/duration'\n    },\n    'geojson': {\n      'name': 'geojson',\n      'id': 'http://id.tincanapi.com/extension/geojson'\n    },\n    'referrer': {\n      'name': 'referrer',\n      'id': 'http://id.tincanapi.com/extension/referrer'\n    },\n    'search': {\n      'name': 'search results returned',\n      'id': 'https://watershedlrs.com/xapi/extensions/result/search-results-returned'\n    }\n  }\n};\n"},function(n,e,t){t(0)(t(49))},function(n,e){n.exports="/**\n * NavigationManager\n * @author Adam Fox\n */\n\nvar global = this;\n\n// Check for NavigationGroup dependency\nif(global.NavigationGroup === undefined){\n\tconsole.log('ERROR: NavigationGroup class has not been defined');\n}\n// Check for NavigationControl dependency\nif(global.NavigationControl === undefined){\n\tconsole.log('ERROR: NavigationControl class has not been defined');\n}\n\nif(global.$ === undefined){\n\tconsole.log('ERROR: jQuery not found!');\n}\n\nglobal.NavigationManager = (function($, NavigationGroup, NavigationControl){\n\t\n\t/**\n\t * NavigationManager\n\t * @constructor\n\t */\n\tfunction NavigationManager(){\n\n\t};\n\n\t/**\n\t * Extend the NavigationManager\n\t */\n\tNavigationManager.prototype = {\n\n\t\tcurrentNavigation: [],\n\t\tregisteredControls: {},\n\n\t\t/**\n\t\t * Register controls.\n\t\t * Any page-by-page alterations triggered by the\n\t\t * setCurrentNavigation method will verify the control against what has been\n\t\t * registered here!\n\t\t * @public\n\t\t */\n\t\tregisterControls: function(controls){\n\t\t\tvar me = this;\n\t\t\tme.registeredControls = null;\n\t\t\tme.registeredControls = new Object();\n\t\t\tif(controls){\n\t\t\t\tfor(var i in controls){\n\t\t\t\t\tvar controlDefinition = controls[i];\n\t\t\t\t\tvar control = new NavigationControl(controlDefinition);\n\t\t\t\t\tif(control.id){\n\t\t\t\t\t\tme.registeredControls[control.id] = control;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Sets the current navigation.\n\t\t * Current navigation can be different on a page-by-page basis.\n\t\t * However only registered controls can be used. A call to register the control should\n\t\t * be made up-front!\n\t\t * @public\n\t\t */\n\t\tsetCurrentNavigation: function(navigationDefinition){\n\t\t\tvar me = this;\n\t\t\tme.currentNavigation = []; // reset the current nav!\n\t\t\tnavigationDefinition = typeof navigationDefinition === 'object' ? navigationDefinition : JSON.parse(navigationDefinition);\n\n\t\t\t// Loop through the groups contained in the navigation definition\n\t\t\tfor(var i in navigationDefinition){\n\n\t\t\t\t// Check we don't already have this group!\n\t\t\t\tvar currentGroup = null;\n\t\t\t\tvar groupDefinition = navigationDefinition[i];\n\t\t\t\tfor(var groupPosition in me.currentNavigation){\n\t\t\t\t\tif( me.currentNavigation[groupPosition].id == groupDefinition.id){\n\t\t\t\t\t\tcurrentGroup = me.currentNavigation[groupPosition];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// If we haven't found the group but have all the info we need\n\t\t\t\t// then go create it!\n\t\t\t\tif(!currentGroup && groupDefinition.id){\n\t\t\t\t\tvar currentGroup = new NavigationGroup(groupDefinition);\n\t\t\t\t}\n\n\t\t\t\t// Do we have a valid group now?\n\t\t\t\tif(currentGroup && currentGroup.id){\n\n\t\t\t\t\tcurrentGroup.resetControls();\t\t\n\t\t\t\t\t\n\t\t\t\t\t// Loop the control definitions!\n\t\t\t\t\tvar controls = groupDefinition.controls;\n\t\t\t\t\tfor(var controlPosition in controls){\n\t\t\t\t\t\t// Look for the control in the registered items!\n\t\t\t\t\t\tvar registeredControl = null;\n\t\t\t\t\t\tvar controlDefinition = controls[controlPosition];\n\n\t\t\t\t\t\t// Don't add controls that aren't visible,\n\t\t\t\t\t\t// also ensure it's not black listed!\n\t\t\t\t\t\tif(!controlDefinition.visible || me.controlBlackListed(controlDefinition)){\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check for a registered control with the same id!\n\t\t\t\t\t\tfor(var y in me.registeredControls){\n\t\t\t\t\t\t\tif(me.registeredControls[y].id == controlDefinition.id){\n\t\t\t\t\t\t\t\tregisteredControl = me.registeredControls[y];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// If we have found the control in the registered list\n\t\t\t\t\t\t// then add it to the current group!\n\t\t\t\t\t\tif(registeredControl){\n\t\t\t\t\t\t\tvar newControl = $.extend(true, {}, registeredControl, new NavigationControl(controlDefinition));\n\t\t\t\t\t\t\t// Items that should not be overwritten!\n\t\t\t\t\t\t\tnewControl.type = registeredControl.type;\n\t\t\t\t\t\t\tnewControl.extra = registeredControl.extra;\n\t\t\t\t\t\t\tnewControl.defaultItem = registeredControl.defaultItem;\n\t\t\t\t\t\t\tif(newControl.partial == ''){\n\t\t\t\t\t\t\t\tnewControl.partial = registeredControl.partial;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrentGroup.addControl(newControl);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Add the group to the current navigation object!\n\t\t\t\t\tme.currentNavigation.push(currentGroup);\n\n\t\t\t\t} else {\n\t\t\t\t\t// Choose what we'd like to do with it\n\t\t\t\t\t// when it's not part of the default nav.\n\t\t\t\t\t// For now, nothing!\n\t\t\t\t}\n\t\t\t}\n\t\t\t//console.log(me.currentNavigation);\n\t\t},\n\n\t\tcontrolBlackListed: function(control){\n\t\t\tif(TOPIC_MANAGER.booCurrentScreenIsMenu() == true){\n\t\t\t\tif(control.id == 'extra-menu' || control.id == 'menuButton' || \n\t\t\t\t\tcontrol.id == 'extra-progress_bar' || control.id == 'progressBar'){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\n\t\t/**\n\t\t *\n\t\t */\n\t\tgetCurrentNavigationGroups: function(){\n\t\t\treturn this.currentNavigation;\n\t\t},\n\n\t\t/**\n\t\t * Return the group by id!\n\t\t * @public\n\t\t */\n\t\tgetNavigationGroupById: function(groupId){\n\t\t\tvar me = this;\n\t\t\tfor(var group in me.currentNavigation){\n\t\t\t\tvar currentGroup = me.currentNavigation[group];\n\t\t\t\tif(currentGroup.id == groupId){\n\t\t\t\t\treturn currentGroup;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t},\n\n\t\tgetRegisteredControlById: function(id){\n\t\t\tvar me = this;\n\t\t\tif(id){\n\t\t\t\tfor(var i in me.registeredControls){\n\t\t\t\t\tif(me.registeredControls[i].id == id){\n\t\t\t\t\t\treturn me.registeredControls[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t};\n\n\t// Return and instance - singleton\n\treturn new NavigationManager();\n\n})(global.$, global.NavigationGroup, global.NavigationControl);"},function(n,e,t){t(0)(t(51))},function(n,e){n.exports='/**\n* @title Deserializer\n* @description To be described. \n*\n*\n* @author Johnc\n* @version 2.0 30/10/06\n*/\n\n// Functionality switchs\n\n// If set to true, any functions found as parts of an object\n// will be extracted and rebuilt. If set to false, the function\n// will become a NULL value.\n// It should be noted that in general functions should not be\n// included in objects that are sent to an LMS as suspend data\n// as it would inflate the size considerably.\nvar CONST_SERIALIZE_FUNCTIONS = true;\n\n// In general this should be set to true so as to avoid any\n// accidental text based glitch\'s.\n// However in the case of very tight size limits, experiment\n// with turning this off to reduce string length as the escaping\n// can inflate string size considerably depending on the data\n// being encoded.\nvar CONST_ESCAPE_STRING_BASED_DATA = true;\n\n// typeof variables\nvar CONST_UNDEFINED = "0";\nvar CONST_STRING = "1";\nvar CONST_NUMBER = "2";\nvar CONST_BOOLEAN = "3";\nvar CONST_FUNCTION = "4";\n\n// instanceof variables\nvar CONST_OBJ_NULL = "5";\nvar CONST_OBJ_DATE = "6";\nvar CONST_OBJ_ARRAY = "7";\nvar CONST_OBJ_OBJECT = "8";\nvar CONST_OBJ_STRING = "9";\nvar CONST_OBJ_NUMBER = "10";\nvar CONST_OBJ_BOOLEAN = "11";\n\n// Used to indicate the item has been used.\nvar CONST_USED_ITEM = "999";\n\n// The default value for the delimiter if no parameter is set\nvar CONST_DEFAULT_DELIMITER = "#";\n\n// Used as a cap on the encoded data\'s string length. Currently set at 3k.\nvar MAX_STRING_LENGTH = 3072;\n\nvar DESERILAIZER =\n{\n\tid : "Da Deserializer",\n\n\t//Run-time properties\n\tstringToDeserialize : "",\n\n\tdeserializedDataArray : new Array(),\n\n\t// Used to catergorize the data split up from the string.\n\ttypeArray : new Array(),\n\tnameArray : new Array(),\n\tdataArray : new Array(),\n\n\t// Can be specified by sending a string to .setDataString()\n\tdelimiterChar : "&",\n\n/* ============================ START CONSTANTS ============================ */\n\t// Constant base values can be found in serializer_constants.js\n\n\t// typeof variables\n\tUNDEFINED : CONST_UNDEFINED,\n\tSTRING : CONST_STRING,\n\tNUMBER : CONST_NUMBER,\n\tBOOLEAN : CONST_BOOLEAN,\n\tFUNCTION : CONST_FUNCTION,\n\n\t// instanceof vaiables\n\tOBJ_NULL : CONST_OBJ_NULL,\n\tOBJ_DATE : CONST_OBJ_DATE,\n\tOBJ_ARRAY : CONST_OBJ_ARRAY,\n\tOBJ_OBJECT : CONST_OBJ_OBJECT,\n\tOBJ_STRING : CONST_OBJ_STRING,\n\tOBJ_NUMBER : CONST_OBJ_NUMBER,\n\tOBJ_BOOLEAN : CONST_OBJ_BOOLEAN,\n\n\t// Used to indicate the item has been used.\n\tUSED_ITEM : CONST_USED_ITEM,\n\n\t// The default value for the delimiter if no parameter is set\n\tDEFAULT_DELIMITER : CONST_DEFAULT_DELIMITER,\n\n/* ============================= END CONSTANTS ============================= */\n\n\n\n/* ============================= START BUILD PARAM\'s =========================== */\n\t// Used to switch on/off the unescaping of text based data.\n\tunescapeDataStrings : CONST_ESCAPE_STRING_BASED_DATA,\n\t// Used to switch on/off the deserializeing of any code found attached to an object.\n\tdeserializeFunctions : CONST_SERIALIZE_FUNCTIONS,\n/* ============================= END BUILD PARAM\'s ============================ */\n\n\n\n/* ============================ START PUBLIC METHODS ============================ */\n\t// Takes a string and sets this.stringToDeserialize with it, then calls\n\t// this.deserializeData() to populate this.deserializedDataArray.\n\tsetDataString : function (whatDataString, whatDelimiter)\n\t{\n\t\tif (whatDelimiter)\n\t\t{\n\t\t\tthis.delimiterChar = whatDelimiter;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.delimiterChar = this.DEFAULT_DELIMITER\n\t\t}\n\t\tthis.typeArray = new Array();\n\t\tthis.nameArray = new Array();\n\t\tthis.dataArray = new Array();\n\t\tthis.debugAlert("Set this.stringToDeserialize:\\n\\n" + whatDataString, 1, false, true)\n\t\tthis.stringToDeserialize = whatDataString\n\t\tthis.deserializeData()\n\t},\n\n\n\t// Returns the entire array of deserialized objects.\n\tgetAllItems : function ()\n\t{\n\t\tthis.debugAlert("Returning all deserialized items: ", 1, this.deserializedDataArray, true);\n\t\tvar tmpArr = this.deserializedDataArray;\n\t\tthis.deserializedDataArray = new Array();\n\t\treturn tmpArr;\n\t},\n\n\t// Clears the entire array of deserialized objects.\n\tremoveAllItems : function ()\n\t{\n\t\tthis.debugAlert("Clearing all deserialized items: ", 1, this.deserializedDataArray, true);\n\t\tthis.deserializedDataArray = new Array()\n\t\tthis.typeArray = new Array();\n\t\tthis.nameArray = new Array();\n\t\tthis.dataArray = new Array();\n\t},\n\n\n\t// Retrieves a named object from the this.deserializedDataArray or throws an error\n\t// if an object of that name can\'t be found.\n\tgetItem : function (whatName)\n\t{\n\t\t// Check if it exists.\n\t\tif (this.deserializedDataArray[whatName])\n\t\t{\n\t\t\tthis.debugAlert("RETRIEVED: " + this.deserializedDataArray[whatName], 1, false, false)\n\t\t\tvar tmpArr = this.deserializedDataArray;\n\t\t\tthis.deserializedDataArray = new Array();\n\t\t\treturn tmpArr[whatName];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.debugAlert("Failed to find data by the name of " + whatName + " in _getItem(), re_formated_deseriliazer.js", 3, this.deserializedDataArray, true)\n\t\t\treturn false;\n\t\t}\n\t},\n/* ============================= END PUBLIC METHODS ============================= */\n\n\n\n/* ============================ START PRIVATE METHODS =========================== */\n\t// Called on object instantiation, parse\'s the string passed into the constructor that gets\n\t// set as this.stringToDeserialize into the re-constructed data objects.\n\tdeserializeData : function ()\n\t{\n\t\tthis.sortIntoArrays();\n\t\tthis.parseArrays();\n\t\tthis.checkUnused();\n\t},\n\n\n\t// Splits the tXX=, nXX= and dXX= (type, name and data) into the relivant arrays and compares the final length\n\t// of the three arrays, throwing an error if they don\'t match. It also throw\'s an error if the prefix (t, n, or d)\n\t// isn\'t understood.\n\tsortIntoArrays : function ()\n\t{\n\t\t// Split into one large array.\n\t\tvar splitArray = this.stringToDeserialize.split(this.delimiterChar)\n\t\tvar count = 0;\n\t\t// Loop through ALL the items, sorting as needed.\n\t\twhile (count < splitArray.length)\n\t\t{\n\t\t\t// Extract the t, n, or d prefix\n\t\t\tvar prefix = splitArray[count].charAt(0);\n\t\t\t// Extract the ID e.g. 2.3.1\n\t\t\tvar currID = splitArray[count].slice(1,splitArray[count].indexOf("="))\n\t\t\t// Sort into relivant array for future use in parseArrays()\n\t\t\tswitch (prefix)\n\t\t\t{\n\t\t\t\tcase "n":\n\t\t\t\t\tthis.nameArray[currID] = splitArray[count].split("=")[1];\n\t\t\t\tbreak\n\t\t\t\tcase "d":\n\t\t\t\t\tthis.dataArray[currID] = splitArray[count].split("=")[1];\n\t\t\t\tbreak\n\t\t\t\tcase "t":\n\t\t\t\t\tthis.typeArray[currID] = splitArray[count].split("=")[1];\n\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthis.debugAlert("Unknown prefix of \'" + prefix + "\' found in \'" + splitArray[count] + "\', _deserializeData(), re_formated_deseriliazer.js", 3, splitArray, true)\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\t// Check the array length\'s match.\n\t\tif (this.typeArray.length != this.nameArray.length || this.typeArray.length != this.dataArray.length)\n\t\t{\n\t\t\tthis.debugAlert("Mismatched array length\'s may indicate missing / corrupt tracking data. _sortIntoArrays(), re_formated_deseriliazer.js", 3, false, true)\n\t\t}\n\t},\n\n\n\t// This function works by testing possible high level ID\'s until it fails. As the\n\t// ID\'s are auto-generated and should always be contiguous, when a possible high\n\t// level ID is not found, the end of the high level data objects can be assumed.\n\t//\n\t// Each valid ID is passed to sortTypeAndDeserialize() and the result is assigned\n\t// to this.deserializedDataArray[] using the objects name as the key.\n\t//\n\t// This function will only ever deal with the high level object\'s, any sub object\'s\n\t// will be handled by _deserializeObject() and _deserializeArray() which will then\n\t// call sortTypeAndDeserialize() independantly.\n\tparseArrays : function ()\n\t{\n\t\tvar count = 0;\n\t\tvar currHighLevelName = this.nameArray[count];\n\t\twhile (currHighLevelName)\n\t\t{\n\t\t\tthis.debugAlert("***** NEW HIGH LEVEL OBJECT Name: " + currHighLevelName + " *****", 1, false, false);\n\n\t\t\tthis.deserializedDataArray[currHighLevelName] = this.sortTypeAndDeserialize(count);\n\n\t\t\tthis.debugAlert("***** FINISHED HIGH LEVEL OBJECT Name: " + currHighLevelName + " *****", 1, this.deserializedDataArray[currHighLevelName], false);\n\t\t\tcount++;\n\t\t\tcurrHighLevelName = this.nameArray[count];\n\t\t}\n\t},\n\n\n\t// This function checks the type of the ID and then call\'s the relivant method (from below)\n\t// to re-construct it, blanks it from the raw array\'s then returns the object.\n\tsortTypeAndDeserialize : function (whatIndex)\n\t{\n\t\tvar returnObj = "";\n\t\tswitch (this.typeArray[whatIndex])\n\t\t{\n\t\t\tcase this.UNDEFINED:\n\t\t\t\treturnObj = this.deserializeUndefined(whatIndex)\n\t\t\tbreak;\n\t\t\tcase this.STRING:\n\t\t\t\treturnObj = this.deserializeString(whatIndex)\n\t\t\tbreak;\n\t\t\tcase this.NUMBER:\n\t\t\t\treturnObj = this.deserializeNumber(whatIndex)\n\t\t\tbreak;\n\t\t\tcase this.BOOLEAN:\n\t\t\t\treturnObj = this.deserializeBoolean(whatIndex)\n\t\t\tbreak;\n\t\t\tcase this.FUNCTION:\n\t\t\t\tif (this.deserializeFunctions)\n\t\t\t\t\treturnObj = this.deserializeFunction(whatIndex)\n\t\t\t\telse\n\t\t\t\t\treturnObj = this.deserializeNull(whatIndex)\n\t\t\tbreak;\n\t\t\tcase this.OBJ_STRING:\n\t\t\t\treturnObj = this.deserializeStringObject(whatIndex)\n\t\t\tbreak;\n\t\t\tcase this.OBJ_NUMBER:\n\t\t\t\treturnObj = this.deserializeNumberObject(whatIndex)\n\t\t\tbreak;\n\t\t\tcase this.OBJ_BOOLEAN:\n\t\t\t\treturnObj = this.deserializeBooleanObject(whatIndex)\n\t\t\tbreak;\n\t\t\tcase this.OBJ_OBJECT:\n\t\t\t\treturnObj = this.deserializeObject(whatIndex)\n\t\t\tbreak;\n\t\t\tcase this.OBJ_ARRAY:\n\t\t\t\treturnObj = this.deserializeArray(whatIndex)\n\t\t\tbreak;\n\t\t\tcase this.OBJ_DATE:\n\t\t\t\treturnObj = this.deserializeDate(whatIndex)\n\t\t\tbreak;\n\t\t\tcase this.OBJ_NULL :\n\t\t\t\treturnObj = this.deserializeNull(whatIndex)\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthis.debugAlert("Unknown type of " + this.typeArray[whatIndex] + ".\\nwhatIndex: " + whatIndex + "\\nthis.dataArray[whatIndex]: " + this.dataArray[whatIndex] + "\\nthis.nameArray[whatIndex]: " + this.dataArray[whatIndex] + "\\n\\nYou can only deserialize strings, numbers, booleans, dates, objects, arrays, nulls, and undefined. _sortTypeAndDeserialize(), re_formated_deseriliazer.js\\n\\n", 3, this.typeArray[whatIndex], false);\n\t\t\tbreak;\n\t\t}\n\t\tthis.typeArray[whatIndex] = this.USED_ITEM;\n\t\tthis.nameArray[whatIndex] = this.USED_ITEM;\n\t\tthis.dataArray[whatIndex] = this.USED_ITEM;\n\n\t\treturn returnObj;\n\t},\n\n\n\t// Simply returns the string "undefined".\n\tdeserializeUndefined : function (whatIndex)\n\t{\n\t\tthis.debugAlert("deserializeUndefined(whatIndex:" + whatIndex + "), this.dataArray[whatIndex]: " + this.dataArray[whatIndex], 1, false, false)\n\t\treturn "undefined";\n\t},\n\n\n\t// Checks wether strings are being escaped and unescape()\'s if required then returns the string.\n\tdeserializeString : function (whatIndex)\n\t{\n\t\tthis.debugAlert("deserializeString(whatIndex:" + whatIndex + "), this.dataArray[whatIndex]: " + this.dataArray[whatIndex], 1, false, false)\n\t\tif (this.unescapeDataStrings)\n\t\t\treturn unescape(unescape(this.dataArray[whatIndex]))\n\t\telse\n\t\t\treturn this.dataArray[whatIndex]\n\t},\n\n\n\t// Same as above, however use\'s the relivant constructor. See serializer_constants.js for more infomation about the differences\n\t// between normal and constructed variables.\n\tdeserializeStringObject : function (whatIndex)\n\t{\n\t\tthis.debugAlert("deserializeStringObject(whatIndex:" + whatIndex + "), this.dataArray[whatIndex]: " + this.dataArray[whatIndex], 1, false, false)\n\t\tif (this.unescapeDataStrings)\n\t\t\treturn new String(unescape(unescape(this.dataArray[whatIndex])))\n\t\telse\n\t\t\treturn new String(this.dataArray[whatIndex])\n\t},\n\n\n\t// Calls parseInt to ensure type isn\'t string then returns the number.\n\tdeserializeNumber : function (whatIndex)\n\t{\n\t\tthis.debugAlert("deserializeNumber(whatIndex:" + whatIndex + "), this.dataArray[whatIndex]: " + this.dataArray[whatIndex], 1, false, false)\n\t\treturn parseInt(this.dataArray[whatIndex])\n\t},\n\n\n\t// Same as above, however use\'s the relivant constructor. See serializer_constants.js for more infomation about the differences\n\t// between normal and constructed variables.\n\tdeserializeNumberObject : function (whatIndex)\n\t{\n\t\tthis.debugAlert("deserializeNumberObject(whatIndex:" + whatIndex + "), this.dataArray[whatIndex]: " + this.dataArray[whatIndex], 1, false, false)\n\t\treturn new Number(parseInt(this.dataArray[whatIndex]))\n\t},\n\n\n\t// Checks for the string "true" and returns true if present or false if not.\n\tdeserializeBoolean : function (whatIndex)\n\t{\n\t\tthis.debugAlert("deserializeBoolean(whatIndex:" + whatIndex + "), this.dataArray[whatIndex]: " + this.dataArray[whatIndex], 1, false, false)\n\t\tif (this.dataArray[whatIndex] == "true")\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t},\n\n\n\t// Same as above, however use\'s the relivant constructor. See serializer_constants.js for more infomation about the differences\n\t// between normal and constructed variables.\n\tdeserializeBooleanObject : function (whatIndex)\n\t{\n\t\tthis.debugAlert("deserializeBooleanObject(whatIndex:" + whatIndex + "), this.dataArray[whatIndex]: " + this.dataArray[whatIndex], 1, false, false)\n\t\tif (this.dataArray[whatIndex] == "true")\n\t\t\treturn new Boolean(true);\n\t\telse\n\t\t\treturn new Boolean(false);\n\t},\n\n\n\t// Checks wether strings are being escaped and unescape()\'s if required then create\'s a new date object\n\t// using the saved value and returns that.\n\tdeserializeDate : function (whatIndex)\n\t{\n\t\tthis.debugAlert("deserializeDate(whatIndex:" + whatIndex + "), this.dataArray[whatIndex]: " + this.dataArray[whatIndex], 1, false, false)\n\t\tif (this.unescapeDataStrings)\n\t\t\treturn new Date(unescape(this.dataArray[whatIndex]))\n\t\telse\n\t\t\treturn new Date(this.dataArray[whatIndex])\n\t},\n\n\n\t// Checks wether strings are being escaped and unescape()\'s if required then creates a new function\n\t// using the constructor and returns that.\n\tdeserializeFunction : function (whatIndex)\n\t{\n\t\tthis.debugAlert("deserializeFunction(whatIndex:" + whatIndex + "), this.dataArray[whatIndex]: " + this.dataArray[whatIndex], 1, false, false)\n\t\tif (this.unescapeDataStrings)\n\t\t\treturn new Function(unescape(this.dataArray[whatIndex]))\n\t\telse\n\t\t\treturn new Function(this.dataArray[whatIndex])\n\t},\n\n\t// This function works by testing possible child ID\'s until it fails. As the\n\t// ID\'s are auto-generated and should always be contiguous, when a possible child\n\t// ID is not found, the end of the child data objects can be assumed.\n\t//\n\t// Each valid ID is passed to sortTypeAndDeserialize() and the result is assigned\n\t// to the array using the objects name as the key. Names are checked to see if they\n\t// are purely numbers and if so parseInt\'d.\n\tdeserializeArray : function (whatBaseIndex)\n\t{\n\t\tthis.debugAlert("deserializeArray(whatBaseIndex:" + whatBaseIndex + ")", 1, false, false)\n\t\tvar returnArray = new Array()\n\t\tvar subItemCount = 1;\n\n\t\t// Loop through the sub items trying to find viable match\'s to add as the object values.\n\t\t// If a sub item match\'s (IE if this object is 5.3, 5.3.1, 5.3.2 etc would match) then send it off\n\t\t// for processing and then assign it to the object as needed.\n\t\tvar nextTestItemName = this.nameArray[whatBaseIndex + "." + subItemCount]\n\t\tif (nextTestItemName)\n\t\t{\n\t\t\twhile (nextTestItemName)\n\t\t\t{\n\t\t\t\t// Check if the name is a number ONLY, if so, parseInt it so\n\t\t\t\t// type is correct.\n\t\t\t\tif (nextTestItemName == parseInt(nextTestItemName).toString())\n\t\t\t\t{\n\t\t\t\t\tnextTestItemName = parseInt(nextTestItemName)\n\t\t\t\t}\n\t\t\t\t// Pass to sortTypeAndDeserialize() which while then call sub functions, possibly\n\t\t\t\t// even recusing into this one.\n\t\t\t\treturnArray[nextTestItemName] = this.sortTypeAndDeserialize(whatBaseIndex + "." + subItemCount)\n\t\t\t\tthis.debugAlert("Added \'" + nextTestItemName + "\' to array with ID: " + whatBaseIndex + ", value was: " + returnArray[nextTestItemName], 1, false, false)\n\t\t\t\t// Increament the subItemCount\n\t\t\t\tsubItemCount++\n\t\t\t\t// Create a reference to the next name to test for.\n\t\t\t\tnextTestItemName = this.nameArray[whatBaseIndex + "." + subItemCount]\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tthis.debugAlert("An Array has been found with no entries, ID:" + whatBaseIndex + ", deserializeArray(), re_formated_deseriliazer.js", 2, false, false)\n\t\treturn returnArray\n\t},\n\n\t// This function works by testing possible child ID\'s until it fails. As the\n\t// ID\'s are auto-generated and should always be contiguous, when a possible child\n\t// ID is not found, the end of the child data objects can be assumed.\n\t//\n\t// Each valid ID is passed to sortTypeAndDeserialize() and the result is assigned\n\t// to the array using the objects name as the key.\n\tdeserializeObject : function (whatBaseIndex)\n\t{\n\t\tthis.debugAlert("deserializeObject(whatBaseIndex:" + whatBaseIndex + ")", 1, false, false)\n\t\tvar returnObj = new Object()\n\t\tvar subItemCount = 1;\n\n\t\t// Loop through the sub items trying to find viable match\'s to add as the object values.\n\t\t// If a sub item match\'s (IE if this object is 5.3, 5.3.1, 5.3.2 etc would match) then send it off\n\t\t// for processing and then assign it to the object as needed.\n\t\tvar nextTestItemName = this.nameArray[whatBaseIndex + "." + subItemCount]\n\t\tif (nextTestItemName)\n\t\t{\n\t\t\twhile (nextTestItemName)\n\t\t\t{\n\t\t\t\t// Pass to sortTypeAndDeserialize() which while then call sub functions, possibly\n\t\t\t\t// even recusing into this one.\n\t\t\t\treturnObj[nextTestItemName] = this.sortTypeAndDeserialize(whatBaseIndex + "." + subItemCount)\n\t\t\t\tthis.debugAlert("Added \'" + nextTestItemName + "\' to object with ID: " + whatBaseIndex + ", value was: " + returnObj[nextTestItemName], 1, false, false)\n\t\t\t\t// Increament the subItemCount\n\t\t\t\tsubItemCount++\n\t\t\t\t// Create a reference to the next name to test for.\n\t\t\t\tnextTestItemName = this.nameArray[whatBaseIndex + "." + subItemCount]\n\t\t\t}\n\t\t\tthis.debugAlert("STOPPED COLLECTING At: " + (whatBaseIndex + "." + subItemCount) + ", name for data was: " + nextTestItemName, 1, false, false)\n\t\t}\n\t\telse\n\t\t\tthis.debugAlert("An object has been found with no properties or methods, ID:" + whatBaseIndex + ", deserializeObject(), re_formated_deseriliazer.js", 2, false, false)\n\t\treturn returnObj\n\t},\n\n\n\t// Simply returns null.\n\tdeserializeNull : function (whatIndex)\n\t{\n\t\tthis.debugAlert("deserializeNull(whatIndex:" + whatIndex + "), this.dataArray[whatIndex]: " + this.dataArray[whatIndex], 1, false, false)\n\t\treturn null;\n\t},\n\n\n\t// As ID\'s are passed to _sortTypeAndDeserialize() their entry in the relivant array\'s\n\t// is set too this.USED_ITEM. Once parseArrays() has finished, each Array is then inspected\n\t// for any entries that aren\'t == this.USED_ITEM and throw\'s an error if it finds any.\n\tcheckUnused : function ()\n\t{\n\t\tfor (var currIndex in this.typeArray)\n\t\t{\n\t\t\tif (currIndex != "indexOf")\n\t\t\t{\n\t\t\t\tif (this.typeArray[currIndex] != this.USED_ITEM)\n\t\t\t\t{\n\t\t\t\t\tthis.debugAlert("Unused TYPE, ID: " + currIndex + ", name: " + this.nameArray[currIndex] + ", type: " + this.typeArray[currIndex] + ", data: " + this.dataArray[currIndex] + ", found by checkUnused() in re_formated_deseriliazer.js", 3, false, true)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (var currIndex in this.nameArray)\n\t\t{\n\t\t\tif (currIndex != "indexOf")\n\t\t\t{\n\t\t\t\tif (this.typeArray[currIndex] != this.USED_ITEM)\n\t\t\t\t{\n\t\t\t\t\tthis.debugAlert("Unused NAME, ID: " + currIndex + ", name: " + this.nameArray[currIndex] + ", type: " + this.typeArray[currIndex] + ", data: " + this.dataArray[currIndex] + ", found by checkUnused() in re_formated_deseriliazer.js", 3, false, true)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (var currIndex in this.dataArray)\n\t\t{\n\t\t\tif (currIndex != "indexOf")\n\t\t\t{\n\t\t\t\tif (this.typeArray[currIndex] != this.USED_ITEM)\n\t\t\t\t{\n\t\t\t\t\tthis.debugAlert("Unused DATA, ID: " + currIndex + ", name: " + this.nameArray[currIndex] + ", type: " + this.typeArray[currIndex] + ", data: " + this.dataArray[currIndex] + ", found by checkUnused() in re_formated_deseriliazer.js", 3, false, true)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\t// Diagnostic function that alerts all properties of the object its passed.\n\t// Functions and Object\'s are not fully listed, but instead have " = A Function"\n\t// of " = A Object" added.\n\talertAll : function ()\n\t{\n\t\tvar names = "Object properties:\\n"\n\n\t\tvar functionsArray = new Array();\n\t\tvar objectsArray = new Array();\n\t\tvar variablesArray = new Array();\n\n\t\tfor (var propCount in this)\n\t\t{\n\t\t\t//alert(typeof propCount)\n\t\t\tevalProp = eval("this." + propCount)\n\t\t\tpropType = typeof evalProp\n\t\t\tswitch (propType)\n\t\t\t{\n\t\t\t\tcase "function":\n\t\t\t\t\tfunctionsArray[functionsArray.length] =  propCount + " = A Function\\n"\n\t\t\t\tbreak;\n\t\t\t\tcase "object":\n\t\t\t\t\t//objectsArray[objectsArray.length] =  propCount + " = A Object\\n"\n\t\t\t\t\tobjectsArray[objectsArray.length] =  propCount + " = " + evalProp + "\\n"\n\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tvariablesArray[variablesArray.length] =  propCount + " = " + evalProp + "\\n"\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tnames += "\\nFUNCTIONS\\n\\n"\n\t\tvar count = 0;\n\t\tfunctionsArray.sort()\n\t\twhile (count < functionsArray.length)\n\t\t{\n\t\t\tnames += functionsArray[count]\n\t\t\tcount++\n\t\t}\n\n\t\tnames += "\\nOBJECTS\\n\\n"\n\t\tvar count = 0;\n\t\tobjectsArray.sort()\n\t\twhile (count < objectsArray.length)\n\t\t{\n\t\t\tnames += objectsArray[count]\n\t\t\tcount++\n\t\t}\n\n\t\tnames += "\\nVARIABLES\\n\\n"\n\t\tvar count = 0;\n\t\tvariablesArray.sort()\n\t\twhile (count < variablesArray.length)\n\t\t{\n\t\t\tnames += variablesArray[count]\n\t\t\tcount++\n\t\t}\n\t\talert(names)\n\t\t//this.debugAlert(names)\n\t},\n\n\t// Pipe\'s through directly to the DEBUG object. See debugger.js for more info.\n\tdebugAlert : function (msg, priority, whatObj, showCallee)\n\t{\n\t\tif (DEBUG)\n\t\t\tDEBUG.lert(msg, priority, whatObj, showCallee, "DESERILAIZER")\n\t}\n/* ============================ END PRIVATE METHODS ============================ */\n}\nDESERILAIZER.debugAlert("DESERILAIZER Initialized", 0)\nDESERILAIZER.debugAlert("Object:", 1, DESERILAIZER, true)'},function(n,e,t){t(0)(t(53))},function(n,e){n.exports="/**\n * ContentTracking State\n * @author Adam Fox\n */\nfunction ContentTrackingState() {\n\n}\n\n/**\n * Extend the ContentTracking\n */\nContentTrackingState.prototype = {\n\n  state: {},\n\n  /*\n   * Add items to the state data\n   */\n  add: function(id, val) {\n    var me = this;\n    if (id) {\n      me.state[id] = val;\n    }\n  },\n\n  /**\n   * Remove items from the state data\n   * @param {string} id\n   */\n  remove: function(id) {\n    var me = this;\n    if (id && me.state.hasOwnProperty(id)) {\n      delete me.state[id];\n    }\n  },\n\n  /**\n   * Clear the state object\n   */\n  clear: function() {\n    var me = this;\n    me.reset();\n  },\n\n  /**\n   * Reset the state object, set the data\n   * passed if it is a valid object!\n   * @param {object} data\n   */\n  reset: function(data) {\n    var me = this;\n    var state = {};\n    if ((typeof data).toLowerCase() == 'object') {\n      state = data;\n    }\n    me.state = null;\n    me.state = state;\n  },\n\n  /**\n   * Get value for the specified id\n   * @param {*} id\n   * @return {*}\n   */\n  get: function(id) {\n    var me = this;\n    if (id != null && id != '') {\n      if (me.state && me.state[id]) {\n        return me.state[id];\n      }\n    }\n    return null;\n  },\n\n  /**\n   * Return the state object\n   * @return {object}\n   */\n  getObject: function() {\n    var me = this;\n    return me.state;\n  },\n\n  /**\n   * Stringify the state data\n   * @return {string}\n   */\n  getString: function() {\n    var me = this;\n    var stateString = '';\n    try {\n      stateString = JSON.stringify(me.state);\n    } catch (e) {\n      stateString = '';\n    }\n    return stateString;\n  },\n};\n"},function(n,e,t){t(0)(t(55))},function(n,e){n.exports="/* global _, GOMO_SCORM_PORTHOLE, GOMO_SCORM_WRAPPER, DESERILAIZER, TOPIC_MANAGER */\n\n/**\n * SCORM tracking adapter\n * @author Adam Fox\n */\n\nvar global = this;\n\nglobal.GOMO_SCORM = (function($) {\n  /**\n   * @type {object}\n   */\n  var scormInteractionTypes = {\n    '1.2': [\n      'true-false',\n      'choice',\n      'fill-in',\n      'matching',\n      'performance',\n      'sequencing',\n      'likert',\n      'numeric'\n    ],\n    '2004': [\n      'true-false',\n      'choice',\n      'fill-in',\n      'long-fill-in', // not in 1.2\n      'matching',\n      'performance',\n      'sequencing',\n      'likert',\n      'numeric',\n      'other' // not in 1.2\n    ]\n  };\n\n  /**\n   * SCORM\n   * @param {object} config\n   */\n  function SCORM(config) {\n    var me = this;\n    me.scorm = null;\n    me.endpoint = '';\n    me.user = null;\n    me.interactionCount = 0;\n\n    // If it's an array then only pull the first item\n    if (config instanceof Array) {\n      config = config[0];\n    }\n\n    // Check we have an object\n    if (config instanceof Object) {\n      if (config.adapter == 'scorm') {\n        // Ability to customise the wrapper...\n        // porthole is used for SCORM wrapper - cross domain\n        switch (config.wrapper) {\n          case 'porthole':\n            me.scorm = GOMO_SCORM_PORTHOLE;\n            break;\n          default:\n            me.scorm = GOMO_SCORM_WRAPPER;\n            break;\n        }\n        me.scorm.version = config.version || '1.2';\n        if (me.scorm.version.substr(0, 4) === '2004') {\n          me.scorm.version = '2004';\n        }\n        me.setDefaultLessonStatus();\n        me.scorm.endpoint = me.endpoint = (config.endpoint || '');\n      }\n    }\n  }\n\n  /**\n   * Extend the ContentTracking\n   */\n  SCORM.prototype = {\n\n    startTime: null,\n    initialised: false,\n    suspendData: null,\n    lessonLocation: null,\n    lessonStatus: null,\n    lessonScore: '',\n    sessionTime: '',\n    user: null,\n    userIsSet: false,\n\n    preferences: {\n      suspendData: {\n        format: 'json',\n        seperator: null\n      }\n    },\n\n    /**\n     * If any pre-start checks are required, set them here\n     * @return {promise}\n     */\n    prestart: function() {\n      var deferred = new $.Deferred();\n      var me = this;\n\n      var getStudent = function(callback) {\n        // Grab the user\n        me.scorm.get('student_id', function(studentId) {\n          me.scorm.get('student_name', function(studentName) {\n            var user = null;\n            if (studentId || studentName) {\n              user = {\n                id: studentId,\n                name: studentName\n              };\n              me.setUser(user);\n              callback();\n            }\n            deferred.resolve();\n          });\n        });\n      };\n\n      var setInitialised = function() {\n        me.initialised = true;\n      };\n\n      // Call SCORM initialise\n      me.scorm.init(function(initialised) {\n        // Set initialised status...\n        me.initialised = initialised;\n        // Has it initialised OK?\n        if (me.initialised) {\n          getStudent(setInitialised);\n        } else {\n          // init() may return false if already auto-initialised by LMS.\n          // so now we will check this is not the case...\n          me.scorm.get('status', function(status) {\n            me.scorm.debug.getCode(function(statusError) {\n              if (statusError == 0) {\n                // no error was found grabbing the status so we're all good\n                getStudent(setInitialised);\n              } else {\n                deferred.reject();\n              }\n            });\n          });\n        }\n      });\n\n      return deferred.promise();\n    },\n\n    /**\n     * Start the SCORM adapter\n     * @param {object} startData\n     * @param {object} settings\n     * @return {boolean}\n     */\n    start: function(startData, settings) {\n      var me = this;\n\n      if (me.initialised) {\n        // Start time\n        me.startTime = new Date();\n\n        // Set min and max scores\n        me.setMinAndMax();\n\n        // Grab the lesson status...\n        me.scorm.get('status', function(lessonStatus) {\n          if (lessonStatus === undefined || me.isLessonStatusNotAttempted()) {\n            me.setLessonStatusIncomplete();\n          }\n          // Get score\n          me.scorm.get('score', function(score) {\n            me.lessonScore = isNaN(parseInt(score)) ? '' : +score;\n            me.lessonStatus = lessonStatus;\n            // Get suspend data\n            me.scorm.get('cmi.suspend_data', function(suspendData) {\n              // Parse the suspend data object...\n              me.suspendData = me.parseObject(suspendData, me.preferences.suspendData);\n              // Get lesson location...\n              me.scorm.get('location', function(location) {\n                location = me.replaceEscapedBrackets(location);\n                location = me.legacyLessonConverter(location);\n                me.lessonLocation = global.gomo.utility.Base64.decodeObject(location);\n                // Now convert suspend data...\n                me.legacySuspendConverter(function() {\n                  // Call success with user\n                  settings.success();\n                });\n              });\n            });\n          });\n        });\n\n        // get and memoize supported interaction elements\n        me.scorm.get('cmi.interactions._children', function(result) {\n          me.supportedInteractionElements = result;\n        });\n\n        // get and memoize interaction count\n        me.scorm.get('cmi.interactions._count', function(result) {\n          me.interactionCount = parseInt(result, 10);\n        });\n\n        return true;\n      }\n\n      // Not initialised\n      settings.error();\n      return false;\n    },\n\n    parseObject: function(data, preferences) {\n      var me = this;\n      var result = {};\n      if (preferences.format == 'string') {\n        // Do we have a string?\n        if (typeof data == 'string') {\n          // Split the string...\n          var dataSplit = data.split(preferences.seperator);\n          if (dataSplit && dataSplit.length) {\n            // Loop through the data...\n            for (var i=0; i<dataSplit.length; i++) {\n              var item = dataSplit[i];\n              var pair = item.split('=');\n              if (pair.length == 2) {\n                var d = pair[1];\n                if (me.testForJson(d)) {\n                  d = global.gomo.utility.Base64.decodeObject(d);\n                }\n                result[pair[0]] = d;\n              }\n            }\n          }\n        }\n      } else {\n        // Default option is JSON\n        result = global.gomo.utility.Base64.decodeObject(data);\n      }\n      return result;\n    },\n\n    composeObject: function(data, preferences) {\n      var result = '';\n      if (preferences.format == 'string') {\n        for (var i in data) { // eslint-disable-line guard-for-in\n          var d = data[i];\n          if (typeof d != 'string') {\n            d = global.gomo.utility.Base64.encodeObject(d);\n          }\n          result += (result !== '' ? preferences.seperator : '' ) + i + '=' + d;\n        }\n      } else {\n        // Default is stringified Object....\n        result = global.gomo.utility.Base64.encodeObject(data);\n      }\n      return result;\n    },\n\n    setPreferences: function(preferences, settings) {\n      var me = this;\n      if (preferences) {\n        if (preferences.suspendData) {\n          // Set the suspend data format and seperator\n          me.preferences.suspendData.format = preferences.suspendData.format ||\n            me.preferences.suspendData.format;\n          me.preferences.suspendData.seperator = preferences.suspendData.seperator ||\n            me.preferences.suspendData.seperator;\n        }\n      }\n\n      if (settings && settings.success) {\n        settings.success();\n      }\n    },\n\n    getUser: function() {\n      var me = this;\n      return me.user;\n    },\n\n    setUser: function(user) {\n      var me = this;\n      me.user = user;\n      me.userIsSet = true;\n    },\n\n    /**\n     * End the SCORM tracking\n     * @param {object} endData\n     * @param {object} settings\n     * @return {boolean}\n     */\n    end: function(endData, settings) {\n      var me = this;\n      if (me.initialised) {\n        // Save summary of results\n        me.summarise(function() {\n          me.scorm.quit(function() {\n            settings.success();\n          });\n        });\n        return true;\n      }\n      settings.error();\n      return false;\n    },\n\n    /**\n     * Page visit\n     * @param {object} visitData\n     * @param {object} settings\n     * @return {boolean}\n     */\n    visit: function(visitData, settings) {\n      var me = this;\n      if (me.initialised) {\n        if (TOPIC_MANAGER.shouldSetLessonLocation()) {\n          me.lessonLocation = me.formatLessonLocation(visitData);\n          me.scorm.set(\n            'location',\n            global.gomo.utility.Base64.encodeObject(me.lessonLocation),\n            function() {\n              settings.success();\n            }\n          );\n        } else {\n          settings.success();\n        }\n        return true;\n      }\n      settings.error();\n      return false;\n    },\n\n    /**\n     * topic visit\n     * @return {boolean}\n     */\n    screenChanged: function() {\n      var me = this;\n      return me.initialised;\n    },\n\n    /**\n     * topic visit\n     * @return {boolean}\n     */\n    topicVisit: function() {\n      var me = this;\n      return me.initialised;\n    },\n\n    /**\n     * Topic completed\n     * @return {boolean}\n     */\n    topicCompleted: function() {\n      return this.initialised;\n    },\n\n    /**\n     * Format the lesson location\n     * ensure the it's only the data we need.\n     * @param {object} visitData\n     * @return {object}\n     */\n    formatLessonLocation: function(visitData) {\n      var maxLength = 255;\n      var lessonLocation = {\n        topicId: visitData.topicId,\n        topicTitle: visitData.topicTitle,\n        pageId: visitData.pageId,\n        pageTitle: visitData.pageTitle\n      };\n      // Check if length is more than the scorm limit of 255 characters and trim if needed.\n      var encodedLessonLocation = global.gomo.utility.Base64.encodeObject(lessonLocation);\n      if (encodedLessonLocation && encodedLessonLocation.length > maxLength) {\n        // Remove topic title and page title then encode again to work out the number of available\n        // characters that the topic and page titles can use.\n        lessonLocation.topicTitle = '';\n        lessonLocation.pageTitle = '';\n        encodedLessonLocation = global.gomo.utility.Base64.encodeObject(lessonLocation);\n        var availableChars = maxLength - encodedLessonLocation.length;\n\n        // Encode the topic and page titles so we can use thier lengths for calculating the trim.\n        var encodedTopicTitle =\n          global.gomo.utility.Base64.encode(visitData.topicTitle) || false;\n        var encodedPageTitle =\n          global.gomo.utility.Base64.encode(visitData.pageTitle) || false;\n\n        // Trim topic and/or page titles if they exceed the max length available.\n        if (\n          availableChars &&\n          encodedTopicTitle &&\n          encodedPageTitle &&\n          (encodedTopicTitle.length + encodedPageTitle.length) > availableChars\n        ) {\n          var trimmedTopicTitle = visitData.topicTitle;\n          var trimmedPageTitle = visitData.pageTitle;\n          var desiredTopicTitleLength = 0;\n          var desiredPageTitleLength = 0;\n          // Different size scenarios require different trimming to fit max size.\n          // Topic title > 70% && page title < 30%\n          if (\n            encodedTopicTitle.length > (availableChars * 0.7) &&\n            encodedPageTitle.length < (availableChars * 0.3)\n          ) {\n            // Page title is less than 30% of availabe space so use that as is and then use the\n            // remaining space for topic title.\n            desiredTopicTitleLength = Math.floor(availableChars - encodedPageTitle.length);\n          }\n          // Topic title > 70% && page title > 30%\n          if (\n            encodedTopicTitle.length > (availableChars * 0.7) &&\n            encodedPageTitle.length > (availableChars * 0.3)\n          ) {\n            // Trim the topic title to 70% of available space and page title to 30%.\n            desiredTopicTitleLength = Math.floor(availableChars * 0.7);\n            desiredPageTitleLength = Math.floor(availableChars * 0.3);\n          }\n          // Topic title < 70% && page title > 30%\n          if (\n            encodedTopicTitle.length < (availableChars * 0.7) &&\n            encodedPageTitle.length > (availableChars * 0.3)\n          ) {\n            // Use topic title as is and trim page title to fill the remaining space.\n            desiredPageTitleLength = Math.floor(availableChars - encodedTopicTitle.length);\n          }\n          // Trim the title strings.\n          if (desiredTopicTitleLength > 0) {\n            trimmedTopicTitle = this.trimTitle(visitData.topicTitle, desiredTopicTitleLength);\n          }\n          if (desiredPageTitleLength > 0) {\n            trimmedPageTitle = this.trimTitle(visitData.pageTitle, desiredPageTitleLength);\n          }\n          // Update the location object to return.\n          lessonLocation.topicTitle = trimmedTopicTitle;\n          lessonLocation.pageTitle = trimmedPageTitle;\n        }\n      }\n\n      return lessonLocation;\n    },\n\n    /**\n     * Trims a title string.\n     * @param {String} title\n     * @param {Number} desiredLength\n     * @return {String}\n     */\n    trimTitle: function(title, desiredLength) {\n      var suffixLength = 4;\n      var suffix = '....';\n      var trim = function(title) {\n        var trimAmountPercent = 0.95;\n        title = title.substring(0, Math.floor(title.length * trimAmountPercent));\n        return title;\n      };\n      // Trim string until its encoded length matches the desired length.\n      while (gomo.utility.Base64.encode(title).length > (desiredLength - suffixLength)) {\n        title = trim(title, desiredLength);\n      }\n      title += suffix;\n      return title;\n    },\n\n    /**\n     * Interaction...\n     * Split these up in to the relevant scorm calls..\n     * @param {object} interactionData\n     * @param {object} settings\n     * @return {boolean}\n     */\n    interaction: function(interactionData, settings) {\n      var me = this;\n      var result = false;\n      var failedInteractions;\n\n      // Capture course level interactions\n      if (interactionData.activity.type.toLowerCase() == 'course') {\n        var score = interactionData.result && interactionData.result.score !== undefined ?\n          interactionData.result.score : me.lessonScore;\n        var interactionType = interactionData.type.toLowerCase();\n        if (me.scorm.version === '1.2' &&\n          _.contains(['incomplete', 'completed', 'started', 'passed', 'failed'], interactionType)) {\n          result = me.setLessonStatus(interactionType, score);\n        } else if (me.scorm.version === '2004' &&\n          _.contains(['incomplete', 'completed', 'started'], interactionType)) {\n          result = me.setLessonStatus({\n            'completion': interactionType,\n            'success': me.lessonStatus.success\n          }, score);\n        } else if (me.scorm.version === '2004' &&\n          _.contains(['passed', 'failed'], interactionType)) {\n          if (interactionType === 'passed') {\n            me.lessonStatus.completion = 'completed';\n          }\n          result = me.setLessonStatus({\n            'completion': me.lessonStatus.completion,\n            'success': interactionType\n          }, score);\n        }\n      }\n\n\n      // modify activity types that scorm 1.2 won't support\n      if (me.scorm.version === '1.2' && interactionData.activity.type == 'other') {\n        // we have a likert overall statement\n        interactionData.activity.type = 'likert';\n      }\n\n      // capture CMI interactions\n      if (_.isString(interactionData.activity.type)\n          &&\n          _.contains(scormInteractionTypes[me.scorm.version], interactionData.activity.type)) {\n        failedInteractions = me.setCMIInteractions(\n          me.interactionCount,\n          me.scorm.set,\n          me.extractCMIInteractionsFromInteractionData(\n            interactionData,\n            me.scorm.version\n          )\n        );\n        result = _.isArray(failedInteractions) && _.isEmpty(failedInteractions);\n        ++me.interactionCount;\n      } else if (interactionData.activity.type.toLowerCase() != 'course') {\n        // Capture other interactions SCORM doesn't care about...\n        // these may be interactions for other adapters so we don't want to error!\n        result = true;\n      }\n\n      if (result) {\n        settings.success(null);\n      } else {\n        if (_.isArray(failedInteractions) && !_.isEmpty(failedInteractions)) {\n          settings.error(\n            'The following interaction element(s) failed: ' + failedInteractions.join(', ')\n          );\n        } else {\n          settings.error();\n        }\n      }\n      return result;\n    },\n\n    /**\n     * Save the passed state to suspend data\n     * @param {object} stateData\n     * @param {object} settings\n     * @return {boolean}\n     */\n    saveState: function(stateData, settings) {\n      var me = this;\n      me.suspendData = stateData.state;\n\n      if (me.initialised) {\n        me.summarise(function(result) {\n          if (result) {\n            settings.success();\n          } else {\n            settings.error();\n          }\n        }, (settings.suppressSave || false));\n        return true;\n      }\n      settings.error();\n      return false;\n    },\n\n    /**\n     * Return the suspend data\n     * @param {object} data\n     * @param {object} settings\n     * @return {boolean}\n     */\n    getState: function(data, settings) {\n      var me = this;\n      if (me.initialised) {\n        settings.success(me.suspendData);\n        return true;\n      }\n      settings.error();\n      return false;\n    },\n\n    /**\n     * Get the last visited location...\n     * @param {object} data\n     * @param {object} settings\n     * @return {boolean}\n     */\n    getLastLocation: function(data, settings) {\n      var me = this;\n      if (me.initialised) {\n        settings.success(me.lessonLocation);\n        return true;\n      }\n      settings.error();\n      return false;\n    },\n\n    /**\n     * Get the course status\n     * @param {object} data\n     * @param {object} settings\n     * @return {boolean}\n     */\n    getCompletionStatus: function(data, settings) {\n      var me = this;\n      if (me.initialised) {\n        if (me.scorm.version === '1.2') {\n          settings.success(me.lessonStatus);\n        } else if (me.scorm.version === '2004') {\n          if (me.lessonStatus.success === 'unknown') {\n            settings.success(me.lessonStatus.completion);\n          } else if (me.lessonStatus.completion === 'unknown') {\n            settings.success(me.lessonStatus.success);\n          } else {\n            settings.success(me.lessonStatus.completion);\n          }\n        }\n        return true;\n      }\n      settings.error();\n      return false;\n    },\n\n    /**\n     * Get the course score\n     * @param {object} data\n     * @param {object} settings\n     * @return {boolean}\n     */\n    getScore: function(data, settings) {\n      var me = this;\n      if (me.initialised) {\n        settings.success(me.lessonScore);\n        return true;\n      }\n      settings.error();\n      return false;\n    },\n\n    /**\n     * Score the course...\n     * @param {object} scoreData\n     * @param {object} settings\n     * @return {boolean}\n     */\n    score: function(scoreData, settings) {\n      var me = this;\n\n      // Validate the score\n      var score;\n      if (_.isObject(scoreData) && _.isNumber(scoreData.raw)) {\n        score = scoreData.raw;\n      } else {\n        score = parseInt(scoreData);\n      }\n\n      // If it's initialised, set the score...\n      if (me.initialised && !isNaN(score)) {\n        me.lessonScore = score;\n        me.scorm.set('score', score, function() {\n          settings.success();\n        });\n        return true;\n      }\n      settings.error();\n      return false;\n    },\n\n    summarise: function(callback, suppressSave) {\n      var me = this;\n      suppressSave = (suppressSave || false);\n\n      callback = ((typeof callback == 'function') ? callback : function() {});\n      if (me.initialised) {\n        var doneLocation = false;\n        var doneSuspend = false;\n        var doneStatus = false;\n        var doneTime = false;\n        var encodedLessonLocation = global.gomo.utility.Base64.encodeObject(me.lessonLocation);\n        // Ensure we've set the items we are holding...\n        me.scorm.set('location', encodedLessonLocation, function() {\n          // Don't duplicate\n          if (doneLocation) {\n            return false;\n          }\n          doneLocation = true;\n          var composedSuspendData = me.composeObject(me.suspendData, me.preferences.suspendData);\n          me.scorm.set('cmi.suspend_data', composedSuspendData, function() {\n            // Don't duplicate\n            if (doneSuspend) {\n              return false;\n            }\n            doneSuspend = true;\n            //\n            me.setLessonStatus(me.lessonStatus, undefined, function() {\n              // Don't duplicate\n              if (doneStatus) {\n                return false;\n              }\n              doneStatus = true;\n              //\n              me.updateSessionTime(function() {\n                // Don't duplicate\n                if (doneTime) {\n                  return false;\n                }\n                doneTime = true;\n                // SCORM commit\n                if (suppressSave == true) {\n                  callback(true);\n                } else {\n                  me.scorm.save(function(success) {\n                    callback(success);\n                  });\n                }\n              });\n            });\n          });\n        });\n        return true;\n      }\n      return false;\n    },\n\n    /**\n     * Set the lesson status\n     * @param {(string|object)} status\n     * @param {object} score\n     * @param {function} callback\n     * @return {boolean}\n     */\n    setLessonStatus: function(status, score, callback) {\n      var me = this;\n      var currentStatus = status;\n      callback = ((typeof callback == 'function') ? callback : function() {});\n      if (currentStatus) {\n        if (me.isReverseStatus(currentStatus)) {\n          currentStatus = me.lessonStatus;\n        }\n        me.lessonStatus = currentStatus;\n        me.scorm.set('status', currentStatus, function() {\n          if (isNaN(score) && typeof score !== 'object') {\n            callback();\n          }\n        });\n        // Save everything...\n        return true;\n      }\n      callback();\n      return false;\n    },\n\n    /**\n     * @param {object} data\n     * @param {string} version\n     * @return {array}\n     */\n    extractCMIInteractionsFromInteractionData: function(data, version) {\n      var me = this;\n\n      // parameter validation\n      var criteria = [\n        _.isObject(data),\n        _.isString(version),\n        _.contains(['1.2', '2004'], version)\n      ];\n      if (!_.every(criteria)) {\n        return null;\n      }\n      data.activity = data.activity || {};\n      data.result = data.result || {};\n      data.response = data.response || {};\n\n      // validate activity type\n      if (_.isString(data.activity.type) &&\n        !_.contains(scormInteractionTypes[version], data.activity.type)) {\n        return [];\n      }\n\n      // elements common to both 1.2 and 2004\n      var elems = [];\n      elems.push(['id', _.isString(data.id) ? data.id.replace(/\\s+/, '-') : null]);\n      elems.push(['type', data.activity.type]);\n      elems.push(['weighting', data.activity.weighting]);\n\n      // correct responses (common to both 1.2 and 2004, except tokenification of 2004)\n      if (_.isObject(data.activity) && _.isArray(data.activity.correctResponses)) {\n        _.each(data.activity.correctResponses, function(correctResponse, index) {\n          elems.push([\n            'correct_responses.' + index.toString() + '.pattern',\n            me.tokenify(version, correctResponse)\n          ]);\n        });\n      }\n\n      // elements which vary between 1.2 and 2004\n      switch (version) {\n        case '1.2':\n          elems.push(['result', data.result.detail === 'incorrect' ? 'wrong' : data.result.detail]);\n          elems.push(['latency', me.dateRangeToSCORM12CMITimespan(\n            data.response.timeResponse,\n            data.response.timeAvailable\n          )]);\n          elems.push(['time', me.dateToSCORM12CMITime(data.response.timeAvailable)]);\n          elems.push(['student_response', data.response.detail]); // no tokenification for SCORM 1.2\n          break;\n\n        case '2004':\n          elems.push(['result', data.result.detail]);\n          elems.push(['latency', me.dateRangeToSCORM2004TimeInterval(\n            data.response.timeResponse,\n            data.response.timeAvailable\n          )]);\n          elems.push(['timestamp', me.dateToSCORM2004Time(data.response.timeAvailable)]);\n          elems.push(['learner_response', me.tokenify('2004', data.response.detail)]);\n          elems.push(['description', data.activity.description]);\n          break;\n      }\n\n      // reject/discard invalid values\n      var isInvalid = function(val) {\n        return _.isUndefined(val) || _.isNull(val) || _.isNaN(val);\n      };\n      return _.reject(elems, function(elem) {\n        return isInvalid(_.last(elem));\n      });\n    },\n\n    /**\n     * @param {number} count\n     * @param {function} set\n     * @param {array} elems\n     * @return {array} containing an element string per failed element\n     */\n    setCMIInteractions: function(count, set, elems) {\n      // parameter validation\n      var criteria = [\n        _.isNumber(count),\n        _.isFunction(set),\n        _.isArray(elems)\n      ];\n      if (!_.every(criteria)) {\n        return null;\n      }\n\n      // filter by supported interaction elements\n      var supportedInteractionElements = this.supportedInteractionElements;\n      if (!_.isString(supportedInteractionElements)) {\n        return [];\n      }\n      supportedInteractionElements = this.supportedInteractionElements.split(',');\n      elems = _.filter(elems, function(elem) {\n        return _.contains(\n          supportedInteractionElements,\n          _.first(_.first(elem).split('.'))\n        );\n      });\n\n      // send each (supported) interaction element\n      var prefix = 'cmi.interactions.' + count + '.';\n      var results = [];\n      _.forEach(elems, function(elem) {\n        var f = _.first(elem);\n        var l = _.last(elem);\n        set(prefix + f, l, function(success) {\n          results.push(success ? null : f);\n        });\n      });\n      return _.filter(results, _.isString);\n    },\n\n    /**\n     * For SCORM 1.2\n     * CMITime: A chronological point in a 24 hour clock. Identified in hours, minutes\n     * and seconds in the format: HH:MM:SS.SS\n     * Hours and minutes shall contain exactly 2 digits. Seconds shall contain\n     * 2 digits, with an optional decimal point and 1 or 2 additional digits (i.e. 34.45).\n     * @param {Date} date\n     * @return {?string}\n     */\n    dateToSCORM12CMITime: function(date) {\n      if (!_.isDate(date)) {\n        return null;\n      }\n      return date.toISOString().substr(11, 8);\n    },\n\n    /**\n     * For SCORM 2004\n     * The time (second,10,0) data type represents a point in time. This\n     * data type shall have a required precision of 1 second and an optional precision of 0.01\n     * seconds\n     * @param {Date} date\n     * @return {?string}\n     */\n    dateToSCORM2004Time: function(date) {\n      if (!_.isDate(date)) {\n        return null;\n      }\n      var retval = date.toISOString();\n      return retval.substr(0, 22) + retval.substr(-1);\n    },\n\n    /**\n     * For SCORM 1.2\n     * CMITimespan: A length of time in hours, minutes and seconds shown in the following\n     * numerical format: HHHH:MM:SS.SS\n     * Hours have a minimum of 2 digits and a maximum of 4 digits. Minutes\n     * shall consist of exactly 2 digits. Seconds shall contain 2 digits, with an\n     * optional decimal point and 1 or 2 additional digits. (i.e. 34.45).\n     * @param {Date} upper\n     * @param {Date} lower\n     * @return {?string}\n     */\n    dateRangeToSCORM12CMITimespan: function(upper, lower) {\n      if (!_.isDate(upper) || !_.isDate(lower)) {\n        return null;\n      }\n      var timeSpan = Math.abs(upper.getTime() - lower.getTime());\n      var inSeconds = Math.round(timeSpan / 1000);\n      var hours = Math.floor(inSeconds / 3600);\n      inSeconds -= hours * 3600;\n      var minutes = Math.floor(inSeconds / 60);\n      inSeconds -= minutes * 60;\n      var seconds = inSeconds;\n      return _.map(\n        [hours, minutes, seconds],\n        function(n) {\n          return n < 10 ? ('0' + n.toString()) : n.toString();\n        }\n      ).join(':');\n    },\n\n    /**\n     * For SCORM 2004\n     * The timeinterval (second, 10, 2) denotes that the value for\n     * the data model element timeinterval represents elapsed time with a precision of 0.01\n     * seconds.\n     * @param {Date} upper\n     * @param {Date} lower\n     * @return {?string}\n     */\n    dateRangeToSCORM2004TimeInterval: function(upper, lower) {\n      if (!_.isDate(upper) || !_.isDate(lower)) {\n        return null;\n      }\n      var cmiTimespan = this.dateRangeToSCORM12CMITimespan(upper, lower);\n      var bits = cmiTimespan.split(':');\n      return 'PT' + bits[0] + 'H' + bits[1] + 'M' + bits[2] + 'S';\n    },\n\n    /**\n     * For SCORM 2004\n     * \"An ISO-10646-1 character string representing a bag of records,\n     * where each record consists of two short_identifier_types  a source and a target.\n     * The records short_identifier_types are separated by a special reserved token ([.]).\n     * Each record in the bag is separated by a special reserved token ([,]).\"\n     * @param {string} version\n     * @param {string} s\n     * @return {string}\n     */\n    tokenify: function(version, s) {\n      if (version !== '2004' || !_.isString(s)) {\n        return s;\n      }\n      return s.replace(/,/g, '[,]').replace(/\\./g, '[.]');\n    },\n\n    /**\n     * Set the min and maximum scores\n     */\n    setMinAndMax: function() {\n      var me = this;\n      // These values should come from SCORM config\n      // default to 0 and 100 for now...\n      me.scorm.set('max', 100);\n      me.scorm.set('min', 0);\n    },\n\n    /**\n     * Set the GEOJSON\n     * @param {object} geoJSON\n     * @param {object} settings\n     * @return {boolean}\n     */\n    setGeoJSON: function(geoJSON, settings) {\n      settings && settings.success();\n      return false;\n    },\n\n    /**\n     * Polling to keep the connection to\n     * SCORM engine active.\n     * @param {object} data\n     * @param {object} settings\n     * @return {boolean}\n     */\n    poll: function(data, settings) {\n      var me = this;\n      // Perform a commit - this has the effect of keeping SCORM active\n      // and also keeping SCORM record up to date in-case of early closes etc.\n      if (me.initialised) {\n        me.summarise(function(success) {\n          if (success) {\n            settings.success();\n            return true;\n          } else {\n            settings.error();\n            return false;\n          }\n        });\n      } else {\n        settings.error();\n        return false;\n      }\n    },\n\n    /**\n     * Update Session Time\n     * @param {function} callback\n     */\n    updateSessionTime: function(callback) {\n      var me = this;\n      var now = new Date();\n      var elapsed = new Date(now - me.startTime);\n      // Make time-zone adjustments...\n      elapsed.setTime(elapsed.getTime() + elapsed.getTimezoneOffset()*60*1000);\n      // Now get the elapsed hrs, mins, secs\n      var elapsedHours = elapsed.getHours();\n      var elapsedMinutes = elapsed.getMinutes();\n      var elapsedSeconds = elapsed.getSeconds();\n\n      elapsedHours = (elapsedHours < 10 ? '0' : '') + elapsedHours;\n      elapsedMinutes = (elapsedMinutes < 10 ? '0' : '') + elapsedMinutes;\n      elapsedSeconds = (elapsedSeconds < 10 ? '0' : '') + elapsedSeconds;\n\n      // Set session time...\n      me.sessionTime = elapsedHours + ':' + elapsedMinutes + ':' + elapsedSeconds;\n      me.scorm.set(\n        'session_time',\n        me.scorm.version === '2004' ? me.dateRangeToSCORM2004TimeInterval(\n          now,\n          me.startTime\n        ) : me.sessionTime,\n        callback\n      );\n    },\n\n    testForJson: function(str) {\n      try {\n        // Parse the data\n        JSON.parse(str);\n      } catch (e) {\n        try {\n          // Is it Base64 encoded?\n          var tmp = global.gomo.utility.Base64.decode(str);\n          JSON.parse(tmp);\n        } catch (e) {\n          // Unable to parse\n          return false;\n        }\n      }\n      return true;\n    },\n\n    /**\n     * Convert old Suspend data type to new data type\n     * gomo 2.2 < data support from LMS return\n     * @param {function} callback\n     */\n    legacySuspendConverter: function(callback) {\n      var me = this;\n      // Suspend data\n      me.scorm.get('cmi.suspend_data', function(suspendData) {\n        //\n        var jsonTracking = me.testForJson(suspendData);\n        if (!jsonTracking) {\n          // de-serialise\n          DESERILAIZER.setDataString(suspendData);\n          var tempSuspendData = DESERILAIZER.getItem('suspendData');\n          if (tempSuspendData) {\n            if (tempSuspendData.strUserVersionChoice != '') {\n              me.suspendData.strUserVersionChoice = tempSuspendData.strUserVersionChoice;\n            }\n            if (tempSuspendData.strTracking) {\n              me.suspendData.courseState = tempSuspendData.strTracking;\n            }\n          }\n        }\n        // Call the callback...\n        ((typeof callback == 'function') ? callback : function() {})();\n      });\n    },\n\n    /**\n     * Convert old Suspend data type to new data type\n     * gomo 2.2 < data support from LMS return\n     * @param {string} lesson\n     * @return {(string|object)}\n     */\n    legacyLessonConverter: function(lesson) {\n      var me = this;\n      var jsonTracking = me.testForJson(lesson);\n      var locationSeperator = '::::';\n\n      if (!jsonTracking && ~lesson.indexOf(locationSeperator)) {\n        var tmpLesson = lesson;\n        var topicId = tmpLesson.split(locationSeperator)[0];\n        var pageId = tmpLesson.split(locationSeperator)[1];\n        var pageTitle = tmpLesson.split(locationSeperator)[2];\n        return {\n          topicId: topicId,\n          pageId: pageId,\n          pageTitle: pageTitle\n        };\n      }\n      return lesson;\n    },\n\n    /**\n     * OnPoint LMS escapes the lesson location string\n     * This means our leading and trailing brackets are HTML character encoded and therefore\n     * need replacing before trying to parse the string.\n     * @param {string} str\n     * @return {string}\n     */\n    replaceEscapedBrackets: function(str) {\n      if (typeof str == 'string') {\n        // Is the beginning { escaped?\n        if (str.substring(0, 5) == '&123;') {\n          str = '{' + str.substr(5);\n        }\n        // Is the ending } escaped?\n        if (str.substr(-5) == '&125;') {\n          str = str.substring(0, str.length-5) + '}';\n        }\n      }\n      return str;\n    },\n\n    /**\n     * for SCORM 1.2, it's a string\n     * cmi.core.lesson_status (passed, completed, failed, incomplete, browsed, not attempted, RW)\n     *\n     * for SCORM 2004, it's an object with two properties (completion and success statuses)\n     * cmi.completion_status (completed, incomplete, not attempted, unknown, RW)\n     * cmi.success_status (passed, failed, unknown, RW)\n     */\n    setLessonStatusIncomplete: function() {\n      var me = this;\n      var s = 'incomplete';\n      if (me.scorm.version === '1.2') {\n        me.lessonStatus = s;\n      } else if (me.scorm.version === '2004') {\n        me.lessonStatus.completion = s;\n      }\n    },\n\n    /**\n     * for SCORM 1.2, it's a string\n     * cmi.core.lesson_status (passed, completed, failed, incomplete, browsed, not attempted, RW)\n     *\n     * for SCORM 2004, it's an object with two properties (completion and success statuses)\n     * cmi.completion_status (completed, incomplete, not attempted, unknown, RW)\n     * cmi.success_status (passed, failed, unknown, RW)\n     */\n    setDefaultLessonStatus: function() {\n      var me = this;\n      var s = 'not attempted';\n      if (me.scorm.version === '1.2') {\n        me.lessonStatus = s;\n      } else if (me.scorm.version === '2004') {\n        me.lessonStatus = {\n          'completion': s,\n          'success': 'unknown'\n        };\n      }\n    },\n\n    /**\n     * @return {boolean}\n     */\n    isLessonStatusNotAttempted: function() {\n      var me = this;\n      var s = 'not attempted';\n      if (me.scorm.version === '1.2') {\n        return me.lessonStatus === s;\n      } else if (me.scorm.version === '2004') {\n        return me.lessonStatus.completion === s;\n      }\n      throw new Error('Unsupported SCORM version');\n    },\n\n    /**\n     * determines whether the given status would 'reverse' the current status, e.g., if the lesson has already been\n     * passed but the given status is a failure\n     * @param {(string|object)} status\n     * @return {boolean}\n     */\n    isReverseStatus: function(status) {\n      var me = this;\n      if (me.scorm.version === '1.2') {\n        return (_.contains(['started', 'incomplete'], status) &&\n          _.contains(['completed', 'passed', 'failed'], me.lessonStatus)) ||\n         (status === 'completed' && _.contains(['passed', 'failed'], me.lessonStatus)) ||\n         (status === 'failed' && me.lessonStatus === 'passed');\n      } else if (me.scorm.version === '2004') {\n        return (_.contains(['started', 'incomplete'], status.completion) &&\n          _.contains(['passed', 'failed'], me.lessonStatus.success)) ||\n         (_.contains(['started', 'incomplete'], status.completion) &&\n         me.lessonStatus.completion === 'completed') ||\n         (status.success === 'failed' && me.lessonStatus.success === 'passed');\n      }\n      throw new Error('Unsupported SCORM version');\n    }\n  };\n\n  return SCORM;\n})(global.$);\n"},function(n,e,t){t(0)(t(57))},function(n,e){n.exports="\n/* global _, TinCan, TOPIC_MANAGER */\n/* eslint-disable valid-jsdoc, require-jsdoc */\n\n/**\n* TinCan Tracking Adapter\n* @author Adam Fox\n*/\n\nvar global = this;\n\nglobal.GOMO_TINCAN = (function($, TinCanRegistry) {\n  // @see {@link https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#interactionacts}\n  var interactionTypes = [\n    'true-false',\n    'choice',\n    'fill-in',\n    'long-fill-in',\n    'matching',\n    'performance',\n    'sequencing',\n    'likert',\n    'numeric',\n    'other'\n  ];\n\n  /**\n   * TINCAN\n   * @constructor\n   */\n  function TINCAN(config) {\n    var me = this;\n    me.tincan = null;\n    me.version = null;\n    me.baseURL = 'http://www.gomolearning.com/xapi/';\n    me.startTime = null;\n    me.user = null;\n    me.userIsSet = false;\n    me.actor = null;\n\n    var stores = [];\n\n    var url = window.location.toString();\n    var urlParts = url.split(':');\n    var protocol = 'http';\n    var pendingSave = false;\n    if (urlParts.length) {\n      protocol = urlParts.shift().toLowerCase();\n      protocol = (protocol == 'http' || protocol == 'https' ? protocol : 'http');\n      url = protocol + ':' + urlParts.join(':');\n    }\n\n    // If it's an array then only pull the first item\n    if (config instanceof Array) {\n      // Collect all stores...\n      for (var i=0; i<config.length; i++) {\n        var currentStore = config[i];\n        me.version = currentStore.version || '1.0.0';\n        delete currentStore.version;\n\n        // Add the protocol if necessary...\n        if (currentStore.endpoint && /^\\/\\//g.test(currentStore.endpoint)) {\n          currentStore.endpoint = protocol + ':' + currentStore.endpoint;\n        }\n\n        // Find any enpoint parameters\n        if (currentStore.endpoint) {\n          var parsedURL = me.parseURL(currentStore.endpoint);\n          if (parsedURL.url) {\n            currentStore.endpoint = parsedURL.url;\n            currentStore.extended = parsedURL.params;\n          }\n\n          // Add store\n          stores.push(currentStore);\n        }\n      }\n    }\n\n    // Create tincan instance\n    me.tincan = new TinCan({\n      recordStores: stores,\n      version: me.version,\n      url: url\n    });\n\n    // Check actor and set as current user.\n    if (me.tincan.actor) {\n      var user = {\n        id: me.tincan.actor.mbox || TinCan.Utils.getSHA1String(\n          JSON.stringify(me.tincan.actor.account)\n        ),\n        name: me.tincan.actor.name\n      };\n      me.setUser(user);\n    }\n\n    me.initialised = true;\n  }\n\n  /**\n   * Extend the ContentTracking\n   */\n  TINCAN.prototype = {\n\n    initialised: false,\n    startTime: null,\n    startData: null,\n    stateData: null,\n    courseLocation: null,\n    courseActivity: null,\n    courseStatus: 'incomplete',\n    courseScore: 0,\n    geoJSON: null,\n    checkedIn: false,\n\n    /**\n     * Start the TINCAN adapter!\n     */\n    start: function(startData, settings) {\n      var me = this;\n\n      // Don't start the adapter if it hasn't been set correctly\n      if (me.actor == null) {\n        return;\n      }\n\n      startData = startData || {};\n      startData.id = startData.id || undefined;\n      startData.name = startData.name || undefined;\n      startData.description = startData.description || undefined;\n      me.startData = startData;\n\n      // Set the start time!\n      me.startTime = new Date();\n\n      // Build activity for start statement\n      var activity = {\n        type: 'course',\n        id: me.startData.id,\n        title: me.startData.name,\n        description: me.startData.description\n      };\n\n      // Add GEOJSON\n      activity.extensions = me.addGeoJSONExtension(activity.extensions);\n\n      me.courseActivity = activity;\n\n      // Get the state data...\n      me.stateData = me.getLiveState('courseState', me.courseActivity);\n      me.courseLocation = me.getLiveState('courseLocation', me.courseActivity);\n\n      // Add platform to start data...\n      var extensions = {};\n      extensions[TinCanRegistry.extensions['browser-info'].id] = {\n        'code_name': navigator.appCodeName,\n        'name': navigator.appName,\n        'version': navigator.appVersion,\n        'platform': navigator.platform,\n        'user-agent-header': navigator.userAgent,\n        'cookies-enabled': navigator.cookieEnabled\n      };\n      var extra = {\n        context: {\n          platform: gomo.outputChecker.isSmartPhone()\n            ? 'phone'\n            : (gomo.outputChecker.isTablet() ? 'tablet' : 'desktop'),\n          extensions: extensions\n        }\n      };\n\n      // Send appropriate statement\n      if (me.courseLocation && me.courseLocation.topicId) {\n        me.sendStatement('resumed', activity, extra, settings.success);\n      } else {\n        me.sendStatement('launched', activity, extra, settings.success);\n      }\n    },\n\n    /**\n     * End the TINCAN tracking!\n     */\n    end: function(endData, settings) {\n      var me = this;\n\n      // Build activity for start statement\n      var activity = {};\n      if (endData && (endData.id || endData.name)) {\n        activity = {\n          type: 'course',\n          id: endData.id || undefined,\n          title: endData.name || undefined,\n          description: endData.description || undefined\n        };\n      } else {\n        activity = me.courseActivity;\n      }\n\n      // Add duration to exited statement...\n      activity.extensions = {};\n      activity.extensions[TinCanRegistry.extensions['duration'].id] =\n        me.createDuration(me.startTime, new Date());\n\n      // Add GEOJSON\n      activity.extensions = me.addGeoJSONExtension(activity.extensions);\n\n      // Add duration to result block...\n      var extra = {\n        result: {\n          duration: me.createDuration(me.startTime, new Date())\n        }\n      };\n\n      // Send the statement\n      me.sendStatement('exited', activity, extra, settings.success);\n    },\n\n    getUser: function(settings) {\n      var me = this;\n      return me.user;\n    },\n\n    setUser: function(user) {\n      var me = this;\n      // User.id will only be set if the url has tincan data params included\n      if (user && user.id) {\n        // Set the correct email address\n        var emailAddress = null;\n        if (typeof me.tincan !== 'undefined' && me.tincan !== null\n        && typeof me.tincan.actor !== 'undefined' && me.tincan.actor !== null\n        && typeof me.tincan.actor.account !== 'undefined' && me.tincan.actor.account !== null) {\n          emailAddress = me.tincan.actor.account.name;\n        }\n\n        if (emailAddress == null || emailAddress.indexOf('@') == 0) {\n          var userId = user.id.toString();\n          emailAddress = userId + (!~userId.indexOf('@') ? '.xapiuser@gomolearning.com' : '');\n        }\n\n        me.user = user;\n        if (me.tincan.actor) {\n          me.actor = me.tincan.actor;\n        } else {\n          me.actor = me.createActor({\n            mbox: emailAddress,\n            name: me.user.name\n          });\n        }\n        me.userIsSet = true;\n      } else if (user && user.name) {\n        if (me.user == null) {\n          me.user = {};\n        }\n        me.user.name = user.name;\n      }\n    },\n\n    setPreferences: function(preferences, settings) {\n      if (settings && settings.success) {\n        settings.success();\n      }\n    },\n\n    /**\n     * Set the GEOJSON\n     */\n    setGeoJSON: function(geoJSON, settings) {\n      var me = this;\n      me.geoJSON = geoJSON;\n      me.checkIn();\n      if (settings && settings.success) {\n        settings.success();\n      }\n      return true;\n    },\n\n    /**\n     * Page visit\n     */\n    visit: function(visitData, settings) {\n      var me = this;\n      me.courseLocation = visitData;\n      var extra = {\n        context: {\n          extensions: {}\n        }\n      };\n\n      var activity = {\n        type: 'page',\n        id: visitData.pageId,\n        title: visitData.pageTitle,\n        description: null\n      };\n\n      extra.context.contextActivities = {\n        parent: [{\n          id: me.baseURL + 'activities/module/' + visitData.topicId,\n          objectType: 'Activity'\n        }]\n      };\n\n      if (visitData.referrer) {\n        extra.context.extensions = me.createReferrerExtension(visitData.referrer);\n      }\n\n      extra.context.extensions[me.baseURL + 'extension/progress'] = visitData.progress;\n\n      // Add GEOJSON\n      activity.extensions = {};\n      activity.extensions = me.addGeoJSONExtension(activity.extensions);\n      me.checkIn();\n\n      me.sendStatement('experienced', activity, extra, null);\n\n      // Check if we are in an assessment topic and do not save lesson location if we are. This is\n      // to stop bookmarking taking us back into an assessment.\n      if (TOPIC_MANAGER.shouldSetLessonLocation()) {\n        me.saveLiveState('courseLocation', visitData, me.courseActivity, function(status) {\n          if (status == null) {\n            settings.success();\n          } else {\n            settings.error();\n          }\n        });\n      }\n    },\n\n    /**\n     * Screen changed\n     * @param {object} data Completion data\n     * @param {object} settings\n     */\n    screenChanged: function(data, settings) {\n      var me = this;\n      var extra = {\n        context: {}\n      };\n      var activity = {\n        type: 'page',\n        id: data.pageId,\n        title: data.pageTitle\n      };\n\n      extra.context.contextActivities = {\n        parent: [{\n          id: me.baseURL + 'activities/module/' + data.topicId,\n          objectType: 'Activity'\n        }]\n      };\n\n      if (data.referrer) {\n        extra.context.extensions = me.createReferrerExtension(data.referrer);\n      }\n\n      // populate result.duration from timeAvailable and timeCompleted\n      if (_.isDate(data.timeAvailable) && _.isDate(data.timeCompleted)) {\n        extra.result = {\n          duration: me.createDuration(\n            data.timeAvailable,\n            data.timeCompleted\n          )\n        };\n      }\n\n      me.sendStatement('left', activity, extra, null);\n    },\n\n    /**\n     * Topic visit\n     */\n    topicVisit: function(visitData, settings) {\n      var me = this;\n\n      var extra = {\n        context: {\n          extensions: {}\n        }\n      };\n\n      var activity = {\n        type: visitData.topicType,\n        id: visitData.topicId,\n        title: visitData.topicTitle\n      };\n\n      extra.context.extensions[me.baseURL + 'extension/progress'] = visitData.progress;\n\n      // Add GEOJSON\n      activity.extensions = {};\n      activity.extensions = me.addGeoJSONExtension(activity.extensions);\n      me.checkIn();\n\n      me.sendStatement('experienced', activity, extra, null);\n    },\n\n    /**\n     * Topic completed\n     * @param {object} data Completion data\n     * @param {object} settings\n     */\n    topicCompleted: function(data, settings) {\n      var me = this;\n      var extra = {\n        context: {},\n        result: {\n          completion: data.completed\n        }\n      };\n      var activity = {\n        type: data.topicType,\n        id: data.topicId,\n        title: data.topicTitle\n      };\n\n      extra.context.contextActivities = {\n        parent: [{\n          id: me.baseURL + 'activities/course/' + me.courseActivity.id,\n          objectType: 'Activity'\n        }]\n      };\n\n      // populate result.duration from timeAvailable and timeCompleted\n      if (_.isDate(data.timeAvailable) && _.isDate(data.timeCompleted)) {\n        extra.result.duration = me.createDuration(\n          data.timeAvailable,\n          data.timeCompleted\n        );\n      }\n\n      me.sendStatement('completed', activity, extra, null);\n    },\n\n    /**\n     * Interaction...\n     * Split these up in to relevant scorm calls..\n     */\n    interaction: function(interactionData, settings) {\n      var me = this;\n\n      // avoid mutating given interaction data by creating a (shallow) clone of its 'result' property\n      var extra = {\n        result: _.clone(interactionData.result)\n      };\n\n      if (interactionData.resultExtention && interactionData.resultExtention.id) {\n        var extentionId = TinCanRegistry.extensions[interactionData.resultExtention.id].id;\n        extra.result.extensions = {};\n        extra.result.extensions[extentionId] = interactionData.resultExtention.value;\n      }\n\n      if (interactionData.referrer) {\n        extra.context = {\n          extensions: me.createReferrerExtension(interactionData.referrer)\n        };\n      }\n\n      if (_.has(interactionData, 'parent')) {\n        extra.context = extra.context || {};\n        extra.context.contextActivities = {};\n\n        extra.context.contextActivities.parent = [{\n          id: me.baseURL + 'activities/' + interactionData.parent,\n          objectType: 'Activity'\n        }];\n      }\n\n      // add duration to course completion statements\n      if (interactionData.activity.type &&\n        interactionData.activity.type == 'course' &&\n        interactionData.type &&\n        interactionData.type == 'completed'\n      ) {\n        extra.result.duration = me.createDuration(me.startTime, new Date());\n      }\n\n      // if a statement has explicitly defined object data then use it\n      if (_.isObject(interactionData.object)) {\n        extra.object = interactionData.object;\n      }\n\n      if (_.isObject(interactionData.response)) {\n        // populate result.response from response.detail\n        if (_.isString(interactionData.response.detail)) {\n          extra.result.response = interactionData.response.detail;\n        }\n\n        // populate result.duration from response.timeAvailable and response.timeResponse\n        if (_.isDate(interactionData.response.timeAvailable)\n            &&\n            _.isDate(interactionData.response.timeResponse)) {\n          extra.result.duration = me.createDuration(\n            interactionData.response.timeAvailable,\n            interactionData.response.timeResponse\n          );\n        }\n      }\n\n      if (interactionData.topicGrouping) {\n        extra.topicGrouping = true;\n      }\n\n      if (interactionData.activity.type === 'asset' && interactionData.assetType) {\n        extra.assetType = interactionData.assetType;\n      }\n\n      if (_.isEmpty(extra.result)) {\n        delete extra.result;\n      }\n\n      // Send statement to TinCan API\n      me.sendStatement(interactionData.type,\n        interactionData.activity,\n        extra,\n        function(result) {\n          if (result == null) {\n            settings.success();\n          } else {\n            settings.error();\n          }\n        });\n    },\n\n    /**\n     * Save the passed state to suspend data\n     */\n    saveState: function(stateData, settings) {\n      var me = this;\n      if (me.pendingSave) return;\n      me.pendingSave = true;\n      me.stateData = stateData.state;\n      // Delay save to stop multiple saves sending incorrect data.\n      setTimeout(function() {\n        me.saveLiveState('courseState', me.stateData, me.courseActivity, function(status) {\n          if (status == null) {\n            settings.success();\n          } else {\n            settings.error();\n          }\n        });\n        me.pendingSave = false;\n      }, 100);\n    },\n\n    /**\n     * Return the suspend data\n     */\n    getState: function(data, settings) {\n      var me = this;\n      settings.success(me.stateData);\n    },\n\n    /**\n     * Get the last visited location...\n     */\n    getLastLocation: function(data, settings) {\n      var me = this;\n      settings.success(me.courseLocation);\n    },\n\n    /**\n     * Get the course status\n     */\n    getCompletionStatus: function(data, settings) {\n      var me = this;\n      if (me.initialised) {\n        settings.success(me.courseStatus);\n        return true;\n      }\n      settings.error();\n      return false;\n    },\n\n    /**\n     * Get the course score\n     */\n    getScore: function(data, settings) {\n      var me = this;\n      if (me.initialised) {\n        settings.success(me.courseScore);\n        return true;\n      }\n      settings.error();\n      return false;\n    },\n\n    score: function(data, settings) {\n      var me = this;\n      // SCORE the course\n      var activity = me.courseActivity;\n      var extra = {\n        result: {\n          score: data\n          // {\n          //   min: 0,\n          //   max: 100,\n          //   raw: data\n          // }\n        }\n      };\n      me.sendStatement('scored', activity, extra, settings.success);\n      return true;\n    },\n\n    /**\n     *\n     */\n    summarise: function(summaryData, settings) {\n      // Nothing to do here!\n      settings.success();\n    },\n\n\n    /**\n     * Polling, can be used to keep connection active...\n     */\n    poll: function(data, settings) {\n      // Nothing to do here!\n      settings.success();\n    },\n\n\n    // Private methods\n\n    addGeoJSONExtension: function(extensions) {\n      var me = this;\n      // Check we have extensions object...\n      if (extensions && typeof extensions === 'object') {\n        if (me.geoJSON) {\n          var geo = me.geoJSON;\n          // geoJSON should be JSON, but just ensure it is...\n          if (typeof geo === 'string') {\n            geo = JSON.parse(geo);\n          }\n          // Add the extension!\n          extensions[TinCanRegistry.extensions['geojson'].id] = geo;\n        }\n      }\n      return extensions;\n    },\n\n    checkIn: function() {\n      var me = this;\n      if (!me.checkedIn && me.geoJSON && me.initialised) {\n        if (me.startData) {\n          // Format the activity\n          var activity = {\n            type: 'course',\n            id: me.startData.id,\n            title: me.startData.name,\n            description: me.startData.description,\n            extensions: {}\n          };\n          activity.extensions = me.addGeoJSONExtension(activity.extensions);\n          me.sendStatement('logged-in', activity, null);\n          me.checkedIn = true;\n        }\n      }\n    },\n\n    /**\n     *\n     */\n    createActor: function(actor) {\n      if (actor) {\n        return new TinCan.Agent(actor);\n      }\n      return null;\n    },\n\n    /**\n     *\n     *\n     */\n    sendStatement: function(verb, activity, extra, callback) {\n      var me = this;\n\n      callback = callback || new Function();\n\n      var tcVerb = me.createVerb(verb);\n      if (typeof tcVerb != 'object') {\n        callback(0);\n        return false;\n      }\n\n      // Create TinCan statement definition\n      var statementDefinition = {\n        actor: me.createActor(me.actor),\n        verb: tcVerb,\n        target: me.createActivity(activity, extra),\n        version: me.version,\n        context: {}\n      };\n\n      // Add any context information\n      if (extra && extra.context) {\n        statementDefinition.context = extra.context;\n      }\n\n      // Add gomo context source context...\n      statementDefinition.context.contextActivities =\n        me.createSourceTag(statementDefinition.context.contextActivities);\n\n      // Add any extra statements which are supported.\n      if (extra && extra.result) {\n        // @see {@link https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#245-result}\n        if (verb === 'answered'\n            &&\n            activity\n            &&\n            activity.type\n            &&\n            (activity.type === 'question' || _.contains(interactionTypes, activity.type))) {\n          extra.result.completion = true;\n        }\n        statementDefinition.result = me.createResult(extra.result, verb);\n      }\n\n      // Save course level details\n      if ((activity && activity.type && activity.type == 'course') || activity == 'course') {\n        switch (verb) {\n          case 'completed':\n            me.courseStatus = verb;\n            break;\n          case 'passed':\n          case 'failed':\n            me.courseStatus = verb;\n            break;\n          case 'scored':\n            if (extra && extra.result && extra.result.score) {\n              if (!isNaN(+extra.result.score.raw)) {\n                me.courseScore = +extra.result.score.raw;\n              }\n            }\n            break;\n        }\n      }\n\n      // Add grouping to all statements\n      if (me.courseActivity && me.courseActivity.id) {\n        statementDefinition.context = statementDefinition.context || {};\n        statementDefinition.context.contextActivities =\n          statementDefinition.context.contextActivities || {};\n        statementDefinition.context.contextActivities.grouping = [\n          {\n            id: 'http://www.gomolearning.com/xapi/activities/course/' + me.courseActivity.id,\n            objectType: 'Activity'\n          }\n        ];\n\n        if (extra && extra.topicGrouping) {\n          var topicId = gomo.topicManager.getCurrentTopic().strObjID;\n          statementDefinition.context.contextActivities.grouping.push({\n            id: 'http://www.gomolearning.com/xapi/activities/module/' + topicId,\n            objectType: 'Activity'\n          });\n        }\n      }\n\n      // Create the actual statement\n      var statement = new TinCan.Statement(statementDefinition);\n\n      // Send it!\n      me.tincan.sendStatement(statement, function(err, xhr) {\n        if (err[0].xhr.status === 204) {\n          // Utils.log('Statement sent successfully');\n          callback(null);\n          return;\n        } else if (err[0].xhr.status === 400) {\n          console.log('Failed to send statement: ' +\n            err[0].xhr.status + ' ' + err[0].xhr.statusText);\n        } else {\n          console.log(err[0]);\n        }\n        callback(0);\n      });\n    },\n\n\n    saveLiveState: function(stateId, stateData, activity, callback) {\n      var me = this;\n      me.tincan.setState(stateId, stateData, {\n        agent: me.createActor(me.actor),\n        activity: me.createActivity(activity),\n        contentType: 'application/json',\n        callback: callback\n      });\n    },\n\n    /**\n     *\n     */\n    getLiveState: function(stateId, activity) {\n      var me = this;\n      var result = me.tincan.getState(stateId, {\n        agent: me.createActor(me.actor),\n        activity: me.createActivity(activity),\n        contentType: 'application/json'\n      });\n\n      if (!result.err && result.state && result.state.contents) {\n        result = result.state.contents;\n      } else {\n        result = {};\n      }\n      return result;\n    },\n\n    /**\n     *\n     */\n    createVerb: function(verb) {\n      var registeredVerb = TinCanRegistry.verbs[verb];\n      if (registeredVerb == undefined) {\n        console.log('Unable to find verb: ' + verb);\n        return '';\n      }\n      return new TinCan.Verb({\n        id: registeredVerb.id,\n        display: {\n          'en-GB': registeredVerb.name\n        }\n      });\n    },\n\n    /**\n     *\n     */\n    createActivity: function(activity, extra) {\n      var me = this;\n\n      if (typeof activity == 'string') {\n        activity = {type: activity};\n      } else {\n        activity = activity || {};\n      }\n\n      var activityId = 0;\n      var activityDefinition = 0;\n\n      // Set the registered activity details...\n      var registeredActivity = TinCanRegistry.activities[activity.type];\n      if (registeredActivity != undefined) {\n        activityId = registeredActivity.id;\n        activityDefinition = activityDefinition || {};\n        if (registeredActivity.name) {\n          activityDefinition.name = {\n            'en-GB': registeredActivity.name\n          };\n        }\n        activityDefinition.type = registeredActivity.id;\n      }\n\n      // Format any question options and reponses\n      if (activity && activity.correctResponses && _.isArray(activity.correctResponses)) {\n        for (var i=0; i<activity.correctResponses.length; i++) {\n          activity.correctResponses[i] = this.formatDelimiters(activity.correctResponses[i]);\n        }\n      }\n      if (extra && extra.result && extra.result.response && _.isString(extra.result.response)) {\n        extra.result.response = this.formatDelimiters(extra.result.response);\n      }\n\n      // Format the question choices\n      if (activity && activity.choices && _.isArray(activity.choices)) {\n        for (var j=0; j<activity.choices.length; j++) {\n          activity.choices[j].id = this.formatDelimiters(activity.choices[j].id);\n        }\n      }\n\n      // Format the question targets\n      if (activity && activity.target && _.isArray(activity.target)) {\n        for (var k=0; k<activity.target.length; k++) {\n          activity.target[k].description['en-GB'] =\n            this.formatDelimiters(activity.target[k].description['en-GB']);\n        }\n      }\n\n      // Override with any use specified.\n      if (activity.id != undefined && activity.id && activity.type) {\n        activityId = me.baseURL + 'activities/' + activity.type + '/' + activity.id;\n      }\n\n      // If description and title exist use them for the description and the name\n      if (activity.title && activity.description) {\n        activityDefinition = activityDefinition || {};\n        activityDefinition.name = {\n          'en-GB': gomo.utility.cleanupText(activity.title)\n        };\n        activityDefinition.description = {\n          'en-GB': gomo.utility.cleanupText(activity.description)\n        };\n      } else if (activity.title) {\n        activityDefinition = activityDefinition || {};\n        activityDefinition.name = {\n          'en-GB': gomo.utility.cleanupText(activity.title)\n        };\n      } else if (activity.description) {\n        activityDefinition = activityDefinition || {};\n        activityDefinition.description = {\n          'en-GB': gomo.utility.cleanupText(activity.title)\n        };\n      }\n\n      if (activity.extensions) {\n        activityDefinition = activityDefinition || {};\n        activityDefinition.extensions = activity.extensions;\n      }\n\n      if (activity.type && _.contains(interactionTypes, activity.type)) {\n        // @see {@link https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#requirements-4}\n        activityDefinition.type = 'http://adlnet.gov/expapi/activities/cmi.interaction';\n\n        // @see {@link https://github.com/adlnet/xAPI-Spec/blob/master/xAPI-Data.md#details-10}\n        activityDefinition.interactionType = activity.type;\n      } else if (activity.type === 'subscreen' || activity.type === 'metatopic') {\n        activityDefinition = activityDefinition || {};\n        activityDefinition.type = me.baseURL + 'activitytypes/' + activity.type;\n      } else if (activity.type === 'asset' && extra && extra.assetType) {\n        activityDefinition = activityDefinition || {};\n        activityDefinition.type = me.baseURL + 'activitytypes/assets/' + extra.assetType;\n      } else if (activity.type === 'extra' && extra && extra.extraType) {\n        activityDefinition = activityDefinition || {};\n        activityDefinition.type = me.baseURL + 'activitytypes/extra/' + extra.extraType;\n      }\n\n      if (activity.correctResponses) {\n        activityDefinition.correctResponsesPattern = activity.correctResponses;\n      }\n\n      if (activity.choices) {\n        activityDefinition.choices = activity.choices;\n        // decode choices and remove markup\n        _.each(activityDefinition.choices, function(item, index) {\n          activityDefinition.choices[index].description['en-GB'] = gomo.utility.cleanupText(\n            item.description['en-GB']\n          );\n        });\n      }\n\n      if (activity.source) {\n        activityDefinition.source = activity.source;\n        // decode source\n        _.each(activityDefinition.source, function(item, index) {\n          activityDefinition.source[index].description['en-GB'] = gomo.utility.cleanupText(\n            item.description['en-GB']\n          );\n        });\n      }\n\n      if (activity.target) {\n        activityDefinition.target = activity.target;\n        // decode target\n        _.each(activityDefinition.target, function(item, index) {\n          activityDefinition.target[index].description['en-GB'] = gomo.utility.cleanupText(\n            item.description['en-GB']\n          );\n        });\n      }\n\n      // Override definition if a statement has defined its own.\n      if (extra && extra.object && extra.object.definition) {\n        activityDefinition = extra.object.definition;\n      }\n\n      if (activityId && activityDefinition) {\n        // Create the activity\n        return new TinCan.Activity({\n          id: activityId,\n          definition: activityDefinition\n        });\n      }\n\n      return null;\n    },\n\n    /**\n     * Create the source tag - using extension source!\n     */\n    createSourceTag: function(contextActivities) {\n      contextActivities = contextActivities || {};\n      contextActivities.category = contextActivities.category || [];\n      var activity = {\n        id: 'http://www.gomolearning.com',\n        definition: {\n          type: 'http://id.tincanapi.com/activitytype/source',\n          name: {\n            'en-GB': 'gomo'\n          },\n          descripton: {\n            'en-GB': 'gomo [www.gomolearning.com]'\n          }\n        }\n      };\n      // If we only have a single category, make an array...\n      if (!(contextActivities.category instanceof Array)) {\n        var category = contextActivities.category;\n        contextActivities = [category];\n      }\n      // Add to array.\n      contextActivities.category.push(activity);\n      return contextActivities;\n    },\n\n    /**\n     * Create TinCan result...\n     * @param {object} result\n     * @param {string} verb\n     */\n    createResult: function(result, verb) {\n      // Score object\n      result = result || {};\n      if (result.score) {\n        result.score = result.score || {};\n        result.score.min = isNaN(+result.score.min) ? 0 : +result.score.min;\n        result.score.max = isNaN(+result.score.max) ? 0 : +result.score.max;\n        result.score.raw = isNaN(+result.score.raw) ? 0 : +result.score.raw;\n\n        if (result.score.scaled === undefined) {\n          result.score.scaled = +(result.score.raw / result.score.max).toFixed(2);\n        }\n\n        // Create a TinCan score object\n        result.score = new TinCan.Score(result.score);\n      }\n\n      // Success status\n      if (result.success !== undefined) {\n        result.success = result.success ? true : false;\n      }\n\n      // Completion status\n      if (result.completion !== undefined) {\n        result.completion = result.completion ? true : false;\n      }\n\n      // verb-specific behaviour\n      if (verb === 'completed' && _.has(result, 'score')) {\n        delete result.score;\n      }\n\n      // Create and return TinCan result object\n      return new TinCan.Result(result);\n    },\n\n    /**\n     * Create an TinCan compatible duration from two date/time stamps.\n     */\n    createDuration: function(start, end) {\n      var duration = '';\n      if (start instanceof Date && end instanceof Date) {\n        var seconds = (end.getTime() - start.getTime())/1000;\n        duration = centisecsToISODuration(seconds * 100, true);\n      }\n      return duration;\n    },\n\n    /**\n     * Parse the URL\n     * returns a parsed url object { url:'', params:{}, original: '' }\n     */\n    parseURL: function(url) {\n      // Create result object\n      var result = {\n        url: '',\n        params: {},\n        original: url\n      };\n      // Parse the URL\n      if (~url.indexOf('?')) {\n        var parts = url.split('?');\n        if (parts.length >= 2) {\n          result.url = parts[0];\n          var params = parts[1].split('&');\n          for (var x=0; x<params.length; x++) {\n            var param = params[x].split('=');\n            result.params[param[0]] = param[1];\n          }\n        }\n      }\n      // Return the results object\n      return result;\n    },\n\n    /**\n     * Replace delimiters with correct xapi ones.\n     * @param {string} val\n     */\n    formatDelimiters: function(val) {\n      val = val.replace(/,/g, '[,]');\n      val = val.replace(/\\./g, '[.]');\n      return val;\n    },\n\n    /**\n     * Create referrer extension\n     * @param {object} data The activity data\n     * @return {object}\n     */\n    createReferrerExtension: function(data) {\n      var me = this;\n      var extension = {};\n      var extra = null;\n\n      if (data.assetType) {\n        extra = {\n          assetType: data.assetType\n        };\n      } else if (data.extraType) {\n        extra = {\n          extraType: data.extraType\n        };\n      }\n\n      var activity = me.createActivity({\n        id: data.id,\n        type: data.type,\n        title: data.title || null,\n        description: data.description || null\n      }, extra);\n      extension[TinCanRegistry.extensions['referrer'].id] = activity;\n\n      return extension;\n    }\n  };\n\n  return TINCAN;\n\n  function centisecsToISODuration(n, bPrecise) {\n    // Note: SCORM and IEEE 1484.11.1 require centisec precision\n    // Parameters:\n    // n = number of centiseconds\n    // bPrecise = optional parameter; if true, duration will\n    // be expressed without using year and/or month fields.\n    // If bPrecise is not true, and the duration is long,\n    // months are calculated by approximation based on average number\n    // of days over 4 years (365*4+1), not counting the extra days\n    // for leap years. If a reference date was available,\n    // the calculation could be more precise, but becomes complex,\n    // since the exact result depends on where the reference date\n    // falls within the period (e.g. beginning, end or ???)\n    // 1 year ~ (365*4+1)/4*60*60*24*100 = 3155760000 centiseconds\n    // 1 month ~ (365*4+1)/48*60*60*24*100 = 262980000 centiseconds\n    // 1 day = 8640000 centiseconds\n    // 1 hour = 360000 centiseconds\n    // 1 minute = 6000 centiseconds\n    var str = 'P';\n    var nCs = n;\n    var nY = 0;\n    var nM = 0;\n    var nD = 0;\n    var nH = 0;\n    var nMin = 0;\n    n = Math.max(n, 0); // there is no such thing as a negative duration\n    // Next set of operations uses whole seconds\n    nCs = Math.round(nCs);\n    if (bPrecise == true) {\n      nD = Math.floor(nCs / 8640000);\n    } else {\n      nY = Math.floor(nCs / 3155760000);\n      nCs -= nY * 3155760000;\n      nM = Math.floor(nCs / 262980000);\n      nCs -= nM * 262980000;\n      nD = Math.floor(nCs / 8640000);\n    }\n    nCs -= nD * 8640000;\n    nH = Math.floor(nCs / 360000);\n    nCs -= nH * 360000;\n    nMin = Math.floor(nCs /6000);\n    nCs -= nMin * 6000;\n    // Now we can construct string\n    if (nY > 0) {\n      str += nY + 'Y';\n    }\n    if (nM > 0) {\n      str += nM + 'M';\n    }\n    if (nD > 0) {\n      str += nD + 'D';\n    }\n    if ((nH > 0) || (nMin > 0) || (nCs > 0)) {\n      str += 'T';\n      if (nH > 0) {\n        str += nH + 'H';\n      }\n      if (nMin > 0) {\n        str += nMin + 'M';\n      }\n      if (nCs > 0) {\n        str += (nCs / 100) + 'S';\n      }\n    }\n    if (str == 'P') {\n      str = 'PT0H0M0S';\n    }\n    // technically PT0S should do but SCORM test suite assumes longer form.\n    return str;\n  }\n})(global.$, global.GOMO_TINCAN_REGISTRY);\n"},function(n,e,t){t(0)(t(59))},function(n,e){n.exports="/* global CONTENT_TRACKING, dataLayer, gtag */\n/**\n * SCORM tracking adapter\n * @author James Hough\n */\n\nvar global = this;\n\nglobal.GOMO_GOOGLE_ANALYTICS = (function($) {\n  /**\n   * GOOGLE_ANALYTICS\n   * @constructor\n   * @param {array} config\n   */\n  function GOOGLE_ANALYTICS(config) {\n    var me = this;\n    // If it's an array then only pull the first item\n    if (config instanceof Array) {\n      config = config[0];\n    }\n    // Check we have an object!\n    if (config instanceof Object) {\n      if (config.adapter == 'google') {\n        me.trackingCode = config.code;\n\n        // Get the google tracking lib\n        $.getScript('https://www.googletagmanager.com/gtag/js?id=' + me.trackingCode)\n          .done(function(script, textStatus) {\n            if (global.LogManager) {\n              global.LogManager.add(\n                'TEXT', 'Text Status ' + textStatus\n              );\n            }\n          })\n          .fail(function(jqxhr, settings, exception) {\n            if (global.LogManager) {\n              global.LogManager.add(\n                'TEXT', 'Exception: ' + exception\n              );\n            }\n          });\n\n        // Create a global placeholder for google tracking once the lib is ready\n        window.dataLayer = window.dataLayer || [];\n        global.gtag = function() {\n          dataLayer.push(arguments);\n        };\n        gtag('js', new Date());\n      }\n    }\n  }\n\n  /**\n   * Extend the ContentTracking\n   */\n  GOOGLE_ANALYTICS.prototype = {\n    eventCategories: ['gomoCore', 'unknown'],\n\n    /*\n     * Start the GA tracking!\n     * @param startData {}\n     * @param settings Generic tracking settings\n     * @return boolean\n     */\n    start: function(startData, settings) {\n      var me = this;\n\n      me.user = CONTENT_TRACKING.getUser() || {};\n      me.app_name = startData.name || 'Unknown';\n      me.app_id = startData.id || 'Unknown';\n\n      // Set up tracking and pass off page load data\n      if (typeof me.user.id !== 'undefined') {\n        gtag('config', me.trackingCode, {\n          user_id: me.user.id,\n          user_name: me.user.name,\n          app_name: me.app_name,\n          app_id: me.app_id\n        });\n      } else {\n        gtag('config', me.trackingCode, {\n          app_name: me.app_name,\n          app_id: me.app_id\n        });\n      }\n\n      me.logEvent({eventCategory: me.eventCategories[0], eventAction: 'launched'});\n\n      settings.success();\n    },\n\n    /**\n     * Get User\n     * @description Google Analytics doesn't return a useful user for gomo so return false to CONTENT_TRACKING\n     * @return {boolean}\n     */\n    getUser: function() {\n      return false;\n    },\n\n    /**\n     * End the session GA tracking!\n     * @param {object} endData {force:boolean, closeWindow:boolean}\n     * @param {object} settings Generic tracking settings\n     */\n    end: function(endData, settings) {\n      var me = this;\n\n      me.logEvent({eventCategory: me.eventCategories[0], eventAction: 'closed'});\n      settings.success();\n    },\n\n    /*\n     * Track a page visit!\n     * @param visitData {topicId:'', pageId:'', pageTitle:''}\n     * @param settings Generic tracking settings\n     */\n    visit: function(visitData, settings) {\n      var me = this;\n\n      // Append the pageId to the screenName to make sure they're unique\n      var gaScreenData = {\n        app_name: me.app_name,\n        app_id: me.app_id,\n        screen_name: visitData.pageTitle + ' ' + visitData.pageId\n      };\n\n      me.logScreenVisit(gaScreenData);\n      settings.success();\n    },\n\n    /**\n     * Log some other kind of interaction\n     * @param {object} interactionData\n     *    {\n     *      type:'',      // Type of action/interaction (started, completed, etc.)\n     *      activity: {   // The activitiy been interacted with...\n     *        id:'',      // Unique id for the activity (topicid, pageid, etc.)\n     *        title:'',   // Human readable title\n     *        type:''     // Type of activity been acted upon (course, lesson, etc.)\n     *      },\n     *      result: { }    // See this.parseResult for definition\n     *    }\n     * @param {object} settings Generic tracking settings\n     */\n    interaction: function(interactionData, settings) {\n      var me = this;\n\n      var gaInteractionData = {\n        eventCategory: me.eventCategories[0],\n        eventAction: interactionData.activity.title,\n        optionalObject: interactionData\n      };\n\n      me.logEvent(gaInteractionData);\n      settings.success();\n    },\n\n    /**\n     * Saves the state object back to the active adapters\n     * @param {object} data\n     * @param {object} settings Generic tracking settings\n     * @return {boolean}\n     */\n    saveState: function(data, settings) {\n      settings.success();\n      return true;\n    },\n\n    /**\n     * GA doesn't support Geo location\n     * @param {object} geoJSON\n     * @param {object} settings\n     * @return {boolean}\n     */\n    setGeoJSON: function(geoJSON, settings) {\n      settings.success();\n      return true;\n    },\n\n    /**\n     * GA doesn't support suspend data\n     * @param {object} data\n     * @param {object} settings\n     * @return {boolean}\n     */\n    getState: function(data, settings) {\n      settings.success();\n      return true;\n    },\n\n    /**\n     * GA doesn't support suspend data\n     * @param {object} data\n     * @param {object} settings\n     * @return {boolean}\n     */\n    getLastLocation: function(data, settings) {\n      settings.success();\n      return true;\n    },\n\n    /**\n     * GA doesn't support this\n     * @param {object} data\n     * @param {object} settings\n     * @return {boolean}\n     */\n    getScore: function(data, settings) {\n      settings.success();\n      return true;\n    },\n\n    /**\n     * GA doesn't support this\n     * @param {object} data\n     * @param {object} settings\n     * @return {boolean}\n     */\n    getCompletionStatus: function(data, settings) {\n      settings.success();\n      return true;\n    },\n\n    /**\n     * GA doesn't support this\n     * @param {object} scoreData\n     * @param {object} settings\n     * @return {boolean}\n     */\n    score: function(scoreData, settings) {\n      settings.success();\n      return true;\n    },\n\n    /**\n     * GA doesn't support this\n     * @param {object} callback\n     * @param {object} suppressSave\n     * @return {boolean}\n     */\n    summarise: function(callback, suppressSave) {\n      return false;\n    },\n\n    /**\n     * GA doesn't support this\n     * @param {object} data\n     * @param {object} settings\n     * @return {boolean}\n     */\n    poll: function(data, settings) {\n      settings.success();\n      return true;\n    },\n\n    /**\n     * GA doesn't support this\n     * @param {object} preferences\n     * @param {object} settings\n     * @return {boolean}\n     */\n    setPreferences: function(preferences, settings) {\n      settings.success();\n      return true;\n    },\n\n    /**\n     * Log application event...\n     * @function\n     * @param {object} options\n     *    {\n     *      eventCategory: {string},\n     *      eventAction: {},\n     *      optionalObject: {}\n     *    }\n     */\n    logEvent: function(options) {\n      var me = this;\n      var eventCategory = options.eventCategory || me.eventCategories[1];\n      var eventAction = options.eventAction || null;\n      var optionalObject = options.optionalObject || null;\n\n      var eventParameters = {};\n      eventParameters.eventCategory = eventCategory;\n      if (optionalObject && typeof optionalObject == 'object') {\n        for (var key in optionalObject) {\n          if (Object.prototype.hasOwnProperty.call(optionalObject, key)) {\n            eventParameters[key] = optionalObject[key];\n          }\n        }\n      }\n\n      gtag('event', eventAction, eventParameters);\n    },\n\n    /**\n     * Log application page visit...\n     * @function\n     * @param {object} screenObject\n     */\n    logScreenVisit: function(screenObject) {\n      gtag('event', 'screen_view', screenObject);\n    }\n  };\n  return GOOGLE_ANALYTICS;\n})(global.$);\n"},function(n,e,t){t(0)(t(61))},function(n,e){n.exports="/* global LOCALISER, _ */\n/**\n * @title Object Reference\n * @description To be described.\n *\n *\n * @author GoMo\n * @version 2.0 17/12/12\n */\n\n// eslint-disable-next-line no-unused-vars\nvar OBJ_REF = {\n  _objObjectHolder: {},\n  _objCategories: {},\n  _objIDHolder: {},\n  _strIdAttribute: 'strObjID',\n\n  add: function(_objVariant, _arrCategories) {\n    return this._addObject(_objVariant, _arrCategories);\n  },\n\n  get: function(_strId, suppressErrors) {\n    if (this._objObjectHolder[_strId]) {\n      return this._objObjectHolder[_strId];\n    } else {\n      if (!suppressErrors) {\n        console.log(LOCALISER.get('OBJ_REF_UNKNOWN_OBJECT_ID', [_strId]));\n      }\n      return false;\n    }\n  },\n\n  testForID: function(_strObjId) {\n    if (this._objObjectHolder[_strObjId]) {\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  getCategory: function(_strCatId) {\n    var _objReturn = {};\n    if (this._objCategories[_strCatId]) {\n      for (var _strId in this._objCategories[_strCatId]) {\n        if (Object.prototype.hasOwnProperty.call(this._objCategories, _strId)) {\n          var _objObject = this._objObjectHolder[_strId];\n          if (_objObject) {\n            _objReturn[_strId] = _objObject;\n          }\n        }\n      }\n    }\n    return _objReturn;\n  },\n  // Used only by instant preview to ensure subscreen references are up to date \n  resetSubscreens: function() {\n    // remove subscreen references from the objObjectHolder\n    this._objObjectHolder = _.omit(this._objObjectHolder, function(value, key) {\n      if (key.indexOf('sub') > 0) return key;\n    });\n    // remove subscreen references from the objIDHolder\n    this._objIDHolder = _.omit(this._objIDHolder, function(value, key) {\n      if (key.indexOf('sub') > 0) return key;\n    });\n    // remove subscreen references from the objCategories['subscreen']\n    if (this._objCategories['subscreen']) {\n      this._objCategories['subscreen'] = {};\n    }\n    // remove subscreen && descendent references from the objCategories\n    var newObjCategories = {};\n\n    _.each(this._objCategories, function(value, key) {\n      newObjCategories[key] = _.omit(value, function(v, k) {\n        if (k.indexOf('sub') > 0) return k;\n      });\n    });\n\n    this._objCategories = newObjCategories;\n  },\n\n  searchCategory: function(_strCatId, _strIdToSearchFor) {\n    // REFACTOR NOTE: Ask Alex what this was intended to be and get it written!\n    LOCALISER.l_alert('OBJ_REF_SEARCH_CODE_PENDING_MESSAGE');\n  },\n\n  _addObject: function(_objVariant, _arrCategories) {\n    if (_objVariant && _objVariant[this._strIdAttribute]) {\n      var _strId = _objVariant[this._strIdAttribute];\n      this._objObjectHolder[_strId] = _objVariant;\n      this._objIDHolder[_strId] = true;\n      if (_arrCategories) {\n        this._addCategories(_strId, _arrCategories);\n      }\n      return true;\n    } else {\n      LOCALISER.l_alert('OBJ_REF_UN-ADDABLE_OBJECT_ERROR');\n      return false;\n    }\n  },\n\n  _addCategories: function(_strId, _arrCategories) {\n    if (_arrCategories instanceof Array) {\n      for (var i = 0; i < _arrCategories.length; i++) {\n        if (_arrCategories[i] instanceof Array) {\n          this._addCategories(_strId, _arrCategories[i]);\n        } else {\n          this._addCategory(_strId, _arrCategories[i]);\n        }\n      }\n    } else {\n      this._addCategory(_strId, _arrCategories);\n    }\n  },\n\n  _addCategory: function(_strId, _strCategory) {\n    this._createCategory(_strCategory);\n    this._objCategories[_strCategory][_strId] = true;\n  },\n\n  _createCategory: function(_strCatId) {\n    if (!this._objCategories[_strCatId]) {\n      this._objCategories[_strCatId] = {};\n    }\n  }\n};\n"},function(n,e,t){t(0)(t(63))},function(n,e){n.exports="/* eslint-disable no-redeclare */\n/* global OUTPUT_MODE_CHECKER, EM, CORE, LOADER, jQuery, $ */\n/**\n * @title Templates\n * @description Collate a list of templates for use by core, extra and asset renderers.\n * getTemplate() will first hand back a template based on the device if one exists, then\n * it will look at the screen size.\n *\n *\n * @author GoMo\n * @version 2.0 17/12/12\n * @version 2.1 07/11/13 - JH - add support for screen size\n */\n\nvar TEMPLATE_MANANGER = {\n  strObjID: 'The HTML template fragement manager',\n  strObjDescription:\n    'This object is in charge of collecting and returning the HTML fragments' +\n    'required to build the course. If multiple fragments are found, the 3rd'+\n    'classname specified will be used to sub catergorize the elements',\n\n  _strFragmentClassname: 'templateFragmentC',\n  _strContentFrameRef: 'mainAreaF',\n  _strTemplateFrameRef: 'templateF',\n\n  _strCurrOutputModeClass: OUTPUT_MODE_CHECKER.strCurrentMode,\n  _strCurrScreenSizeClass: OUTPUT_MODE_CHECKER.strCurrentScreenSize + 'C',\n\n  _objCurrDOM: null,\n\n  _objTemplateFragments: {},\n\n  _strTemplateCollectionID: 'templatesWrapperL',\n\n  _strCollectionLog: '',\n\n  handleEvent_primeDOMReferences: function(_objWhatDOM) {\n    this._objCurrDOM = _objWhatDOM;\n\n    this._strCollectionLog = '';\n\n    if (this._collectTemplates()) {\n      gomo.assetManager.setCommonAssetTemplates();\n\n      if (this._strCollectionLog != '') {\n        // This needs tracking in an Error System\n        console.log('TEMPLATE.primeDOMReferences() ' + this._strCollectionLog);\n      }\n      this._objCurrDOM.getElementById(this._strTemplateCollectionID).innerHTML = '';\n      EM.trigger('htmlTemplatesLoadedAndCollected');\n    } else {\n      // This needs tracking in an Error System\n      console.log('TEMPLATE.primeDOMReferences() ');\n    }\n  },\n\n  handleEvent_outputModeChanged: function(_objOutputChangeData) {\n    this._strCurrOutputModeClass = _objOutputChangeData['strNewOutputMode'];\n  },\n\n  handleEvent_screenSizeChanged: function(_objScreenSize) {\n    this._strCurrScreenSizeClass = _objScreenSize.strUpdatedScreenSize + 'C';\n  },\n\n  getTemplate: function(_strWhatTemplateName, _strOptionalClassRequest) {\n    if (this._objTemplateFragments[_strWhatTemplateName]) {\n      if (\n        typeof _strOptionalClassRequest != 'undefined' &&\n        this._objTemplateFragments[_strWhatTemplateName][_strOptionalClassRequest + 'C']\n      ) {\n        return this._objTemplateFragments[_strWhatTemplateName][_strOptionalClassRequest + 'C'];\n      }\n      // If there is a specific data fragment for the current MODE ie. smartphone, tablet\n      if (this._objTemplateFragments[_strWhatTemplateName][this._strCurrOutputModeClass]) {\n        return this._objTemplateFragments[_strWhatTemplateName][this._strCurrOutputModeClass];\n      // eslint-disable-next-line brace-style\n      }\n      // Outwise, look for a specific size\n      else if (this._objTemplateFragments[_strWhatTemplateName][this._strCurrScreenSizeClass]) {\n        return this._objTemplateFragments[_strWhatTemplateName][this._strCurrScreenSizeClass];\n      // eslint-disable-next-line brace-style\n      } // Otherwise return the generic one.\n      else {\n        return this._objTemplateFragments[_strWhatTemplateName]['generic'];\n      }\n    }\n\n    // This needs tracking in an Error System\n    console.log('TEMPLATE.getTemplate() ' + _strWhatTemplateName);\n    return false;\n  },\n\n  _collectTemplates: function() {\n    if (this._objCurrDOM) {\n      var _arrTemplateFragments = CORE.getElementsByClassName(\n        this._objCurrDOM,\n        this._strFragmentClassname\n      );\n      if (_arrTemplateFragments.length > 0) {\n        var count = 0;\n        while (count < _arrTemplateFragments.length) {\n          this._addTemplateFragement(_arrTemplateFragments[count]);\n          count++;\n        }\n        return true;\n      } else {\n        return false;\n      }\n    } else {\n      return false;\n    }\n  },\n\n  /** * HTML FRAGMENTS FROM LOADER ***/\n\n  collectTemplatesFromFragment: function(templatesBundle) {\n    this._strCollectionLog = '';\n\n    if (this._parseDomForTemplates(templatesBundle)) {\n      if (this._strCollectionLog != '') {\n        LOADER._debug(\n          'DUPLICATE_TEMPLATES_ERROR of ' +\n            this._strCollectionLog +\n            ', see TEMPLATE_MANAGER.collectTemplatesFromFragment()'\n        );\n      }\n    }\n  },\n\n  _parseDomForTemplates: function(templatesBundle) {\n    if (!this._objCurrDOM && !templatesBundle) {\n      return false;\n    }\n\n    // If we've been passed a DOM then it's from a fragment file.\n    var _templateFragments;\n    var sourceTemplates = this._objCurrDOM;\n    if (templatesBundle) {\n      sourceTemplates = templatesBundle;\n    }\n\n    if (sourceTemplates && sourceTemplates instanceof jQuery) {\n      _templateFragments = sourceTemplates.find('.' + this._strFragmentClassname);\n      if (_templateFragments.length) {\n        _templateFragments.each(function() {\n          TEMPLATE_MANANGER._addTemplateFragement($(this), true);\n        });\n        return true;\n      }\n    } else {\n      _templateFragments = CORE.getElementsByClassName(\n        this._objCurrDOM,\n        this._strFragmentClassname\n      );\n      if (_templateFragments.length > 0) {\n        var count = 0;\n        while (count < _templateFragments.length) {\n          this._addTemplateFragement(_templateFragments[count]);\n          count++;\n        }\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  /** * HTML FRAGMENTS FROM LOADER END ***/\n\n  _addTemplateFragement: function(_domWhatTemplateFragment, jqueryElement) {\n    var _arrFragmentClasses = [];\n    if (jqueryElement) {\n      _arrFragmentClasses = _domWhatTemplateFragment.attr('class').split(' ');\n    } else {\n      _arrFragmentClasses = _domWhatTemplateFragment.className.split(' ');\n    }\n    var _strFragmentID = _arrFragmentClasses[1];\n\n    if (_arrFragmentClasses[2]) {\n      var _strSubType = _arrFragmentClasses[2];\n    } else {\n      var _strSubType = false;\n    }\n\n    var _htmFragmentData = '';\n    if (jqueryElement) {\n      _htmFragmentData = _domWhatTemplateFragment.html();\n    } else {\n      _htmFragmentData = _domWhatTemplateFragment.innerHTML;\n    }\n\n    _htmFragmentData = this._cleanupFragmentForNewAssetStyle(_htmFragmentData);\n    _htmFragmentData = this._replaceTemplateIDPrefixes(_htmFragmentData);\n\n    if (!this._objTemplateFragments[_strFragmentID]) {\n      this._objTemplateFragments[_strFragmentID] = {};\n    }\n\n    if (!_strSubType) {\n      if (this._objTemplateFragments[_strFragmentID]['generic']) {\n        this._strCollectionLog +=\n          '\\n\\n* _strFragmentID: ' + _strFragmentID + '\\n  _strSubType:' + _strSubType;\n      }\n      this._objTemplateFragments[_strFragmentID]['generic'] = new TemplateFragment(\n        _strFragmentID,\n        _strSubType,\n        _htmFragmentData\n      );\n    } else {\n      if (this._objTemplateFragments[_strFragmentID][_strSubType]) {\n        this._strCollectionLog +=\n          '\\n\\n* _strFragmentID: ' + _strFragmentID + '\\n  _strSubType:' + _strSubType;\n      }\n      this._objTemplateFragments[_strFragmentID][_strSubType] = new TemplateFragment(\n        _strFragmentID,\n        _strSubType,\n        _htmFragmentData\n      );\n    }\n  },\n\n  _replaceTemplateIDPrefixes: function(_htmFragmentData) {\n    // YY_PREFIX_000_00_YY\n    return _htmFragmentData.replace(/YY_PREFIX_\\d{3}_\\d{2}_YY/g, '');\n  },\n\n  _cleanupFragmentForNewAssetStyle: function(fragment) {\n    // This replace is for partial handlebar fragments\n    fragment = fragment.replace(/{{&gt;/g, '{{>');\n    return fragment;\n  }\n};\n\n/**\n * .\n * @param {String} _strFragmentID fragment id.\n * @param {String} _strSubType sub type.\n * @param {String} _htmFragmentData fragment data.\n * @param {Object} _objWhatDOM dom object\n*/\nfunction TemplateFragment(_strFragmentID, _strSubType, _htmFragmentData, _objWhatDOM) {\n  this.strObjID = _strFragmentID;\n  this.strSubType = _strSubType;\n  this.htmData = _htmFragmentData;\n\n  if (!_objWhatDOM) {\n    this._objCurrDOM = document;\n  } else {\n    this._objCurrDOM = _objWhatDOM;\n  }\n\n  this._preprocessFragment();\n}\n\nTemplateFragment.prototype = {\n  _preprocessFragment: function() {\n    // Replaces the faked tag markup with proper tags.\n    this.htmData = this.htmData.replace(/\\[TAG\\s([^\\]]+)\\]/g, '<$1>');\n\n    // Replaces alt=XX_TEXT_XX with alt=\"XX_TEXT_XX\"\n    this.htmData = this.htmData.replace(/<[^>]+\\s[^>]+>/g, function(_strMatch) {\n      return _strMatch.replace(/([\\w-]+=)([\\w-]+)/g, '$1\"$2\"');\n    });\n\n    // Adds the onerror handler to images\n    this.htmData = this.htmData.replace(\n      /<img/g,\n      '<img onerror=\"EM.trigger(\\'imageLoadFailure\\', this)\"'\n    );\n\n    // Adds the onload handler to images\n    this.htmData = this.htmData.replace(\n      /<img/g,\n      '<img onload=\"EM.trigger(\\'imageLoadCompleted\\', this)\"'\n    );\n  },\n\n  getContentAsDOMNodes: function(_booOmitTextNodes) {\n    var _domContainer = this._objCurrDOM.createElement('div');\n    _domContainer.innerHTML = this.htmData;\n    var _arrChildNodes = [];\n    while (_domContainer.childNodes.length > 0) {\n      var _domCurrChild = _domContainer.removeChild(\n        _domContainer.childNodes[_domContainer.childNodes.length - 1]\n      );\n      if (!_booOmitTextNodes || (_booOmitTextNodes && _domCurrChild.nodeType != 3)) {\n        _arrChildNodes.push(_domCurrChild);\n      }\n    }\n    return _arrChildNodes;\n  }\n};\n\nEM.register(TEMPLATE_MANANGER);\n"},function(n,e,t){t(0)(t(65))},function(n,e){n.exports="/**\n* @title Image Preloader\n* @description Used to preload interface and content images\n* The main method is\n* - handleEvent_preloadImages, accepts object parameter,\n* e.g. {\"strPreloadType\" : topic, \"strCallback\" : \"imagesPreloaded\", \"objCourseData\" : _objCourseData}\n*\n*\n*\n* @author Kasparas Galdikas\n* @version 2.0 31/01/2012 Kasparas Galdikas: Created a file.\n*/\n\nvar IMAGE_PRELOADER =\n{\n\tstrObjID : \"Image preloader\",\n\n\t_strImagePath : ROOT_PATH + STR_LOCAL_RESOURCES_PATH,\n\n\t_objPreloadData : null,\n\n\t_objImageMetaData : null,\n\t_arrFilteredFileList : null,\n\t_objLoadedImages : {},\n\t_intCurrFileIndex : 0,\n\t_intImageFilesCount : null,\n\n\t/*\n\t * handleEvent_preloadImages\n\t * @param\tObject\n\t */\n\n\thandleEvent_preloadImages : function(_objWhatPreloadData)\n\t{\n\t\tthis._objPreloadData = _objWhatPreloadData;\n\n\t\tif(!BOO_PRELOAD_IMAGES)\n\t\t{\n\t\t\tthis._reportImagesPreloaded();\n\n\t\t\treturn;\n\t\t}\n\n\t\tif(!OBJ_PRELOADER_CONFIG[this._objPreloadData['strPreloadType']])\n\t\t{\n\t\t\tthis._reportImagesPreloaded();\n\t\t\treturn;\n\t\t}\n\n\t\tthis._objImageMetaData = CORE.objImageMetaData;\n\n\t\tif(this._objImageMetaData)\n\t\t{\n\t\t\tthis._preparePreloadData();\n\t\t}\n\t},\n\n\t/*\n\t * _init\n\t *\n\t */\n\n\t_init : function()\n\t{\n\t\t//console.log(\"starting image preloader\");\n\n\t\t//console.log(\"Number of files to load: \" + this._intImageFilesCount);\n\n\t\tthis._loadImage();\n\t},\n\n\t/*\n\t * _preparePreloadData\n\t *\n\t */\n\n\t_preparePreloadData : function()\n\t{\n\t\tvar _arrFileList = null;\n\t\tvar _strPreloadType = this._objPreloadData['strPreloadType'].toUpperCase();\n\n\t\tif(this[\"_get\" + _strPreloadType + \"Images\"])\n\t\t{\n\t\t\t_arrFileList = this[\"_get\" + _strPreloadType + \"Images\"]();\n\n\t\t\tthis._intImageFilesCount = (_arrFileList.length)-1;\n\t\t\tthis._arrFilteredFileList = _arrFileList;\n\n\t\t\tthis._init();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//alert(\"ERROR: Unknown preload type of '\" + _strPreloadType + \"' found. IMAGE_PRELOADER._preparePreloadData(), image_preloader.js\");\n\t\t\tLOCALISER.l_alert(\"IMAGE_PRELOADER_UNKNOWN_PRELOAD_TYPE_ERROR\", [_strPreloadType]);\n\t\t\treturn;\n\t\t}\n\t},\n\n\t/*\n\t * _getINTERFACEImages\n\t *\n\t */\n\t_getINTERFACEImages : function()\n\t{\n\t\tvar _arrImageMetaData = this._objImageMetaData['imagefiles']['file'];\n\t\tvar _arrTempData = [];\n\n\t\tfor(var i = 0; i<_arrImageMetaData.length; i++)\n\t\t{\n\t\t\tvar _objCurrItem = \t_arrImageMetaData[i];\n\n\t\t\tif(!(_objCurrItem['@filename'].match(/t[0-9]{4}/)) && !(_objCurrItem['@filename'].match(/p[0-9]{2}_i[0-9]{3}/)))\n\t\t\t{\n\t\t\t\t_arrTempData.push(_objCurrItem);\n\t\t\t}\n\t\t}\n\n\n\t\treturn _arrTempData;\n\t},\n\n\t/*\n\t * _getTOPICImages\n\t *\n\t */\n\t_getTOPICImages : function()\n\t{\n\t\tvar _arrTempData = [];\n\t\tvar _regEx = \".png\"\n\n\t\tvar _arrStrTopicImages = TOPIC_STRUCTURE_PARSER._parseTopicDataForFilenames(this._objPreloadData.objCourseData, _regEx);\n\n\t\tfor(var i=0;i<_arrStrTopicImages.length;i++)\n\t\t{\n\t\t\tif (_arrStrTopicImages[i].indexOf(\"t999s99\") < 0)\n\t\t\t{\n\t\t\t\t_arrTempData.push({'@filename':_arrStrTopicImages[i]});\n\t\t\t}\n\t\t}\n\n\t\tthis._objPreloadData.objCourseData.booImagesPreloaded = true;\n\t\treturn _arrTempData;\n\t},\n\n\t/*\n\t * _getALLImages\n\t *\n\t */\n\t_getALLImages : function()\n\t{\n\t\treturn this._objImageMetaData['imagefiles']['file'];\n\t},\n\n\t/*\n\t * _loadImage\n\t *\n\t */\n\t_loadImage : function()\n\t{\n\t\tif(this._intImageFilesCount > 0)\n\t\t{\n\t\t\t// REFACTOR NOTE: This is a temporary workaround in leiu of figuring out the root cause\n\t\t\t// for the error on reload.\n\t\t\tif (!this._arrFilteredFileList)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar _objCurrFile = this._arrFilteredFileList[this._intCurrFileIndex];\n\n\t\t\tif(_objCurrFile)\n\t\t\t{\n\t\t\t\t//console.log(\"_loadImage, \" +  this._intCurrFileIndex + \", \" + _objCurrFile['@filename']);\n\t\t\t\tthis._objLoadedImages[_objCurrFile['@filename']] = new Image();\n\t\t\t\tthis._objLoadedImages[_objCurrFile['@filename']].src = this._strImagePath + _objCurrFile['@filename'];\n\t\t\t\tthis._objLoadedImages[_objCurrFile['@filename']].onload = function() { EM.trigger('imageReportLoaded') };\n\t\t\t\tthis._objLoadedImages[_objCurrFile['@filename']].onerror = function() { EM.trigger('imageReportLoadFailed') };\n\t\t\t\tthis._objLoadedImages[_objCurrFile['@filename']].onabort = function() { EM.trigger('imageReportLoadFailed') };\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tEM.trigger('imageReportLoadFailed');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._reportImagesPreloaded();\n\t\t}\n\t},\n\n\t/*\n\t * handleEvent_imageReportLoaded\n\t *\n\t */\n\thandleEvent_imageReportLoaded : function()\n\t{\n\t\tif(this._arrFilteredFileList)\n\t\t{\n\t\t\tvar _arrImageFiles = this._arrFilteredFileList;\n\t\t\tvar _objCurrFile = _arrImageFiles[this._intCurrFileIndex];\n\n\t\t\tif(_objCurrFile)\n\t\t\t{\n\t\t\t\t_objCurrFile['@status'] = true;\n\t\t\t}\n\n\t\t\tthis._imageStatusChanged();\n\t\t}\n\n\t\t//console.log(\"imageReportLoaded, \" + _objCurrFile['@filename']);\n\t},\n\n\t/*\n\t * handleEvent_imageReportLoadFailed\n\t *\n\t */\n\thandleEvent_imageReportLoadFailed : function()\n\t{\n\t\tvar _arrImageFiles = this._arrFilteredFileList;\n\t\tvar _objCurrFile = _arrImageFiles[this._intCurrFileIndex];\n\n\t\t// REFACTOR NOTE: This is a temporary workaround in leiu of figuring out the root cause\n\t\t// for the error on reload.\n\t\tif ((!this._arrFilteredFileList) || (!_arrImageFiles[this._intCurrFileIndex]))\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\n\t\tif(!_objCurrFile)\n\t\t{\n\t\t\t// REFACTOR NOTE: This seems to be incorrect; the message should be warning about an un-registered\n\t\t\t// file failing to load?\n\t\t\t//alert(\"ERROR: image_preloader.js - An image has failed to load - current file index: \" + this._intCurrFileIndex);\n\t\t\tLOCALISER.l_alert(\"IMAGE_PRELOADER_UNKNOWN_FILE_LOADED_ERROR\", [this._intCurrFileIndex]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_objCurrFile['@status'] = false;\n\t\t\tif( BOO_PRELOADER_WARN_IMAGE_LOAD_FAIL)\n\t\t\t{\n\t\t\t\t//alert(\"ERROR: image_preloader.js - An image has failed to load - \" + _objCurrFile['@filename']);\n\t\t\t\tLOCALISER.l_alert(\"IMAGE_PRELOADER_REGISTERED_FILE_LOAD_ERROR\", [_objCurrFile['@filename']]);\n\t\t\t}\n\t\t}\n\n\n\t\tthis._imageStatusChanged();\n\n\t\t//console.log(\"imageReportLoadFailed, \" + _objCurrFile['@filename']);\n\t},\n\n\t/*\n\t * _imageStatusChanged\n\t *\n\t */\n\n\t_imageStatusChanged : function()\n\t{\n\t\tif(this._intCurrFileIndex < this._intImageFilesCount)\n\t\t{\n\t\t\tthis._intCurrFileIndex++\n\n\t\t\tthis._loadImage();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._checkAllLoaded();\n\t\t}\n\t},\n\n\t/*\n\t * _checkAllLoaded\n\t *\n\t */\n\t_checkAllLoaded : function()\n\t{\n\t\t//console.log(\"_checkAllLoaded\");\n\n\t\tvar _booAllLoaded = true;\n\t\tvar _arrImageFiles = this._arrFilteredFileList;\n\n\t\tvar _intFailedPreloads = 0;\n\n\t\tfor(var i = 0; i < _arrImageFiles.length; i++)\n\t\t{\n\t\t\tvar _objCurrFile = _arrImageFiles[i];\n\n\t\t\tif(_objCurrFile['@status'] == false)\n\t\t\t{\n\t\t\t\t_booAllLoaded = false;\n\n\t\t\t\t_intFailedPreloads++;\n\t\t\t}\n\t\t}\n\n\t\tif(_booAllLoaded)\n\t\t{\n\t\t\tthis._reportImagesPreloaded();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//Could display a message here saying what we couldn't load etc..\n\t\t\t//Proceed anyway\n\t\t\tthis._reportImagesPreloaded();\n\t\t}\n\t},\n\n\t/*\n\t * _reportImagesPreloaded\n\t *\n\t */\n\t_reportImagesPreloaded : function()\n\t{\n\t\tvar _strCallBack = this._objPreloadData['strCallback'];\n\n\t\tEM.trigger(_strCallBack);\n\n\t\tthis._cleanUp();\n\t},\n\n\t/*\n\t * _cleanUp\n\t *\n\t */\n\t_cleanUp : function()\n\t{\n\t\tthis._arrFilteredFileList = null;\n\t\tthis._objLoadedImages = null;\n\t\tthis._objLoadedImages = {};\n\t\tthis._intCurrFileIndex = 0;\n\t\tthis._objPreloadData = null;\n\t}\n}\n\nEM.register(IMAGE_PRELOADER);"},function(n,e,t){t(0)(t(67))},function(n,e){n.exports='/**\n* @title The JSON Post processor\n* @description The object that take the JSON object after its conversion from XML and performs some post processing on it to amend the structure in the event of singleton nodes. This is required as the JSON>XML process can produce different data shapes if there is only a single asset.\n*\n* @author JohnC\n* @version 2.0 08-11-10\n*/\n\nvar JSON_POST =\n{\n\tstrObjID : "The JSON Post processor.",\n\tstrObjDescription : "The object that take the JSON object after its conversion from XML and performs some post processing on it.",\n\n\t// 2D Array, pairs are parent node name / current node name.\n\t// NOTE: For nodes that should always be converted regardless\n\t// of thier parent, use the wildcard * in the parent name.\n\t_arrNodesToCheckForArrayWrapping :\n\t[\n\t\t["screens","screen"],\n\t\t["assets","asset"],\n\t\t["subassets","subasset"],\n\t\t["subscreens","subscreen"],\n\t\t["viewpoints","viewpoint"],\n\t\t["options","option"],\n\t\t["imagefiles","file"],\n\t\t["helpcontent","help"],\n\t\t["glossaryterms","term"],\n\t\t["videofiles","video"],\n\t\t["course","item"]\n\t],\n\n\tprocess : function (_objWhatJSON)\n\t{\n\t\t//alert("processJSON")\n\t\tvar _objReturnData = this._parseObject(_objWhatJSON, false);\n\t\treturn _objReturnData;\n\t},\n\n\t_parseObject : function (_objWhatObject, _strParentNodeName)\n\t{\n\t\tfor (var _strCurrIndex in _objWhatObject)\n\t\t{\n\t\t\tvar _objCurrItem = _objWhatObject[_strCurrIndex];\n\n\t\t\tif (_objCurrItem)\n\t\t\t{\n\t\t\t\tvar _strConstructor = _objCurrItem.constructor.toString();\n\t\t\t\tvar _booIsArray = (_objCurrItem instanceof Array);\n\t\t\t\tvar _booIsObject = (_objCurrItem instanceof Object);\n\n\t\t\t\t// If its a listed node, wrap it in an array so its\n\t\t\t\t// consistant with the arrays that occur with multiples\n\t\t\t\t// of a given type.\n\t\t\t\tif ((this._checkCurrNodeNameForWrapping(_strCurrIndex, _strParentNodeName)) && ((!_booIsArray) && (_strConstructor.indexOf("Array") < 0)))\n\t\t\t\t{\n\t\t\t\t\t_objWhatObject[_strCurrIndex] = [_objWhatObject[_strCurrIndex]];\n\t\t\t\t\t_objCurrItem = _objWhatObject[_strCurrIndex];\n\t\t\t\t}\n\n\t\t\t\t// Recheck the value\'s here in case they have changed due to the above;\n\t\t\t\t_strConstructor = _objCurrItem.constructor.toString();\n\t\t\t\t_booIsArray = (_objCurrItem instanceof Array);\n\t\t\t\t_booIsObject = (_objCurrItem instanceof Object);\n\n\t\t\t\t// If its an object, recurse.\n\t\t\t\tif (((_booIsObject) || (_strConstructor.indexOf("Object") > -1)) && (((!_booIsArray) && (_strConstructor.indexOf("Array") < 0))))\n\t\t\t\t{\n\t\t\t\t\t// Must assign directly to the JSON object\n\t\t\t\t\t_objWhatObject[_strCurrIndex] = this._parseObject(_objCurrItem, _strCurrIndex)\n\t\t\t\t}\n\n\n\t\t\t\t// If its an array branch, and possibly recurse if it\n\t\t\t\t// contains arrays or objects.\n\t\t\t\tif (_booIsArray || (_strConstructor.indexOf("Array") > -1))\n\t\t\t\t{\n\t\t\t\t\t// Must assign directly to the JSON object\n\t\t\t\t\t_objWhatObject[_strCurrIndex] = this._parseArray(_objCurrItem)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn _objWhatObject;\n\t},\n\n\n\t_parseArray : function (_arrWhatArray)\n\t{\n\t\tvar count = 0;\n\t\twhile (count < _arrWhatArray.length)\n\t\t{\n\t\t\tvar _objCurrItem = _arrWhatArray[count];\n\n\t\t\tvar _strConstructor = _objCurrItem.constructor.toString();\n\t\t\tvar _booIsArray = (_objCurrItem instanceof Array)\n\t\t\tvar _booIsObject = (_objCurrItem instanceof Object)\n\n\t\t\tif (((_booIsObject) || (_strConstructor.indexOf("Object") > -1)) && ((!_booIsArray) || (_strConstructor.indexOf("Array") < 0)))\n\t\t\t{\n\t\t\t\t// Must assign directly to the JSON object\n\t\t\t\t_arrWhatArray[count] = this._parseObject(_objCurrItem);\n\t\t\t}\n\t\t\tif (_booIsArray || (_strConstructor.indexOf("Array") > -1))\n\t\t\t{\n\t\t\t\t// Must assign directly to the JSON object\n\t\t\t\t_arrWhatArray[count] = this._parseArray(_objCurrItem);\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\n\t\treturn _arrWhatArray;\n\t},\n\n\t_checkCurrNodeNameForWrapping : function(_strWhatNodeName, _strWhatParentNodeName)\n\t{\n\t\t// If there\'s no parent, we can\'t be in a collection.\n\t\tif (!_strWhatParentNodeName)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\tvar count = 0;\n\t\twhile (count < this._arrNodesToCheckForArrayWrapping.length)\n\t\t{\n\t\t\tif ((this._arrNodesToCheckForArrayWrapping[count][0] == _strWhatParentNodeName) || (this._arrNodesToCheckForArrayWrapping[count][0] == "*"))\n\t\t\t{\n\t\t\t\tif (this._arrNodesToCheckForArrayWrapping[count][1] == _strWhatNodeName)\n\t\t\t\t{\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\treturn false;\n\t},\n\n\tdebug : function (strMessage, intPriority, objCallerObject, booCalleeChain)\n\t{\n\t\tif (DEBUG)\n\t\t{\n\t\t\tDEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n\t\t}\n\t}\n}\n//AUTO_DOC.register(JSON_POST, JSON_POST.strObjID);'},function(n,e,t){t(0)(t(69))},function(n,e){n.exports="/* global COURSE_TITLE:true, DEBUG, Module, Topic */\n/* exported COURSE_TITLE, COURSE_STRUCTURE_PARSER */\n\n/**\n * @title Course Structure Parser\n * @description To be described.\n *\n *\n * @author GoMo\n * @version 2.0 17/12/12\n */\n\nvar COURSE_STRUCTURE_PARSER = {\n  strObjID: 'Course structure parser',\n\n  parseCourseData: function(_objWhatCourseJSON) {\n    var _objCourse = new Module(_objWhatCourseJSON['course']);\n    COURSE_TITLE = _objWhatCourseJSON.course.title || 'Unknown';\n    _objCourse.objCourseLaunchers = this._setCourseLaunchers(_objWhatCourseJSON['course']);\n    this._addTopics(_objCourse);\n    this._addMetaTopics(_objCourse);\n    return _objCourse;\n  },\n\n  _setCourseLaunchers: function(_objWhatCourse) {\n    var _objCourseLaunchers = {};\n    if (_objWhatCourse) {\n      var _objCourseStructure = _objWhatCourse.launchTopics;\n\n      if (_objCourseStructure.menu) {\n        _objCourseLaunchers.menu = _objCourseStructure.menu;\n      }\n      if (_objCourseStructure.primaryTopic) {\n        _objCourseLaunchers.primaryTopic = _objCourseStructure.primaryTopic;\n      }\n    }\n    return _objCourseLaunchers;\n  },\n\n  _addTopics: function(_objWhatElement) {\n    var _objCurrItemsCollection = _objWhatElement.objRawData.objTopics;\n    var _strTopicTitle;\n    for (_strTopicTitle in _objCurrItemsCollection) {\n      if (Object.prototype.hasOwnProperty.call(_objCurrItemsCollection, _strTopicTitle)) {\n        var _objCurrOptionElement = new Topic(\n          _objCurrItemsCollection[_strTopicTitle],\n          _objWhatElement\n        );\n        // REFACTOR NOTE: Do we still require a parent on an adhoc button system?\n        // _objCurrOptionElement.objParent = _objWhatElement;\n        _objWhatElement.addContainer(_objCurrOptionElement);\n      }\n    }\n  },\n\n  _addMetaTopics: function(_objWhatElement) {\n    if (_objWhatElement.objRawData.objMetaTopics) {\n      _objWhatElement.arrMetaTopics = [];\n      var _objCurrItemsCollection = _objWhatElement.objRawData.objMetaTopics;\n      var _strTopicTitle;\n      for (_strTopicTitle in _objCurrItemsCollection) {\n        if (Object.prototype.hasOwnProperty.call(_objCurrItemsCollection, _strTopicTitle)) {\n          var _objCurrOptionElement = new Topic(_objCurrItemsCollection[_strTopicTitle]);\n          // REFACTOR NOTE: Do we still require a parent on an adhoc button system?\n          // _objCurrOptionElement.objParent = _objWhatElement;\n          _objCurrOptionElement.strObjType = _objCurrItemsCollection[_strTopicTitle].strType;\n          _objWhatElement.arrMetaTopics.push(_objCurrOptionElement);\n        }\n      }\n    }\n  },\n\n  debug: function(strMessage, intPriority, objCallerObject, booCalleeChain) {\n    if (DEBUG) {\n      DEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n    }\n  },\n\n  booTerminal: true\n};\n"},function(n,e,t){t(0)(t(71))},function(n,e){n.exports="/* globals EM, LOCALISER, SCREEN_LAYOUT_PARSER, BOO_ALERT_ASSETLESS_SCREENS, CORE, DEBUG */\n/* globals Asset, Screen, SUB_SCREEN_INTERACTIONS, OBJ_REF, DISPLAY_CONDITIONS_INTERACTIONS */\n/* globals SubAsset, SubScreen, OBJ_LEGACY_GROUP_DATA */\n\n/**\n * @title Topic Structure Parser\n * @description To be described.\n *\n *\n * @author GoMo\n * @version 2.0 17/12/12\n */\n\nvar TOPIC_STRUCTURE_PARSER = {\n  strObjID: 'Topic structure parser',\n  arrDefaultAndClonedSubscreenIDs: [],\n\n  objPreProcessedAssets: {},\n\n  handleEvent_reportPreProcessedAssets: function() {\n    var _strReportText = LOCALISER.get('TOPIC_STRUCTURE_PARSER_PREPROCESS_ASSETS_REPORT_PREFIX');\n    for (var _strCurrAssetType in this.objPreProcessedAssets) {\n      if (Object.prototype.hasOwnProperty.call(this.objPreProcessedAssets, _strCurrAssetType)) {\n        _strReportText +=\n          'Asset type: ' +\n          LOCALISER.get('TOPIC_STRUCTURE_PARSER_PREPROCESS_ASSETS_REPORT_ASSET_PREFIX', [\n            _strCurrAssetType\n          ]) +\n          '\\n\\n';\n        var _objCurrAssetPreProcessingData = this.objPreProcessedAssets[_strCurrAssetType];\n        for (var _strCurrPreprocessResult in _objCurrAssetPreProcessingData) {\n          if (\n            Object.prototype.hasOwnProperty.call(\n              _objCurrAssetPreProcessingData,\n              _strCurrPreprocessResult\n            )\n          ) {\n            var _arrCurrAssetIDs = _objCurrAssetPreProcessingData[_strCurrPreprocessResult];\n            _strReportText += _strCurrPreprocessResult + _arrCurrAssetIDs.join(',');\n          }\n        }\n      }\n    }\n    alert(_strReportText);\n  },\n\n  parseTopicData: function(_objWhatTopicDataObject) {\n    var _arrScreenData = [];\n\n    _objWhatTopicDataObject.strNavigationType =\n      _objWhatTopicDataObject.objRawTopicData.strNavigationType;\n    _objWhatTopicDataObject.booContinuousScrolling =\n      _objWhatTopicDataObject.objRawTopicData.booContinuousScrolling;\n    var _arrRawScreenData = _objWhatTopicDataObject.objRawTopicData.arrScreens;\n    if (_arrRawScreenData) {\n      var count = 0;\n      while (count < _arrRawScreenData.length) {\n        var _objCurrRawScreenData = _arrRawScreenData[count];\n        var _objScreenCourseObject = this._createScreenData(\n          _objCurrRawScreenData,\n          _objWhatTopicDataObject\n        );\n        _objScreenCourseObject.objScreenLayoutData = SCREEN_LAYOUT_PARSER.getScreenLayoutData(\n          _objScreenCourseObject\n        );\n\n        _arrScreenData.push(_objScreenCourseObject);\n        count++;\n      }\n    }\n    _objWhatTopicDataObject.arrScreens = _arrScreenData;\n\n    this._setDefaults(_objWhatTopicDataObject);\n\n    return _arrScreenData;\n  },\n\n  parseDynamicTopicData: function(_objWhatTopicDataObject) {\n    var _arrScreenData = [];\n    var _arrRawScreenData = _objWhatTopicDataObject.objRawTopicData.arrScreens;\n    if (_arrRawScreenData) {\n      var count = 0;\n      while (count < _arrRawScreenData.length) {\n        var _objCurrRawScreenData = _arrRawScreenData[count];\n        if (!_objCurrRawScreenData.isDynamicScreen) {\n          // This screen doesn't need re-parsing so find it and add it to the new array\n          for (\n            var parsedCount = 0;\n            parsedCount < _objWhatTopicDataObject.arrScreens.length;\n            parsedCount++\n          ) {\n            var parsedScreen = _objWhatTopicDataObject.arrScreens[parsedCount];\n            if (parsedScreen.strObjID === _objCurrRawScreenData.strID) {\n              _arrScreenData.push(parsedScreen);\n              break;\n            }\n          }\n          count++;\n          continue;\n        }\n        var _objScreenCourseObject = this._createScreenData(\n          _objCurrRawScreenData,\n          _objWhatTopicDataObject\n        );\n        _objScreenCourseObject.objScreenLayoutData = SCREEN_LAYOUT_PARSER.getScreenLayoutData(\n          _objScreenCourseObject\n        );\n\n        _arrScreenData.push(_objScreenCourseObject);\n        count++;\n      }\n    }\n    _objWhatTopicDataObject.arrScreens = _arrScreenData;\n\n    var onlyDynamicScreens = true;\n    this._setDefaults(_objWhatTopicDataObject, onlyDynamicScreens);\n    return _arrScreenData;\n  },\n\n  // Creates a subscreen with a single text asset inside of it.\n  transferTextPropertyIntoSubScreen: function(_objWhatAssetDataHolder, _strWhatTextToConvert) {\n    var _strNewSubScreenID = this._getNextFreeSubScreenID(_objWhatAssetDataHolder);\n    var _objRawSubScreenData = this._createEmptySubscreen(\n      _strNewSubScreenID,\n      _objWhatAssetDataHolder.strObjID\n    );\n\n    var _strAssetID = _strNewSubScreenID + 'a01';\n    var _strRelatedLayoutID = _strNewSubScreenID + 'lay00';\n\n    var _objRawLayoutData = this._createEmptyLayoutBlock(\n      _strRelatedLayoutID,\n      _objWhatAssetDataHolder.strObjID\n    );\n    var _objRawTextAssetData = this._createSimpleTextAsset(\n      _strAssetID,\n      _objWhatAssetDataHolder.strObjID,\n      _strRelatedLayoutID,\n      _strWhatTextToConvert\n    );\n\n    _objRawSubScreenData.arrLayouts.push(_objRawLayoutData);\n    _objRawSubScreenData.arrAssets.push(_objRawTextAssetData);\n\n    return _objRawSubScreenData;\n  },\n\n  _parseTopicDataForFilenames: function(_objWhatTopicDataObject, _regexFileExt) {\n    var _strResult = this._parseObject(\n      _objWhatTopicDataObject.objRawTopicData,\n      _objWhatTopicDataObject.objParent,\n      _regexFileExt\n    );\n    var _arrSplit = _strResult.split(',');\n    _arrSplit.pop();\n    return _arrSplit;\n  },\n\n  _parseObject: function(_objWhatTopicDataObject, _objParent, _regexFileExt) {\n    var _strResult = '';\n\n    for (var _strCurrIndex in _objWhatTopicDataObject) {\n      if (Object.prototype.hasOwnProperty.call(_objWhatTopicDataObject, _strCurrIndex)) {\n        var _objCurrItem = _objWhatTopicDataObject[_strCurrIndex];\n        if (_objCurrItem == _objParent) {\n          continue;\n        }\n\n        if (typeof _objCurrItem == 'string') {\n          _strResult += this._checkForString(_objCurrItem, _regexFileExt);\n          // eslint-disable-next-line valid-typeof\n        } else if (typeof _objCurrItem == 'object' && !(typeof _objCurrItem == 'array')) {\n          _strResult += this._parseObject(_objCurrItem, _objWhatTopicDataObject, _regexFileExt);\n          // eslint-disable-next-line valid-typeof\n        } else if (typeof _objCurrItem == 'array') {\n          _strResult += this._parseArray(_objCurrItem, _objWhatTopicDataObject, _regexFileExt);\n        }\n      }\n    }\n\n    return _strResult;\n  },\n\n  _parseArray: function(_arrWhatArray, _objParent, _regexFileExt) {\n    var _strResult = '';\n    var count = 0;\n    while (count < _arrWhatArray.length) {\n      var _objCurrItem = _arrWhatArray[count];\n\n      if (_objCurrItem == _objParent) {\n        continue;\n      }\n\n      if (typeof _objCurrItem == 'string') {\n        _strResult += this._checkForString(_objCurrItem, _regexFileExt);\n        // eslint-disable-next-line valid-typeof\n      } else if (typeof _objCurrItem == 'object' && !(typeof _objCurrItem == 'array')) {\n        _strResult += this._parseObject(_objCurrItem, _objParent, _regexFileExt);\n        // eslint-disable-next-line valid-typeof\n      } else if (typeof _objCurrItem == 'array') {\n        _strResult += this._parseArray(_objCurrItem, _objParent, _regexFileExt);\n      }\n      count++;\n    }\n    return _strResult;\n  },\n\n  _checkForString: function(_strToCheck, _regexFileExt) {\n    var _arrRes = _strToCheck.match(_regexFileExt);\n    if (_arrRes) {\n      return _strToCheck + ',';\n    }\n    return '';\n  },\n\n  _createScreenData: function(_objWhatRawScreenData, _objWhatParentTopicDataObject) {\n    var _objTheScreenCourseObject = new Screen(\n      _objWhatRawScreenData,\n      _objWhatParentTopicDataObject\n    );\n\n    var _arrAssetData = [];\n    if (_objWhatRawScreenData.arrAssets && _objWhatRawScreenData.arrAssets.length > 0) {\n      var _arrRawAssetData = _objWhatRawScreenData.arrAssets;\n      var count = 0;\n      while (count < _arrRawAssetData.length) {\n        var _objRawAssetData = _arrRawAssetData[count];\n        var _objTheCourseAssetData = this._createAssetData(\n          _objRawAssetData,\n          _objTheScreenCourseObject\n        );\n        _arrAssetData.push(_objTheCourseAssetData);\n\n        var _strCurrAssetType = _objRawAssetData.strType;\n        if (!_objTheScreenCourseObject.objAssetCountsByType[_strCurrAssetType]) {\n          _objTheScreenCourseObject.objAssetCountsByType[_strCurrAssetType] = 1;\n        } else {\n          _objTheScreenCourseObject.objAssetCountsByType[_strCurrAssetType]++;\n        }\n        count++;\n      }\n    } else if (BOO_ALERT_ASSETLESS_SCREENS) {\n      LOCALISER.l_alert('TOPIC_STRUCTURE_PARSER_ASSETLESS_SCREEN_ERROR', [\n        _objTheScreenCourseObject.strObjID\n      ]);\n    }\n\n    _objTheScreenCourseObject.arrAssets = _arrAssetData;\n\n    if (\n      _objWhatRawScreenData.objDisplayConditions &&\n      _objWhatRawScreenData.objDisplayConditions.arrDisplayConditions.length\n    ) {\n      _objTheScreenCourseObject.objDisplayConditions = _objWhatRawScreenData.objDisplayConditions;\n    }\n\n    var _arrSubScreens = this._mergeSubScreensAndClonedSubscreens(\n      _objWhatRawScreenData,\n      _objTheScreenCourseObject\n    );\n\n    _objTheScreenCourseObject.arrSubScreens = _arrSubScreens;\n\n    _objTheScreenCourseObject.booHasQuestionAsset = _objTheScreenCourseObject.checkForAssetMetaType(\n      'question'\n    );\n\n    return _objTheScreenCourseObject;\n  },\n\n  _mergeSubScreensAndClonedSubscreens: function(_objWhatRawScreenData, _objTheScreenCourseObject) {\n    this.arrDefaultAndClonedSubscreenIDs = [];\n    this.arrDefaultAndClonedSubscreenIDs.strID = _objWhatRawScreenData.strID;\n    for (var intCount = 0; intCount < _objWhatRawScreenData.arrSubscreens.length; intCount++) {\n      this.arrDefaultAndClonedSubscreenIDs.push({\n        strID: _objWhatRawScreenData.arrSubscreens[intCount].strID\n      });\n    }\n\n    // Get clone list and add to this.arrDefaultAndClonedSubscreenIDs\n    // ### All subscreens should now been cloned for possible future clashes.\n\n    // Grab cloned ID's from the screen data\n    var _arrToClone = CORE.getArrayOfItemsFromObjectAtKeyValue(\n      _objWhatRawScreenData.arrAssets,\n      'strActionType',\n      'showSubScreen'\n    );\n\n    var _arrCloneList = [];\n    for (intCount = 0; intCount < _arrToClone.length; intCount++) {\n      var _booAssetOwnedSubscreen = false;\n      var _strToClone = _arrToClone[intCount].objParameters.strSubScreenID;\n      if (_arrToClone[intCount].objParameters.booAssetOwnedSubscreen) {\n        _booAssetOwnedSubscreen = true;\n      }\n      var _strCloneStrId = this._createNextSubScreenID();\n\n      var cloneFrom = _strToClone;\n      if (_arrToClone[intCount].objParameters.strSubScreenUUID) {\n        cloneFrom = _arrToClone[intCount].objParameters.strSubScreenUUID;\n      }\n      SUB_SCREEN_INTERACTIONS.registerSubscreens(cloneFrom, _strCloneStrId);\n\n      this.arrDefaultAndClonedSubscreenIDs.push({strID: _strCloneStrId});\n      _arrCloneList.push({\n        strToClone: _strToClone,\n        strCloneStrId: _strCloneStrId,\n        booAssetOwnedSubscreen: _booAssetOwnedSubscreen\n      });\n      // Point the action to the new subscreen\n      _arrToClone[intCount].objParameters.strSubScreenID = _strCloneStrId;\n    }\n\n    var _arrRawSubScreenData = [];\n    var _objRawSubScreenData = [];\n    var _objTheCourseSubScreenData = {};\n    var count = 0;\n    // Grab cloned ID's from the subscreens data so we can translate later (for assets which own subscreens)\n    if (_objWhatRawScreenData.arrSubscreens && _objWhatRawScreenData.arrSubscreens.length > 0) {\n      _arrRawSubScreenData = _objWhatRawScreenData.arrSubscreens;\n      while (count < _arrRawSubScreenData.length) {\n        _objRawSubScreenData = _arrRawSubScreenData[count];\n        _objTheCourseSubScreenData = this._createSubScreenData(\n          _objRawSubScreenData,\n          _objTheScreenCourseObject\n        );\n\n        var subArrToClone = CORE.getArrayOfItemsFromObjectAtKeyValue(\n          _objRawSubScreenData.arrAssets,\n          'strActionType',\n          'showSubScreen'\n        );\n        // Add strType actions too. These are built from user created actions which are forced to use strType due to editor legacy design\n        subArrToClone.concat(\n          CORE.getArrayOfItemsFromObjectAtKeyValue(\n            _objRawSubScreenData.arrAssets,\n            'strType',\n            'showSubScreen'\n          )\n        );\n\n        var countSubscreens = 0;\n        var cloneTo = [];\n        while (countSubscreens < subArrToClone.length) {\n          if (subArrToClone[countSubscreens].objParameters.strSubScreenUUID) {\n            cloneFrom = subArrToClone[countSubscreens].objParameters.strSubScreenUUID;\n            cloneTo = subArrToClone[countSubscreens].objParameters.strSubScreenID;\n            SUB_SCREEN_INTERACTIONS.registerSubscreens(cloneFrom, cloneTo);\n          }\n          countSubscreens++;\n        }\n\n        count++;\n      }\n    }\n\n    // Build all subscreens\n    var _arrSubScreens = [];\n    if (_objWhatRawScreenData.arrSubscreens && _objWhatRawScreenData.arrSubscreens.length > 0) {\n      _arrRawSubScreenData = _objWhatRawScreenData.arrSubscreens;\n      count = 0;\n      while (count < _arrRawSubScreenData.length) {\n        _objRawSubScreenData = _arrRawSubScreenData[count];\n        _objTheCourseSubScreenData = OBJ_REF.get(_objRawSubScreenData.strID);\n\n        // If the subscreens is built inside an asset, it won't be rendered yet and needs creating\n        if (_objTheCourseSubScreenData == false) {\n          _objTheCourseSubScreenData = this._createSubScreenData(\n            _objRawSubScreenData,\n            _objTheScreenCourseObject\n          );\n        }\n\n        // _objTheCourseSubScreenData.objSubScreenLayoutData = SCREEN_LAYOUT_PARSER.getScreenLayoutData(_objTheCourseSubScreenData);\n\n        _arrSubScreens.push(_objTheCourseSubScreenData);\n\n        // Build clones and add to subscreen data array\n        for (intCount = 0; intCount < _arrCloneList.length; intCount++) {\n          if (_arrCloneList[intCount].strToClone == _arrRawSubScreenData[count].strID) {\n            var _objCloneData = CORE.cloneObject(_arrRawSubScreenData[count]);\n            _objCloneData.strID = _arrCloneList[intCount].strCloneStrId;\n            _objCloneData.booAssetOwnedSubscreen = _arrCloneList[intCount].booAssetOwnedSubscreen;\n\n            var _objOptions = {\n              _strSearchTerm: '',\n              _strSearchValue: _arrCloneList[intCount].strToClone,\n              _arrResult: [],\n              _strReplace: _arrCloneList[intCount].strCloneStrId\n            };\n            CORE.searchObj(_objCloneData, _objOptions);\n\n            _objWhatRawScreenData.arrSubscreens.push(_objCloneData);\n            _arrRawSubScreenData[count].cloned = true;\n          }\n        }\n        count++;\n      }\n    }\n    return _arrSubScreens;\n  },\n\n  // SUBSCREEN ID ITERATOR\n  _createNextSubScreenID: function() {\n    var count = 0;\n    var _intCurrHighestID = -1;\n    var _strSubScreenIDPrefix = this.arrDefaultAndClonedSubscreenIDs.strID;\n    while (count < this.arrDefaultAndClonedSubscreenIDs.length) {\n      var _objCurrSubscreen = this.arrDefaultAndClonedSubscreenIDs[count];\n      if (_objCurrSubscreen.strID.indexOf(_strSubScreenIDPrefix) > -1) {\n        var _intCurrSubscreenIDIndex = this._getSubIDIndex(_objCurrSubscreen['strID']);\n        if (_intCurrSubscreenIDIndex > _intCurrHighestID) {\n          _intCurrHighestID = _intCurrSubscreenIDIndex;\n        }\n      }\n      count++;\n    }\n    if (_intCurrHighestID == -1) {\n      // No assets for this screen yet. Don't want id's ending in a00.\n      _intCurrHighestID = 0;\n    }\n    return _strSubScreenIDPrefix + this._padSubScreenID(_intCurrHighestID + 1);\n  },\n\n  _getSubIDIndex: function(_strWhatFullSubScreenID) {\n    var _strSubID = _strWhatFullSubScreenID.slice(\n      _strWhatFullSubScreenID.lastIndexOf('sub') + 3,\n      _strWhatFullSubScreenID.length\n    );\n\n    // We can't just parseInt() as the asset ID's start with 0 and parseInt() would think they are Octal.\n    var count = 0;\n    while (count < _strSubID.length) {\n      if (_strSubID.charAt(count) != '0') {\n        _strSubID = _strSubID.slice(count, _strSubID.length);\n        break;\n      }\n      count++;\n    }\n    return parseInt(_strSubID);\n  },\n\n  /** SUBSCREEN ID ITERATOR END **/\n\n  _createAssetData: function(_objWhatRawAssetData, _objWhatParentScreenObject) {\n    // Allow's pre-processing of certain asset types.\n    _objWhatRawAssetData = this._preProcessAssetData(\n      _objWhatRawAssetData,\n      _objWhatParentScreenObject\n    );\n\n    var _objTheAssetCourseObject = new Asset(_objWhatRawAssetData, _objWhatParentScreenObject);\n\n    // Loop through any sub assets\n    var _arrSubAssets = [];\n    if (\n      _objWhatRawAssetData['subassets'] &&\n      _objWhatRawAssetData['subassets']['subasset'] &&\n      _objWhatRawAssetData['subassets']['subasset'].length > 0\n    ) {\n      var _arrRawSubAssetsData = _objWhatRawAssetData['subassets']['subasset'];\n      var count = 0;\n      while (count < _arrRawSubAssetsData.length) {\n        var _objRawSubAssetData = _arrRawSubAssetsData[count];\n        var _objTheCourseSubAssetData = this._createSubAssetData(\n          _objRawSubAssetData,\n          _objTheAssetCourseObject\n        );\n        _arrSubAssets.push(_objTheCourseSubAssetData);\n        count++;\n      }\n    }\n    _objTheAssetCourseObject.arrSubAssets = _arrSubAssets;\n\n    return _objTheAssetCourseObject;\n  },\n\n  _preProcessAssetData: function(_objWhatRawAssetData, _objWhatParentScreenObject) {\n    // REFACTOR NOTE: This is a temporary workaround for the change over from one asset name to another.\n    if (_objWhatRawAssetData.strType == 'assessment_intro') {\n      _objWhatRawAssetData.strType = 'assessmentintro';\n    }\n    if (_objWhatRawAssetData.strType == 'assessment_results') {\n      _objWhatRawAssetData.strType = 'assessmentresults';\n    }\n\n    if (!_objWhatRawAssetData.strGroup) {\n      _objWhatRawAssetData.strGroup = OBJ_LEGACY_GROUP_DATA[_objWhatRawAssetData.strType];\n    }\n\n    if (this['_preProcess_' + _objWhatRawAssetData.strType + '_Asset']) {\n      _objWhatRawAssetData = this['_preProcess_' + _objWhatRawAssetData.strType + '_Asset'](\n        _objWhatRawAssetData,\n        _objWhatParentScreenObject\n      );\n    }\n\n    if (this['_preProcess_' + _objWhatRawAssetData.strGroup + '_GroupAsset']) {\n      _objWhatRawAssetData = this['_preProcess_' + _objWhatRawAssetData.strGroup + '_GroupAsset'](\n        _objWhatRawAssetData,\n        _objWhatParentScreenObject\n      );\n    }\n    return _objWhatRawAssetData;\n  },\n\n  _createSubScreenData: function(_objWhatRawSubScreenData, _objWhatParentAssetDataObject) {\n    var _objTheSubScreenCourseObject = new SubScreen(\n      _objWhatRawSubScreenData,\n      _objWhatParentAssetDataObject\n    );\n\n    var _arrAssetData = [];\n    if (_objWhatRawSubScreenData.arrAssets && _objWhatRawSubScreenData.arrAssets.length > 0) {\n      var _arrRawAssetData = _objWhatRawSubScreenData.arrAssets;\n      var count = 0;\n      while (count < _arrRawAssetData.length) {\n        var _objRawAssetData = _arrRawAssetData[count];\n        var _objTheCourseAssetData = this._createAssetData(\n          _objRawAssetData,\n          _objTheSubScreenCourseObject\n        );\n        _arrAssetData.push(_objTheCourseAssetData);\n        count++;\n      }\n    } else if (BOO_ALERT_ASSETLESS_SCREENS) {\n      LOCALISER.l_alert('', [_objTheSubScreenCourseObject.strObjID]);\n    }\n    _objTheSubScreenCourseObject.arrAssets = _arrAssetData;\n    return _objTheSubScreenCourseObject;\n  },\n\n  _createSubAssetData: function(_objRawSubAssetData, _objTheAssetCourseObject) {\n    return new SubAsset(_objRawSubAssetData, _objTheAssetCourseObject);\n  },\n\n  _addToPreProcessedAssetList: function(_strAssetType, _strPreprocessResult, _strAssetID) {\n    if (!this.objPreProcessedAssets[_strAssetType]) {\n      this.objPreProcessedAssets[_strAssetType] = {};\n    }\n    if (!this.objPreProcessedAssets[_strAssetType][_strPreprocessResult]) {\n      this.objPreProcessedAssets[_strAssetType][_strPreprocessResult] = [];\n    }\n    this.objPreProcessedAssets[_strAssetType][_strPreprocessResult].push(_strAssetID);\n  },\n\n  _getPrecedingSibling: function(\n    _objWhatRawAssetData,\n    _objWhatParentScreenObject,\n    _booIgnoreColumns\n  ) {\n    var count = 0;\n    var _arrScreenAssets = _objWhatParentScreenObject.objRawData.arrAssets;\n    while (count < _arrScreenAssets.length) {\n      var _objCurrAsset = _arrScreenAssets[count];\n      // If we've found the current asset\n      if (_objCurrAsset.strID == _objWhatRawAssetData.strID) {\n        var _intCurrColumnAffinity = _objCurrAsset['@columnaffinity'];\n        if (count > 0) {\n          if (_booIgnoreColumns) {\n            return _arrScreenAssets[count - 1];\n          }\n\n          var iCount = count - 1;\n          // Loop back through the assets to find the first predecessor in the same column.\n          while (iCount >= 0) {\n            var _objCurrPredecessor = _arrScreenAssets[iCount];\n            if (_objCurrPredecessor['@columnaffinity'] == _intCurrColumnAffinity) {\n              return _objCurrPredecessor;\n            }\n            iCount--;\n          }\n          // If we've not found one by now, there where predecessor's but they weren't in the same column\n          return false;\n        } else {\n          return false;\n        }\n      }\n      count++;\n    }\n\n    LOCALISER.l_alert('TOPIC_STRUCTURE_PARSER_UNABLE_TO_FIND_ASSET_TO_GET_PRECEDING_ASSET_ERROR', [\n      _objWhatRawAssetData.strID\n    ]);\n    return false;\n  },\n\n  _getFollowingSibling: function(\n    _objWhatRawAssetData,\n    _objWhatParentScreenObject,\n    _booIgnoreColumns\n  ) {\n    var count = 0;\n    var _arrScreenAssets = _objWhatParentScreenObject.objRawData.arrAssets;\n    while (count < _arrScreenAssets.length) {\n      var _objCurrAsset = _arrScreenAssets[count];\n      // If we've found the current asset\n      if (_objCurrAsset.strID == _objWhatRawAssetData.strID) {\n        var _intCurrColumnAffinity = _objCurrAsset['@columnaffinity'];\n        if (count < _arrScreenAssets.length - 1) {\n          if (_booIgnoreColumns) {\n            return _arrScreenAssets[count + 1];\n          }\n\n          var iCount = count + 1;\n          // Loop on through the assets to find the first following asset in the same column.\n          while (iCount < _arrScreenAssets.length) {\n            var _objCurrFollowing = _arrScreenAssets[iCount];\n            if (_objCurrFollowing['@columnaffinity'] == _intCurrColumnAffinity) {\n              return _objCurrFollowing;\n            }\n            iCount++;\n          }\n          // If we've not found one by now, there where following asset's but they weren't in the same column\n          return false;\n        } else {\n          return false;\n        }\n      }\n      count++;\n    }\n    LOCALISER.l_alert('TOPIC_STRUCTURE_PARSER_UNABLE_TO_FIND_ASSET_TO_GET_FOLLOWING_ASSET_ERROR', [\n      _objWhatRawAssetData.strID\n    ]);\n    return false;\n  },\n\n  _preProcess_question_GroupAsset: function(_objWhatRawAssetData, _objWhatParentScreenObject) {\n    if (\n      !_objWhatRawAssetData.strAttempts ||\n      _objWhatRawAssetData.strAttempts == '' ||\n      _objWhatRawAssetData.strAttempts == 'null' ||\n      _objWhatRawAssetData.strAttempts == 'body'\n    ) {\n      _objWhatRawAssetData.strAttempts = 1;\n      this._addToPreProcessedAssetList(\n        _objWhatRawAssetData.strType,\n        'Added default attempts value:\\n\\n',\n        _objWhatRawAssetData.strID\n      );\n    }\n    return _objWhatRawAssetData;\n  },\n\n  _createEmptySubscreen: function(_strNewSubScreenID, _strInstigatingAssetID) {\n    var _objBlankSubscreen = {\n      strID: _strNewSubScreenID,\n      strType: 'standard',\n      strTitle: 'Auto-generated by pre-process action for asset \\'' + _strInstigatingAssetID + '\\'',\n      strDataType: 'screen',\n      strInstigatingAssetID: _strInstigatingAssetID,\n\n      objNormalBackgroundSrc: {\n        strSrc: '',\n        strAltText: '',\n        strBriefText: ''\n      },\n\n      objAltBackgroundSrc: {\n        strSrc: '',\n        strAltText: '',\n        strBriefText: ''\n      },\n\n      strScreenBackgroundColor: '',\n      strBackgroundOpacity: '1',\n\n      objItemPositioning: {\n        intTop: 50,\n        intLeft: 50,\n        intWidth: 50,\n        intHeight: 50,\n        strAlignment: 'bottom'\n      },\n\n      arrLayouts: [],\n      arrAssets: [],\n      arrSubscreens: [],\n      strSubscreenType: 'reveal',\n      strNotes: '',\n      strMetaData: '',\n\n      objNavigationConfiguration: {},\n      booCountAsFinalScreen: false,\n      booLockScreenUntilComplete: false\n    };\n\n    return _objBlankSubscreen;\n  },\n\n  _createEmptyLayoutBlock: function(_strWhatLayoutID) {\n    var _objNewLayoutBlock = {\n      strID: _strWhatLayoutID,\n      strDataType: 'layout',\n      intNumberOfColumns: 1,\n      strCSSClass: '',\n      strMetaData: '',\n      objStylingData: {\n        objColumn1Styles: {\n          strBackgroundColour: '',\n          strBackgroundOpacity: '',\n          strBackgroundImage: ''\n        },\n        objColumn2Styles: {\n          strBackgroundColour: '',\n          strBackgroundOpacity: '',\n          strBackgroundImage: ''\n        },\n        objColumn3Styles: {\n          strBackgroundColour: '',\n          strBackgroundOpacity: '',\n          strBackgroundImage: ''\n        },\n        objColumn4Styles: {\n          strBackgroundColour: '',\n          strBackgroundOpacity: '',\n          strBackgroundImage: ''\n        }\n      }\n    };\n\n    return _objNewLayoutBlock;\n  },\n\n  _createSimpleTextAsset: function(\n    _strWhatAssetID,\n    _strInstigatingAssetID,\n    _strRelatedLayoutID,\n    _strWhatTextToConvert\n  ) {\n    var _objNewTextAsset = {\n      // Use of \"gomo-auto\" presumes the archtecture will take care of populating a value automatically.\n      strID: _strWhatAssetID,\n      strLabel: 'Auto-generated by pre-process action for asset \\'' + _strInstigatingAssetID + '\\'',\n      // Asset's strID property?\n      strType: 'text',\n      strGroup: 'presentation', // ### Check these make sense!\n      strVersion: '1.0',\n      strLayoutID: _strRelatedLayoutID,\n      strDataType: 'assets',\n      intLayoutColumn: 0,\n      intColumnPositionIndex: 0,\n      booGroupTemplateDataLocked: null,\n      strGroupTemplateId: null,\n      booInteractive: false,\n      arrSearchableFields: ['strContent'],\n      arrTranslatableFields: ['strContent'],\n      objDeveloperOptions: {\n        objMetaData: {\n          strRawMetaData: ''\n        },\n        objAdvancedStyling: {\n          strCustomCSSClasses: ''\n        }\n      },\n\n      // Other asset specific properties\n      strTextStyle: 'gomo-body',\n      strTextAlign: 'left-align',\n      strContent: _strWhatTextToConvert,\n\n      arrDisplayConditions: [],\n      objActionSets: {},\n      objDisplayAnimation: {\n        strAnimationType: 'none',\n        intAnimationDelay: 1,\n        intAnimationDuration: 1\n      }\n    };\n\n    return _objNewTextAsset;\n  },\n\n  _getNextFreeSubScreenID: function(_objWhatAssetDataHolder) {\n    var _objParentElement = _objWhatAssetDataHolder.objParent;\n    if (_objParentElement.strObjType == 'subscreen') {\n      _objParentElement = _objParentElement.objParent;\n    }\n\n    var count = 0;\n    var _intCurrHighestID = -1;\n\n    var _arrExistingSubScreens = _objParentElement.objRawData.arrSubscreens;\n    while (count < _arrExistingSubScreens.length) {\n      var _objCurrSubScreen = _arrExistingSubScreens[count];\n      var _intCurrSubScreenIDIndex = this._getSubScreenIDIndex(_objCurrSubScreen.strID);\n      if (_intCurrSubScreenIDIndex > _intCurrHighestID) {\n        _intCurrHighestID = _intCurrSubScreenIDIndex;\n      }\n      count++;\n    }\n\n    return _objParentElement.strObjID + this._padSubScreenID(_intCurrHighestID + 1);\n  },\n\n  _getSubScreenIDIndex: function(_strWhatFullSubScreenID) {\n    var _strSubScreentID = _strWhatFullSubScreenID.slice(\n      _strWhatFullSubScreenID.indexOf('sub') + 3,\n      _strWhatFullSubScreenID.length\n    );\n\n    // We can't just parseInt() as the asset ID's start with 0 and parseInt() would think they are Octal.\n    var count = 0;\n    while (count < _strSubScreentID.length) {\n      if (_strSubScreentID.charAt(count) != '0') {\n        _strSubScreentID = _strSubScreentID.slice(count, _strSubScreentID.length);\n        break;\n      }\n      count++;\n    }\n    return parseInt(_strSubScreentID);\n  },\n\n  _padSubScreenID: function(_intWhatSubScreenID) {\n    var _strSubScreenID = _intWhatSubScreenID.toString();\n\n    while (_strSubScreenID.length < 2) {\n      _strSubScreenID = '0' + _strSubScreenID;\n    }\n    return 'sub' + _strSubScreenID;\n  },\n\n  _setDefaults: function(_objWhatTopicData, onlyDynamicScreens) {\n    // Moved here from initial asset creation inside the constructor as display conditions\n    // can now rely on the states of other assets that may or may not have been parsed at\n    // the previous point where display conditions where set.\n    this._setInitialDisplayConditionsOnTopicObject(_objWhatTopicData, onlyDynamicScreens);\n  },\n\n  _setInitialDisplayConditionsOnTopicObject: function(_objWhatTopicData, onlyDynamicScreens) {\n    var count = 0;\n    while (count < _objWhatTopicData.arrScreens.length) {\n      var _objCurrScreen = _objWhatTopicData.arrScreens[count];\n      // If we're only setting dynamic screens and this isn't one then skip to next loop\n      if (\n        onlyDynamicScreens &&\n        _objCurrScreen.objRawData &&\n        !_objCurrScreen.objRawData.isDynamicScreen\n      ) {\n        count++;\n        continue;\n      }\n      DISPLAY_CONDITIONS_INTERACTIONS.setObjectsDisplayedState(_objCurrScreen, 'screen');\n      this._setInitialDisplayConditionsOnScreenObject(_objCurrScreen, onlyDynamicScreens);\n      count++;\n    }\n  },\n\n  _setInitialDisplayConditionsOnScreenObject: function(_objWhatScreen, dynamicScreensItem) {\n    // Set Assets Display conditions\n    var count = 0;\n    while (count < _objWhatScreen.arrAssets.length) {\n      var _objCurrAsset = _objWhatScreen.arrAssets[count];\n      DISPLAY_CONDITIONS_INTERACTIONS.setObjectsDisplayedState(_objCurrAsset, 'asset', dynamicScreensItem);\n\n      var _arrCurrSubScreenArray = _objWhatScreen.arrSubScreens;\n      if (_arrCurrSubScreenArray) {\n        var iCount = 0;\n        while (iCount < _arrCurrSubScreenArray.length) {\n          var _objCurrScreen = _arrCurrSubScreenArray[iCount];\n          this._setInitialDisplayConditionsOnScreenObject(_objCurrScreen);\n          iCount++;\n        }\n      }\n\n      count++;\n    }\n\n    // Set Navigations Display conditions\n    for (var navigationObject in _objWhatScreen.objNavigationItems) {\n      if (\n        Object.prototype.hasOwnProperty.call(_objWhatScreen.objNavigationItems, navigationObject)\n      ) {\n        _objWhatScreen.objNavigationItems[navigationObject].screenId = _objWhatScreen.strObjID;\n        DISPLAY_CONDITIONS_INTERACTIONS.setObjectsDisplayedState(\n          _objWhatScreen.objNavigationItems[navigationObject],\n          'navigation'\n        );\n      }\n    }\n  },\n\n  debug: function(strMessage, intPriority, objCallerObject, booCalleeChain) {\n    if (DEBUG) {\n      DEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n    }\n  }\n};\n\nEM.register(TOPIC_STRUCTURE_PARSER);\n"},function(n,e,t){t(0)(t(73))},function(n,e){n.exports="/**\n* @title Screen Layout Parser\n* @description To be described.\n*\n*\n* @author GoMo\n* @version 2.0 17/12/12\n*/\n\n// REFACTOR NOTE: Add some error checking?\n// REFACTOR NOTE: This file needs multiple coding standards issues correcting.\n// REFACTOR NOTE: I'm also unsure if the data returned from this class is ever actually used?\n\nvar SCREEN_LAYOUT_PARSER =\n{\n    strObjID : \"Sreen layout parser\",\n\n    _objTempLayoutData : {'rows' : []},\n\n    getScreenLayoutData : function(_objWhatScreenData)\n    {\n        var _arrAssets = _objWhatScreenData.arrAssets;\n        var _intScreenRow = 0;\n\n        for(var i = 0; i < _arrAssets.length; i++)\n        {\n            var _objCurrAsset = _arrAssets[i];\n\t\t\tvar _intCurrAssetColumnAffinity = _objCurrAsset.intColumnAffinity;\n\n\t\t\tvar _objPrevAsset = _arrAssets[(i-1)];\n\t\t\tvar _intPrevAssetColumnAffinity = ((_objPrevAsset) ? _objPrevAsset.intColumnAffinity : null);\n\n\t\t\t// if it's a spanning asset\n\t\t\tif(_objCurrAsset && _intCurrAssetColumnAffinity == 0)\n\t\t\t{\n\t\t\t\t// check if there are any assets in current row\n\t\t\t\t// and whether the previous asset was not a spanning one\n\t\t\t\tif((this._checkAssetExistsInCurrRow(_intScreenRow)) && (_objPrevAsset && _intPrevAssetColumnAffinity != 0))\n\t\t\t\t{\n\t\t\t\t\t// then increment row\n\t\t\t\t\t_intScreenRow++;\n\t\t\t\t}\n\n\t\t\t\t// add asset to row\n\t\t\t\tthis._addAssetToRow(_intScreenRow, _objCurrAsset);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// here is a normal asset with a particular column affinity\n\t\t\t\t// therefore we check if previous asset was a spanning one\n\t\t\t\tif(_objPrevAsset && _intPrevAssetColumnAffinity == 0)\n\t\t\t\t{\n\t\t\t\t\t// start a new row\n\t\t\t\t\t_intScreenRow++;\n\t\t\t\t}\n\n\t\t\t\t// add asset to row\n\t\t\t\tthis._addAssetToRow(_intScreenRow, _objCurrAsset);\n\t\t\t}\n        }\n\n\t\tvar _objTemplateLayoutData = this._objTempLayoutData;\n\n\t\t// reset the object\n\t\tthis._objTempLayoutData = {'rows' : []};\n\n        return _objTemplateLayoutData;\n    },\n\n    _checkAssetExistsInCurrRow : function(_intWhatCurrRow)\n    {\n    \tif(!this._objTempLayoutData['rows'][_intWhatCurrRow]) return false;\n\n    \tfor(_intColumnIndex in this._objTempLayoutData['rows'][_intWhatCurrRow]['columns'])\n    \t{\n    \t\tvar _arrCurrColumnData = this._objTempLayoutData['rows'][_intWhatCurrRow]['columns'][_intColumnIndex];\n\n    \t\tif(_arrCurrColumnData.length > 0)\n    \t\t{\n    \t\t\treturn true;\n    \t\t}\n    \t}\n\n    \treturn false;\n    },\n\n\t_addAssetToRow : function(_intRowIndex, _objWhatAssetData)\n\t{\n\t\tvar _objScreenData = _objWhatAssetData.objParent;\n\n\t\tif (!this._objTempLayoutData['rows'][_intRowIndex])\n\t\t{\n\t\t\t//this._objTempLayoutData['rows'][_intRowIndex] = this._setUpColumns(_objScreenData.intColumns, _objWhatAssetData.intColumnAffinity);\n\t\t\t//REFACTOR NOTE: This seens like an odd data structure to be using as 'columns' is the only item within this object?\n\t\t\tthis._objTempLayoutData['rows'][_intRowIndex] = {'columns' : {}};\n\t\t}\n\n\t\tif (!this._objTempLayoutData['rows'][_intRowIndex]['columns'][_objWhatAssetData.intColumnAffinity])\n\t\t{\n\t\t\tthis._objTempLayoutData['rows'][_intRowIndex]['columns'][_objWhatAssetData.intColumnAffinity] = [];\n\t\t}\n\t\tthis._objTempLayoutData['rows'][_intRowIndex]['columns'][_objWhatAssetData.intColumnAffinity].push(_objWhatAssetData.strObjID);\n\t},\n\n\t/*\n\t_setUpColumns : function(_intWhatScreenColumns, _intWhatAssetColumnAffinity)\n\t{\n\t\tvar _objColumnDataTemplate = {'columns' : {}};\n\n\t\t// set up columns for the given row\n\n\t\tif(_intWhatAssetColumnAffinity == 0)\n\t\t{\n\t\t\t_objColumnDataTemplate['columns'][_intWhatAssetColumnAffinity] = [];\n\n\t\t\treturn _objColumnDataTemplate;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(var i = 1; i <= _intWhatScreenColumns; i++)\n\t\t\t{\n\t\t\t\t_objColumnDataTemplate['columns'][i] = [];\n\t\t\t}\n\n\t\t\treturn _objColumnDataTemplate;\n\t\t}\n\t}*/\n\n\tbooTerminal : true\n}\n\n"},function(n,e,t){t(0)(t(75))},function(n,e){n.exports="/**\n* @title Course Objects\n* @description To be described.\n*\n*\n* @author GoMo\n* @version 2.0 17/12/12\n*/\n\n/* global INT_UNVISITED, OBJ_REF, EM, OBJ_ASSET_BOUNDARIES */\n\n/**\n * Module\n * @param {object} _objWhatData\n */\nfunction Module(_objWhatData) {\n  this.strObjID = _objWhatData['@id'];\n  this.strTitle = _objWhatData['#text'];\n  this.objRawData = _objWhatData;\n  this.objParent = null;\n  this.arrContainers = [];\n  this.strObjType = 'course';\n  this.intTrackingState = INT_UNVISITED;\n  this.strObjRelationalID = this.strObjID;\n  OBJ_REF.add(this, [this.strObjType]);\n}\n\n/**\n * Section\n * @param {object} _objWhatData\n */\nfunction Section(_objWhatData) {\n  this.strObjID = _objWhatData['@id'];\n  this.strTitle = _objWhatData['#text'];\n  this.objRawData = _objWhatData;\n  this.objParent = null;\n  this.arrContainers = [];\n  this.strObjType = 'section';\n  this.intTrackingState = INT_UNVISITED;\n  this.strObjRelationalID = this.strObjID;\n  OBJ_REF.add(this, [this.strObjType]);\n}\n\n/**\n * Topic\n * @param {object} _objWhatData\n * @param {object} _objWhatParent\n */\nfunction Topic(_objWhatData, _objWhatParent) {\n  var booReloadedData = OBJ_REF.testForID(_objWhatData.strID);\n  var previousData = booReloadedData ? OBJ_REF.get(_objWhatData.strID) : false;\n  this.strObjID = _objWhatData.strTopicID;\n  this.strTitle = '';\n  this.strNavigationType = _objWhatData.strNavigationType;\n  this.booTopicLoaded = false;\n  this.objRawCourseData = _objWhatData;\n  this.objRawTopicData = false;\n  this.objParent = _objWhatParent;\n  if (_objWhatData['@duration']) {\n    // This functionlaity has been dropped in favour of allowing the\n    // user to specify their own timing strings\n    // this.intDuration = parseInt(_objWhatData['@duration']);\n    this.intDuration = _objWhatData['@duration'];\n  } else {\n    this.intDuration = 0;\n  }\n  if (_objWhatData.strTopicDataFilename) {\n    this.strTopicDataFilename = _objWhatData.strTopicDataFilename;\n  } else {\n    this.strTopicDataFilename = null;\n  }\n  this.strObjType = 'topic';\n  if (_objWhatData['@model']) {\n    this.strObjTopicModel = _objWhatData['@model'];\n  } else {\n    this.strObjTopicModel = 'linear';\n  }\n  this.objAnsweredQuestions = booReloadedData ? previousData.objAnsweredQuestions : {};\n  this.objViewedQuestions = booReloadedData ? previousData.objViewedQuestions : {};\n\n  this.intTrackingState = booReloadedData ? previousData.intTrackingState : INT_UNVISITED;\n  this.intNavigationIndex =  booReloadedData ? previousData.intNavigationIndex :0;\n  this.arrScreens = [];\n  this.arrSourceScreens = [];\n  this.booImagesPreloaded = false;\n\n  if (this['extendTopicWrapperFor_' + this.strObjTopicModel + '_Topic']) {\n    this['extendTopicWrapperFor_' + this.strObjTopicModel + '_Topic']();\n  }\n\n  EM.trigger('topicCreated', {objTopicData: this});\n  OBJ_REF.add(this, [this.strObjType, this.strObjTopicModel]);\n}\n\n/**\n * Screen\n * @param {object} _objWhatData\n * @param {object} _objWhatParentTopic\n */\nfunction Screen(_objWhatData, _objWhatParentTopic) {\n  var booReloadedData = OBJ_REF.testForID(_objWhatData.strID);\n  var previousData = booReloadedData ? OBJ_REF.get(_objWhatData.strID) : false;\n  this.strObjID = _objWhatData.strID;\n  this.strTitle = _objWhatData.strTitle;\n  this.objRawData = _objWhatData;\n  this.objParent = _objWhatParentTopic;\n  this.objNavigationItems = _objWhatData.objNavigationConfiguration;\n  this.arrAssets = [];\n  this.arrSubScreens = [];\n  this.objAssetCountsByType = {};\n  this.booHasQuestionAsset = false;\n  this.strObjType = 'screen';\n  this.strOrigin = 'unknown';\n  this.objScreenLayoutData = {};\n  this.screenInteractedState = booReloadedData ? previousData.screenInteractedState : 0;\n  this.booIsDisplayed = booReloadedData ? previousData.booIsDisplayed : true;\n\n  this.arrChildLayouts = [];\n\n  // If this is NOT a normal screen type then ignore this step.\n  // To note, this will be true with 'search' extra on Content Banks\n\n  if (typeof _objWhatData['arrLayouts'] == 'undefined') {\n    return;\n  }\n\n  this._createLayoutObjects(_objWhatData['arrLayouts']);\n\n  if (_objWhatData['@columns']) {\n    this.intColumns = parseInt(_objWhatData['@columns']);\n  } else {\n    this.intColumns = 1;\n  }\n  this.booScreenShown = booReloadedData ? previousData.booScreenShown : false;\n  this.booScreenComplete = booReloadedData ? previousData.booScreenComplete : false;\n\n  // alert(_objWhatParentTopic.strObjTopicModel)\n  if (this['extendScreenWrapperFor_' + _objWhatParentTopic.strObjTopicModel + '_Topic']) {\n    this['extendScreenWrapperFor_' + _objWhatParentTopic.strObjTopicModel + '_Topic']();\n  }\n\n  EM.trigger('screenCreated', this);\n  OBJ_REF.add(this, [this.strObjType]);\n}\n\n/**\n * Layout data holder\n * @param {object} _objWhatJSONLayoutData\n * @param {object} _objWhatParentItem\n * @param {number} _intLayoutIndex\n */\nfunction LayoutDataHolder(_objWhatJSONLayoutData, _objWhatParentItem, _intLayoutIndex) {\n  this.objLayoutData = _objWhatJSONLayoutData;\n  this.objParentItem = _objWhatParentItem;\n\n  this.intLayoutIndex = _intLayoutIndex;\n\n  if (this.objLayoutData['intNumberOfColumns']) {\n    this.intColumns = parseInt(this.objLayoutData['intNumberOfColumns']);\n  } else {\n    this.objLayoutData['intNumberOfColumns'] = 1;\n    this.intColumns = 1;\n  }\n\n  // DATA_HOLDER_INTEGRETITY_CHECKER.addDataHolderReference(this.objLayoutData, \"layout\");\n\n  this.strObjID = this.objLayoutData['strID'];\n\n  OBJ_REF.add(this, [this.strObjType]);\n}\n\n/**\n * Asset\n * @param {object} _objWhatData\n * @param {object} _objWhatParentScreen\n */\nfunction Asset(_objWhatData, _objWhatParentScreen) {\n  var booReloadedData = OBJ_REF.testForID(_objWhatData.strID);\n  var previousData = booReloadedData ? OBJ_REF.get(_objWhatData.strID) : false;\n  this.strObjID = _objWhatData.strID;\n  this.strAssetType = _objWhatData.strType;\n\n  this.strAssetGroup = _objWhatData.strGroup;\n\n  this.objRawData = _objWhatData;\n  this.objParent = _objWhatParentScreen;\n\n  this.arrScreens = [];\n  this.arrSubAssets = [];\n\n  this.intLastInteractedSubAssetIndex = null;\n  this.strLastInteractedSubAssetID = '';\n  this.domLastInteractedItem = null;\n  this.initialised = null;\n\n  this.arrOptionStates = [];\n  this.objOptionStates = {}; // Use one or the other\n  this.objStateData = {}; // REFACTOR NOTE: This seems like duplication? JC\n\n  this.booIsCorrect = booReloadedData ? previousData.booIsCorrect : null;\n  this.booInteractable = true; // Set to false for answered questions\n  this.booComplete = booReloadedData ? previousData.booComplete : false;\n  this.strObjType = 'asset';\n  this.intUsersQuestionAttempts = booReloadedData ? previousData.intUsersQuestionAttempts : 0;\n  this.booIsDisplayed = booReloadedData ? previousData.booIsDisplayed : true;\n  this.booIsFirstAssetInColumn = false;\n  this.booIsLastAssetInColumn = false;\n\n  this.timeAvailable = null;\n  this.completionStatementSent = false;\n  this.trackingCompletionDelayed = false;\n\n  this.arrSearchableFields = _objWhatData.arrSearchableFields || null;\n\n  if (_objWhatData.strLayoutColumn) {\n    this.intColumnAffinity = parseInt(_objWhatData.strLayoutColumn);\n  } else {\n    this.intColumnAffinity = 1;\n  }\n\n  if (OBJ_ASSET_BOUNDARIES[_objWhatData.strType]) {\n    this.objAssetBoundaries = OBJ_ASSET_BOUNDARIES[_objWhatData.strType];\n  }\n\n  EM.trigger('assetCreated', {objAssetData: this});\n  OBJ_REF.add(this, [this.strObjType, this.strAssetType]);\n}\n\n/**\n * Subscreen\n * @param {object} _objWhatData\n * @param {object} _objWhatParentAsset\n */\nfunction SubScreen(_objWhatData, _objWhatParentAsset) {\n  this.strObjID = _objWhatData.strID;\n  this.strTitle = _objWhatData.strTitle;\n  this.strType = _objWhatData.strSubscreenType;\n  this.objRawData = _objWhatData;\n  this.objParent = _objWhatParentAsset;\n  this.arrAssets = [];\n  this.objAssetCountsByType = {};\n  this.booHasQuestionAsset = false;\n  this.strObjType = 'subscreen';\n\n  this.objSubScreenLayoutData = {};\n\n  this.arrChildLayouts = [];\n  this._createLayoutObjects(_objWhatData['arrLayouts']);\n\n  OBJ_REF.add(this, [this.strObjType]);\n  this.objAdditionalData = this.getAdditionalData(_objWhatData);\n  this.objTypeSubscreenDomExists = {};\n}\n\n/**\n * Sub asset\n * @param {object} _objWhatData\n * @param {object} _objWhatParentAsset\n */\nfunction SubAsset(_objWhatData, _objWhatParentAsset) { // eslint-disable-line no-unused-vars\n  this.strObjID = _objWhatData.strID;\n  this.strSubAssetType = _objWhatData.strTitle;\n  this.strAction = _objWhatData.arrActions;\n  this.objRawData = _objWhatData;\n  this.objParent = _objWhatParentAsset;\n  this.arrOptionStates = [];\n  this.strObjType = 'subasset';\n}\n\nModule.prototype.addContainer = addContainer;\nSection.prototype.addContainer = addContainer;\n\nModule.prototype.getParent = getParent;\nSection.prototype.getParent = getParent;\nTopic.prototype.getParent = getParent;\nAsset.prototype.getParent = getParent;\n\n\nModule.prototype.findTopic = findTopic;\nSection.prototype.findTopic = findTopic;\n\nModule.prototype.findMetaTopic = findMetaTopic;\nSection.prototype.findMetaTopic = findMetaTopic;\n\nTopic.prototype.addScreenData = addScreenData;\nTopic.prototype.findScreen = findScreen;\nTopic.prototype.getAssetsByType = getAssetsByTypeFromTopic;\nScreen.prototype.findSubScreen = findSubScreen;\n\nScreen.prototype._createLayoutObjects = _createLayoutObjects;\nSubScreen.prototype._createLayoutObjects = _createLayoutObjects;\n\nLayoutDataHolder.prototype.getRelatedAssets = getRelatedAssets;\nLayoutDataHolder.prototype._sortAssetsByColumnPositionIndex = _sortAssetsByColumnPositionIndex;\n\n\nScreen.prototype.findAsset = findAssetFromScreen;\nScreen.prototype.getAsset = findAsset;\nSubScreen.prototype.findAsset = findAsset;\n\nScreen.prototype.getAssetTypes = getAssetTypes;\nSubScreen.prototype.getAssetTypes = getAssetTypes;\n\nScreen.prototype.getAssetsByType = getAssetsByType;\nSubScreen.prototype.getAssetsByType = getAssetsByType;\n\nScreen.prototype.checkForAssetMetaType = checkForAssetMetaType;\nSubScreen.prototype.checkForAssetMetaType = checkForAssetMetaType;\n\nScreen.prototype.getAdditionalData = getAdditionalData;\nSubScreen.prototype.getAdditionalData = getAdditionalData;\n\nAsset.prototype.getActionSet = getAssetActionSet;\n\n/**\n * Add container\n * @param {object} _objWhatChildElement\n */\nfunction addContainer(_objWhatChildElement) {\n  this.arrContainers[this.arrContainers.length] = _objWhatChildElement;\n}\n\n/**\n * Get parent\n * @return {object}\n */\nfunction getParent() {\n  // REFACTOR NOTE: check if function is used and works with _split\n  /* if (!this.objParent) {\n    var _arrIDSplit = this.strObjID.split('_');\n    _arrIDSplit.pop();\n    this.objParent = CORE.getCourseItemById(_strParentID);\n    var _strParentID = _arrIDSplit.join('_');\n    this.arrFamilyTree = this.getFamilyTree();\n  } */\n  return this.objParent;\n}\n\n/**\n * Add screen data\n * @param {object} _objWhatScreenData\n */\nfunction addScreenData(_objWhatScreenData) {\n  this.arrScreens[this.arrScreens.length] = _objWhatScreenData;\n}\n\n/**\n * Find topic\n * @param {string} _strWhatTopicID\n * @return {object}\n */\nfunction findTopic(_strWhatTopicID) {\n  // Takes either the course structure ID 'p61_i582' or the content data file ID 'content_1415'\n  var count = 0;\n  while (count < this.arrContainers.length) {\n    var _objCurrContainer = this.arrContainers[count];\n    if ((_objCurrContainer.strObjID == _strWhatTopicID) ||\n       (_objCurrContainer.strTopicDataFilename == 'content_' + _strWhatTopicID)) {\n      return _objCurrContainer;\n    }\n    if (_objCurrContainer['findTopic']) {\n      var _objChildSearchResult = _objCurrContainer.findTopic(_strWhatTopicID);\n      if (_objChildSearchResult) {\n        return _objChildSearchResult;\n      }\n    }\n    count++;\n  }\n  return false;\n}\n\n/**\n * Find meta topic\n * @param {string} _strWhatTopicID\n * @return {object}\n */\nfunction findMetaTopic(_strWhatTopicID) {\n  var count = 0;\n  while (count < this.arrMetaTopics.length) {\n    var _objCurrContainer = this.arrMetaTopics[count];\n    if ((_objCurrContainer.strObjID == _strWhatTopicID) ||\n      (_objCurrContainer.strTopicDataFilename == 'content_' + _strWhatTopicID)) {\n      return _objCurrContainer;\n    }\n    if (_objCurrContainer['findTopic']) {\n      var _objChildSearchResult = _objCurrContainer.findTopic(_strWhatTopicID);\n      if (_objChildSearchResult) {\n        return _objChildSearchResult;\n      }\n    }\n    count++;\n  }\n  return false;\n}\n\n\n/**\n * Get related assets\n * @param {number} _intWhatColumnIndex\n * @param {boolean} _booGetAllRelatedAssets\n * @return {object}\n */\nfunction getRelatedAssets(_intWhatColumnIndex, _booGetAllRelatedAssets) {\n  // REFACTOR NOTE: This should store the results of each get and\n  // return the stored values instead, if they exist.\n  var _arrReturnItems = [];\n  var _arrScreenAsset = this.objParentItem.arrAssets;\n\n  var count = 0;\n  while (count < _arrScreenAsset.length) {\n    var _objCurrAssetDataWrapper = _arrScreenAsset[count];\n    var _objCurrRawAssetData = _objCurrAssetDataWrapper.objRawData;\n\n    if ((_objCurrRawAssetData['strLayoutID'] == this.strObjID) &&\n      (_objCurrRawAssetData['intLayoutColumn'] == _intWhatColumnIndex) &&\n      (_arrScreenAsset[count].booIsDisplayed || _booGetAllRelatedAssets)) {\n      // Set both items too false, we'll update them at the end of the loop\n      // when we know where the list ends.\n      _objCurrAssetDataWrapper.booIsFirstAssetInColumn = false;\n      _objCurrAssetDataWrapper.booIsLastAssetInColumn = false;\n\n      _arrReturnItems.push(_arrScreenAsset[count]);\n    }\n    count++;\n  }\n\n  if (_arrReturnItems.length > 0) {\n    _arrReturnItems.sort(this._sortAssetsByColumnPositionIndex);\n    _arrReturnItems[0].booIsFirstAssetInColumn = true;\n    _arrReturnItems[_arrReturnItems.length - 1].booIsLastAssetInColumn = true;\n  }\n\n  return _arrReturnItems;\n}\n\n/**\n * Sort assets by column position index\n * @param {object} _objAssetA\n * @param {object} _objAssetB\n * @return {number}\n */\nfunction _sortAssetsByColumnPositionIndex(_objAssetA, _objAssetB) {\n  var _intColumnIndexA = parseInt(_objAssetA.objRawData.intColumnPositionIndex);\n  var _intColumnIndexB = parseInt(_objAssetB.objRawData.intColumnPositionIndex);\n\n  if (_intColumnIndexA > _intColumnIndexB) {\n    return 1;\n  }\n  if (_intColumnIndexA < _intColumnIndexB) {\n    return -1;\n  }\n  // Shouldn't happen.\n  return 0;\n}\n\n\n// Compares the id to see if a given screens ID appears within it.\n// This means an asset ID could be passed in and the parent screen would\n// still be returned.\n/**\n * Find screen\n * @param {string} _strWhatID\n * @return {object}\n */\nfunction findScreen(_strWhatID) {\n  var count = 0;\n  var _strWhatIdClean = _strWhatID;\n\n  // Remove reference to subscreen and/or asset if it exists\n  if (_strWhatID.lastIndexOf('sub') >= _strWhatID.lastIndexOf('s')) {\n    _strWhatIdClean = _strWhatID.substring(0, _strWhatID.lastIndexOf('sub'));\n  } else if (_strWhatID.lastIndexOf('a') > _strWhatID.lastIndexOf('s')) {\n    _strWhatIdClean = _strWhatID.substring(0, _strWhatID.lastIndexOf('a'));\n  }\n\n  // Remove HTML ID if found\n  if (_strWhatIdClean.indexOf('screenWrapper_') != -1) {\n    _strWhatIdClean = _strWhatIdClean.replace('screenWrapper_', '');\n  }\n  if (_strWhatIdClean.lastIndexOf('L') == (_strWhatIdClean.length -1) ) {\n    _strWhatIdClean = _strWhatIdClean.substring(0, _strWhatIdClean.lastIndexOf('L'));\n  }\n\n  while (count < this.arrScreens.length) {\n    var _objCurrScreen = this.arrScreens[count];\n    if (_strWhatIdClean == _objCurrScreen.strObjID) {\n      return _objCurrScreen;\n    }\n    count++;\n  }\n}\n\n/**\n * Create layout objects\n * @param {array} _arrWhatLayouts\n */\nfunction _createLayoutObjects(_arrWhatLayouts) {\n  var count = 0;\n  while (count < _arrWhatLayouts.length) {\n    var _objCurrLayout = _arrWhatLayouts[count];\n    this.arrChildLayouts.push(new LayoutDataHolder(_objCurrLayout, this, count));\n    count++;\n  }\n}\n\n/**\n * Find subscreen\n * @param {string} _strWhatID\n * @return {object}\n */\nfunction findSubScreen(_strWhatID) {\n  var count = 0;\n  var subScreenID = _strWhatID;\n\n  // Remove reference to asset if it exists\n  if (_strWhatID && _strWhatID.lastIndexOf('a') > 0) {\n    subScreenID = _strWhatID.substring(0, _strWhatID.lastIndexOf('a'));\n  }\n\n  while (count < this.arrSubScreens.length) {\n    var _objCurrSubScreen = this.arrSubScreens[count];\n    if (subScreenID == _objCurrSubScreen.strObjID) {\n      return _objCurrSubScreen;\n    }\n    count++;\n  }\n}\n\n// Compares the asset id to see if a given assets ID appears within it.\n// This means an asset ID could be passed in and the parent screen would\n// still be returned.\n/**\n * Find asset\n * @param {string} _strWhatID\n * @return {object}\n */\nfunction findAsset(_strWhatID) {\n  var count = 0;\n  while (count < this.arrAssets.length) {\n    var _objCurrAsset = this.arrAssets[count];\n    if (_strWhatID == _objCurrAsset.strObjID) {\n      return _objCurrAsset;\n    }\n    count++;\n  }\n}\n\n/**\n * Find asset from screen\n * @param {string} _strWhatID\n * @return {boject}\n */\nfunction findAssetFromScreen(_strWhatID) {\n  var _objCurrentAsset = this.getAsset(_strWhatID);\n  if (typeof _objCurrentAsset == 'undefined') {\n    var count = 0;\n    while (count < this.arrSubScreens.length) {\n      var _objCurrentSubscreen = this.arrSubScreens[count];\n      _objCurrentAsset = _objCurrentSubscreen.findAsset(_strWhatID);\n      if (typeof _objCurrentAsset != 'undefined') {\n        return _objCurrentAsset;\n      }\n      count++;\n    }\n  }\n  return _objCurrentAsset;\n}\n\n/**\n * Get asset types\n * @return {object}\n */\nfunction getAssetTypes() {\n  var count = 0;\n  var _objAssetTypes = {};\n  while (count < this.arrAssets.length) {\n    var _objCurrAsset = this.arrAssets[count];\n    var _strAssetType = _objCurrAsset.strAssetType;\n\n    if (_objAssetTypes[_strAssetType]) {\n      _objAssetTypes[_strAssetType]++;\n    } else {\n      _objAssetTypes[_strAssetType] = 0;\n    }\n    count++;\n  }\n  return _objAssetTypes;\n}\n\n/**\n * Get assets by type from topic\n * @param {string} _strAssetType\n * @param {boolean} _booJustFirstAsset\n * @return {array}\n */\nfunction getAssetsByTypeFromTopic(_strAssetType, _booJustFirstAsset) {\n  var _arrMatchingAssets = [];\n  var count = 0;\n  while (count < this.arrScreens.length) {\n    var _objCurrScreen = this.arrScreens[count];\n    var _arrMatchingScreenAssets = _objCurrScreen.getAssetsByType(\n      _strAssetType,\n      _booJustFirstAsset\n    );\n\n    if (_arrMatchingScreenAssets) {\n      _arrMatchingAssets = _arrMatchingAssets.concat(_arrMatchingScreenAssets);\n    }\n    if (_booJustFirstAsset && _arrMatchingAssets.length > 0) {\n      return _arrMatchingAssets[0];\n    }\n\n    var iCount = 0;\n    while (iCount < _objCurrScreen.arrSubScreens.length) {\n      var _objCurrSubScreen = _objCurrScreen.arrSubScreens[iCount];\n      var _arrMatchingSubScreenAssets = _objCurrSubScreen.getAssetsByType(\n        _strAssetType,\n        _booJustFirstAsset\n      );\n\n      if (_arrMatchingSubScreenAssets) {\n        _arrMatchingAssets = _arrMatchingAssets.concat(_arrMatchingSubScreenAssets);\n      }\n\n      if (_booJustFirstAsset && _arrMatchingAssets.length > 0) {\n        return _arrMatchingAssets[0];\n      }\n\n      iCount++;\n    }\n\n    count++;\n  }\n  if (!_booJustFirstAsset) {\n    return _arrMatchingAssets;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Get asset by type\n * @param {*} _strAssetType\n * @param {*} _booJustFirstAsset\n * @return {array}\n */\nfunction getAssetsByType(_strAssetType, _booJustFirstAsset) {\n  var _arrAssets = this.arrAssets;\n  var _arrMatchingAssets = [];\n  var count = 0;\n  while (count < _arrAssets.length) {\n    var _objCurrAsset = _arrAssets[count];\n    if (_objCurrAsset.strAssetType == _strAssetType) {\n      if (_booJustFirstAsset) {\n        return _objCurrAsset;\n      }\n      _arrMatchingAssets.push(_objCurrAsset);\n    }\n    count++;\n  }\n  if (!_booJustFirstAsset) {\n    return _arrMatchingAssets;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Check for asset meta type\n * @param {string} _strWhatMetaType\n * @return {boolean}\n */\nfunction checkForAssetMetaType(_strWhatMetaType) {\n  var _arrCurrAssets = this.arrAssets;\n  var count = 0;\n  while (count < _arrCurrAssets.length) {\n    if (_arrCurrAssets[count].strAssetGroup == _strWhatMetaType) {\n      return true;\n    }\n    count++;\n  }\n  return false;\n}\n\n/**\n * Get additional data\n * @param {object} _objWhatSubScreenData\n * @return {object}\n */\nfunction getAdditionalData(_objWhatSubScreenData) {\n  var _strSubScreenMetaData = _objWhatSubScreenData.strMetadata;\n\n  if (_strSubScreenMetaData == null ||\n    _strSubScreenMetaData.length == 0 ||\n    !(_strSubScreenMetaData.indexOf('hotspotCoords') > -1)) {\n    return '';\n  }\n\n  var _strHighLevelDataSeperator = '###';\n  var _strHighLevelNameValueSeperator = '===';\n  var _strValueDataSeperator = '!!!';\n  var _strNameValueSeperator = ':::';\n\n  var _objMetaData = {};\n\n  if ((_strSubScreenMetaData) && (_strSubScreenMetaData != '')) {\n    var _arrHighLevelSplit = _strSubScreenMetaData.split(_strHighLevelDataSeperator);\n\n    var count = 0;\n    while (count < _arrHighLevelSplit.length) {\n      var _arrNameValueSplit = _arrHighLevelSplit[count].split(_strHighLevelNameValueSeperator);\n      var _strName = _arrNameValueSplit[0];\n      var _strValues = _arrNameValueSplit[1];\n      _objMetaData[_strName] = {};\n\n      var _arrValuesSplit = _strValues.split(_strValueDataSeperator);\n      var _objCurrValueObject = _objMetaData[_strName];\n      var iCount = 0;\n\n      while (iCount < _arrValuesSplit.length) {\n        var _arrCurrValueSplit = _arrValuesSplit[iCount].split(_strNameValueSeperator);\n        var _strValueName = _arrCurrValueSplit[0];\n        var _strCurrValue = _arrCurrValueSplit[1];\n        _objCurrValueObject[_strValueName] = _strCurrValue;\n        iCount++;\n      }\n      count++;\n    }\n  }\n\n  return _objMetaData;\n}\n\n/**\n * Get asset action set\n * @param {number} _intWhatActionSetID\n * @return {array}\n */\nfunction getAssetActionSet(_intWhatActionSetID) {\n  var _arrCurrActionSet = this.objRawData.objActionSets[_intWhatActionSetID];\n  if (_arrCurrActionSet) {\n    return _arrCurrActionSet;\n  }\n  this.debug('ERROR: I was asked to retrieve the action set with the ID \\'' +\n    _intWhatActionSetID + '\\' in the asset \\'' + this.strObjID +\n    '\\', however no matching actionset was found. .getAssetActionSet(), course_objects.js');\n  return false;\n}\n"},function(n,e,t){t(0)(t(77))},function(n,e){n.exports="/**\n* @title Section Manager\n* @description To be described.\n*\n*\n* @author GoMo\n* @version 2.0 17/12/12\n*\n* REFACTOR NOTE: This needs to be refactored in light of the new 'everythings a topic' system.\n*\t\t\t\t Tracking can still be carried out here, but will most likely involve 'actions' too.\n*/\n\nvar SECTION_MANAGER =\n{\n\tstrObjID : \"The topic manager\",\n\tstrObjDescription : \"This object loads page arrays and controls navigation within topics.\",\n\n\t_objWhatContentPageDOM : null,\n\t_objWhatContentPageFrame : null,\n\t_objInitialTrackingData : null,\n\n\t// REFACTOR NOTE: Is this required any more in the non-frame landscape?\n\thandleEvent_contentPageFrameReferenceUpdated : function (_objWhatFrameRef)\n\t{\n\t\tthis._objWhatContentPageFrame = _objWhatFrameRef;\n\t\t//alert(this._objWhatContentPageFrame.location);\n\t\t//this._objWhatContentPageFrame = frames[\"mainAreaF\"];\n\t},\n\n\thandleEvent_startedTracking : function ()\n\t{\n\t\tvar trackingState = CONTENT_TRACKING.state.get('courseState');\n\t\tif(trackingState){\n\t\t\tthis._objInitialTrackingData = trackingState;\n\t\t\tthis._applyTrackingData(CORE.objCourseData);\n\t\t\tthis._updateCourseObjectCompletionStatus(CORE.objCourseData);\n\t\t\tthis._checkCourseCompletionStatus(CORE.objCourseData);\n\n\t\t\t// Update variable holder\n\t\t\tif(CONTENT_TRACKING && CONTENT_TRACKING.initialised){\n\t\t\t\t// If content tracking is enabled\n\t\t\t\t// then get the results from content tracking because they may apply certain rules...\n\t\t\t\tCONTENT_TRACKING.getCompletionStatus({ success: function(ctStatus){\n\t\t\t\t\tif(ctStatus == 'completed'){\n\t\t\t\t\t\tVARIABLES_HOLDER.setCourseCompleted();\n\t\t\t\t\t}\n\t\t\t\t\tif(ctStatus == 'passed' || ctStatus == 'failed'){\n\t\t\t\t\t\tVARIABLES_HOLDER.setCoursePassFail(ctStatus == 'passed');\t\n\t\t\t\t\t}\n\t\t\t\t}});\n\n\t\t\t\tCONTENT_TRACKING.getScore({ success: function(ctScore){\n\t\t\t\t\tVARIABLES_HOLDER.updateCourseScore(ctScore);\t\n\t\t\t\t}});\n\t\t\t}\t\n\t\t}\n\t},\n\n\thandleEvent_showCourseObject : function (_objWhatDataObject)\n\t{\n\t\tvar _objCanShowResponse = SECTION_MANAGER.canShowItem(_objWhatDataObject)\n\t\tif (_objCanShowResponse['booCanShow'])\n\t\t{\n\t\t\t//alert(\"handleEvent_showCourseObject\")\n\t\t\tthis._objCurrCourseObject = _objWhatDataObject;\n\t\t\tCORE.setCurrentCourseObject(this._objCurrCourseObject);\n\t\t\t//alert(\"Show menu for: \" + _objWhatDataObject.strObjID)\n\n\t\t\tif (TOPIC_MANAGER.shouldSetLessonLocation()){\n\t\t\t\tCONTENT_TRACKING.visit({\n\t\t\t\t\ttopicId: this._objCurrCourseObject.strObjID,\n\t\t\t\t\tpageId: 'menu',\n\t\t\t\t\tpageTitle: 'Menu',\n\t\t\t\t\tprogress: VARIABLES_HOLDER.getVariableValue('gomo_course_completion_percentage')\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis._objWhatContentPageFrame.MASTER_RENDERER.renderItem(_objWhatDataObject);\n\n\t\t\t//var _objCurrPage = this._getCurrPageObject(this._objTopicDataArrays[this._objCurrCourseObject.strObjID]);\n\t\t\t//PAGE_MANAGER.showPage(_objCurrPage[\"pageData\"]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tEM.trigger(\"showCourseObjectFailed\", _objCanShowResponse);\n\t\t}\n\t},\n\n\thandleEvent_showTopic : function (_objWhatTopicObject)\n\t{\n\t\tthis._objCurrCourseObject = _objWhatTopicObject;\n\t},\n\n\thandleEvent_loadTopicObject : function (_objBookmarkData)\n\t{\n\t\tvar _objWhatTopicObject = CORE.objCourseData.findTopic(_objBookmarkData['strTopicID']);\n\t\tthis._objCurrCourseObject = _objWhatTopicObject;\n\t},\n\n\thandleEvent_courseObjectStateChanged : function (_objWhatTopic)\n\t{\n\t\tthis._updateCourseTrackingState(_objWhatTopic);\n\t},\n\n\tgetCurrMenuID : function ()\n\t{\n\t\tif (this._objCurrCourseObject)\n\t\t{\n\t\t\treturn this._objCurrCourseObject.strObjID;\n\t\t}\n\t\treturn false;\n\t},\n\n\tcanShowItem : function (_objWhatCourseObject)\n\t{\n\t\tvar _objResponseData =\n\t\t{\n\t\t\t'booCanShow':true,\n\t\t\t'strErrorMessage':\"\"\n\t\t};\n\n\t\tif (!BOO_LOCK_TOPICS)\n\t\t{\n\t\t\treturn _objResponseData;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_objResponseData['booCanShow'] = this._checkCourseObjectsPreviousSiblings(_objWhatCourseObject);\n\t\t\treturn _objResponseData\n\t\t}\n\t},\n\n\t//REFACTOR Is possibly a duplicate function.\n\tisMenuTopic : function (_objWhatTopic)\n\t{\n\t\tvar _objMenuTopic = CORE['objCourseData']['objCourseLaunchers']['menu'];\n\t\tif ((_objMenuTopic) && (_objMenuTopic.strTopicID == _objWhatTopic.strObjID))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t},\n\n\t/**\n\t * Takes the course/topic object and updates the overall tracking state (CORE.objCourseData).\n\t * Once the each topic is up to date the overall course completion status will be checked\n\t * and updated (_checkCourseCompletionStatus). Followed by a call to _updateTrackingString\n\t */\n\t_updateCourseTrackingState : function (_objWhatCourseObject)\n\t{\n\t\t// Are we dealing with a topic or course object?\n\t\tvar _objParentCourseObject = _objWhatCourseObject.objParent;\n\t\tif (_objParentCourseObject)\t{\n\t\t\t// Topic - update overall course status...\n\t\t\tthis._updateCourseObjectCompletionStatus(_objParentCourseObject);\n\t\t} else {\n\t\t\t// Course - check the overall status...\n\t\t\tthis._checkCourseCompletionStatus(_objWhatCourseObject);\n\t\t\t// Update the object in core\n\t\t\tCORE['objCourseData'] = _objWhatCourseObject;\t\t\t\n\t\t}\n\n\t\t// Now parse the course data and create the tracking string....\n\t\tthis._updateTrackingString(CORE['objCourseData']);\n\t},\n\n\t/**\n\t * Called by _updateCourseTrackingState to update each topic..\n\t */\n\t_updateCourseObjectCompletionStatus : function (_objWhatCourseObject)\n\t{\n\t\tvar count = 0;\n\t\tvar _arrContainers = _objWhatCourseObject.arrContainers;\n\t\tvar _booAllCompleted = true;\n\t\tvar _booSomeStarted = false;\n\n\t\tvar totalTopics = 0;\n\t\tvar completedTopics = 0;\n\n\t\t// Loop all containers\n\t\twhile (count < _arrContainers.length)\n\t\t{\n\t\t\t// Check the completed state\n\t\t\tvar _objCurrContainer = _arrContainers[count];\n\t\t\tif(this._isTrackedTopic(_objCurrContainer)){\n\t\t\t\tif (_objCurrContainer.intTrackingState < INT_COMPLETED) {\n\t\t\t\t\t_booAllCompleted = false;\n\t\t\t\t}\n\t\t\t\t// Check the visited state\n\t\t\t\tif (_objCurrContainer.intTrackingState > INT_UNVISITED) {\n\t\t\t\t\t_booSomeStarted = true;\n\t\t\t\t}\n\t\t\t\tif (_objCurrContainer.intTrackingState == INT_COMPLETED){\n\t\t\t\t\tcompletedTopics++;\n\t\t\t\t}\n\t\t\t\ttotalTopics++;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\n\t\t// Calculate completion percentage\n\t\tif(totalTopics > 0){\n\t\t\tvar completedPercentage = parseInt((completedTopics/totalTopics) * 100);\n\t\t\tif(VARIABLES_HOLDER){\n\t\t\t\tVARIABLES_HOLDER.updateCourseCompletionPercentage(completedPercentage);\n\t\t\t}\n\t\t}\n\n\t\t// Update overall completed state\n\t\t//\n\t\tif ((_booAllCompleted) && (_objWhatCourseObject.intTrackingState < INT_COMPLETED)){\n\t\t\t// All containers/topics complete therefore the overall course is complete\n\t\t\t_objWhatCourseObject.intTrackingState = INT_COMPLETED;\n\n\t\t\t//this.debug(\"Section / Course Compeleted, id: \" + _objWhatCourseObject.strObjID, 1);\n\t\t\tvar _strDebugMsg = LOCALISER.get(\"SECTION_MANAGER_SECTION_COMPLETED_DEBUG\") + \" \" + _objWhatCourseObject.strObjID;\n\t\t\tthis.debug(_strDebugMsg, 1);\n\t\t}\n\n\t\t// Update overall visited state\n\t\t//\n\t\tif ((_booSomeStarted) && (_objWhatCourseObject.intTrackingState < INT_VISITED)){\n\t\t\t// All containers/topics visited therefore set overall course visited.\n\t\t\t_objWhatCourseObject.intTrackingState = INT_VISITED;\n\n\t\t\t//this.debug(\"Section / Course started, id: \" + _objWhatCourseObject.strObjID, 1);\n\t\t\tvar _strDebugMsg = LOCALISER.get(\"SECTION_MANAGER_SECTION_STARTED_DEBUG\") + \" \" + _objWhatCourseObject.strObjID;\n\t\t\tthis.debug(_strDebugMsg, 1);\n\t\t}\n\n\t\t// Fire event, re-run _updateCourseObjectCompletionStatus and complete the process\n\t\tEM.trigger(\"courseObjectStateChanged\", _objWhatCourseObject);\n\t},\n\n\t/**\n\t * Checks the course overall completion status and calls the relevtant\n\t * tracking methods.\n\t */\n\t_checkCourseCompletionStatus : function (_objWhatCourseObject)\n\t{\n\t\tif (_objWhatCourseObject.intTrackingState == INT_COMPLETED) {\n\t\t\t// Course Completed!!\n\t\t\tCORE.setCourseCompleted();\n\t\t} \n\t},\n\n\t/**\n\t * Generate the content tracking state string...\n\t */\n\t_updateTrackingString : function (_objWhatCourseObject)\n\t{\n\t\tvar _arrTrackingData = this._createTrackingArray(_objWhatCourseObject);\n\t\tvar _objTrackingHash = this._createTrackingHash(_arrTrackingData);\n\t\tCONTENT_TRACKING.state.add('courseState', _objTrackingHash);\n\t},\n\n\t/**\n\t * Creates an array of all topics and their tracking state\n\t */\n\t_createTrackingArray : function (_objWhatCourseObject)\n\t{\n\t\tvar _arrTrackingData = [];\n\t\t_arrTrackingData.push([_objWhatCourseObject.strObjID, _objWhatCourseObject.intTrackingState]);\n\t\t// Find all containers\n\t\tif (_objWhatCourseObject.arrContainers)\n\t\t{\n\t\t\tvar count = 0;\n\t\t\t// Loop all course containers and grab their tracking status then add to\n\t\t\t// overall tracking array(_arrTrackingData).\n\t\t\twhile (count < _objWhatCourseObject.arrContainers.length)\n\t\t\t{\n\t\t\t\tvar _objCurrContainer = _objWhatCourseObject.arrContainers[count];\n\t\t\t\tvar _arrContainerTrackingData = this._createTrackingArray(_objCurrContainer);\n\t\t\t\t_arrTrackingData = _arrTrackingData.concat(_arrContainerTrackingData);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\treturn _arrTrackingData;\n\t},\n\n\t/**\n\t * Converts array of topic ids and tracking status in to an associative array\n\t */\n\t_createTrackingHash : function (_arrWhatTrackingData)\n\t{\n\t\tvar _objTrackingHash = {};\n\t\tvar count = 0;\n\t\twhile (count < _arrWhatTrackingData.length)\n\t\t{\n\t\t\tvar _arrCurrContainerData = _arrWhatTrackingData[count];\n\t\t\t_objTrackingHash[_arrCurrContainerData[0]] = _arrCurrContainerData[1];\n\t\t\tcount++;\n\t\t}\n\t\treturn _objTrackingHash;\n\t},\n\n\t/**\n\t * Sets the initial tracking state on the passed course object.\n\t */\n\t_applyTrackingData : function (_objWhatCourseObject)\n\t{\n\t\tvar _intCurrTrackingData = this._objInitialTrackingData[_objWhatCourseObject.strObjID]\n\t\tif ((_intCurrTrackingData !== false) && (typeof _intCurrTrackingData != \"undefined\")) {\n\t\t\t_objWhatCourseObject.intTrackingState = _intCurrTrackingData;\n\t\t} else {\n\t\t\t//alert(\"ERROR: Unable to locate tracking data for '\" + _objWhatCourseObject.strObjID + \"'. If the course structure has recently changed, then this issue will correct itself upon exiting the course and can be ignored. If not, please leave this message on screen and contact a developer if possible. SECTION_MANAGER._applyTrackingData(), section_manager.js\");\n\t\t\t//LOCALISER.l_alert(\"SECTION_MANAGER_MISSING_TRACKING_DATA_ERROR\", [_objWhatCourseObject.strObjID]);\n\t\t}\n\n\t\tif (_objWhatCourseObject.arrContainers)\n\t\t{\n\t\t\tvar count = 0;\n\t\t\twhile (count < _objWhatCourseObject.arrContainers.length)\n\t\t\t{\n\t\t\t\tvar _objCurrContainer = _objWhatCourseObject.arrContainers[count];\n\t\t\t\tthis._applyTrackingData(_objCurrContainer);\n\t\t\t\tif(VARIABLES_HOLDER){\n\t\t\t\t\tVARIABLES_HOLDER.checkTopicCompletion(_objCurrContainer);\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t},\n\n\t_checkCourseObjectsPreviousSiblings : function (_objWhatCourseObject)\n\t{\n\t\tvar _objParentCourseObject = _objWhatCourseObject.objParent;\n\n\t\t// If the item is already started, it must be accessible so no need to check further.\n\t\tif (_objWhatCourseObject.intTrackingState > INT_UNVISITED)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\tif (_objParentCourseObject)\n\t\t{\n\t\t\tif (_objParentCourseObject.intTrackingState == INT_COMPLETED)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tvar _arrSiblings = _objParentCourseObject.arrContainers;\n\t\t\tvar count = 0;\n\t\t\twhile (count < _arrSiblings.length)\n\t\t\t{\n\t\t\t\tvar _objCurrSibling = _arrSiblings[count];\n\t\t\t\tif (_objCurrSibling.strObjID == _objWhatCourseObject.strObjID)\n\t\t\t\t{\n\t\t\t\t\t// If we aren't the first child, we can rely on the below check to\n\t\t\t\t\t// have thrown us out if required.\n\t\t\t\t\tif (count > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse\t// Otherwise, we need to check the parents siblings to make sure the previous higher level course objects are complete.\n\t\t\t\t\t{\n\t\t\t\t\t\treturn this._checkCourseObjectsPreviousSiblings(_objParentCourseObject);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (_objCurrSibling.intTrackingState != INT_COMPLETED)\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn true\n\t\t}\n\t},\n\n\t_isTrackedTopic : function (_objWhatTopic)\n\t{\n\t\tvar _booIsMenuTopic = this.isMenuTopic(_objWhatTopic);\n\t\tif (_booIsMenuTopic)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\n\t\t// Add other checks as required.\n\n\t\treturn true;\n\t},\n\n\tdebug : function (strMessage, intPriority, objCallerObject, booCalleeChain)\n\t{\n\t\tif (DEBUG)\n\t\t{\n\t\t\tDEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n\t\t}\n\t}\n}\n\nEM.register(SECTION_MANAGER);"},function(n,e,t){t(0)(t(79))},function(n,e){n.exports="/* globals SUB_SCREEN_INTERACTIONS, SCREEN_INTERACTIONS, EM, OUTPUT_MODE_CHECKER,\nBOO_BLANK_ENTIRE_PAGE, LOCALISER, ErrorHandler, DEBUG, CONTENT_TRACKING, CORE, PREVIEW_DATA, $ */\n/**\n * @title Popup Manager\n * @description To be described.\n *\n *\n * @author GoMo\n * @version 2.0 17/12/12\n */\n\nvar POPUP_MANANGER = {\n  strObjID: 'The manager of things popup.',\n\n  _objRegisteredPopups: {},\n\n  _strCurrOutputModeClass: 'graphicalC',\n\n  _objAnimationHandle: false,\n\n  _objCurrDOM: null,\n\n  _strPopupWrapperID: 'popupWrapperL',\n  _strContentAreaID: 'contentWrapperL',\n  _domPopupLayer: null,\n  _objPopupVisibilityStates: {},\n  _strCurrShownPopupID: false,\n\n  booCanShowPopup: true,\n  timeAvailable: null,\n  popupStatementDetails: null,\n\n  handleEvent_primeDOMReferences: function(_objWhatDOM) {\n    if (!this._objCurrDOM) {\n      this._objCurrDOM = _objWhatDOM;\n      // Set key listener to close popups.\n      var listenForEscape = function(e) {\n        if (e.keyCode === 27 || e.key === 'Escape') {\n          POPUP_MANANGER.closeAllPopups();\n        }\n      };\n      window.addEventListener('keydown', listenForEscape);\n    }\n  },\n\n  handleEvent_outputModeChanged: function(_objOutputChangeData) {\n    this._strCurrOutputModeClass = _objOutputChangeData['strNewOutputMode'];\n  },\n\n  handleEvent_topicChange: function() {\n    this._hidePopups();\n    this.unlockPopups();\n  },\n\n  handleEvent_screenChange: function() {\n    this._hidePopups();\n    this.unlockPopups();\n  },\n\n  handleEvent_popupButtonClicked: function(_objPopupData) {\n    if (PREVIEW_DATA.editorMode && _objPopupData.strPopupID === 'languageSelector') {\n      var alertType = 'warning';\n      var title = 'Action disabled';\n      var message = 'Language switching is disabled in this view.';\n      var buttons = [\n        {\n          label: 'Ok',\n          type: 'primary',\n          action: function() {}\n        }\n      ];\n      gomo.alertManager.create(alertType, title, message, buttons);\n      return;\n    }\n    var _strNewPopupID = _objPopupData['strPopupID'];\n\n    if (SUB_SCREEN_INTERACTIONS && SUB_SCREEN_INTERACTIONS.hideSubScreens) {\n      SUB_SCREEN_INTERACTIONS.hideSubScreens();\n    }\n\n    if (this._strCurrShownPopupID != _strNewPopupID) {\n      if (this._objPopupVisibilityStates[this._strCurrShownPopupID]) {\n        this.hidePopup({strPopupID: this._strCurrShownPopupID});\n      }\n      this.showPopup(_objPopupData);\n      SCREEN_INTERACTIONS.takeFocusFromScreen();\n    } else {\n      if (this._objPopupVisibilityStates[_strNewPopupID]) {\n        this.hidePopup(_objPopupData);\n        this._strCurrShownPopupID = false;\n      } else {\n        this._strCurrShownPopupID = _strNewPopupID;\n        this.showPopup(_objPopupData);\n        SCREEN_INTERACTIONS.takeFocusFromScreen();\n      }\n    }\n  },\n\n  handleEvent_genericPopupAction: function(_objButtonData) {\n    var _strLink = '';\n    if (_objButtonData.strTopicId && _objButtonData.strTopicId != '') {\n      _strLink = _objButtonData.strTopicId;\n    } else {\n      _strLink = _objButtonData.strType;\n    }\n\n    var _objActions = [\n      {\n        objParameters: {target_id: _strLink},\n        strActionGroup: 'navigation',\n        strObjectType: 'action',\n        strType: 'metaTopic_link'\n      }\n    ];\n\n    var _objActionOptions = {};\n    var objOptionalExtraData = {};\n\n    _objActionOptions.objActions = _objActions;\n    _objActionOptions.objOptionalExtraData = objOptionalExtraData;\n\n    // Example feed back for completion of subscreen display.\n    // _objActionOptions.objOptionalExtraData.funTriggerCallBack = function(){alert('Screen\n    // displayed for Action ' + _objButtonData.strAssetID)};\n\n    EM.trigger('processActions', _objActionOptions);\n  },\n\n  handleEvent_closePopup: function(_objPopupData) {\n    this.hidePopup(_objPopupData);\n  },\n\n  handleEvent_returnFocusFromPopup: function() {\n    SCREEN_INTERACTIONS.returnFocusToScreen();\n    gomo.tabManager.focusLastScreenElement();\n  },\n\n  registerPopup: function(_strName, _objReference) {\n    // alert(\"registerPopup(_strName: \" + _strName + \", _objReference: \" + _objReference + \")\")\n    this._objRegisteredPopups[_strName] = _objReference;\n    this._objPopupVisibilityStates[_strName] = false;\n    _objReference.objPopupManager = this;\n  },\n\n  showPopup: function(_objPopupData) {\n    var _strNewPopupID = _objPopupData['strPopupID'];\n    this._strCurrShownPopupID = _strNewPopupID;\n\n    if (!this.booCanShowPopup && this._strCurrOutputModeClass != 'accessibleC') {\n      return false;\n    }\n\n    this.timeAvailable = new Date();\n\n    SCREEN_INTERACTIONS.prepareCurrentScreenForPopupLayers(false);\n\n    if (_objPopupData.strInsertionWrapper) {\n      this._domPopupLayer = this._objCurrDOM.getElementById(_objPopupData.strInsertionWrapper);\n      if (_objPopupData.strInsertionWrapper === 'outerPopupWrapperL') {\n        EM.trigger('showExtentionWrapper');\n      }\n    } else {\n      this._domPopupLayer = this._objCurrDOM.getElementById(this._strPopupWrapperID);\n    }\n    this._domPopupLayer.style.display = 'block';\n\n    this._hidePopups();\n    this.lockPopups();\n\n    if (BOO_BLANK_ENTIRE_PAGE) {\n      EM.trigger('toggleBlanking', {strState: 'ON', objWhatDOM: false});\n    } else {\n      EM.trigger('toggleBlanking', {\n        strState: 'ON',\n        objWhatDOM: SCREEN_INTERACTIONS.getShownScreenElement()\n      });\n    }\n\n    if (this._objRegisteredPopups[_strNewPopupID]) {\n      if (this._objRegisteredPopups[_strNewPopupID].showPopup) {\n        this._objRegisteredPopups[_strNewPopupID].showPopup(this._domPopupLayer, _objPopupData);\n        this.setPopupDetails(\n          _objPopupData,\n          this._objRegisteredPopups[_strNewPopupID].popupLocaleTitle\n        );\n        this.sendEnterStatement();\n        gomo.dataBinding.unregisterGroup('popup');\n        gomo.translationManager.translateLocalisations(this._domPopupLayer, _strNewPopupID, {\n          group: 'popup'\n        });\n        this._objPopupVisibilityStates[_strNewPopupID] = true;\n        // SCREEN_INTERACTIONS.prepareCurrentScreenForPopupLayers(false);\n        if (_objPopupData._objActionData && _objPopupData._objActionData.funCallBack) {\n          _objPopupData._objActionData.funCallBack();\n        }\n        // Run any required postprocessing like column width sizes\n        EM.trigger('newlyRenderedItemInDocument');\n      } else {\n        // alert(\"ERROR: Unable to show the popup for '\" + _strNewPopupID + \"' as it doesn't seem\n        // to have a .showPopup() method. POPUP_MANANGER.showPopup(), popup_mananger.js\");\n        LOCALISER.l_alert('POPUP_MANAGER_MISSING_SHOW_POPUP_METHOD_ERROR', [_strNewPopupID]);\n        this.unlockPopups();\n      }\n    } else {\n      // alert(\"ERROR: Unable to show the popup for '\" + _strNewPopupID + \"' as it doesn't seem to\n      // be registered. POPUP_MANANGER.showPopup(), popup_mananger.js\");\n      LOCALISER.l_alert('POPUP_MANAGER_UNREGISTERED_POPUP_ERROR', [_strNewPopupID]);\n      this.unlockPopups();\n    }\n  },\n\n  hideAllPopups: function() {\n    this._hidePopups();\n  },\n\n  hidePopup: function(_objPopupData) {\n    var _strPopupID = _objPopupData['strPopupID'];\n    if (this._objRegisteredPopups[_strPopupID].hidePopup) {\n      this._objRegisteredPopups[_strPopupID].hidePopup(_objPopupData);\n      this.sendExitStatement();\n      this._objPopupVisibilityStates[_strPopupID] = false;\n\n      if (this._strCurrOutputModeClass == 'accessibleC') {\n        this._domPopupLayer = this._objCurrDOM.getElementById(this._strPopupWrapperID);\n        this._domPopupLayer.style.display = 'none';\n      }\n\n      if (BOO_BLANK_ENTIRE_PAGE) {\n        EM.trigger('toggleBlanking', {strState: 'OFF', objWhatDOM: false});\n      } else {\n        EM.trigger('toggleBlanking', {\n          strState: 'OFF',\n          objWhatDOM: SCREEN_INTERACTIONS.getShownScreenElement()\n        });\n      }\n      SCREEN_INTERACTIONS.restoreCurrentScreenFromPopupLayers(false);\n    } else {\n      // alert(\"ERROR: Unable to hide the popup for '\" + _strPopupID + \"' as it doesn't seem to\n      // have a .hidePopup() method. POPUP_MANANGER._hidePopups(), popup_mananger.js\");\n      LOCALISER.l_alert('POPUP_MANAGER_MISSING_HIDE_POPUP_METHOD_ERROR', [_strPopupID]);\n    }\n  },\n\n  postAnimationTidyUp: function() {\n    // The external wrapper may have been used so we close it by default\n    EM.trigger('hideExtentionWrapper');\n  },\n\n  lockPopups: function() {\n    this.booCanShowPopup = false;\n  },\n\n  unlockPopups: function() {\n    EM.trigger('returnFocusFromPopup');\n    this.booCanShowPopup = true;\n    // SCREEN_INTERACTIONS.restoreCurrentScreenFromPopupLayers(false);\n  },\n\n  _hidePopups: function() {\n    for (var _strCurrKey in this._objRegisteredPopups) {\n      if (this._objPopupVisibilityStates[_strCurrKey]) {\n        this.hidePopup({strPopupID: _strCurrKey});\n      }\n    }\n  },\n\n  debug: function(strMessage, intPriority, objCallerObject, booCalleeChain) {\n    if (DEBUG) {\n      DEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n    }\n  },\n\n  // Get the tabbable elements from the popup.\n  getAccessibleItems: function() {\n    var accessibleElements = false;\n    var currentPopup = this._objRegisteredPopups[this._strCurrShownPopupID];\n    if (currentPopup && currentPopup.getAccessibleElements) {\n      accessibleElements = currentPopup.getAccessibleElements();\n    }\n    return accessibleElements;\n  },\n\n  setPopupDetails: function(data, localisation) {\n    var details = {\n      id: data.strPopupID,\n      referrerId: data.strPopupID,\n      referrerTitle: '',\n      referrerType: 'extra',\n      title: '',\n      type: 'subscreen'\n    };\n\n    if (data._metaTopic && data._metaTopic.objRawTopicData) {\n      details.title = data._metaTopic.objRawTopicData.strTitle;\n      details.id = data._metaTopic.strObjID;\n      details.type = 'metatopic';\n    } else if (data.strPopupID === 'lastPageVisited') {\n      details.referrerId = CORE.objCourseData.strObjID;\n      details.referrerTitle = gomo.getCourseTitle();\n      details.referrerType = 'course';\n    }\n\n    if (!details.title && localisation) {\n      details.title = gomo.localiser.get(localisation);\n    }\n\n    this.popupStatementDetails = details;\n  },\n\n  sendEnterStatement: function() {\n    var me = this;\n    if (!me.popupStatementDetails) return;\n    var currentScreenData = gomo.screenManager.getCurrentScreenData();\n    var currentScreenID =\n      (currentScreenData && currentScreenData.strObjID) ? currentScreenData.strObjID : '';\n    CONTENT_TRACKING.interaction({\n      type: 'experienced',\n      activity: {\n        id: me.popupStatementDetails.id,\n        title: me.popupStatementDetails.title,\n        type: me.popupStatementDetails.type\n      },\n      referrer: {\n        id: me.popupStatementDetails.referrerId,\n        title: me.popupStatementDetails.referrerTitle,\n        type: me.popupStatementDetails.referrerType,\n        extraType: me.popupStatementDetails.referrerId\n      },\n      parent: 'page/' + currentScreenID,\n      topicGrouping: true\n    });\n  },\n\n  sendExitStatement: function() {\n    var me = this;\n    if (!me.popupStatementDetails) return;\n    var currentScreenData = gomo.screenManager.getCurrentScreenData();\n    var currentScreenID =\n      (currentScreenData && currentScreenData.strObjID) ? currentScreenData.strObjID : '';\n    CONTENT_TRACKING.interaction({\n      type: 'left',\n      activity: {\n        id: me.popupStatementDetails.id,\n        title: me.popupStatementDetails.title,\n        type: me.popupStatementDetails.type\n      },\n      response: {\n        timeAvailable: me.timeAvailable,\n        timeResponse: new Date()\n      },\n      referrer: {\n        id: me.popupStatementDetails.referrerId,\n        title: me.popupStatementDetails.referrerTitle,\n        type: me.popupStatementDetails.referrerType,\n        extraType: me.popupStatementDetails.referrerId\n      },\n      parent: 'page/' + currentScreenID,\n      topicGrouping: true\n    });\n    me.timeAvailable = null;\n    me.popupStatementDetails = null;\n  },\n\n  closeAllPopups: function() {\n    // Find all open popups.\n    for (var popup in this._objRegisteredPopups) {\n      if (this._objRegisteredPopups.hasOwnProperty(popup)) {\n        if (this._objRegisteredPopups[popup].booPopupShown) {\n          // If popup is open close it.\n          this.hidePopup({strPopupID: popup});\n        }\n      }\n    }\n  }\n};\n\n\nEM.register(POPUP_MANANGER);\n"},function(n,e,t){t(0)(t(81))},function(n,e){n.exports="/* global EM, TOPIC_INTERACTIONS, CONTENT_TRACKING, VARIABLES_HOLDER, LogManager,\nBOO_PRELOAD_IMAGES, ARR_DATA_REFRESH_LOAD_SEQUENCE, DYNAMIC_CONTENT_SCREEN_MANAGER,\n_, SECTION_MANAGER, CORE, STR_DYNAMIC_TRANSITION_TYPE:true, ErrorHandler, SCROLLING_MANAGER,\nSTR_TRANSITION_TYPE, BOO_DYNAMIC_CONTINUOUS_SCROLLING:true, CONTINUOUS_SCROLLING,\nSTR_PRELOAD_TYPE_TOPIC_LOAD, SCREEN_INTERACTIONS, STR_EMPTY_TOPIC_MESSAGE, MASTER_RENDERER,\nSUB_SCREEN_RENDERER, LOADER, OBJ_PLAYER_REFRESH_DATA, INT_VISITED,\nBOO_LINEAR_COMPLETE_ON_LAST_PAGE, INT_COMPLETED, LOCALISER, $, TOPIC_STRUCTURE_PARSER,\nJSON_POST, BOO_SHOW_LOCKED_SCREEN_PLACEHOLDER, BOO_TURN_OFF_CONTINUOUS_SCROLL_ASSET_RESET */\n\n/**\n * @title Topic Manager\n * @description To be described.\n *\n *\n * @author GoMo\n * @version 2.0 17/12/12\n */\n\nvar TOPIC_MANAGER = {\n  strObjID: 'The topic manager',\n  strObjDescription: 'This object loads page arrays and controls navigation within topics.',\n\n  _booDebug: false,\n\n  _strTopicDataSuffix: '_nav',\n  _strPageDataSuffix: '_page',\n  _strTopicDataBasePath: '',\n\n  _strPostLoadMethod: '',\n  _objPostLoadData: {},\n\n  _objCurrCourseObject: null,\n\n  _strBookmarkStringToSkipToo: false,\n\n  _booLoadingPage: false,\n\n  _objWhatContentPageFrame: null,\n\n  _booNavigationLocked: false,\n  _booMasterNavigationLocked: false,\n\n  _booCorrectSelectionOrigin: false,\n\n  topicAvailable: null,\n  topicType: '',\n  screenDetails: {\n    available: null,\n    topicId: '',\n    pageId: '',\n    pageTitle: '',\n    referrerId: '',\n    referrerTitle: '',\n    referrerType: ''\n  },\n\n  handleEvent_updateAnimationLock: function(_booAnimationLockState) {\n    this._booNavigationLocked = _booAnimationLockState;\n  },\n\n  handleEvent_updateMasterLock: function(_booMasterLockState) {\n    this._booMasterNavigationLocked = _booMasterLockState;\n  },\n\n  handleEvent_contentPageFrameReferenceUpdated: function(_objWhatFrameRef) {\n    this._objWhatContentPageFrame = _objWhatFrameRef;\n  },\n\n  handleEvent_goToPage: function(_objWhatModifier) {\n    // show loading layer\n    if ((this._booNavigationLocked)\n      || (_objWhatModifier == 1 && this._booMasterNavigationLocked)) {\n      // Trigger call back for any error which failed the navigation so pending actions can continue\n      if (typeof(_objWhatModifier.origin) !== 'undefined'\n        && _objWhatModifier.origin === 'scrolling_manager'\n        && typeof(_objWhatModifier.counter) !== 'undefined'\n        && _objWhatModifier.counter > 0) {\n        _objWhatModifier.counter--;\n        setTimeout(function() {\n          EM.trigger('goToPage', _objWhatModifier);\n        }, 10);\n        return;\n      } else {\n        if (_objWhatModifier.funCallBack) {\n          _objWhatModifier.funCallBack();\n        }\n        return;\n      }\n    }\n    this._booLoadingPage = true;\n    var _booPageFound = false;\n    var _booTopicFound = false;\n    var _booErrorOnScreenLoad = false;\n    var _objScreenNavigation = null;\n    var _booScreenIdNotSupplied = null;\n\n    if (this._isNumericModifier(_objWhatModifier) || _objWhatModifier.booForceNumericModifier) {\n      _objScreenNavigation = this.gotoPageByScreenIndex(_objWhatModifier);\n      var _strWhatModifier = _objScreenNavigation._strWhatModifier;\n      _booPageFound = _objScreenNavigation._booPageFound;\n    } else {\n      // Otherwise its a screen ID and possible data over-ride\n      _objScreenNavigation = this.gotoPageByScreenId(_objWhatModifier);\n      if (_objScreenNavigation) {\n        _booTopicFound = _objScreenNavigation._booTopicFound;\n        _booPageFound = _objScreenNavigation._booPageFound;\n        _booErrorOnScreenLoad = _objScreenNavigation._booErrorOnScreenLoad;\n        _booScreenIdNotSupplied = _objScreenNavigation._booScreenIdNotSupplied;\n      }\n    }\n\n    if (_booPageFound) {\n      EM.trigger('screenChange');\n      this.sendScreenChanged();\n\n      var _objNewScreen = this._getCurrScreenObject();\n      _objNewScreen.booScreenShown = true;\n\n      this._checkTopicState();\n      var _strNewPageID = _objNewScreen['strObjID'];\n      var _objActionData = {};\n      if (_objWhatModifier.booTriggeredByActionsObj) {\n        _objActionData = _objWhatModifier;\n      }\n      this._objWhatContentPageFrame = TOPIC_INTERACTIONS.switchToScreen(\n        _strNewPageID,\n        this._objCurrCourseObject.intNavigationIndex + 1,\n        this._objCurrCourseObject.arrScreens.length,\n        _strWhatModifier,\n        _objActionData\n      );\n\n      if (this._objCurrCourseObject.strObjTopicModel == 'linear') {\n        var topicTitle = gomo.translationManager.getTopicTitle() ||\n        _objNewScreen.objParent.strTitle;\n        this.setScreenReferrer(this.screenDetails.pageId, this.screenDetails.pageTitle);\n        CONTENT_TRACKING.visit({\n          topicId: this._objCurrCourseObject.strObjID,\n          pageId: _strNewPageID,\n          pageTitle: _objNewScreen.strTitle,\n          topicTitle: topicTitle,\n          progress: VARIABLES_HOLDER.getVariableValue('gomo_course_completion_percentage'),\n          referrer: {\n            id: this.screenDetails.referrerId,\n            type: this.screenDetails.referrerType,\n            title: this.screenDetails.referrerTitle\n          }\n        });\n        this.screenDetails.available = new Date();\n        this.screenDetails.topicId = this._objCurrCourseObject.strObjID;\n        this.screenDetails.topicTitle = topicTitle;\n        this.screenDetails.pageId = _strNewPageID;\n        this.screenDetails.pageTitle = _objNewScreen.strTitle;\n      }\n\n      if (typeof LogManager !== 'undefined') {\n        LogManager.setLogMessageData({screenId: _strNewPageID});\n      }\n    } else {\n      if (!_booTopicFound) {\n        this._debug('Topic not found. gotopage()');\n      } if (_booTopicFound && _booErrorOnScreenLoad == true) {\n        this._debug('Topic found but screenID not found. gotopage()');\n      } if (_booTopicFound && _booScreenIdNotSupplied == true) {\n        this._debug('Topic found but screenID not included. gotopage()');\n      }\n      // Trigger call back for any error which failed the navigation so pending actions can continue\n      if (_objWhatModifier.funCallBack) {\n        _objWhatModifier.funCallBack();\n      }\n    }\n  },\n\n  handleEvent_bouncePage: function(data) {\n    var currentScreenElement = $('#screenWrapper_' + data.strObjID + 'L');\n\n    if (!BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n      if (typeof data.strWhatModifier !== 'undefined') {\n        // moving forwards\n        if (data.strWhatModifier === '1') {\n          $(currentScreenElement).addClass('bounce-scale-horizontal-next')\n            .bind('oanimationend animationend webkitAnimationEnd', function() {\n              $(this).removeClass('bounce-scale-horizontal-next');\n            });\n        } else if (data.strWhatModifier === '-1') {\n          $(currentScreenElement).addClass('bounce-scale-horizontal-back')\n            .bind('oanimationend animationend webkitAnimationEnd', function() {\n              $(this).removeClass('bounce-scale-horizontal-back');\n            });\n        }\n      }\n    } else if (BOO_DYNAMIC_CONTINUOUS_SCROLLING && !BOO_SHOW_LOCKED_SCREEN_PLACEHOLDER) {\n      if (typeof data.strWhatModifier !== 'undefined') {\n        if (data.strWhatModifier === '1') {\n          $('#contentWrapperInnerL').addClass('bounce-scale-vertical-next')\n            .bind('oanimationend animationend webkitAnimationEnd', function() {\n              $(this).removeClass('bounce-scale-vertical-next');\n            });\n        } else if (data.strWhatModifier === '-1') {\n          $('#contentWrapperInnerL').addClass('bounce-scale-vertical-back')\n            .bind('oanimationend animationend webkitAnimationEnd', function() {\n              $(this).removeClass('bounce-scale-vertical-back');\n            });\n        }\n      }\n    }\n  },\n\n  handleEvent_resetCourseObject: function() {\n    // On Topic change reset the page index and destroy the current topic reference.\n    if (this._objCurrCourseObject) {\n      if (DYNAMIC_CONTENT_SCREEN_MANAGER) {\n        // Store the answered and viewed questions\n        DYNAMIC_CONTENT_SCREEN_MANAGER.storeIncorrectQuestions(\n          _.extend({}, this._objCurrCourseObject)\n        );\n      }\n\n      this.resetAssetsInitialisedStatus();\n\n      if (this.topicAvailable) {\n        this.sendTopicCompleted();\n      }\n\n      this._objCurrCourseObject.objAnsweredQuestions = {};\n      this._objCurrCourseObject.objViewedQuestions = {};\n\n      this._objCurrCourseObject.intNavigationIndex = 0;\n      this._objCurrCourseObject = null;\n\n      // Reset limits for scrolling.\n      SCROLLING_MANAGER.setMinYPosition(null);\n      SCROLLING_MANAGER.setMaxYPosition(null);\n    }\n  },\n\n  handleEvent_showTopic: function(_objWhatTopicObject) {\n    var _objCanShowResponse = SECTION_MANAGER.canShowItem(_objWhatTopicObject);\n    if (_objCanShowResponse['booCanShow']) {\n      this._objCurrCourseObject = _objWhatTopicObject;\n      this._objCurrCourseObject.objAnsweredQuestions = {};\n      this._objCurrCourseObject.objViewedQuestions = {};\n\n      CORE.setCurrentCourseObject(this._objCurrCourseObject);\n\n      if (!this._objCurrCourseObject.objRawTopicData) {\n        CORE.showLoadingLayer();\n        this._loadTopic(this._objCurrCourseObject);\n      } else {\n        var _objOptions = {};\n        _objOptions._booForceReRender = true;\n        EM.trigger('showCurrentPage', _objOptions);\n      }\n    } else {\n      EM.trigger('showTopicFailed', _objCanShowResponse);\n    }\n  },\n\n  handleEvent_loadTopicObject: function(_objTopicData) {\n    if (_objTopicData.langCode && gomo.translationManager) {\n      gomo.translationManager.setTranslation(_objTopicData.langCode, true, function() {});\n    }\n\n    var _objWhatTopicObject = CORE.objCourseData.findTopic(_objTopicData['strTopicID']);\n\n    if (_objWhatTopicObject == false) {\n      this._debug('Selected Topic isn\\'t loaded in this Player.');\n      // Do the callback if it exists\n      if (_objTopicData &&\n        _objTopicData._objActionData &&\n        _objTopicData._objActionData.funCallBack) {\n        _objTopicData._objActionData.funCallBack();\n      }\n      return;\n    }\n\n    this._objCurrCourseObject = _objWhatTopicObject;\n    this._strBookmarkStringToSkipToo = _objTopicData['strScreenID'];\n    CORE.setCurrentCourseObject(this._objCurrCourseObject);\n\n    gomo.translationManager.resetTopicData();\n    var redirectData = false;\n\n    if (!this._objCurrCourseObject.objRawTopicData) {\n      CORE.showLoadingLayer();\n      this._loadTopic(this._objCurrCourseObject);\n    } else if (DYNAMIC_CONTENT_SCREEN_MANAGER) {\n      this.addScreenData();\n      redirectData = DYNAMIC_CONTENT_SCREEN_MANAGER.getRedirectScreenId(\n        _objTopicData._objActionData.strWhatModifier\n      );\n    }\n\n    var _objOptions = {};\n    _objOptions._objActionData = _objTopicData._objActionData;\n    if (redirectData) {\n      _objOptions._objActionData.strWhatModifier = redirectData.redirect;\n      // This is needed for switching topics,\n      // but we can't return to content banks from another session\n      this._strBookmarkStringToSkipToo = redirectData.redirect;\n      _objOptions._objActionData.redirectParentTopicId = redirectData.topic;\n    }\n    _objOptions._booForceReRender = true;\n\n    if (_objWhatTopicObject.strNavigationType && _objWhatTopicObject.strNavigationType != '') {\n      STR_DYNAMIC_TRANSITION_TYPE = _objWhatTopicObject.strNavigationType;\n    } else {\n      STR_DYNAMIC_TRANSITION_TYPE = STR_TRANSITION_TYPE;\n    }\n\n    /*\n     * Swiping will break vertical scrolling by jumping to the next screen,\n     * if the user is trying to scroll down a page which overruns the devices display\n     */\n    if (STR_DYNAMIC_TRANSITION_TYPE == 'verticalSlide') {\n      EM.trigger('disableSwiping');\n    } else {\n      EM.trigger('enableSwipe');\n    }\n\n    gomo.translationManager.changeTopic();\n    if (typeof LogManager !== 'undefined') {\n      LogManager.setLogMessageData();\n    }\n\n    if (_objWhatTopicObject.booContinuousScrolling &&\n      _objWhatTopicObject.booContinuousScrolling != '') {\n      BOO_DYNAMIC_CONTINUOUS_SCROLLING = _objWhatTopicObject.booContinuousScrolling;\n    } else {\n      BOO_DYNAMIC_CONTINUOUS_SCROLLING = CONTINUOUS_SCROLLING;\n    }\n\n    this.topicAvailable = new Date();\n\n    EM.trigger('showCurrentPage', _objOptions);\n  },\n\n  handleEvent_topicImagesPreloadComplete: function() {\n    var _objOptions = {};\n    _objOptions._booForceReRender = true;\n    EM.trigger('showCurrentPage', _objOptions);\n  },\n\n  handleEvent_showCurrentPage: function(_objOptions) {\n    if (BOO_PRELOAD_IMAGES && !this._objCurrCourseObject.booImagesPreloaded) {\n      EM.trigger('preloadImages', {\n        strPreloadType: STR_PRELOAD_TYPE_TOPIC_LOAD,\n        strCallback: 'topicImagesPreloadComplete',\n        objCourseData: this._objCurrCourseObject\n      });\n      return;\n    }\n    EM.trigger('setTopicModelType', this._objCurrCourseObject.strObjTopicModel);\n\n    var _booCanShowPage = this._checkTopicValidity();\n\n    if (!_booCanShowPage) {\n      var _objWhatParent = this._objCurrCourseObject.getParent();\n      CORE.setCurrentCourseObject(_objWhatParent);\n      EM.trigger('showCourseObject', _objWhatParent);\n\n      this._debug(STR_EMPTY_TOPIC_MESSAGE);\n      return;\n    }\n\n    if (_objOptions) {\n      SUB_SCREEN_RENDERER.resetRenderedSubscreens();\n      this._objWhatContentPageFrame = MASTER_RENDERER.renderItem(this._objCurrCourseObject);\n    }\n\n    if (this._strBookmarkStringToSkipToo) {\n      this._setNavigationIndexFromScreenID();\n      this._strBookmarkStringToSkipToo = false;\n    }\n\n    var _objCurrScreen = this._getCurrScreenObject();\n    _objCurrScreen.booScreenShown = true;\n    var _strCurrPageID = _objCurrScreen['strObjID'];\n    EM.trigger('setLastScreenID', _strCurrPageID);\n\n    this._checkTopicState();\n    if (typeof LogManager !== 'undefined') {\n      LogManager.setLogMessageData({screenId: _strCurrPageID});\n    }\n    this._objWhatContentPageFrame = TOPIC_INTERACTIONS.switchToScreen(\n      _strCurrPageID,\n      this._objCurrCourseObject.intNavigationIndex + 1,\n      this._objCurrCourseObject.arrScreens.length,\n      null,\n      _objOptions._objActionData\n    );\n    if (this._objCurrCourseObject.strObjTopicModel == 'linear') {\n      if (this.screenDetails.available) {\n        this.sendScreenChanged();\n      }\n      // Do we have an assessment results asset, if so this is an assessment topic type otherwise a\n      // module type\n      this.topicType = 'module';\n      var hasAssementResultsAsset =\n        this._objCurrCourseObject.getAssetsByType(\n          'assessmentresults', false\n        ).length >0 ? true : false;\n      if (hasAssementResultsAsset) {\n        this.topicType = 'assessment';\n      }\n      this.setScreenReferrer(this.screenDetails.pageId, this.screenDetails.pageTitle);\n      CONTENT_TRACKING.topicVisit({\n        topicId: this._objCurrCourseObject.strObjID,\n        topicTitle: this._objCurrCourseObject.strTitle,\n        topicType: this.topicType,\n        progress: VARIABLES_HOLDER.getVariableValue('gomo_course_completion_percentage')\n      });\n      var topicTitle = gomo.translationManager.getTopicTitle() || _objCurrScreen.objParent.strTitle;\n      CONTENT_TRACKING.visit({\n        topicId: this._objCurrCourseObject.strObjID,\n        pageId: _strCurrPageID,\n        pageTitle: _objCurrScreen.strTitle,\n        topicTitle: topicTitle,\n        progress: VARIABLES_HOLDER.getVariableValue('gomo_course_completion_percentage'),\n        referrer: {\n          id: this.screenDetails.referrerId,\n          type: this.screenDetails.referrerType,\n          title: this.screenDetails.referrerTitle\n        }\n      });\n      this.screenDetails.available = new Date();\n      this.screenDetails.topicId = this._objCurrCourseObject.strObjID;\n      this.screenDetails.topicTitle = topicTitle;\n      this.screenDetails.pageId = _strCurrPageID;\n      this.screenDetails.pageTitle = _objCurrScreen.strTitle;\n    }\n  },\n\n  handleEvent_setPopupTopicMode: function(_objTutorialData) {\n    this._objCurrCourseObject = _objTutorialData;\n    CORE.setCurrentCourseObject(this._objCurrCourseObject);\n\n    if (!this._objCurrCourseObject.objRawTopicData) {\n      this._loadTutorial(this._objCurrCourseObject);\n    } else {\n      EM.trigger('showPopupTopicContent');\n    }\n  },\n\n  handleEvent_questionAssetAnswered: function(_objWhatAssetWrapper) {\n    this._objCurrCourseObject.objAnsweredQuestions[_objWhatAssetWrapper.strObjID] =\n      _objWhatAssetWrapper;\n    gomo.eventManager.raise('questionAnswered', [_objWhatAssetWrapper]);\n  },\n\n  handleEvent_questionAssetReset: function(_objWhatAssetWrapper) {\n    if (this._objCurrCourseObject.objAnsweredQuestions[_objWhatAssetWrapper.strObjID]) {\n      this._objCurrCourseObject.objAnsweredQuestions[_objWhatAssetWrapper.strObjID].booIsCorrect =\n        false;\n      delete this._objCurrCourseObject.objAnsweredQuestions[_objWhatAssetWrapper.strObjID];\n      gomo.eventManager.raise('questionReset', [_objWhatAssetWrapper]);\n    }\n  },\n\n  handleEvent_questionAssetViewed: function(_objWhatAssetWrapper) {\n    this._objCurrCourseObject.objViewedQuestions[_objWhatAssetWrapper.strObjID] =\n      _objWhatAssetWrapper;\n    gomo.eventManager.raise('questionViewed', [_objWhatAssetWrapper]);\n  },\n\n  handleEvent_setCurrentCourseObject: function(_objNewCourseObject) {\n    if (_objNewCourseObject && this._objCurrCourseObject.objRawTopicData) {\n      this._objCurrCourseObject = _objNewCourseObject;\n    }\n  },\n\n  shouldSetLessonLocation: function() {\n    var _objAssementResultsAsset =\n      this._objCurrCourseObject.getAssetsByType('assessmentresults', true);\n    if (\n      _objAssementResultsAsset &&\n      (_objAssementResultsAsset.objRawData.booIsCourseCompletingAssessment ||\n        _objAssementResultsAsset.objRawData.booIsTrackedAssessment ||\n        _objAssementResultsAsset.objRawData.booSetScore)\n    ) {\n      return false;\n    }\n\n    return true;\n  },\n\n  getNextOrPreviousUnlockedScreenIndex: function(_strWhatModifier) {\n    if (_strWhatModifier == 'previousScreen' || _strWhatModifier == 'nextScreen') {\n      _strWhatModifier = (_strWhatModifier == 'previousScreen') ? '-1' : '1';\n    }\n\n    var _intModifier = parseInt(_strWhatModifier);\n    var _intNewPageIndex = this._objCurrCourseObject.intNavigationIndex + _intModifier;\n    var i;\n\n    if (_intNewPageIndex >= 0\n    && _intNewPageIndex < this._objCurrCourseObject.arrScreens.length) {\n      if (_intModifier > 0) {\n        for (\n          i=_intNewPageIndex; i < this._objCurrCourseObject.arrScreens.length; i += _intModifier\n        ) {\n          if (typeof this._objCurrCourseObject.arrScreens[i] !== 'undefined'\n          && this._objCurrCourseObject.arrScreens[i].booIsDisplayed) {\n            return i;\n          }\n        }\n      } else {\n        for (i=_intNewPageIndex; i >= 0; i += _intModifier) {\n          if (typeof this._objCurrCourseObject.arrScreens[i] !== 'undefined'\n          && this._objCurrCourseObject.arrScreens[i].booIsDisplayed) {\n            return i;\n          }\n        }\n      }\n    }\n    return -1;\n  },\n\n  getNextOrPreviousScreenId: function(sourceAssetScreenId, _strWhatModifier) {\n    if (_strWhatModifier == 'previousScreen' || _strWhatModifier == 'nextScreen') {\n      _strWhatModifier = (_strWhatModifier == 'previousScreen') ? '-1' : '1';\n    }\n    var _intModifier = parseInt(_strWhatModifier);\n    var assetNavigationIndex = null;\n    if (sourceAssetScreenId) {\n      for (var screenIndex in this._objCurrCourseObject.arrScreens) {\n        if (this._objCurrCourseObject.arrScreens[screenIndex].strObjID === sourceAssetScreenId) {\n          assetNavigationIndex = parseInt(screenIndex);\n          break;\n        }\n      }\n    } else {\n      assetNavigationIndex = this._objCurrCourseObject.intNavigationIndex;\n    }\n    var _intNewPageIndex = assetNavigationIndex + _intModifier;\n\n    var targetScreen = this._objCurrCourseObject.arrScreens[_intNewPageIndex];\n    var response = false;\n    if (targetScreen && targetScreen.strObjID) {\n      response = targetScreen.strObjID;\n    }\n    return response;\n  },\n\n  gotoPageByScreenIndex: function(_objWhatModifier) {\n    var _strWhatModifier = '';\n    var _booPageFound = false;\n\n    if (_objWhatModifier.booForceNumericModifier) {\n      _strWhatModifier = _objWhatModifier.strWhatModifier;\n    } else {\n      _strWhatModifier = _objWhatModifier;\n    }\n\n    var intNavIndex = this.getNextOrPreviousUnlockedScreenIndex(_strWhatModifier);\n\n    if (intNavIndex > -1) {\n      this._objCurrCourseObject.intNavigationIndex = intNavIndex;\n      _booPageFound = true;\n    }\n\n    if (!_booPageFound) {\n      this._debug(\n        'ERROR: An attempt was made to access a page outside of the bounds of the topic array. ' +\n          'TOPIC_MANAGER.handleEvent_goToPage(), topic_manager.js'\n      );\n    }\n\n    var _objReturnData = {};\n    _objReturnData._strWhatModifier = _strWhatModifier;\n    _objReturnData._booPageFound = _booPageFound;\n\n    return _objReturnData;\n  },\n\n  // REFACTOR NOTE : I haven't had an opportunity to figure out why all this is needed yet.\n  // Needs tidying up. - JH\n  gotoPageByScreenId: function(_objWhatModifier) {\n    var _booTopicFound = false;\n    var _booPageFound = false;\n    var _booErrorOnScreenLoad = false;\n    var _booScreenIdNotSupplied = false;\n    var modifier = _objWhatModifier['strWhatModifier'];\n\n    // Need to check for the actual topic here not the new one that doesn't exist.\n    if (_objWhatModifier.redirectParentTopicId) {\n      // We have a dynamic redirect which may have a screen ID that is nonsense so use the real\n      // parent topic ID.\n      modifier = _objWhatModifier.redirectParentTopicId;\n    }\n    if (!this.booTopicExisits(modifier)) {\n      return {_booTopicFound: false};\n    }\n\n    if (this._booTopicCompare(modifier, 'currentScreen') == false) {\n      _booTopicFound = true;\n      var _newTopicId = this.getTopicId(_objWhatModifier['strWhatModifier']);\n      if (_objWhatModifier.redirectParentTopicId) {\n        _newTopicId = _objWhatModifier.redirectParentTopicId;\n      }\n\n      var _objData = {};\n      _objData.strTopicID = _newTopicId;\n      _objData.strScreenID = _objWhatModifier['strWhatModifier'];\n      _objData._objActionData = _objWhatModifier;\n\n      if (_objData.strTopicID == _objData.strScreenID) {\n        _booScreenIdNotSupplied = true;\n      }\n\n      SCREEN_INTERACTIONS.hideAllScreens();\n      EM.trigger('preLoadTopicObject', _objData);\n      DYNAMIC_CONTENT_SCREEN_MANAGER.resetDynamicScreensDisplayState();\n      EM.trigger('resetCourseObject');\n      EM.trigger('topicChange');\n      EM.trigger('loadTopicObject', _objData);\n      EM.trigger('postLoadTopicObject', _objData);\n    } else {\n      _booTopicFound = true;\n      var _strWhatModifier = this._getScreenDirection(_objWhatModifier);\n\n      if (_strWhatModifier !== false) {\n        var count = 0;\n        while (count < this._objCurrCourseObject.arrScreens.length) {\n          var _objCurrPage = this._objCurrCourseObject.arrScreens[count];\n          if (_objCurrPage.strObjID == _objWhatModifier['strWhatModifier']\n          && _objCurrPage.booIsDisplayed) {\n            this._objCurrCourseObject.intNavigationIndex = count;\n            _booPageFound = true;\n            break;\n          }\n          count++;\n        }\n      } else {\n        _booErrorOnScreenLoad = true;\n      }\n    }\n\n    var _objReturnData = {};\n    _objReturnData._booTopicFound = _booTopicFound;\n    _objReturnData._booPageFound = _booPageFound;\n    _objReturnData._booErrorOnScreenLoad = _booErrorOnScreenLoad;\n    _objReturnData._booScreenIdNotSupplied = _booScreenIdNotSupplied;\n\n    return _objReturnData;\n  },\n\n  unlockNavigation: function() {\n    this._booNavigationLocked = false;\n  },\n\n  inTopic: function() {\n    if (this._objCurrCourseObject) {\n      return true;\n    }\n    return false;\n  },\n\n  getCurrentTopic: function() {\n    if (this._objCurrCourseObject) {\n      return this._objCurrCourseObject;\n    } else {\n      return false;\n    }\n  },\n\n  booTopicExisits: function(_strFullTopicId) {\n    if (this._splitTopicId(_strFullTopicId)) {\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  getTopicId: function(_strTopicFullId) {\n    var _arrSplitId = this._splitTopicId(_strTopicFullId);\n    var _strTopicId = _arrSplitId[0];\n\n    return _strTopicId;\n  },\n\n  getScreenId: function(_strTopicFullId) {\n    var _arrSplitId = this._splitTopicId(_strTopicFullId);\n    var _strScreenId = _arrSplitId[1];\n\n    return _strScreenId;\n  },\n\n  booCurrentScreenIsMenu: function(_strScreenId) {\n    var _strMenuScreenId = '';\n    if (\n      CORE.objCourseData.objCourseLaunchers &&\n      CORE.objCourseData.objCourseLaunchers.menu &&\n      CORE.objCourseData.objCourseLaunchers.menu.strScreenID\n    ) {\n      _strMenuScreenId = CORE.objCourseData.objCourseLaunchers.menu.strScreenID;\n    }\n\n    if (_strMenuScreenId !== '') {\n      var strCurrentScreenId = _strScreenId;\n      if (typeof strCurrentScreenId == 'undefined') {\n        var objCurrentScreen = SCREEN_INTERACTIONS.getCurrentScreenData();\n        if (objCurrentScreen && objCurrentScreen.strObjID) {\n          strCurrentScreenId = objCurrentScreen.strObjID;\n        }\n      }\n\n      if (strCurrentScreenId == _strMenuScreenId) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  /**\n  * @public\n  * Attempt to find the screen ID in the current topic data and return boolean\n  * @param {string} screenId\n  * @return {boolean}\n  */\n  isScreenInCurrentTopic: function(screenId) {\n    var currTopicData = this.getCurrentTopic();\n    if (currTopicData.findScreen && currTopicData.findScreen(screenId)) {\n      return true;\n    }\n    return false;\n  },\n\n  isContinuousScrollEnabled: function() {\n    return BOO_DYNAMIC_CONTINUOUS_SCROLLING;\n  },\n\n  _getScreenDirection: function(_objLoadScreen) {\n    if (_objLoadScreen['strWhatModifier']) {\n      var _strCurrentScreen = SCREEN_INTERACTIONS.getCurrentScreenData();\n      var _arrSplitFromScreen = this._splitTopicId(_strCurrentScreen.strObjID);\n      var modifier = _objLoadScreen.redirectParentTopicId || _objLoadScreen.strWhatModifier;\n      var _arrSplitToScreen = this._splitTopicId(modifier);\n\n      var _intFromScreen = _arrSplitFromScreen[1];\n      var _intToScreen = _arrSplitToScreen[1];\n    } else {\n      return false;\n    }\n\n    var _strWhatModifier = false;\n    if (_intFromScreen < _intToScreen) {\n      _strWhatModifier = '1';\n    } else if (_intFromScreen > _intToScreen) {\n      _strWhatModifier = '-1';\n    } else {\n      this._debug('This link is pointing to this screen.');\n    }\n\n    return _strWhatModifier;\n  },\n\n  _booTopicCompare: function(_strTopicIdBase, _strTopicIdSecondary) {\n    if (_strTopicIdBase == 'currentScreen') {\n      var _objTopicIdBase = SCREEN_INTERACTIONS.getCurrentScreenData();\n      _strTopicIdBase = _objTopicIdBase.strObjID;\n    }\n\n    if (_strTopicIdSecondary == 'currentScreen') {\n      var _objTopicIdSecondary = SCREEN_INTERACTIONS.getCurrentScreenData();\n      _strTopicIdSecondary = _objTopicIdSecondary.strObjID;\n    }\n\n    var _arrSplitFromScreen = this._splitTopicId(_strTopicIdBase);\n    var _arrSplitToScreen = this._splitTopicId(_strTopicIdSecondary);\n\n    var _strFromTopic = _arrSplitFromScreen[0];\n    var _strToTopic = _arrSplitToScreen[0];\n\n    if (_strFromTopic == _strToTopic) {\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  _splitTopicId: function(_strFullTopicId) {\n    if (CORE.objCourseData.arrContainers) {\n      var intCount = 0;\n      while (intCount < CORE.objCourseData.arrContainers.length) {\n        var objCurrentTopic = CORE.objCourseData.arrContainers[intCount];\n        if (_strFullTopicId.indexOf(objCurrentTopic.strObjID) != -1) {\n          // Check that the ids are the same or the next value is a screenId\n          if (\n            _strFullTopicId.length == objCurrentTopic.strObjID.length ||\n            _strFullTopicId.charAt(objCurrentTopic.strObjID.length) == 's'\n          ) {\n            var _arrTopicScreen = [];\n            _arrTopicScreen[0] = objCurrentTopic.strObjID;\n            _arrTopicScreen[1] = _strFullTopicId.replace(objCurrentTopic.strObjID, '');\n            if (_arrTopicScreen[1] == '') {\n              _arrTopicScreen[1] = '01';\n            }\n            return _arrTopicScreen;\n          }\n        }\n        intCount++;\n      }\n      this._debug('Topic ' + _strFullTopicId + ' not found. TOPIC_MANAGER._splitTopicId()');\n      return false;\n    } else {\n      this._debug('Topics not found. TOPIC_MANAGER._splitTopicId()');\n      return false;\n    }\n  },\n\n  getTopicDataFromUnloadedTopic: function(_objWhatTopicObject) {\n    var _strTopicDataFilename = _objWhatTopicObject.strTopicDataFilename.split('.')[0];\n    var _objTopicData = LOADER.loadTopicData(_strTopicDataFilename);\n    return _objTopicData;\n  },\n\n  _loadTopic: function(_objWhatTopicObject) {\n    this._strPostLoadMethod = 'handleEvent_showCurrentPage';\n    this._objPostLoadData = {param: {_booForceReRender: true}};\n\n    var _strTopicDataFilename = _objWhatTopicObject.strTopicDataFilename.split('.')[0];\n\n    var _objTopicData = LOADER.loadTopicData(_strTopicDataFilename);\n    if (_objTopicData) {\n      // check for dyn. screens and replace\n      this.addData(_objTopicData);\n    } else {\n      OBJ_PLAYER_REFRESH_DATA.arrFileList[0].strFile = _strTopicDataFilename;\n      OBJ_PLAYER_REFRESH_DATA.arrFileList[0].strType = 'player-data';\n      LOADER.startLoadSequence(ARR_DATA_REFRESH_LOAD_SEQUENCE, true);\n    }\n  },\n\n  _sortIntoPhaseOrder: function(_arrWhatSourceScreens) {\n    var _objSortedScreens = {arrIntroScreens: [], arrQuestionScreens: [], arrEndScreens: []};\n    var count = 0;\n    var _booFoundQuestionScreen = false;\n    var _booFoundEndOfQuestionScreens = false;\n    while (count < _arrWhatSourceScreens.length) {\n      var _objCurrScreen = _arrWhatSourceScreens[count];\n      if (_objCurrScreen.booHasQuestionAsset) {\n        _booFoundQuestionScreen = true;\n      }\n      if (!_objCurrScreen.booHasQuestionAsset && _booFoundQuestionScreen) {\n        _booFoundEndOfQuestionScreens = true;\n      }\n\n      if (!_booFoundQuestionScreen) {\n        _objSortedScreens['arrIntroScreens'].push(_objCurrScreen);\n      }\n      if (_booFoundQuestionScreen && !_booFoundEndOfQuestionScreens) {\n        _objSortedScreens['arrQuestionScreens'].push(_objCurrScreen);\n      }\n      if (_booFoundQuestionScreen && _booFoundEndOfQuestionScreens) {\n        _objSortedScreens['arrEndScreens'].push(_objCurrScreen);\n      }\n\n      count++;\n    }\n    return _objSortedScreens;\n  },\n\n  _randomSort: function(_objItemA, _objItemB) {\n    var _intResult = TOPIC_MANAGER._getRandomNumber(-1, 3);\n    return _intResult;\n  },\n\n  _getRandomNumber: function(_intStart, _intEndPoint) {\n    return _intStart + Math.floor(Math.random() * _intEndPoint);\n  },\n\n  _getCurrScreenObject: function() {\n    return this._objCurrCourseObject.arrScreens[this._objCurrCourseObject.intNavigationIndex];\n  },\n\n  _setNavigationIndexFromScreenID: function() {\n    var count = 0;\n    var intDefaultScreen = 0;\n    while (count < this._objCurrCourseObject.arrScreens.length) {\n      var _objCurrScreen = this._objCurrCourseObject.arrScreens[count];\n      if (_objCurrScreen.strObjID == this._strBookmarkStringToSkipToo\n        && _objCurrScreen.booIsDisplayed) {\n        this._objCurrCourseObject.intNavigationIndex = count;\n        return;\n      }\n      count++;\n    }\n    var firstUnlockedScreen = -1;\n    // check to see if the initial screen in a topic is hidden\n    if (!this._objCurrCourseObject.arrScreens[intDefaultScreen].booIsDisplayed\n      && !BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n      firstUnlockedScreen = _.findIndex(\n        this._objCurrCourseObject.arrScreens, {booIsDisplayed: true}\n      );\n      if (firstUnlockedScreen > -1) intDefaultScreen = firstUnlockedScreen;\n    }\n\n    this._objCurrCourseObject.intNavigationIndex = intDefaultScreen;\n    return;\n  },\n\n  _isNumericModifier: function(_strWhatModifier) {\n    var _intParsedValue = parseInt(_strWhatModifier);\n\n    // If we've lost some length, it wasn't a proper number.\n    if (_intParsedValue.toString().length != _strWhatModifier.length) {\n      return false;\n    }\n    if (isNaN(_intParsedValue)) {\n      return false;\n    }\n    return true;\n  },\n\n  /**\n   * Responsible to checking the state of each page and determining the overall\n   * topic tracking status.\n   */\n  _checkTopicState: function() {\n    if (this._objCurrCourseObject.intTrackingState < INT_COMPLETED) {\n      var count = 0;\n      var _arrCurrScreens = this._objCurrCourseObject.arrScreens;\n      var _booAllShown = true;\n      var _booSomeShown = false;\n      var _booLastPageShown = false;\n      var contentHeight = $('#contentWrapperInnerL').outerHeight();\n      var screenHeight = $('#contentWrapperL').outerHeight();\n      var _objCurrScreen = null;\n      var _strDebugMsg = '';\n\n      // Loop each screen in the topic\n      while (count < _arrCurrScreens.length) {\n        // If all screens are visible then let this topic be complete.\n        if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n          if (contentHeight > screenHeight) {\n            // Check if the screen has been shown!\n            _objCurrScreen = _arrCurrScreens[count];\n            if (_objCurrScreen.booScreenShown) {\n              _booSomeShown = true;\n            } else {\n              _booAllShown = false;\n            }\n            // Have we seen this page?\n            if (\n              _objCurrScreen.booScreenShown &&\n              // Now is this the final screen OR should it be treat as the final screen?\n              (count == _arrCurrScreens.length - 1 ||\n                _objCurrScreen.objRawData['booCountAsFinalScreen'])\n            ) {\n              // set the last page show variable!\n              _booLastPageShown = true;\n            }\n          } else {\n            _booLastPageShown = true;\n          }\n        } else {\n          // Check if the screen has been shown!\n          _objCurrScreen = _arrCurrScreens[count];\n          if (_objCurrScreen.booScreenShown) {\n            _booSomeShown = true;\n          } else {\n            _booAllShown = false;\n          }\n          // Have we seen this page?\n          if (\n            _objCurrScreen.booScreenShown &&\n            // Now is this the final screen OR should it be treat as the final screen?\n            (count == _arrCurrScreens.length - 1 ||\n              _objCurrScreen.objRawData['booCountAsFinalScreen'])\n          ) {\n            // set the last page show variable!\n            _booLastPageShown = true;\n          }\n        }\n\n        count++;\n      }\n\n      // If we've seen all the pages then set the overall topic status to complete\n      if (\n        (_booAllShown && this._objCurrCourseObject.intTrackingState < INT_COMPLETED) ||\n        (BOO_LINEAR_COMPLETE_ON_LAST_PAGE && _booLastPageShown)\n      ) {\n        _strDebugMsg = LOCALISER.get('TOPIC_MANAGER_TOPIC_COMPLETED_DEBUG') +\n          ' ' + this._objCurrCourseObject.strObjID;\n        this._debug(_strDebugMsg);\n\n        this._objCurrCourseObject.intTrackingState = INT_COMPLETED;\n        EM.trigger('courseObjectStateChanged', this._objCurrCourseObject);\n        // Update system variables\n        try {\n          VARIABLES_HOLDER.checkTopicCompletion(this._objCurrCourseObject);\n        } catch (e) {\n          typeof ErrorHandler != 'undefined' && ErrorHandler['catch'] && ErrorHandler['catch'](e);\n        }\n\n        return;\n      }\n\n      // If we have only seen a selection of pages then mark the topic as visited\n      if (_booSomeShown && this._objCurrCourseObject.intTrackingState < INT_VISITED) {\n        _strDebugMsg = LOCALISER.get('TOPIC_MANAGER_TOPIC_STARTED_DEBUG') +\n          ' ' + this._objCurrCourseObject.strObjID;\n        this._debug(_strDebugMsg);\n\n        this._objCurrCourseObject.intTrackingState = INT_VISITED;\n        EM.trigger('courseObjectStateChanged', this._objCurrCourseObject);\n        return;\n      }\n    }\n  },\n\n  _checkTopicValidity: function() {\n    if (this._objCurrCourseObject.arrScreens.length > 0 &&\n      typeof _.findWhere(\n        this._objCurrCourseObject.arrScreens, {booIsDisplayed: true}\n      ) !== 'undefined') {\n      return true;\n    }\n    return false;\n  },\n\n  // Used by loader.js\n  addData: function(_objWhatData) {\n    if (_objWhatData && !this._objCurrCourseObject.booTopicLoaded) {\n      this._objCurrCourseObject.objRawTopicData = JSON_POST.process(_objWhatData['topic']);\n      this._objCurrCourseObject.strTitle = this._objCurrCourseObject.objRawTopicData.strTitle;\n\n      this.addScreenData();\n      this._objCurrCourseObject.booTopicLoaded = true;\n    }\n  },\n\n  addScreenData: function() {\n    if (!this._objCurrCourseObject.booTopicLoaded) {\n      this._objCurrCourseObject.arrScreens =\n        TOPIC_STRUCTURE_PARSER.parseTopicData(this._objCurrCourseObject);\n    }\n\n    // Check if our topic has a dynamic content screen.\n    // If it has, inject the meta topic screens to our topic\n    if (DYNAMIC_CONTENT_SCREEN_MANAGER) {\n      DYNAMIC_CONTENT_SCREEN_MANAGER.updateTopicScreens(this._objCurrCourseObject);\n      this._objCurrCourseObject.arrScreens =\n        TOPIC_STRUCTURE_PARSER.parseDynamicTopicData(this._objCurrCourseObject);\n      // Restore raw data\n      DYNAMIC_CONTENT_SCREEN_MANAGER.restoreTopicRawData(this._objCurrCourseObject);\n    }\n  },\n\n  silentlyLoadTopicObject: function(topicRequest) {\n    var preloadTopicData = CORE.objCourseData.findTopic(topicRequest['strTopicID']);\n    if (preloadTopicData) {\n      this.silentlyAddData(preloadTopicData);\n    } else {\n      console.log('Topic not found in silent loader - ' + topicRequest['strTopicID']);\n    }\n  },\n\n  silentlyAddData: function(_objWhatData, forceLiveData) {\n    var count = 0;\n    var _objTopicData = _objWhatData;\n    if (!forceLiveData) {\n      var _strTopicDataFilename = _objWhatData.strTopicDataFilename.split('.')[0];\n      _objTopicData = LOADER.loadTopicData(_strTopicDataFilename);\n    }\n\n    if (_objTopicData) {\n      while (count < CORE.objCourseData.arrContainers.length) {\n        if (\n          CORE.objCourseData.arrContainers[count] &&\n          CORE.objCourseData.arrContainers[count].strObjID == _objTopicData.topic.strID &&\n          (!CORE.objCourseData.arrContainers[count].booTopicLoaded || forceLiveData)\n        ) {\n          CORE.objCourseData.arrContainers[count].booTopicLoaded = true;\n          CORE.objCourseData.arrContainers[count].objRawTopicData =\n            JSON_POST.process(_objTopicData['topic']);\n          CORE.objCourseData.arrContainers[count].strTitle =\n            CORE.objCourseData.arrContainers[count].objRawTopicData.strTitle;\n          CORE.objCourseData.arrContainers[count].arrScreens =\n            TOPIC_STRUCTURE_PARSER.parseTopicData(CORE.objCourseData.arrContainers[count]);\n\n          // Process dynamic screens, ie content banks.\n          var dynamicScreenIds = {};\n          _.each(CORE.objCourseData.arrContainers[count].arrScreens, function(screenData, index) {\n            if (\n              !_.isUndefined(screenData.objRawData) &&\n              _.isMatch(screenData.objRawData, {strType: 'dynamicContentScreen'}) &&\n              !_.isUndefined(screenData.objRawData.arrMetaTopicOptions) &&\n              !_.isUndefined(\n                _.find(screenData.objRawData.arrMetaTopicOptions, function(opt) {\n                  return opt.booActivate && opt.screenCount > 0;\n                })\n              )\n            ) {\n              dynamicScreenIds[screenData.strObjID] = index;\n              // Rebuild topic data to include dynamic screens.\n              if (DYNAMIC_CONTENT_SCREEN_MANAGER) {\n                DYNAMIC_CONTENT_SCREEN_MANAGER.updateTopicScreens(\n                  CORE.objCourseData.arrContainers[count]\n                );\n                CORE.objCourseData.arrContainers[count].arrScreens =\n                  TOPIC_STRUCTURE_PARSER.parseDynamicTopicData(\n                    CORE.objCourseData.arrContainers[count]\n                  );\n                DYNAMIC_CONTENT_SCREEN_MANAGER.restoreTopicRawData(\n                  CORE.objCourseData.arrContainers[count]\n                );\n              }\n              // Set the last screen id to the first dynamic screen.\n              var lastScreenId = SCREEN_INTERACTIONS.getLastScreenID();\n              if (\n                !_.isUndefined(dynamicScreenIds[lastScreenId]) &&\n                !_.isUndefined(CORE.objCourseData.arrContainers[count]) &&\n                !_.isUndefined(CORE.objCourseData.arrContainers[count].arrScreens)\n              ) {\n                var currentTopicScreensData = CORE.objCourseData.arrContainers[count].arrScreens;\n                var newDynamicScreenId =\n                  currentTopicScreensData[dynamicScreenIds[lastScreenId]].strObjID;\n                EM.trigger('setLastScreenID', newDynamicScreenId);\n              }\n            }\n          });\n        }\n        count++;\n      }\n    } else {\n      console.log(_objWhatData + ' topic not found. topic_manager.silentlyAddData()');\n    }\n  },\n\n  sendTopicCompleted: function() {\n    if (this._objCurrCourseObject && this.topicAvailable) {\n      CONTENT_TRACKING.topicCompleted({\n        topicId: this._objCurrCourseObject.strObjID,\n        topicTitle: this._objCurrCourseObject.strTitle,\n        topicType: this.topicType,\n        timeAvailable: this.topicAvailable,\n        timeCompleted: new Date(),\n        completed: this._objCurrCourseObject.intTrackingState === INT_COMPLETED\n      });\n    }\n  },\n\n  sendScreenChanged: function() {\n    CONTENT_TRACKING.screenChanged({\n      topicId: this.screenDetails.topicId,\n      pageId: this.screenDetails.pageId,\n      pageTitle: this.screenDetails.pageTitle,\n      topicTitle: this.screenDetails.topicTitle,\n      timeAvailable: this.screenDetails.available,\n      timeCompleted: new Date(),\n      referrer: {\n        id: this.screenDetails.referrerId,\n        type: this.screenDetails.referrerType,\n        title: this.screenDetails.referrerTitle\n      }\n    });\n  },\n\n  setScreenReferrer: function(pageId, pageTitle) {\n    if (this.screenDetails.referrerId) {\n      this.screenDetails.referrerId = pageId;\n      this.screenDetails.referrerType = 'page';\n      this.screenDetails.referrerTitle = pageTitle;\n    } else {\n      this.screenDetails.referrerId = CORE.objCourseData.strObjID;\n      this.screenDetails.referrerType = 'course';\n      this.screenDetails.referrerTitle = CORE.objCourseData.objRawData.title;\n    }\n  },\n\n  resetAssetsInitialisedStatus: function() {\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING && BOO_TURN_OFF_CONTINUOUS_SCROLL_ASSET_RESET) {\n      _.each(this._objCurrCourseObject.arrScreens, function(screen) {\n        if (screen.arrAssets) {\n          _.each(screen.arrAssets, function(asset) {\n            if (asset.initialised) {\n              asset.initialised = null;\n            }\n          });\n        }\n      });\n    }\n  },\n\n  _debug: function(_strMessage) {\n    if (window['console'] && window.console.log && this._booDebug) {\n      console.log('TOPIC MANAGER: ' + _strMessage);\n    }\n  }\n};\n\nEM.register(TOPIC_MANAGER);\n"},function(n,e,t){t(0)(t(83))},function(n,e){n.exports='/**\n* @title Topic Manager\n* @description To be described.\n*\n*\n* @author GoMo\n* @version 2.0 17/12/12\n*/\n\nvar META_TOPIC_MANAGER =\n{\n\tstrObjID : "The meta topic manager",\n\tstrObjDescription : "This object loads screens in popups and controls navigation.",\n\n\t_strTopicType : "meta",\n\n\t_strPostLoadMethod : "",\n\t_objPostLoadData : {},\n\t_objCurrMetaObject : null,\n\n\t_strBookmarkStringToSkipToo : false,\n\t_booLoadingPage : false,\n\n\thandleEvent_loadMetaTopic : function(_objWhatMetaTopicData)\n\t{\n\t\tthis._booLoadingPage = true;\n\t\tvar _booTopicFound = false;\n\t\tthis._objCurrMetaObject = {};\n\n\t\tif (_objWhatMetaTopicData.strWhatMetaTopicId)\n\t\t{\n\t\t\tif (this._getReferencedMetaTopicId(_objWhatMetaTopicData.strWhatMetaTopicId) != false)\n\t\t\t{\n\t\t\t\t_objWhatMetaTopicData.strWhatMetaTopicId = this._getReferencedMetaTopicId(_objWhatMetaTopicData.strWhatMetaTopicId);\n\t\t\t}\n\n\t\t\tif (this.booMetaTopicExisits(_objWhatMetaTopicData.strWhatMetaTopicId) == false)\n\t\t\t{\n\t\t\t\t_booTopicFound = false;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_booTopicFound = true;\n\t\t\t}\n\n\t\t\tthis.gotoMetaTopicByScreenId(_objWhatMetaTopicData);\n\t\t}\n\n\t\tif (!_booTopicFound)\n\t\t{\n\t\t\t//alert("ERROR: Unable to resolve the modifier \'" + _strWhatModifier + "\', so we\'re staying here for now until things become clearer. TOPIC_MANAGER.handleEvent_goToPage(), topic_manager.js");\n\t\t\tLOCALISER.l_alert("TOPIC_MANAGER_UNRESOLVABLE_NAV_MODIFIER_ERROR", [_strWhatModifier]);\n\t\t\tif (_objWhatMetaTopicData.funCallBack)\n\t\t\t{\n\t\t\t\t_objWhatMetaTopicData.funCallBack();\n\t\t\t}\n\t\t}\n\t},\n\n\tgotoMetaTopicByScreenId : function (_objWhatMetaTopicData)\n\t{\n\t\tvar _newTopicId = this.getMetaTopicId(_objWhatMetaTopicData.strWhatMetaTopicId);\n\n\t\tvar _objData = {};\n\t\tvar _strMetaTopic = _objWhatMetaTopicData.strWhatMetaTopicId;\n\n\t\t_objData.strTopicID = this.getMetaTopicId(_strMetaTopic);\n\t\t_objData.strScreenID = this.getMetaScreenId(_strMetaTopic);\n\t\t_objData._objActionData = _objWhatMetaTopicData;\n\t\t_objData._objActionData.strFullScreenId = _objData.strTopicID + _objData.strScreenID;\n\n\t\tthis.loadMetaTopicObject(_objData);\n\t},\n\n\tgetCurrentMetaTopic : function ()\n\t{\n\t\treturn this._objCurrMetaObject;\n\t},\n\n\tloadMetaTopicObject : function (_objMetaTopicData)\n\t{\n\t\tvar _objWhatTopicObject = CORE.objCourseData.findMetaTopic(_objMetaTopicData[\'strTopicID\']);\n\t\tif (_objWhatTopicObject == false)\n\t\t{\n\t\t\talert("Selected Topic isn\'t loaded in this Player.");\n\t\t\t// Do the callback if it exists\n\t\t\tif(_objTopicData && _objTopicData._objActionData && _objTopicData._objActionData.funCallBack) {\n\t\t\t\t_objTopicData._objActionData.funCallBack();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tthis._objCurrMetaObject = _objWhatTopicObject;\n\t\tthis._strBookmarkStringToSkipToo = _objMetaTopicData[\'strScreenID\'];\n\n\t\tif (!this._objCurrMetaObject.objRawTopicData)\n\t\t{\n\t\t\tCORE.showLoadingLayer();\n\t\t\tthis._loadMetaTopic(this._objCurrMetaObject);\n\t\t\tthis._objCurrMetaObject.strObjTopicModel = this._strTopicType;\n\t\t}\n\t\t\n\t\tvar callback = function(){\n\t\t\tvar _objOptions = {};\n\t\t\t_objOptions._objActionData = _objMetaTopicData._objActionData;\n\t\t\t_objOptions._booForceReRender = true;\n\t\t\t_objOptions._metaTopic = META_TOPIC_MANAGER._objCurrMetaObject;\n\t\t\tMETA_TOPIC_MANAGER.showCurrentMetaTopic(_objOptions);\n\t\t};\n\n\t\tgomo.translationManager.loadMetaTopic(callback);\t\t\n\t},\n\n\tshowCurrentMetaTopic : function (_objOptions)\n\t{\n\t\t_objOptions[\'strPopupID\'] = this._objCurrMetaObject.strObjType;\n\t\tEM.trigger(\'popupButtonClicked\',_objOptions);\n\n\t\tif (_objOptions._objActionData.funCallBack)\n\t\t{\n\t\t\t_objOptions._objActionData.funCallBack();\n\t\t}\n\t},\n\n\tbooMetaTopicExisits : function (_strFullTopicId)\n\t{\n\t\tif (this._splitMetaTopicId(_strFullTopicId))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t},\n\n\tgetMetaTopicId : function (_strTopicFullId)\n\t{\n\t\tvar _arrSplitId = this._splitMetaTopicId(_strTopicFullId);\n\t\tvar _strTopicId = _arrSplitId[0];\n\n\t\treturn _strTopicId;\n\t},\n\n\tgetMetaScreenId : function (_strTopicFullId)\n\t{\n\t\tvar _arrSplitId = this._splitMetaTopicId(_strTopicFullId);\n\t\tvar _strScreenId = _arrSplitId[1];\n\n\t\treturn _strScreenId;\n\t},\n\n\t_getReferencedMetaTopicId : function (_strWhatMetaTopicId)\n\t{\n\t\tvar count = 0;\n\t\tvar _strTopicId = false;\n\t\tvar _arrMetaTopics = CORE.objCourseData.arrMetaTopics;\n\n\t\twhile (count < _arrMetaTopics.length)\n\t\t{\n\t\t\tif (_strWhatMetaTopicId == _arrMetaTopics[count].strObjType )\n\t\t\t{\n\t\t\t\t_strTopicId = _arrMetaTopics[count].strObjID;\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\n\t\treturn _strTopicId;\n\t},\n\n\t_splitMetaTopicId : function (_strFullTopicId)\n\t{\n\t\tif (CORE.objCourseData.arrMetaTopics)\n\t\t{\n\t\t\tvar intCount = 0;\n\t\t\twhile(intCount < CORE.objCourseData.arrMetaTopics.length)\n\t\t\t{\n\t\t\t\tvar objCurrentTopic = CORE.objCourseData.arrMetaTopics[intCount];\n\t\t\t\tif (_strFullTopicId.indexOf(objCurrentTopic.strObjID) != -1)\n\t\t\t\t{\n\t\t\t\t\t//Check that the ids are the same or the next value is a screenId\n\t\t\t\t\tif (_strFullTopicId.length == objCurrentTopic.strObjID.length\n\t\t\t\t\t    || _strFullTopicId.charAt(objCurrentTopic.strObjID.length) == "s")\n\t\t\t\t\t{\n\t\t\t\t\t\tvar _arrTopicScreen = [];\n\t\t\t\t\t\t_arrTopicScreen[0] = objCurrentTopic.strObjID;\n\t\t\t\t\t\t_arrTopicScreen[1] = _strFullTopicId.replace(objCurrentTopic.strObjID, "");\n\t\t\t\t\t\tif (_arrTopicScreen[1] == "")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t_arrTopicScreen[1] = "s01"\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn _arrTopicScreen;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tintCount++;\n\t\t\t}\n\t\t\talert("Meta topic "+_strFullTopicId+" not found. META_TOPIC_MANAGER._splitTopicId()");\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\talert("Meta topics not found. META_TOPIC_MANAGER._splitTopicId()");\n\t\t\treturn false;\n\t\t}\n\t},\n\n\t_loadMetaTopic : function (_objWhatMetaTopicObject)\n\t{\n\t\tthis._strPostLoadMethod = "handleEvent_showCurrentPage";\n\t\tthis._objPostLoadData = {\'param\':{\'_booForceReRender\':true}};\n\n\t\tvar _strTopicDataFilename = _objWhatMetaTopicObject.strTopicDataFilename.split(".")[0];\n\t\tvar _strPath = "";\n\n\t\tvar _objTopicData = LOADER.loadTopicData(_strTopicDataFilename);\n\t\tif (_objTopicData)\n\t\t{\n\t\t\tthis.addData(_objTopicData);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tOBJ_PLAYER_REFRESH_DATA.arrFileList[0].strFile = _strTopicDataFilename;\n\t\t\tOBJ_PLAYER_REFRESH_DATA.arrFileList[0].strType = "player-data";\n\t\t\tLOADER.startLoadSequence(ARR_DATA_REFRESH_LOAD_SEQUENCE, true);\n\t\t}\n\t},\n\n\t//Used by loader_object_literal.js\n\taddData : function (_objWhatData)\n\t{\n\t\tif (_objWhatData)\n\t\t{\n\t\t\tthis._objCurrMetaObject.objRawTopicData = JSON_POST.process(_objWhatData[\'topic\']);\n\t\t\tthis._objCurrMetaObject.arrScreens = TOPIC_STRUCTURE_PARSER.parseTopicData(this._objCurrMetaObject);\n\t\t}\n\t},\n\n\tdebug : function (strMessage, intPriority, objCallerObject, booCalleeChain)\n\t{\n\t\tif (DEBUG)\n\t\t{\n\t\t\tDEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n\t\t}\n\t}\n}\n\nEM.register(META_TOPIC_MANAGER);'},function(n,e,t){t(0)(t(85))},function(n,e){n.exports="/* globals _, LOADER, CORE, VARIABLES_HOLDER, OBJ_REF */\n/**\n * Dynamic content screen manager\n * For every topic, it checks for dynamic content screens\n * and replaces them with meta topic screens\n *\n * @author Manos Tzoumas\n * @version 1.0 13/08/16\n */\n\n// eslint-disable-next-line no-unused-vars\nvar DYNAMIC_CONTENT_SCREEN_MANAGER = {\n  screenType: 'dynamicContentScreen',\n\n  currentTopicRawData: null,\n  dynamicContentTopic: false,\n  answeredViewedQuestions: {},\n  currentTopicMetaScreens: {},\n  metaTopicsRef: [],\n  redirects: [],\n  currentTopicAddedScreens: [],\n  foundDynamicScreenPlaceholders: {},\n\n  /**\n   * Reset screens on leaving a dynamic topic\n   */\n  resetDynamicScreensDisplayState: function() {\n    var me = this;\n    var currentScreenParent;\n    // If we don't have dynamic screens or the list is empty, then return\n    if (!me.currentTopicAddedScreens ||\n      (me.currentTopicAddedScreens && me.currentTopicAddedScreens.length === 0)) {\n      return;\n    }\n    // For every dynamic screen that's been added, reset displayed state to false\n    for (var screen in me.currentTopicAddedScreens) {\n      if (Object.prototype.hasOwnProperty.call(me.currentTopicAddedScreens, screen)) {\n        currentScreenParent = OBJ_REF.get(me.currentTopicAddedScreens[screen].strID);\n        if (currentScreenParent) {\n          currentScreenParent.booIsDisplayed = false;\n        }\n      }\n    }\n\n    // Reset the current added screens as we're changing topic\n    me.currentTopicAddedScreens = [];\n  },\n\n  /**\n   * Check if the current topic has any dynamic screens\n   * and replace them with the meta topic screens\n   * @param {object} currentTopic\n   */\n  updateTopicScreens: function(currentTopic) {\n    var me = this;\n    var screensToRemove = [];\n    var screensToAdd = {};\n    var topicScreens = [];\n\n    // Reset reference of meta topics used\n    me.metaTopicsRef = [];\n\n    // Get the dynamic screen data for this topic.\n    var screensData = me.getDynamicContentScreenData(currentTopic);\n    screensToRemove = screensData.screensToRemove;\n    screensToAdd = screensData.screensToAdd;\n    topicScreens = screensData.topicScreens;\n    me.redirects = screensData.redirects;\n\n    // Can we update our array of screens\n    if (screensToRemove.length) {\n      me.dynamicContentTopic = true;\n      me.currentTopicRawData = [].concat(topicScreens);\n      var newTopicScreensList = [];\n\n      // Create new list of screens\n      for (var k = 0; k < topicScreens.length; k++) {\n        // Remove the dynamic screen and add the new meta screens\n        if (_.indexOf(screensToRemove, k) >= 0) {\n          newTopicScreensList = newTopicScreensList.concat(\n            screensToAdd[screensToRemove[_.indexOf(screensToRemove, k)]]\n          );\n        } else {\n          newTopicScreensList.push(topicScreens[k]);\n        }\n      }\n\n      // Update topic raw data screens array\n      currentTopic.objRawTopicData.arrScreens = [].concat(newTopicScreensList);\n    }\n  },\n\n  getDynamicContentScreenData: function(currentTopic) {\n    var me = this;\n    var screensToRemove = [];\n    var screensToAdd = {};\n    var topicScreens = [];\n    var redirects = [];\n\n    if (currentTopic.objRawTopicData && currentTopic.objRawTopicData.arrScreens.length) {\n      topicScreens = currentTopic.objRawTopicData.arrScreens;\n\n      for (var i = 0; i < topicScreens.length; i++) {\n        if (topicScreens[i].strType == me.screenType) {\n          screensToRemove.push(i);\n          me.foundDynamicScreenPlaceholders[topicScreens[i].strID] = me.screenType;\n\n          var currentScreenNewScreens = [];\n\n          if (!(currentTopic.strObjID in me.answeredViewedQuestions)) {\n            me.answeredViewedQuestions[currentTopic.strObjID] = {};\n          }\n\n          if (!(topicScreens[i].strID in me.answeredViewedQuestions[currentTopic.strObjID])) {\n            me.answeredViewedQuestions[currentTopic.strObjID][topicScreens[i].strID] = [];\n          }\n\n          var dynamicScreenOptions = {\n            topicId: currentTopic.strObjID,\n            screenId: topicScreens[i].strID,\n            booRepeatIncorrectScreens: topicScreens[i].booRepeatIncorrectScreens,\n            booShowMinOfScreenCount: topicScreens[i].booShowMinOfScreenCount\n          };\n\n          // if repeat incorrect screens then set show min of screen count to false locally.\n          if (dynamicScreenOptions.booRepeatIncorrectScreens) {\n            dynamicScreenOptions.booShowMinOfScreenCount = false;\n          }\n          // Get meta topic screens\n          if (topicScreens[i].arrMetaTopicOptions.length) {\n            for (var mt = 0; mt < topicScreens[i].arrMetaTopicOptions.length; mt++) {\n              // Check if the meta topic has been activated\n              if (topicScreens[i].arrMetaTopicOptions[mt].booActivate) {\n                currentScreenNewScreens = currentScreenNewScreens.concat(\n                  me.getMetaTopicScreens(\n                    topicScreens[i].arrMetaTopicOptions[mt],\n                    dynamicScreenOptions\n                  )\n                );\n              }\n            }\n\n            for (var ns = 0; ns < currentScreenNewScreens.length; ns++) {\n              if (!(currentScreenNewScreens[ns].strObjID in me.currentTopicMetaScreens)) {\n                me.currentTopicMetaScreens[currentScreenNewScreens[ns].strID] =\n                  topicScreens[i].strID;\n              }\n            }\n\n            // Can we randomise all the screens?\n            if (topicScreens[i].booAllowRandomiseOrder) {\n              currentScreenNewScreens = _.shuffle(currentScreenNewScreens);\n            }\n\n            // Check if the dynamic screen is the final screen\n            // If yes, mark the last injected page as final\n            if (topicScreens[i].booCountAsFinalScreen && currentScreenNewScreens.length > 0) {\n              currentScreenNewScreens[\n                currentScreenNewScreens.length - 1\n              ].booCountAsFinalScreen = true;\n            }\n          }\n\n          // Add flag to new screens to tell us they came from a bank. Used currently to stop search returning results from banked content.\n          var j = 0;\n          while (j < currentScreenNewScreens.length) {\n            currentScreenNewScreens[j].booFromContentBank = true;\n            j++;\n          }\n\n          screensToAdd[i] = currentScreenNewScreens;\n          me.currentTopicAddedScreens = me.currentTopicAddedScreens.concat(currentScreenNewScreens);\n\n          // Clear incorrect screens array\n          me.answeredViewedQuestions[currentTopic.strObjID][topicScreens[i].strID] = [];\n        }\n      }\n    }\n\n    // Store redirects to dynamic screens\n    if (screensToRemove.length) {\n      redirects = [];\n      _.each(screensToRemove, function(screenId) {\n        if (topicScreens[screenId] && screensToAdd[screenId].length) {\n          redirects.push({\n            screen: topicScreens[screenId].strID,\n            redirect: screensToAdd[screenId][0].strID,\n            topic: currentTopic.strObjID\n          });\n        }\n      });\n    }\n\n    return {\n      'screensToRemove': screensToRemove,\n      'screensToAdd': screensToAdd,\n      'topicScreens': topicScreens,\n      'redirects': redirects\n    };\n  },\n\n  /**\n   * Get the necessary screens from the meta topic\n   * @param {array} metaTopicOptions\n   * @param {object} options\n   * @return {array} newTopicScreens\n   */\n  getMetaTopicScreens: function(metaTopicOptions, options) {\n    var me = this;\n    var newTopicScreens = [];\n\n    // Make sure that we are always requesting at least one screen\n    metaTopicOptions.intScreenToDisplay =\n      metaTopicOptions.intScreenToDisplay == 0 ? 1 : metaTopicOptions.intScreenToDisplay;\n\n    // Find meta topic and load its data\n    var metaTopic = CORE.objCourseData.findMetaTopic(metaTopicOptions.strID);\n\n    if (metaTopic && metaTopic.strTopicDataFilename) {\n      me.metaTopicsRef.push(metaTopic);\n\n      var topicDataFilename = metaTopic.strTopicDataFilename.split('.')[0];\n      var topicData = LOADER.loadTopicData(topicDataFilename);\n\n      if (topicData && topicData.topic) {\n        var metaTopicScreens = topicData.topic.arrScreens;\n\n        // Get the screens that we need to display\n        if (metaTopicOptions.intScreenToDisplay >= metaTopicScreens.length) {\n          metaTopicOptions.intScreenToDisplay = metaTopicScreens.length;\n\n          // Repeat only incorrect screens\n          var incorrectScreens;\n          if (options.booRepeatIncorrectScreens) {\n            incorrectScreens = me.answeredViewedQuestions[options.topicId][options.screenId];\n\n            // Do we have any incorrect screens?\n            if (incorrectScreens.length && !options.booShowMinOfScreenCount) {\n              for (var i = 0; i < metaTopicScreens.length; i++) {\n                if (_.contains(incorrectScreens, metaTopicScreens[i].strID)) {\n                  newTopicScreens.push(metaTopicScreens[i]);\n                }\n              }\n            } else {\n              // If not, then show all the screens\n              newTopicScreens = [].concat(metaTopicScreens);\n            }\n          } else {\n            // Get all screens\n            newTopicScreens = [].concat(metaTopicScreens);\n          }\n        } else {\n          var randomScreens = [];\n          incorrectScreens = me.answeredViewedQuestions[options.topicId][options.screenId];\n          newTopicScreens = [];\n\n          // Repeat only incorrect screens, if any\n          if (options.booRepeatIncorrectScreens && incorrectScreens.length) {\n            // Get the incorrect screen index\n            for (var j = 0; j < metaTopicScreens.length; j++) {\n              if (_.contains(incorrectScreens, metaTopicScreens[j].strID)) {\n                randomScreens.push(j);\n              }\n            }\n\n            if (options.booShowMinOfScreenCount) {\n              // Generate unique random numbers but not get incorrect screens\n              randomScreens = [].concat(\n                me.generateArrayOfNumbers(\n                  metaTopicOptions.intScreenToDisplay,\n                  metaTopicScreens.length,\n                  randomScreens\n                )\n              );\n            }\n          } else {\n            // Generate unique random numbers\n            randomScreens = me.generateArrayOfNumbers(\n              metaTopicOptions.intScreenToDisplay,\n              metaTopicScreens.length\n            );\n          }\n\n          if (metaTopicOptions.booAllowRandomiseOrder) {\n            // Make sure that the screens will be in a random order\n            randomScreens = _.shuffle(randomScreens);\n          } else {\n            // Sort the array in ascending order\n            randomScreens.sort(function(a, b) {\n              return a - b;\n            });\n          }\n\n          // Copy the meta topic screens to our array\n          for (var k = 0; k < randomScreens.length; k++) {\n            newTopicScreens.push(metaTopicScreens[randomScreens[k]]);\n          }\n        }\n      }\n    }\n\n    // Add flag to dynamic screens\n    for (var count = 0; count < newTopicScreens.length; count++) {\n      newTopicScreens[count].isDynamicScreen = true;\n    }\n\n    return newTopicScreens;\n  },\n\n  /**\n   * Generate an array of random numbers\n   * @param {number} length\n   * @param {number} max\n   * @param {array} currArr\n   * @return {array} arr\n   */\n  generateArrayOfNumbers: function(length, max, currArr) {\n    var arr = [];\n\n    if (currArr && currArr.length) {\n      arr = arr.concat(currArr);\n    }\n\n    // Generate unique random numbers\n    while (arr.length < length) {\n      var value = Math.floor(Math.random() * max);\n      var found = false;\n      for (var i = 0; i < arr.length; i++) {\n        if (arr[i] == value) {\n          found = true;\n          break;\n        }\n      }\n      if (!found) {\n        arr.push(value);\n      }\n    }\n\n    return arr;\n  },\n\n  /**\n   * Restore the topic raw data\n   * @param {object} currentTopic\n   */\n  restoreTopicRawData: function(currentTopic) {\n    var me = this;\n\n    // Reset topic raw data\n    if (me.dynamicContentTopic) {\n      currentTopic.objRawTopicData.arrScreens[\n        currentTopic.objRawTopicData.arrScreens.length - 1\n      ].booCountAsFinalScreen = false;\n      currentTopic.objRawTopicData.arrScreens = [].concat(me.currentTopicRawData);\n      me.currentTopicRawData = null;\n    }\n  },\n\n  /**\n   * Store any incorrect question of every topic with a dynamic screen\n   * @param {object} unloadedTopic\n   */\n  storeIncorrectQuestions: function(unloadedTopic) {\n    var me = this;\n\n    // Create an array with all the incorrect screens\n    if (me.dynamicContentTopic) {\n      var systemVariables = VARIABLES_HOLDER._objSystemVariablesHash;\n\n      for (var i = 0; i < unloadedTopic.arrScreens.length; i++) {\n        var currScreenId = unloadedTopic.arrScreens[i].strObjID;\n\n        if (currScreenId in me.currentTopicMetaScreens) {\n          var dynamicScreenId = me.currentTopicMetaScreens[currScreenId];\n          var screenCorrectness =\n            systemVariables[VARIABLES_HOLDER._strScreenCorrectPrefix + '.' + currScreenId] || false;\n          screenCorrectness = screenCorrectness === 'true' ? true : false;\n\n          if (\n            dynamicScreenId in me.answeredViewedQuestions[unloadedTopic.strObjID] &&\n            !screenCorrectness\n          ) {\n            me.answeredViewedQuestions[unloadedTopic.strObjID][dynamicScreenId].push(currScreenId);\n          }\n        }\n      }\n    }\n\n    me.currentTopicMetaScreens = {};\n    me.dynamicContentTopic = false;\n  },\n\n  /**\n   * Return the referenced topics\n   * @return {array} me.metaTopicsRef\n   */\n  getReferencedMetaTopics: function() {\n    var me = this;\n    return me.metaTopicsRef;\n  },\n\n  getRedirectScreenId: function(screenId) {\n    var me = this;\n    var redirectData = false;\n\n    // Search for the screen in the redirects data.\n    if (me.redirects) {\n      _.each(me.redirects, function(data) {\n        if (\n          data &&\n          data.screen &&\n          data.screen === screenId &&\n          data.redirect\n        ) {\n          redirectData = data;\n        }\n      });\n    }\n\n    return redirectData;\n  },\n\n  /**\n   * Return boolean if screenId is a dynamic screen that's been replaced\n   * As we remove the screen from the topic data, we can't check the screen data itself. So this cache is kept\n   * @param {string} screenId\n   * @return {boolean}\n   */\n  isDynamicScreenPlaceholder: function(screenId) {\n    var me = this;\n    if (me.foundDynamicScreenPlaceholders[screenId]) {\n      return true;\n    }\n    return false;\n  }\n};\n"},function(n,e,t){t(0)(t(87))},function(n,e){n.exports="/* globals BOO_FAKE_PHP_PROCESS_VALUES_FOR_REVIEW, STR_PROJECT_NAME_FOR_REVIEW, TOPIC_MANAGER,\nSECTION_MANAGER, EM, $, STR_PRELOAD_TYPE_COURSE_LOAD, LOCALISER, CONTENT_TRACKING,\nANIMATOR_INTERFACE_2, OUTPUT_MODE_CHECKER, STR_DYNAMIC_TRANSITION_TYPE: true, CLOSE_METHOD,\nCLOSE_METHODS, COURSE_STRUCTURE_PARSER, VARIABLES_HOLDER, ErrorHandler, SCROLLING_MANAGER,\nBOO_USE_LOCAL_DATA, BOO_DYNAMIC_CONTINUOUS_SCROLLING, SCREEN_INTERACTIONS, STR_TRANSITION_TYPE,\nSTR_LOCAL_DATA_PATH, STR_PROJECT_SERVER_PATH, STR_PROJECT_ID, STR_FULL_SERVER_PATH,\nSTR_BASE_SERVER_PATH, BOO_USE_LOCAL_RESOURCES, STR_LOCAL_RESOURCES_PATH, LOADER,\nSTR_PROJECT_SERVER_PATH: true, STR_FULL_SERVER_PATH: true, _, PREVIEW_DATA */\n/**\n * @title Core\n * @description The object responsible for overall instatiation of the various other objects and a\n * convienient placeholder for certain global properties.\n *\n *\n * @author GoMo\n * @version 2.0 17/12/12\n */\n\nvar CORE = {\n  strObjID: 'The core',\n  strObjDescription:\n    'The object responsible for overall instatiation of the various other objects and a' +\n    'convienient placeholder for certain global properties.',\n\n  _objLoadElements: {\n    templates: false,\n    frameset: false,\n    contentpage: false,\n    coursestructure: false,\n    lmsdata: false,\n    videodata: false,\n    imagedata: false,\n    sharedimages: false,\n    sharedvideos: false,\n    sharedvariables: false\n  },\n\n  _booLastPageShown: false,\n  _objOptionalLoadElements: {},\n  _objReloadElements: {templates: false, contentpage: false},\n\n  _strPreviewPrimarySplitKey: '&',\n  _strPreviewSecondarySplitKey: '=',\n\n  _booLoadCompleted: false,\n  booFirstCourseScreenDisplayed: false,\n\n  _objContentFrameReference: null,\n  _objCurrDOM: null,\n\n  objCourseData: null,\n  objCurrCourseObject: null,\n\n  objResourceMetaData: null,\n\n  objMenuLoader: {},\n  objPrimaryTopicLoader: {},\n\n  booExitCalled: false,\n\n  previousScrollScreenLoad: null,\n\n  booCourseInteractedWith: false,\n\n  // Needs to be set by the editPreview class in editor ideally.\n  editorMode: true,\n\n  handleEvent_primeDOMReferences: function(_objWhatDOM) {\n    this._objLoadElements['frameset'] = true;\n    this._objCurrDOM = _objWhatDOM;\n\n    this._setDataPath();\n    this._setResourcesPath();\n\n    this.hideLoadingLayer();\n\n    if (BOO_FAKE_PHP_PROCESS_VALUES_FOR_REVIEW) {\n      this._objCurrDOM.title = STR_PROJECT_NAME_FOR_REVIEW;\n    }\n  },\n\n  handleEvent_refreshPage: function() {\n    var _objSearchHash = this.getSearchAsHash();\n\n    if (TOPIC_MANAGER.inTopic()) {\n      var _objCurrScreen = SCREEN_INTERACTIONS.getCurrentScreenData();\n      var _strCurrScreenID = _objCurrScreen.strObjID;\n      // window.location.search = \"screenID=\" + _strCurrScreenID;\n      _objSearchHash['screenID'] = _strCurrScreenID;\n      delete _objSearchHash['menuPage'];\n      delete _objSearchHash['entrySequence'];\n    } else {\n      var _strMenuID = SECTION_MANAGER.getCurrMenuID();\n      if (_strMenuID) {\n        // window.location.search = \"menuPage=\" + _strMenuID;\n        delete _objSearchHash['screenID'];\n        _objSearchHash['menuPage'] = _strMenuID;\n        delete _objSearchHash['entrySequence'];\n      } else {\n        // window.location.search = \"entrySequence=\" + this._intEntrySequenceIndex;\n        delete _objSearchHash['screenID'];\n        delete _objSearchHash['menuPage'];\n        _objSearchHash['entrySequence'] = this._intEntrySequenceIndex;\n      }\n    }\n\n    var _strNewSearchText = this.convertHashToSearchString(_objSearchHash);\n    window.location.search = _strNewSearchText;\n  },\n\n  handleEvent_startedTracking: function(_booLMSFound) {\n    this._objLoadElements['lmsdata'] = true;\n\n    var courseState = CONTENT_TRACKING.state.get('courseState');\n    if (courseState) {\n      _.each(this.objCourseData.arrContainers.length, function(value, key) {\n        if (courseState[value['strObjID']]) {\n          value['intTrackingState'] = courseState[value['strObjID']];\n        }\n      });\n      EM.trigger('updateTopicTracking');\n    }\n  },\n\n  handleEvent_frameLoaded: function(_objWhatFrameReference) {\n    if (!this._booLoadCompleted) {\n      this._objLoadElements['contentpage'] = true;\n    } else if (this.booReloadSequence) {\n      this._objReloadElements['contentpage'] = true;\n      EM.trigger('broadcastResourceMetaData', this.objResourceMetaData);\n      EM.trigger('broadcastExtrasData');\n      EM.trigger('broadcastGroupVariablesData', this.objSharedVariablesData);\n      this._setDataPath();\n      this._setResourcesPath();\n      this._testReloadElements();\n    } else {\n      this._objReloadElements['contentpage'] = true;\n      this._objReloadElements['templates'] = true;\n      EM.trigger('broadcastResourceMetaData', this.objResourceMetaData);\n      EM.trigger('broadcastExtrasData');\n      EM.trigger('broadcastGroupVariablesData', this.objSharedVariablesData);\n      this._setDataPath();\n      this._setResourcesPath();\n      this._testReloadElements();\n    }\n    // This should only be listened to by frameset level scripts; content page level scripts\n    // should listen for \"primeDOMReferences\".\n    EM.trigger('contentPageFrameReferenceUpdated', _objWhatFrameReference);\n    // REFACTOR NOTE: Pass through a dynamic variable.\n    EM.trigger('registerNavMenu');\n    this._objContentFrameReference = _objWhatFrameReference;\n  },\n\n  handleEvent_htmlTemplatesLoadedAndCollected: function() {\n    if (!this._booLoadCompleted) {\n      this._objLoadElements['templates'] = true;\n    } else {\n      // If the content reloads after the inital load sequence, we need to check the content and\n      // templates (if required) have both reloaded.\n      this._objReloadElements['templates'] = true;\n      this._testReloadElements();\n    }\n  },\n\n  handleEvent_courseStructureLoaded: function() {\n    this._objLoadElements['coursestructure'] = true;\n  },\n\n  handleEvent_resourceMetaDataLoaded: function() {\n    this._objLoadElements['imagedata'] = true;\n    this._objLoadElements['videodata'] = true;\n\n    EM.trigger('preloadImages', {\n      strPreloadType: STR_PRELOAD_TYPE_COURSE_LOAD,\n      strCallback: 'imagesPreloaded'\n    });\n  },\n\n  handleEvent_variablesDataLoaded: function() {\n    this._objLoadElements['variables'] = true;\n  },\n\n  handleEvent_imagesPreloaded: function() {\n    this._objLoadElements['imagepreload'] = true;\n  },\n\n  windowUnload: function() {\n    this.exit(true);\n  },\n\n  handleEvent_exit: function(_booFromUnload) {\n    if (PREVIEW_DATA.editorMode) {\n      var alertType = 'warning';\n      var title = 'Action disabled';\n      var message = 'The exit action is disabled in this view.';\n      var buttons = [\n        {\n          label: 'Ok',\n          type: 'primary',\n          action: function() {}\n        }\n      ];\n      gomo.alertManager.create(alertType, title, message, buttons);\n      return;\n    }\n    this.exit(_booFromUnload);\n  },\n\n  exit: function(unloading) {\n    if (!unloading) {\n      // var _booConfirmResult = window.confirm(\"Are you sure you wish to exit?\");\n      var _strExitMessage = LOCALISER.get('CORE_EXIT_MESSAGE');\n      var _booConfirmResult = window.confirm(_strExitMessage);\n      if (!_booConfirmResult) {\n        return;\n      }\n    }\n\n    // indicate exit has been called\n    this.booExitCalled = true;\n\n    // Sends the last screen left statement\n    gomo.topicManager.sendScreenChanged();\n\n    // Sends the last topic completed statement\n    gomo.topicManager.sendTopicCompleted();\n\n    var me = this;\n    var finalise = function() {\n      // Close the window if event has not been fired from the unload.\n      if (!unloading) {\n        me._executeCloseProcess();\n      }\n    };\n\n    // End the tracking\n    CONTENT_TRACKING.end(null, {\n      success: finalise,\n      error: finalise\n    });\n  },\n\n  exitProcessData: function(finalise) {\n    // indicate exit has been called\n    this.booExitCalled = true;\n\n    // Sends the last screen left statement\n    gomo.topicManager.sendScreenChanged();\n\n    // Sends the last topic completed statement\n    gomo.topicManager.sendTopicCompleted();\n\n    // End the tracking\n    CONTENT_TRACKING.end(null, {\n      success: finalise,\n      error: finalise\n    });\n  },\n\n  handleEvent_screenAnimationComplete: function() {\n    if (CORE && CORE.startupPopup) {\n      CORE.startupPopup();\n    }\n  },\n\n  handleEvent_firstCourseScreenDisplayed: function() {\n    this.booFirstCourseScreenDisplayed = true;\n    // Add a listener for a click anywhere in the course.\n    // This is to allow Chrome to autoplay background videos unmuted if the user has intereacted\n    // with the course.\n    $(document).click(CORE.setVideoSoundEnabled);\n  },\n\n  handleEvent_screenSizeChanged: function() {\n    if (typeof ANIMATOR_INTERFACE_2 != 'undefined') {\n      ANIMATOR_INTERFACE_2.setAnimationRegisters();\n    } else {\n      alert('ANIMATOR_INTERFACE_2 isn\\'t registered. This Extra is required by this version of ' +\n          'the Player.');\n    }\n  },\n\n  handleEvent_showExtentionWrapper: function() {\n    var _domExtentionWrapper = this._objCurrDOM.getElementById('extensionWrapperL');\n    _domExtentionWrapper.style.display = 'block';\n  },\n\n  handleEvent_hideExtentionWrapper: function() {\n    var _domExtentionWrapper = this._objCurrDOM.getElementById('extensionWrapperL');\n    _domExtentionWrapper.style.display = 'none';\n    var _domOuterPopupWrapper = this._objCurrDOM.getElementById('outerPopupWrapperL');\n    _domOuterPopupWrapper.style.transform = 'none';\n  },\n\n  init: function() {\n    EM.trigger('broadcastResourceMetaData', this.objResourceMetaData);\n\n    OUTPUT_MODE_CHECKER.checkOutputMode();\n    OUTPUT_MODE_CHECKER.pollScreenSize();\n\n    this._checkForLoadRequestFromURL();\n\n    var _objWhatFakedBookmarkData = {};\n    var _objSearchHash = this.getSearchAsHash();\n    // Boot order selection\n    if (_objSearchHash['screenID'] && _objSearchHash['screenID']!== 'false') {\n      _objWhatFakedBookmarkData.strTopicID = _objSearchHash['screenID'].split('s')[0];\n      _objWhatFakedBookmarkData.strScreenID = _objSearchHash['screenID'];\n    } else if (this.objCourseData.objCourseLaunchers.loadRequest) {\n      _objWhatFakedBookmarkData.strTopicID =\n        this.objCourseData.objCourseLaunchers.loadRequest.topicID;\n      _objWhatFakedBookmarkData.strScreenID =\n        this.objCourseData.objCourseLaunchers.loadRequest.screenID;\n    } else if (this.objCourseData.objCourseLaunchers.primaryTopic) {\n      _objWhatFakedBookmarkData.strTopicID =\n        this.objCourseData.objCourseLaunchers.primaryTopic.strTopicID;\n      _objWhatFakedBookmarkData.strScreenID =\n        this.objCourseData.objCourseLaunchers.primaryTopic.strScreenID;\n    } else if (this.objCourseData.objCourseLaunchers.menu) {\n      _objWhatFakedBookmarkData.strTopicID =\n        this.objCourseData.objCourseLaunchers.menu.strTopicID;\n      _objWhatFakedBookmarkData.strScreenID =\n        this.objCourseData.objCourseLaunchers.menu.strScreenID;\n    }\n\n    // Store a language code if found in the url of the course or parent frame. Used to force lang\n    // change if needed.\n    if (_objSearchHash['langCode']) {\n      _objWhatFakedBookmarkData.langCode = _objSearchHash['langCode'];\n    } else if (!PREVIEW_DATA || (PREVIEW_DATA && !PREVIEW_DATA.editorMode)) {\n      try {\n        var urlParams = new URLSearchParams(window.parent.location.search);\n        var langCode = urlParams.get('langCode');\n        if (langCode) {\n          _objWhatFakedBookmarkData.langCode = langCode;\n        }\n      } catch (err) {\n        console.log('URL search params not found.');\n      }\n    }\n\n    // Set Menu link\n    if (this.objCourseData.objCourseLaunchers.menu) {\n      this.objMenuLoader.strTopicID = this.objCourseData.objCourseLaunchers.menu.strTopicID;\n      this.objMenuLoader.strScreenID = this.objCourseData.objCourseLaunchers.menu.strScreenID;\n    }\n    // Set Primary Tpoic link\n    if (this.objCourseData.objCourseLaunchers.primaryTopic) {\n      this.objPrimaryTopicLoader.strTopicID =\n        this.objCourseData.objCourseLaunchers.primaryTopic.strTopicID;\n      this.objPrimaryTopicLoader.strScreenID =\n        this.objCourseData.objCourseLaunchers.primaryTopic.strScreenID;\n    }\n\n    this.initialCourseLoad(_objWhatFakedBookmarkData);\n  },\n\n  initialCourseLoad: function(_objWhatFakedBookmarkData) {\n    EM.trigger('preLoadTopicObject', _objWhatFakedBookmarkData);\n    EM.trigger('loadTopicObject', _objWhatFakedBookmarkData);\n    EM.trigger('postLoadTopicObject', _objWhatFakedBookmarkData);\n\n    var me = this;\n    $(window).bind('beforeunload', function() {\n      me.windowUnload.apply(me);\n    });\n\n    if (STR_DYNAMIC_TRANSITION_TYPE == null) {\n      STR_DYNAMIC_TRANSITION_TYPE = STR_TRANSITION_TYPE;\n    }\n  },\n\n  handleEvent_setCurrentCourseObject: function(_objWhatCourseObject) {\n    this.setCurrentCourseObject(_objWhatCourseObject);\n  },\n\n  addData: function(_objWhatData, _strWhatDataID) {\n    if (_objWhatData) {\n      switch (_strWhatDataID) {\n        case 'course_structure_json':\n          this.objCourseData = COURSE_STRUCTURE_PARSER.parseCourseData(_objWhatData);\n          this.setCurrentCourseObject(this.objCourseData);\n          EM.trigger('courseStructureLoaded');\n          break;\n        case 'resource_metadata_json':\n          this._setResourceMetaData(_objWhatData);\n          EM.trigger('resourceMetaDataLoaded');\n          break;\n        case 'variables_json':\n          this._setSharedVariablesData(_objWhatData);\n          EM.trigger('variablesDataLoaded');\n          break;\n      }\n    } else {\n      LOCALISER.l_alert('CORE_SPECIFIC_DATA_LOAD_FAILURE_ERROR', [_strWhatDataID]);\n    }\n  },\n\n  allFilesProcessed: function(_booSuccess) {\n    if (_booSuccess) {\n      // EM.trigger(\"courseStructureLoaded\");\n    } else {\n      // alert(\"ERROR: There where issue's loading some data, core.js, CORE.allFilesProcessed().\");\n      LOCALISER.l_alert('CORE_GENERAL_DATA_LOAD_FAILURE_ERROR');\n    }\n  },\n\n  setCurrentCourseObject: function(_objWhatCourseObject) {\n    this.objCurrCourseObject = _objWhatCourseObject;\n  },\n\n  getCurrentCourseObject: function() {\n    return this.objCurrCourseObject;\n  },\n\n  cloneObject: function(_objWhatTemplate) {\n    if (_objWhatTemplate === false) {\n      return false;\n    }\n\n    var _objClone = {};\n    for (var _strCurrIndex in _objWhatTemplate) {\n      if (Object.prototype.hasOwnProperty.call(_objWhatTemplate, _strCurrIndex)) {\n        // this._debug(\"_strPropType: \" + _strPropType, 1);\n        var _strPropType = typeof _objWhatTemplate[_strCurrIndex];\n        switch (_strPropType) {\n          case 'function':\n            this._debug(\n              'ERROR: TEMPLATE_DATA.cloneObject(), object property with a typeof == \\'function\\'' +\n                ' found. Do not pass complex objects with functions to this method.',\n              3\n            );\n            break;\n          case 'object':\n            if (_objWhatTemplate[_strCurrIndex] === null) {\n              _objClone[_strCurrIndex] = null;\n            } else if (_objWhatTemplate[_strCurrIndex] instanceof Array) {\n              _objClone[_strCurrIndex] = this.cloneArray(_objWhatTemplate[_strCurrIndex]);\n            } else {\n              _objClone[_strCurrIndex] = this.cloneObject(_objWhatTemplate[_strCurrIndex]);\n            }\n            break;\n          default:\n            _objClone[_strCurrIndex] = _objWhatTemplate[_strCurrIndex];\n            break;\n        }\n      }\n    }\n    return _objClone;\n  },\n\n  cloneArray: function(_arrWhatArray) {\n    var _arrClone = [];\n    var count = 0;\n    while (count < _arrWhatArray.length) {\n      var _strPropType = typeof _arrWhatArray[count];\n      switch (_strPropType) {\n        case 'function':\n          this._debug(\n            'ERROR: TEMPLATE_DATA.cloneArray(), array item with property typeof == \\'function\\'' +\n              'found. Do not pass complex objects with functions to this method.',\n            3\n          );\n          break;\n        case 'object':\n          if (_arrWhatArray[count] === null) {\n            _arrClone[count] = null;\n          } else if (_arrWhatArray[count] instanceof Array) {\n            _arrClone[count] = this.cloneArray(_arrWhatArray[count]);\n          } else {\n            _arrClone[count] = this.cloneObject(_arrWhatArray[count]);\n          }\n          break;\n        default:\n          _arrClone[count] = _arrWhatArray[count];\n          break;\n      }\n      count++;\n    }\n    return _arrClone;\n  },\n\n  searchObj: function(objToSearch, objOptions) {\n    var strSearchTerm = objOptions._strSearchTerm;\n    var strSearchValue = objOptions._strSearchValue;\n    var strReplace;\n    if (objOptions._strReplace) {\n      strReplace = objOptions._strReplace;\n    } else {\n      strReplace = false;\n    }\n\n    for (var key in objToSearch) {\n      if (objToSearch[key] instanceof Array) {\n        this.searchArr(objToSearch[key], objOptions);\n      } else if (typeof objToSearch[key] === 'object') {\n        this.searchObj(objToSearch[key], objOptions);\n      } else if (typeof objToSearch[key] === 'string') {\n        /* If the new key is also a match, do not replace. Some new keys can contain\n          * an old key such as - OLD : p001i01s1sub10 - NEW : p001i01s1sub101\n          */\n        if (key.indexOf(strSearchTerm) > -1\n        && objToSearch[key].indexOf(strSearchValue) > -1\n        && objToSearch[key].indexOf(strReplace) == -1) {\n          /* Replace if we have a replace string.\n          * Also if we are dealing with a file reference, do not do the replace.\n          */\n          if (strReplace && key != 'strSrc') {\n            objToSearch[key] = objToSearch[key].replace(strSearchValue, strReplace);\n          }\n          objOptions._arrResult.push(objToSearch);\n        }\n      }\n    }\n    return objOptions._arrResult;\n  },\n\n  getArrayOfItemsFromObjectAtKeyValue: function(objectToSearch, keyToMatch, valueToMatch) {\n    var returnItems = [];\n\n    var searchItem = function(searchNode) {\n      if (searchNode) {\n        if (searchNode.constructor === Object) {\n          for (var key in searchNode) {\n            if (key == keyToMatch && searchNode[key] == valueToMatch && !searchNode.cloned) {\n              // Some assets duplicate copy their actions to different objects so we don't want to\n              // repeat them\n              searchNode.cloned = true;\n              returnItems.push(searchNode);\n            } else {\n              searchItem(searchNode[key]);\n            }\n          }\n        } else if (searchNode.constructor === Array) {\n          var count = 0;\n          while (count < searchNode.length) {\n            searchItem(searchNode[count]);\n            count++;\n          }\n        }\n      }\n    };\n\n    searchItem(objectToSearch);\n    return returnItems;\n  },\n\n  searchArr: function(objToSearch, objOptions) {\n    var count = 0;\n    while (count < objToSearch.length) {\n      if (objToSearch[count] instanceof Array) {\n        this.searchArr(objToSearch[count], objOptions);\n      } else if (typeof objToSearch[count] === 'object') {\n        this.searchObj(objToSearch[count], objOptions);\n      }\n      count++;\n    }\n  },\n\n  componentToHex: function(_intWhatComponentValue) {\n    var _hexVersionOfValue = parseInt(_intWhatComponentValue).toString(16);\n    // Pad with leading 0 as required\n    return _hexVersionOfValue.length == 1 ? '0' + _hexVersionOfValue : _hexVersionOfValue;\n  },\n\n  rgbToHex: function(_intRed, _intGreen, _intBlue, _intAlpha) {\n    var _hexRed = this.componentToHex(_intRed);\n    var _hexGreen = this.componentToHex(_intGreen);\n    var _hexBlue = this.componentToHex(_intBlue);\n\n    if (_intAlpha || _intAlpha === 0) {\n      var _hexAlpha = this.componentToHex(_intAlpha);\n      return '#' + _hexAlpha + _hexRed + _hexGreen + _hexBlue;\n    } else {\n      return '#' + _hexRed + _hexGreen + _hexBlue;\n    }\n  },\n\n  hexToRgb: function(strHex) {\n    if (strHex.indexOf('#') == -1) {\n      return strHex;\n    }\n    // Expand shorthand form (e.g. \"03F\") to full form (e.g. \"0033FF\")\n    var shorthandRegex = /^#?([a-f\\d])([a-f\\d])([a-f\\d])$/i;\n    strHex = strHex.replace(shorthandRegex, function(m, r, g, b) {\n      return r + r + g + g + b + b;\n    });\n\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(strHex);\n\n    if (result == null) {\n      this._debug('Invalid Hex attempting to being converted. hexToRgb()');\n      return '';\n    }\n\n    var intRed = parseInt(result[1], 16);\n    var intGreen = parseInt(result[2], 16);\n    var intBlue = parseInt(result[3], 16);\n\n    var strResult = intRed + ',' + intGreen + ',' + intBlue;\n    return strResult;\n  },\n\n  _executeCloseProcess: function() {\n    if (!window['callPhantom']) {\n      // Check for a custom close...\n      if (\n        typeof CLOSE_METHOD !== 'undefined' &&\n        CLOSE_METHOD != '' &&\n        typeof CLOSE_METHODS[CLOSE_METHOD] !== undefined\n      ) {\n        if (CLOSE_METHODS[CLOSE_METHOD]()) {\n          return false;\n        }\n      }\n\n      window.opener = null;\n      top.window.close();\n      // Fallback close for script initiated load, if above didn't work - JH\n      open(location, '_self').close();\n      // Timeout 500 required as iOS will render the alert even if we have a 0 timeout on the alert\n      // after a successful close.\n      setTimeout(function() {\n        alert('We were unable to close your browser due to your browsers security protocols. ' +\n            'Please close manually.');\n      }, 500);\n    }\n  },\n\n  _checkForLoadRequestFromURL: function() {\n    var _objScreenURLData = this._checkForScreenURL();\n    if (_objScreenURLData) {\n      this.objCourseData.objCourseLaunchers.loadRequest = _objScreenURLData;\n    }\n  },\n\n  _checkForScreenURL: function() {\n    var _strLocationSearch = window.location.search;\n    _strLocationSearch = _strLocationSearch.slice(1, _strLocationSearch.length);\n    if (_strLocationSearch && _strLocationSearch != '') {\n      var _arrSearchSplit = _strLocationSearch.split(this._strPreviewPrimarySplitKey);\n      var count = 0;\n      var _objNameValuePairs = {strPreviewType: 'screen'};\n      while (count < _arrSearchSplit.length) {\n        var _arrNameValueSplit = _arrSearchSplit[count].split(this._strPreviewSecondarySplitKey);\n        _objNameValuePairs[_arrNameValueSplit[0]] = _arrNameValueSplit[1];\n        count++;\n      }\n\n      if ((_objNameValuePairs['topicID'] && _objNameValuePairs['topicID']!== 'false') &&\n      (_objNameValuePairs['screenID'] && _objNameValuePairs['screenID']!== 'false')) {\n        // If both are set, just return the bookmark\n        return _objNameValuePairs;\n      }\n      return false;\n    }\n    return false;\n  },\n\n  _setDataPath: function() {\n    // alert(\"BOO_USE_LOCAL_DATA: \" + BOO_USE_LOCAL_DATA)\n    if (BOO_USE_LOCAL_DATA) {\n      EM.trigger('setDataPath', STR_LOCAL_DATA_PATH);\n      // this._hideServerDataIcon();\n    } else {\n      STR_PROJECT_SERVER_PATH = 'projects/project_' + STR_PROJECT_ID + '/';\n      STR_FULL_SERVER_PATH = STR_BASE_SERVER_PATH + STR_PROJECT_SERVER_PATH;\n      EM.trigger('setDataPath', STR_FULL_SERVER_PATH);\n      this._showServerDataIcon();\n    }\n  },\n\n  _setResourcesPath: function() {\n    if (BOO_USE_LOCAL_RESOURCES) {\n      EM.trigger('setResourcesPath', STR_LOCAL_RESOURCES_PATH);\n    } else {\n      STR_PROJECT_SERVER_PATH = 'projects/project_' + STR_PROJECT_ID + '/';\n      STR_FULL_SERVER_PATH = STR_BASE_SERVER_PATH + STR_PROJECT_SERVER_PATH;\n      EM.trigger('setResourcesPath', STR_FULL_SERVER_PATH);\n    }\n  },\n\n  _setResourceMetaData: function(_objWhatData) {\n    this.objResourceMetaData = _objWhatData;\n  },\n\n  _setSharedVariablesData: function(_objWhatData) {\n    this.objSharedVariablesData = _objWhatData;\n  },\n\n  _testReloadElements: function() {\n    if (LOADER.booLoadSequenceComplete) {\n      for (var _strCurrLoadKey in this._objReloadElements) {\n        if (!this._objReloadElements[_strCurrLoadKey]) {\n          return false;\n        }\n      }\n      CORE.booReloadSequence = false;\n      this._objReloadElements['contentpage'] = false;\n      this._objReloadElements['templates'] = false;\n      EM.trigger('broadcastResourceMetaData', this.objResourceMetaData);\n      EM.trigger('broadcastGroupVariablesData', this.objSharedVariablesData);\n      EM.trigger('broadcastSharedResourceData', {'imageFiles': this.objSharedImageData});\n      // Not required currently\n      // EM.trigger(\"broadcastSharedVideoData\", this.objSharedVideoData);\n      this._reRenderCurrentItem();\n    }\n  },\n\n  getCourseItemById: function(_strWhatID, _objWhatParent) {\n    if (!_objWhatParent) {\n      _objWhatParent = this.objCourseData;\n    }\n\n    // If its the overall course that needs returning, handle that here\n    if (_objWhatParent.strObjID == _strWhatID) {\n      return _objWhatParent;\n    }\n\n    var count = 0;\n    while (count < _objWhatParent.arrContainers.length) {\n      var _objCurrItem = _objWhatParent.arrContainers[count];\n      if (_objCurrItem.strObjID == _strWhatID) {\n        return _objCurrItem;\n      }\n      if (_objCurrItem.arrContainers && _objCurrItem.arrContainers.length > 0) {\n        var _objRecursionResult = this.getCourseItemById(_strWhatID, _objCurrItem);\n        if (_objRecursionResult) {\n          return _objRecursionResult;\n        }\n      }\n      count++;\n    }\n    return false;\n  },\n\n  getElementsByClassName: function(_objWhatDOM, className, tag, elm) {\n    var getElementsByClassName;\n    if (_objWhatDOM) {\n      if (_objWhatDOM.getElementsByClassName) {\n        getElementsByClassName = function(_objWhatDOM, className, tag, elm) {\n          elm = elm || _objWhatDOM;\n          var elements = elm.getElementsByClassName(className);\n          var nodeName = tag ? new RegExp('\\\\b' + tag + '\\\\b', 'i') : null;\n          var returnElements = [];\n          var current;\n          for (var i = 0, il = elements.length; i < il; i += 1) {\n            current = elements[i];\n            if (!nodeName || nodeName.test(current.nodeName)) {\n              returnElements.push(current);\n            }\n          }\n          return returnElements;\n        };\n      } else if (_objWhatDOM.evaluate) {\n        getElementsByClassName = function(_objWhatDOM, className, tag, elm) {\n          tag = tag || '*';\n          elm = elm || _objWhatDOM;\n          className = className || '';\n          if (className == '') {\n            return [];\n          }\n          var classes = className.split(' ');\n          var classesToCheck = '';\n          var xhtmlNamespace = 'http://www.w3.org/1999/xhtml';\n          var namespaceResolver =\n            _objWhatDOM.documentElement.namespaceURI === xhtmlNamespace ? xhtmlNamespace : null;\n          var returnElements = [];\n          var elements;\n          var node;\n          for (var j = 0, jl = classes.length; j < jl; j += 1) {\n            classesToCheck += '[contains(concat(\\' \\', @class, \\' \\'), \\' ' + classes[j] + ' \\')]';\n          }\n          try {\n            elements = _objWhatDOM.evaluate(\n              './/' + tag + classesToCheck,\n              elm,\n              namespaceResolver,\n              0,\n              null\n            );\n          } catch (e) {\n            elements = _objWhatDOM.evaluate('.//' + tag + classesToCheck, elm, null, 0, null);\n            typeof ErrorHandler != 'undefined' && ErrorHandler['catch'] && ErrorHandler['catch'](e);\n          }\n          while ((node = elements.iterateNext())) {\n            returnElements.push(node);\n          }\n          return returnElements;\n        };\n      } else {\n        getElementsByClassName = function(_objWhatDOM, className, tag, elm) {\n          tag = tag || '*';\n          elm = elm || _objWhatDOM;\n          className = className || '';\n          if (className == '') {\n            return [];\n          }\n          var classes = className.split(' ');\n          var classesToCheck = [];\n          var elements = tag === '*' && elm.all ? elm.all : elm.getElementsByTagName(tag);\n          var current;\n          var returnElements = [];\n          var match;\n          for (var k = 0, kl = classes.length; k < kl; k += 1) {\n            classesToCheck.push(new RegExp('(^|\\\\s)' + classes[k] + '(\\\\s|$)'));\n          }\n          for (var l = 0, ll = elements.length; l < ll; l += 1) {\n            current = elements[l];\n            match = false;\n            for (var m = 0, ml = classesToCheck.length; m < ml; m += 1) {\n              match = classesToCheck[m].test(current.className);\n              if (!match) {\n                break;\n              }\n            }\n            if (match) {\n              returnElements.push(current);\n            }\n          }\n          return returnElements;\n        };\n      }\n      return getElementsByClassName(_objWhatDOM, className, tag, elm);\n    } else {\n      return false;\n    }\n  },\n\n  showLoadingLayer: function() {\n    var _domLoadingLayer = this._objCurrDOM.getElementById('initialLoadingL');\n    var _domScreenBackground = this._objCurrDOM.getElementById('screenHolderL');\n\n    if (_domLoadingLayer != false && _domLoadingLayer != null) {\n      _domScreenBackground.innerHTML = '';\n      _domLoadingLayer.style.display = 'block';\n      return true;\n    }\n  },\n\n  hideLoadingLayer: function() {\n    var _domLoadingLayer = this._objCurrDOM.getElementById('initialLoadingL');\n\n    if (_domLoadingLayer != false && _domLoadingLayer != null) {\n      _domLoadingLayer.style.display = 'none';\n      return true;\n    }\n  },\n\n  getSearchAsHash: function() {\n    var _objSearchHash = {};\n    var _strLocationSearchParams = document.location.search;\n    _strLocationSearchParams = _strLocationSearchParams.slice(1, _strLocationSearchParams.length);\n\n    if (_strLocationSearchParams != '') {\n      var _arrSearchSplit = _strLocationSearchParams.split('&');\n      var count = 0;\n      while (count < _arrSearchSplit.length) {\n        var _arrCurrSearchParamSplit = _arrSearchSplit[count].split('=');\n        _objSearchHash[_arrCurrSearchParamSplit[0]] = _arrCurrSearchParamSplit[1];\n        count++;\n      }\n    }\n    return _objSearchHash;\n  },\n\n  setCourseIncomplete: function(score, filter, response) {\n    var me = this;\n    filter = filter || '';\n    var statement = {\n      type: 'incomplete',\n      activity: {\n        id: me.objCourseData.strObjID,\n        title: me.objCourseData.objRawData.title,\n        type: 'course'\n      },\n      result: {\n        completion: true // Just course completion!\n      }\n    };\n    if (score !== false && score !== undefined) {\n      statement.result.score = {\n        min: 0,\n        max: 100,\n        raw: score\n      };\n    }\n    if (response !== undefined) {\n      statement.response = response;\n    }\n\n    // Track completion\n    CONTENT_TRACKING.interaction(statement, {\n      adapter: filter\n    });\n\n    if (!filter) {\n      // Update variables...\n      if (VARIABLES_HOLDER) {\n        // Update variables...\n        if (VARIABLES_HOLDER) {\n          if (CONTENT_TRACKING.initialised) {\n            // If content tracking is enabled\n            // then get the results from content tracking because they may apply certain rules...\n            CONTENT_TRACKING.getCompletionStatus({\n              success: function(ctStatus) {\n                if (!(ctStatus == 'completed' || ctStatus == 'passed' || ctStatus == 'failed')) {\n                  if (score !== undefined) {\n                    try {\n                      VARIABLES_HOLDER.updateCourseCompletionPercentage(score);\n                    } catch (e) {\n                      typeof ErrorHandler != 'undefined' &&\n                        ErrorHandler['catch'] &&\n                        ErrorHandler['catch'](e);\n                    }\n                  }\n                  try {\n                    VARIABLES_HOLDER.setCourseStarted();\n                  } catch (e) {\n                    typeof ErrorHandler != 'undefined' &&\n                      ErrorHandler['catch'] &&\n                      ErrorHandler['catch'](e);\n                  }\n                }\n              }\n            });\n          } else {\n            if (score !== undefined) {\n              try {\n                VARIABLES_HOLDER.updateCourseCompletionPercentage(score);\n              } catch (e) {\n                typeof ErrorHandler != 'undefined' &&\n                  ErrorHandler['catch'] &&\n                  ErrorHandler['catch'](e);\n              }\n            }\n            try {\n              VARIABLES_HOLDER.setCourseStarted();\n            } catch (e) {\n              typeof ErrorHandler != 'undefined' &&\n                ErrorHandler['catch'] &&\n                ErrorHandler['catch'](e);\n            }\n          }\n        }\n      }\n    }\n  },\n\n  setCourseCompleted: function(score, filter, response) {\n    var me = this;\n    filter = filter || '';\n    var statement = {\n      type: 'completed',\n      activity: {\n        id: me.objCourseData.strObjID,\n        title: me.objCourseData.objRawData.title,\n        type: 'course'\n      },\n      result: {\n        completion: true // Just course completion!\n      }\n    };\n    if (score !== false && score !== undefined) {\n      statement.result.score = {\n        min: 0,\n        max: 100,\n        raw: score\n      };\n    }\n    if (response !== undefined) {\n      statement.response = response;\n    }\n\n    // Track completion\n    CONTENT_TRACKING.interaction(statement, {\n      adapter: filter\n    });\n\n    if (!filter) {\n      // Update variables...\n      if (VARIABLES_HOLDER) {\n        if (CONTENT_TRACKING.initialised) {\n          // If content tracking is enabled\n          // then get the results from content tracking because they may apply certain rules...\n          CONTENT_TRACKING.getCompletionStatus({\n            success: function(ctStatus) {\n              if (ctStatus == 'completed') {\n                if (score !== undefined) {\n                  try {\n                    VARIABLES_HOLDER.updateCourseCompletionPercentage(score);\n                  } catch (e) {\n                    typeof ErrorHandler != 'undefined' &&\n                      ErrorHandler['catch'] &&\n                      ErrorHandler['catch'](e);\n                  }\n                }\n                try {\n                  VARIABLES_HOLDER.setCourseCompleted();\n                } catch (e) {\n                  typeof ErrorHandler != 'undefined' &&\n                    ErrorHandler['catch'] &&\n                    ErrorHandler['catch'](e);\n                }\n              }\n            }\n          });\n        } else {\n          if (score !== undefined) {\n            try {\n              VARIABLES_HOLDER.updateCourseCompletionPercentage(score);\n            } catch (e) {\n              typeof ErrorHandler != 'undefined' &&\n                ErrorHandler['catch'] &&\n                ErrorHandler['catch'](e);\n            }\n          }\n          try {\n            VARIABLES_HOLDER.setCourseCompleted();\n          } catch (e) {\n            typeof ErrorHandler != 'undefined' &&\n              ErrorHandler['catch'] &&\n              ErrorHandler['catch'](e);\n          }\n        }\n      }\n    }\n  },\n\n  setCourseScore: function(score) {\n    // Track completion\n    CONTENT_TRACKING.score({\n      min: 0,\n      max: 100,\n      raw: score\n    });\n\n    // Update variables...\n    if (VARIABLES_HOLDER) {\n      try {\n        VARIABLES_HOLDER.updateCourseScore(score);\n      } catch (e) {\n        typeof ErrorHandler != 'undefined' && ErrorHandler['catch'] && ErrorHandler['catch'](e);\n      }\n    }\n  },\n\n  setCoursePassFail: function(passed, score, response) {\n    var me = this;\n    var statement = {\n      type: passed ? 'passed' : 'failed',\n      activity: {\n        id: me.objCourseData.strObjID,\n        title: me.objCourseData.objRawData.title,\n        type: 'course'\n      },\n      result: {\n        success: passed // Indicate pass/fail\n      }\n    };\n    if (score !== false && score !== undefined) {\n      statement.result.score = {\n        min: 0,\n        max: 100,\n        raw: score\n      };\n    }\n    if (response !== undefined) {\n      statement.response = response;\n    }\n\n    // Track completion\n    CONTENT_TRACKING.interaction(statement);\n\n    // Update variables...\n    if (VARIABLES_HOLDER) {\n      if (CONTENT_TRACKING.initialised) {\n        // If content tracking is enabled\n        // then get the results from content tracking because they may apply certain rules...\n        CONTENT_TRACKING.getScore({\n          success: function(ctScore) {\n            try {\n              VARIABLES_HOLDER.updateCourseScore(ctScore);\n            } catch (e) {\n              typeof ErrorHandler != 'undefined' &&\n                ErrorHandler['catch'] &&\n                ErrorHandler['catch'](e);\n            }\n          }\n        });\n        CONTENT_TRACKING.getCompletionStatus({\n          success: function(ctStatus) {\n            if (ctStatus == 'passed' || ctStatus == 'failed') {\n              try {\n                VARIABLES_HOLDER.setCoursePassFail(ctStatus == 'passed');\n              } catch (e) {\n                typeof ErrorHandler != 'undefined' &&\n                  ErrorHandler['catch'] &&\n                  ErrorHandler['catch'](e);\n              }\n            }\n          }\n        });\n      } else {\n        try {\n          VARIABLES_HOLDER.setCoursePassFail(passed);\n          VARIABLES_HOLDER.updateCourseScore(score);\n        } catch (e) {\n          typeof ErrorHandler != 'undefined' && ErrorHandler['catch'] && ErrorHandler['catch'](e);\n        }\n      }\n    }\n\n    CONTENT_TRACKING.saveState();\n  },\n\n  convertHashToSearchString: function(_objWhatSearchHash) {\n    var _arrSearchParams = [];\n    for (var _strCurrKey in _objWhatSearchHash) {\n      if (Object.prototype.hasOwnProperty.call(_objWhatSearchHash, _strCurrKey)) {\n        _arrSearchParams.push(_strCurrKey + '=' + _objWhatSearchHash[_strCurrKey]);\n      }\n    }\n    var _strNewSearchText = _arrSearchParams.join('&');\n    return _strNewSearchText;\n  },\n\n  /**\n  * Register the user has clicked anywhere so we can un-mute all background videos.\n  */\n  setVideoSoundEnabled: function() {\n    // Remove the click event as we only need to handle it once.\n    $(document).off('click', CORE.setVideoSoundEnabled);\n    CORE.booCourseInteractedWith = true;\n    // Unmute any background videos that may be playing muted.\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n      $('.screenLevelBackgroundVideo').prop('muted', false);\n    } else {\n      $('#backgroundVideo').prop('muted', false);\n    }\n  },\n\n  _hideServerDataIcon: function() {\n    var _domServerIcon = this._objCurrDOM.getElementById('remoteServerIconL');\n    _domServerIcon.style.display = 'none';\n  },\n\n  _showServerDataIcon: function() {\n    var _domServerIcon = this._objCurrDOM.getElementById('remoteServerIconL');\n    _domServerIcon.style.display = 'block';\n  },\n\n  _debug: function(_strMessage) {\n    if (window['console'] && window.console.log && this._booDebug) {\n      console.log('CORE: ' + _strMessage);\n    }\n  },\n\n  handleEvent_loadTopicObject: function(loadData) {\n    SCROLLING_MANAGER.pollScreenScrolling(loadData);\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n      EM.trigger('disableSwiping');\n    }\n  }\n};\n\nEM.register(CORE);\n"},function(n,e,t){t(0)(t(89))},function(n,e){n.exports="/* globals BOO_DYNAMIC_CONTINUOUS_SCROLLING, OUTPUT_MODE_CHECKER, $, ISCROLL_INTERFACE */\n/* globals SCREEN_INTERACTIONS, TOPIC_MANAGER, EM */\n/**\n * @title Scrolling Manager\n * @description Handle Scrolling needs/requests and the different scrolling libraries that gomo\n * uses.\n *\n * @author GoMo\n * @version 2.0 29/09/16\n */\n\nvar SCROLLING_MANAGER = {\n  enabledScreenSwitchFromScrolling: true,\n  scrollingCurrentScreens: [],\n  scrollingScreenCenterPosition: 0,\n  findCenterPosition: true, // useful to scroll to a set position, not finding the center screen\n  viewPortHeight: 0,\n  savedScrollPosition: 0,\n  previousScrollPosition: 0,\n  minYPosition: null,\n  maxYPosition: null,\n  postRenderTriggered: {},\n  pollingPaused: false,\n\n  disableCenterPosition: function() {\n    this.findCenterPosition = false;\n  },\n\n  enableCenterPosition: function() {\n    this.findCenterPosition = true;\n  },\n\n  // Enable screen loading when scrolling the screen in continuous scroll mode\n  enableScreenSwitchFromScrolling: function() {\n    this.enabledScreenSwitchFromScrolling = true;\n  },\n  // Disable screen loading when scrolling the screen in continuous scroll mode\n  disableScreenSwitchFromScrolling: function() {\n    this.enabledScreenSwitchFromScrolling = false;\n  },\n\n  enablePolling: function() {\n    // Give the browser time to finish it's rendering process before re-enabling polling\n    setTimeout(function() {\n      SCROLLING_MANAGER.pollingPaused = false;\n    }, 0);\n  },\n\n  disablePolling: function() {\n    this.pollingPaused = true;\n  },\n\n  // Save the current scroll position\n  saveScrollPosition: function(screenScrollerId) {\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n      // iScroll position\n      if (OUTPUT_MODE_CHECKER.applyScrolling()) {\n        this.savedScrollPosition = $('#contentWrapperInnerL').css('transform');\n      } else {\n        // top scroll position\n        this.savedScrollPosition = $('#contentWrapperL').scrollTop();\n      }\n    } else {\n      if (OUTPUT_MODE_CHECKER.applyScrolling() && screenScrollerId) {\n        this.savedScrollPosition = $('#' + screenScrollerId + ' .scrollWrapperC').css(\n          'transform'\n        );\n      }\n    }\n  },\n\n  // Allow user defined scroll position\n  setScrollPosition: function(scrollPosition) {\n    this.savedScrollPosition = scrollPosition.toString();\n  },\n\n  // Restore the scroll position previously saved\n  restoreScrollPosition: function(screenScrollerId, duration) {\n    duration = duration || 0;\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n      // iScroll position\n      var yPosition = 0;\n      if (OUTPUT_MODE_CHECKER.applyScrolling()) {\n        if (this.savedScrollPosition !== 0) {\n          if (this.savedScrollPosition.indexOf(',') !== -1) {\n            yPosition = parseInt(this.savedScrollPosition.split(',')[5]);\n          } else {\n            yPosition = parseInt(this.savedScrollPosition);\n          }\n          var xPosition = 0;\n          var elementId = 'contentWrapperL';\n          // Set the position with iscroll interface so iscroll is aware of the update\n          ISCROLL_INTERFACE.scrollToPosition(elementId, xPosition, yPosition, duration);\n        }\n      } else {\n        if (gomo.outputChecker.animationEnabled) {\n          // top scroll position\n          $('#contentWrapperL').animate({\n            scrollTop: this.savedScrollPosition\n          },\n          {\n            duration: 350\n          });\n        } else {\n          $('#contentWrapperL').scrollTop(this.savedScrollPosition);\n        }\n      }\n    } else if (OUTPUT_MODE_CHECKER.applyScrolling() && screenScrollerId) {\n      if (this.savedScrollPosition !== 0) {\n        yPosition = parseInt(this.savedScrollPosition.split(',')[5]);\n        // Set the position with iscroll\n        ISCROLL_INTERFACE.scrollToPosition(screenScrollerId, 0, yPosition, duration);\n      }\n    }\n  },\n\n  // Return the scroll Position (top position)\n  getScrollPosition: function() {\n    var scrollPosition = null;\n\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n      // iScroll position\n      if (OUTPUT_MODE_CHECKER.applyScrolling()) {\n        scrollPosition = Math.abs(\n          parseInt(\n            $('#contentWrapperInnerL')\n              .css('transform')\n              .split(',')[5]\n          )\n        );\n      } else {\n        // top scroll position\n        scrollPosition = $('#contentWrapperL').scrollTop();\n      }\n    }\n\n    return scrollPosition;\n  },\n\n  getCurrentScreenScrollerId: function() {\n    var screenScrollerId;\n    var screenId;\n    var currentScreenData = SCREEN_INTERACTIONS.getCurrentScreenData();\n\n    if (currentScreenData && currentScreenData.strObjID) {\n      screenId = SCREEN_INTERACTIONS.getCurrentScreenData().strObjID;\n    }\n    var screenDomId = SCREEN_INTERACTIONS.getScreenWrapperID(screenId);\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n      screenScrollerId = 'contentWrapperL';\n    } else {\n      screenScrollerId = ISCROLL_INTERFACE.getFirstScrollerChild(screenDomId);\n    }\n\n    return screenScrollerId;\n  },\n\n  // setMinYPosition\n  setMinYPosition: function(position) {\n    if (position || position == 0) {\n      this.minYPosition = position;\n    } else {\n      this.minYPosition = null;\n    }\n\n    // If we're not scrolled to the min position, scroll us down\n    var scrollPosition = this.getScrollPosition();\n    // Make sure both positions are valid\n    if (scrollPosition !== null && this.minYPosition !== null) {\n      if (scrollPosition < this.minYPosition) {\n        var xPosition = 0;\n        var elementId = 'contentWrapperL';\n        var duration = 500;\n        ISCROLL_INTERFACE.scrollToPosition(\n          elementId,\n          xPosition,\n          SCROLLING_MANAGER.minYPosition * -1,\n          duration\n        );\n      }\n    }\n  },\n\n  // setMaxYPosition\n  setMaxYPosition: function(position) {\n    if (position || position == 0) {\n      this.maxYPosition = position;\n    } else {\n      this.maxYPosition = null;\n    }\n\n    // If we've scrolled passed the max position, scroll us back\n    var scrollPosition = this.getScrollPosition();\n    // Make sure both positions are valid\n    if (scrollPosition !== null && this.maxYPosition !== null) {\n      if (scrollPosition > this.maxYPosition) {\n        var xPosition = 0;\n        var elementId = 'contentWrapperL';\n        var duration = 500;\n        ISCROLL_INTERFACE.scrollToPosition(\n          elementId,\n          xPosition,\n          (SCROLLING_MANAGER.maxYPosition - 50) * -1,\n          duration\n        );\n      }\n    }\n  },\n\n  // Trigger scrolling on topic data update or render output change\n  pollScreenScrolling: function(loadData, forced) {\n    // Desktop doesn't use iScroll so can continue to use this method for screenScrolling polling\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n      this.previousScrollScreenLoad = SCREEN_INTERACTIONS.getCurrentScreenData().strObjID;\n\n      var topicData = TOPIC_MANAGER.getCurrentTopic();\n      // make sure we are not staying in the same topic or if we know we need to rebuild - forced\n      if ((loadData && loadData.strTopicID == topicData.strObjID) || forced) {\n        this.setCurrentScreens(topicData);\n      }\n\n      this.viewPortHeight = $('#contentWrapperL').height();\n      SCROLLING_MANAGER.scrollingScreenCenterPosition = this.viewPortHeight / 2;\n\n      if (!OUTPUT_MODE_CHECKER.applyScrolling()) {\n        this.postRenderTriggered = {};\n        SCROLLING_MANAGER.pollBrowserScroll();\n      } else {\n        // Force the screen to stay in scrollTop position 0 for iscroll devices, regardless of\n        // elements requesting focus\n        $('#contentWrapperL').scroll(function() {\n          $('#contentWrapperL').scrollTop(0);\n        });\n      }\n    } else if (OUTPUT_MODE_CHECKER.isSmartPhone()) {\n      // Force the screen to stay in scrollTop position 0 for iscroll devices, regardless of\n      // elements requesting focus\n      $('.linearScreenWrapperC').scroll(function() {\n        $(this).scrollTop(0);\n      });\n    }\n  },\n\n  // Figure out the current screen based off of the browsers scroll position\n  pollBrowserScroll: function() {\n    // Use the browsers scroller to determine the current screen\n    $('#contentWrapperL').on('scroll DOMMouseScroll', function() {\n      if (SCROLLING_MANAGER.pollingPaused) {\n        return;\n      }\n      var browserScrollCheck = function(scrollPosition, maxScrollPosition) {\n        SCROLLING_MANAGER.previousScrollPosition = scrollPosition;\n\n        // Don't save the position if the scrolling screen loader is locked\n        if (SCROLLING_MANAGER.enabledScreenSwitchFromScrolling) {\n          SCROLLING_MANAGER.savedScrollPosition = scrollPosition;\n        }\n\n        // Check if we've reached the bottom of the scroll area (the last screen)\n        if (scrollPosition >= maxScrollPosition) {\n          var finalScreenIndex = SCROLLING_MANAGER.scrollingCurrentScreens.length - 1;\n          SCROLLING_MANAGER.loadScreenFromScrolling(\n            SCROLLING_MANAGER.scrollingCurrentScreens[finalScreenIndex].screenId\n          );\n        } else if (scrollPosition == 0) {\n          SCROLLING_MANAGER.loadScreenFromScrolling(\n            SCROLLING_MANAGER.scrollingCurrentScreens[0].screenId\n          );\n        } else {\n          var wrapperPosition = (SCROLLING_MANAGER.findCenterPosition) ?\n            scrollPosition + SCROLLING_MANAGER.scrollingScreenCenterPosition : scrollPosition;\n          var countScreens = 0;\n          while (countScreens < SCROLLING_MANAGER.scrollingCurrentScreens.length) {\n            var screenId = SCROLLING_MANAGER.scrollingCurrentScreens[countScreens].screenId;\n            var screenPositionTop =\n              SCROLLING_MANAGER.scrollingCurrentScreens[countScreens].screenDom.offsetTop;\n            var screenPositionBottom =\n              screenPositionTop +\n              SCROLLING_MANAGER.scrollingCurrentScreens[countScreens].screenDom.offsetHeight;\n\n            // If the screen is not in the center but IS visible, trigger post render actions\n            if (!(screenId in SCROLLING_MANAGER.postRenderTriggered)\n              && screenPositionTop <= SCROLLING_MANAGER.viewPortHeight + scrollPosition\n              && screenPositionTop >= scrollPosition) {\n              SCROLLING_MANAGER.postRenderScreenFromScrolling(\n                screenId\n              );\n            }\n\n            // If the screen is in the centre of the viewport, load the screen\n            if (wrapperPosition >= screenPositionTop && wrapperPosition <= screenPositionBottom) {\n              SCROLLING_MANAGER.loadScreenFromScrolling(\n                screenId\n              );\n            }\n\n            countScreens++;\n          }\n        }\n      };\n\n      var scrollPosition = $('#contentWrapperL').scrollTop();\n      var scrollAreaHeight = $('#contentWrapperInnerL').height() - SCROLLING_MANAGER.viewPortHeight;\n\n      /*\n       * If the content wrapper is less than or equal to the screen size, double check it's not\n       * set to 100% by checking all screen heights.\n       * The Parallax asset is one asset that will set the contentWrapperInnerL to 100% and break\n       * the max height check for scrolling.\n       */\n      if (scrollAreaHeight <= 0) {\n        var screenBasedScrollAreaHeight = 0;\n\n        $('#contentWrapperInnerL .linearScreenWrapperC').each(function() {\n          var currentElement = $(this);\n\n          screenBasedScrollAreaHeight += currentElement.height();\n        });\n\n        scrollAreaHeight = screenBasedScrollAreaHeight - SCROLLING_MANAGER.viewPortHeight;\n      }\n\n      /* If the scroll position has jumped greater than 10 pixels to 0 (top), then assume\n       * rendering is doing something and has collapsed the element. Wait for it to complete.\n       */\n      if (scrollPosition == 0 && SCROLLING_MANAGER.previousScrollPosition > 10) {\n        setTimeout(function() {\n          browserScrollCheck(scrollPosition, scrollAreaHeight);\n        }, 0);\n      } else {\n        browserScrollCheck(scrollPosition, scrollAreaHeight);\n      }\n    });\n  },\n\n  // Figure out the current screen based off of the iscroll position\n  pollIscrollScrolling: function() {\n    // Use iScroll screen check only in coontinuous scrolling mode\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING && OUTPUT_MODE_CHECKER.applyScrolling()) {\n      var browserScrollCheck = function(scrollPosition, maxScrollPosition) {\n        // If we're outside a custom threshold, return to the area\n        if (SCROLLING_MANAGER.maxYPosition || SCROLLING_MANAGER.minYPosition) {\n          var scrollPositionInt = SCROLLING_MANAGER.getScrollPosition();\n          var xPosition = 0;\n          var elementId = 'contentWrapperL';\n          var duration = 500;\n          if (scrollPositionInt > SCROLLING_MANAGER.maxYPosition) {\n            ISCROLL_INTERFACE.scrollToPosition(\n              elementId,\n              xPosition,\n              (SCROLLING_MANAGER.maxYPosition - 50) * -1,\n              duration\n            );\n          } else if (scrollPositionInt < SCROLLING_MANAGER.minYPosition) {\n            ISCROLL_INTERFACE.scrollToPosition(\n              elementId,\n              xPosition,\n              SCROLLING_MANAGER.minYPosition * -1,\n              duration\n            );\n          }\n        }\n\n        SCROLLING_MANAGER.previousScrollPosition = scrollPosition;\n\n        // Don't save the position if the scrolling screen loader is locked\n        if (SCROLLING_MANAGER.enabledScreenSwitchFromScrolling) {\n          SCROLLING_MANAGER.savedScrollPosition = scrollPosition;\n        }\n\n        var yPosition = Math.abs(parseInt(scrollPosition.split(',')[5]));\n\n        // Check if we've reached the bottom of the scroll area (the last screen)\n        if (yPosition >= maxScrollPosition) {\n          var finalScreenIndex = SCROLLING_MANAGER.scrollingCurrentScreens.length - 1;\n          SCROLLING_MANAGER.loadScreenFromScrolling(\n            SCROLLING_MANAGER.scrollingCurrentScreens[finalScreenIndex].screenId\n          );\n        } else if (yPosition == 0) {\n          SCROLLING_MANAGER.loadScreenFromScrolling(\n            SCROLLING_MANAGER.scrollingCurrentScreens[0].screenId\n          );\n        } else {\n          // Reduce dom calls by content poisiton\n          var wrapperPosition = (SCROLLING_MANAGER.findCenterPosition) ?\n            yPosition + SCROLLING_MANAGER.scrollingScreenCenterPosition : yPosition;\n\n          while (countScreens < SCROLLING_MANAGER.scrollingCurrentScreens.length) {\n            var screenId = SCROLLING_MANAGER.scrollingCurrentScreens[countScreens].screenId;\n            var screenPositionTop =\n              SCROLLING_MANAGER.scrollingCurrentScreens[countScreens].screenDom.offsetTop;\n            var screenPositionBottom =\n              screenPositionTop +\n              SCROLLING_MANAGER.scrollingCurrentScreens[countScreens].screenDom.offsetHeight;\n\n              // If the screen is not in the center but IS visible, trigger post render actions\n            if (!(screenId in SCROLLING_MANAGER.postRenderTriggered)\n            && screenPositionTop <= SCROLLING_MANAGER.viewPortHeight + yPosition\n            && screenPositionTop >= yPosition) {\n              SCROLLING_MANAGER.postRenderScreenFromScrolling(\n                screenId\n              );\n            }\n\n            // If the screen is in the centre of the viewport, load the screen\n            if (wrapperPosition >= screenPositionTop && wrapperPosition <= screenPositionBottom) {\n              SCROLLING_MANAGER.loadScreenFromScrolling(\n                screenId\n              );\n            }\n\n            // If the screen is not in the center but now visible, trigger post render actions\n\n            countScreens++;\n          }\n        }\n      };\n\n      var countScreens = 0;\n      var scrollPosition = $('#contentWrapperInnerL').css('transform');\n      var scrollAreaHeight = $('#contentWrapperInnerL').height() - SCROLLING_MANAGER.viewPortHeight;\n\n      /*\n       * If the content wrapper is less than or equal to the screen size, double check it's not\n       * set to 100% by checking all screen heights.\n       * The Parallax asset is one asset that will set the contentWrapperInnerL to 100% and break\n       * the max height check for scrolling.\n       */\n      if (scrollAreaHeight <= 0) {\n        var screenBasedScrollAreaHeight = 0;\n\n        $('#contentWrapperInnerL .linearScreenWrapperC').each(function() {\n          var currentElement = $(this);\n\n          screenBasedScrollAreaHeight += currentElement.height();\n        });\n\n        scrollAreaHeight = screenBasedScrollAreaHeight - SCROLLING_MANAGER.viewPortHeight;\n      }\n\n      /* If the scroll position has switched to none, then assume rendering is doing something\n       *  and has collapsed the element. Wait for it to complete\n       */\n      if (\n        (scrollPosition == 0 || scrollPosition == 'none') &&\n        (typeof SCROLLING_MANAGER.previousScrollPosition !== 'undefined' ||\n          SCROLLING_MANAGER.previousScrollPosition !== null)\n      ) {\n        setTimeout(function() {\n          browserScrollCheck(scrollPosition, scrollAreaHeight);\n        }, 0);\n      } else {\n        browserScrollCheck(scrollPosition, scrollAreaHeight);\n      }\n    }\n  },\n\n  // Load a new screen based on scroll or iScroll position\n  loadScreenFromScrolling: function(screenToLoad, triggeredFromGomo) {\n    if (this.enabledScreenSwitchFromScrolling) {\n      if (SCROLLING_MANAGER.previousScrollScreenLoad != screenToLoad) {\n        SCROLLING_MANAGER.previousScrollScreenLoad = screenToLoad;\n        // We don't want to change position on the screen, just load the data.\n        var options = {\n          scrollTo: false,\n          triggeredFromGomo: triggeredFromGomo || false,\n          origin: 'scrolling_manager',\n          counter: 10\n        };\n\n        var actionData = {};\n\n        var actions = [\n          {\n            objParameters: {target_id: screenToLoad},\n            strActionGroup: 'navigation',\n            strObjectType: 'action',\n            strType: 'internal_link'\n          }\n        ];\n\n        actionData.objActions = actions;\n        actionData.objOptionalExtraData = options;\n\n        EM.trigger('processActions', actionData);\n      }\n    }\n  },\n\n  postRenderScreenFromScrolling: function(screenId) {\n    SCROLLING_MANAGER.postRenderTriggered[screenId] = true;\n    SCREEN_INTERACTIONS._showScreensPostRenderAssets(screenId);\n  },\n\n  getVisibleScreenList: function() {\n    var topicData = TOPIC_MANAGER.getCurrentTopic();\n    var viewportTop = $('#contentWrapperL')[0].scrollTop;\n    var viewportHeight = $('#contentWrapperL')[0].offsetHeight;\n    var i = 0;\n    var visibleScreens = [];\n\n    this.setCurrentScreens(topicData);\n\n    while (i < SCROLLING_MANAGER.scrollingCurrentScreens.length) {\n      var currScreen = SCROLLING_MANAGER.scrollingCurrentScreens[i];\n      var screenCenter = currScreen.screenDom.offsetTop + currScreen.screenDom.offsetHeight / 2;\n      if (screenCenter >= viewportTop && screenCenter <= viewportHeight + viewportTop) {\n        visibleScreens.push(currScreen.screenId);\n      }\n      i++;\n    }\n    return visibleScreens;\n  },\n\n  setCurrentScreens: function(topicData) {\n    var screensData = topicData.arrScreens;\n    var count = 0;\n\n    // Clear current screens so changing topics works.\n    SCROLLING_MANAGER.scrollingCurrentScreens = [];\n\n    // Store all current screens in this topic.\n    while (count < screensData.length) {\n      SCROLLING_MANAGER.scrollingCurrentScreens.push({\n        screenDom: SCREEN_INTERACTIONS.getScreenWrapper(screensData[count].strObjID),\n        screenId: screensData[count].strObjID\n      });\n      count++;\n    }\n  }\n};\n"},function(n,e,t){t(0)(t(91))},function(n,e){n.exports="/* global ContentTrackingState, ErrorHandler, USER_REGISTRATION_EXTRA, _, ALERT_TRACKING_ERRORS */\n/* global CONTENT_TRACKING, OUTPUT_MODE_CHECKER, VARIABLES_HOLDER, ENABLE_VISIT_HISTORY */\n\n/**\n* ContentTracking API\n* @author Adam Fox\n*/\n\nvar global = this;\n\n// Until we have require or something similar, ensure we these variables are available\nglobal.GOMO_SCORM = global.GOMO_SCORM || null;\nglobal.GOMO_TINCAN = global.GOMO_TINCAN || null;\nglobal.GOMO_GOOGLE_ANALYTICS = global.GOMO_GOOGLE_ANALYTICS || null;\n\n// Again, until we have require of similar, hacky way of keying the adpaters\nglobal.CONTENT_TRACKING_ADAPTERS = {\n  'scorm': {\n    adapter: global.GOMO_SCORM\n  },\n  'tincan': {\n    adapter: global.GOMO_TINCAN\n  },\n  'google': {\n    adapter: global.GOMO_GOOGLE_ANALYTICS\n  }\n};\n\nglobal.CONTENT_TRACKING = (function($, Adapters) {\n  /**\n   * ContentTracking\n   * @constructor\n   */\n  function ContentTracking() {\n    // empty\n  }\n\n  /**\n   * Extend the ContentTracking\n   */\n  ContentTracking.prototype = {\n\n    initialised: false,\n    active: false,\n    adapters: null,\n    state: new ContentTrackingState(),\n    pollingInterval: null,\n    lastSave: null,\n    config: null,\n    user: null,\n    queue: [],\n    courseId: 0,\n    alertErrors: true,\n\n    /*\n     * Initialise all the adapters\n     */\n    init: function(config, settings) {\n      var me = this;\n      var adapters = {};\n      var initialisedAny = false;\n      var i;\n\n      me.log('Init');\n      me.config = config;\n\n      // Loop through all store configs and\n      // group them per adapter.\n      if (config && config.enabled) {\n        if (config.stores && config.stores.length) {\n          // Group them per adapter...\n          for (i=0; i<config.stores.length; i++) {\n            var storeDefinition = config.stores[i];\n            if (storeDefinition) {\n              adapters[storeDefinition.adapter] =\n                adapters[storeDefinition.adapter] || {stores: [], instance: null};\n              adapters[storeDefinition.adapter].stores.push(storeDefinition);\n            }\n          }\n          // Now initialise each adapter\n          for (i in adapters) {\n            if (typeof Adapters[i].adapter !== 'undefined') {\n              // Pass the array of stores and leave that for the adapter to sort!\n              var adapter = new Adapters[i].adapter(adapters[i].stores); // eslint-disable-line new-cap, max-len\n              // Keep ref to tracking api\n              adapter.trackingAPI = me;\n              adapters[i].instance = adapter;\n              initialisedAny = true;\n            }\n          }\n\n          me.adapters = adapters;\n          me.initialised = initialisedAny;\n        }\n      }\n    },\n\n    /*\n     * PreStart\n     */\n    prestart: function() {\n      var deferred = new $.Deferred();\n      var me = this;\n      var adapterName;\n\n      // get an array of deferred promises to check before continuing\n      var deferreds = [];\n\n      if (me.adapters) {\n        for (adapterName in me.adapters) { // eslint-disable-line guard-for-in\n          var currentAdapter = me.adapters[adapterName].instance;\n          if (typeof currentAdapter.prestart !== 'undefined') {\n            deferreds.push(currentAdapter.prestart());\n          }\n        }\n        $.when.apply($, deferreds).then(function() {\n          deferred.resolve();\n        });\n      } else {\n        deferred.resolve();\n      }\n\n      return deferred.promise();\n    },\n\n    /*\n     * Start the tracking!\n     * @param startData {}\n     * @param settings Generic tracking settings\n     * @return boolean\n     */\n    start: function(startData, settings) {\n      var deferred = new $.Deferred();\n      var me = this;\n      var adapterName;\n\n      // Do we have the course id??\n      if (startData && startData.id && startData.id !== undefined) {\n        me.courseId = startData.id;\n      }\n\n      var loadTheUser = function() {\n        // All the tracking adapters have initialised and grabbed their users at this point.\n        // so get a user for use throughout the tracking process..\n        if (me.adapters) {\n          for (adapterName in me.adapters) { // eslint-disable-line guard-for-in\n            var currentAdapter = me.adapters[adapterName].instance;\n            // Break at the first user! We'll use the first one detected.\n            me.user = currentAdapter.getUser();\n            if (me.user) {\n              break;\n            }\n          }\n        }\n\n        me.getUser().then(function(getUserResult) {\n          // Set the user for content tracking\n          me.setUser(getUserResult);\n          // set the user from the adapters .setUser(userData)\n          if (me.adapters) {\n            for (adapterName in me.adapters) { // eslint-disable-line guard-for-in\n              var currentAdapter = me.adapters[adapterName].instance;\n              // If the adapter user isn't complete or set,\n              // but the username has been found, then use this name\n              if (currentAdapter.userIsSet == false\n                  &&\n                  currentAdapter.user !== null\n                  &&\n                  typeof currentAdapter.user.name !== 'undefined') {\n                me.user.name = currentAdapter.user.name;\n              }\n              if (currentAdapter.userIsSet == false\n                  &&\n                  typeof currentAdapter.setUser !== 'undefined') {\n                currentAdapter.setUser(getUserResult);\n              }\n            }\n          }\n          startTheAdapters();\n        });\n      };\n\n      // Load variables from cookies, wil be overwritten if the adpater loads any variables\n      if (me.courseId) {\n        var cookieVars = me.getCookie('gomo-' + me.courseId + '-variables');\n        if (cookieVars !== '') {\n          var variables = global.gomo.utility.Base64.decodeObject(cookieVars);\n          _.each(variables, function(item) {\n            // Add callback event here as we only need to call it after loading variables\n            if (VARIABLES_HOLDER) {\n              item = VARIABLES_HOLDER.addItemCallback(item);\n            }\n            gomo.eventManager.legacy('updateVariableValue', item);\n          });\n        }\n      }\n\n      var startTheAdapters = function() {\n        if (me.user) {\n          me.setUser(me.user);\n        }\n\n        // Get the success and error methods\n        settings = me.parseSettings(settings);\n        var success = settings.success;\n\n        // Override the sucess method\n        // we want to set the state data once it's initialised\n        settings.success = function() {\n          me.active = true;\n          me.getState({\n            // When successfully getting the state data\n            success: function(state) {\n              if (state) {\n                me.state.reset(state);\n                success();\n              }\n            },\n            error: settings.error\n          });\n          if (me.config.pollingInterval) {\n            me.startPolling(me.config.pollingInterval);\n          }\n          var variables = me.state.get('variables') || [];\n          _.each(variables, function(item) {\n            // Add callback event here as we only need to call it after loading variables\n            if (VARIABLES_HOLDER) {\n              item = VARIABLES_HOLDER.addItemCallback(item);\n            }\n            gomo.eventManager.legacy('updateVariableValue', item);\n          });\n        };\n\n        if (startData.preferences) {\n          me.setPreferences(startData.preferences);\n        }\n\n        // Start the adapters\n        me.performAction('start', startData, settings);\n\n        deferred.resolve();\n      };\n\n\n      me.log('Start');\n      loadTheUser();\n\n      return deferred.promise();\n    },\n\n    /**\n     * End the tracking!\n     * @param {object} endData {force:boolean, closeWindow:boolean}\n     * @param {object} settings Generic tracking settings\n     * @return {boolean}\n     */\n    end: function(endData, settings) {\n      var me = this;\n      // Ensure we have an object for the end data...\n      endData = endData || {};\n      settings = me.parseSettings(settings);\n\n      if (me.active || (endData.force || false)) {\n        me.log('End');\n        // Stop polling...\n        me.endPolling();\n        // End the tracking...\n        var success = settings.success;\n        settings.success = function(result) {\n          me.active = false;\n          success(result);\n          // Generic window close.\n          if ((endData.closeWindow || false)) {\n            // If we do not detect phantomJS then close the window!\n            if (!window['callPhantom']) {\n              top.close();\n            }\n          }\n        };\n        // Perform the end action\n        return me.performAction('end', endData, settings);\n      } else {\n        settings.error();\n      }\n      return false;\n    },\n\n    /*\n     * Log a page visit!\n     * @param visitData {topicId:'', pageId:'', topicTitle: '', pageTitle:''}\n     * @param settings Generic tracking settings\n     * @return boolean\n     */\n    visit: function(visitData, settings) {\n      var me = this;\n      me.log('Visit');\n      visitData = visitData || {};\n      visitData.topicId = visitData.topicId || '';\n      visitData.pageId = visitData.pageId || '';\n      visitData.topicTitle = gomo.utility.decodeHtml(visitData.topicTitle) || '';\n      visitData.pageTitle = gomo.utility.decodeHtml(visitData.pageTitle) || '';\n      visitData.progress = visitData.progress || 0;\n      visitData.referrerId = visitData.referrerId || '';\n\n      // Perform the visit request\n      var result = me.performAction('visit', visitData, settings);\n\n      // Add page to the visit history if enabled.\n      if (ENABLE_VISIT_HISTORY) {\n        var history = me.state.get('visitHistory');\n        var historyId = ''.concat(visitData.topicId, visitData.pageId);\n        history = history || [];\n\n        // Check it's not already in there\n        if (historyId != '' && !~$.inArray(historyId, history)) {\n          history.push(historyId);\n        }\n\n        // Set history back on state object\n        me.state.add('visitHistory', history);\n      }\n\n      me.saveState({\n        suppressSave: false\n      });\n\n      // Restart the polling\n      me.restartPolling();\n\n      return result;\n    },\n\n    /**\n     * Log a screen changed\n     * @param {object} data {topicId:'', topicType:''}\n     * @return {boolean}\n     */\n    screenChanged: function(data) {\n      var me = this;\n      me.log('Screen completed');\n      data = data || {};\n      data.topicId = data.topicId || '';\n      data.pageId = data.pageId || '';\n      data.pageTitle = gomo.utility.decodeHtml(data.pageTitle) || '';\n      data.progress = data.progress || 0;\n      data.timeAvailable = data.timeAvailable || null;\n      data.timeCompleted = data.timeCompleted || null;\n      data.referrer = data.referrer || null;\n\n      // Perform the visit request\n      var result = me.performAction('screenChanged', data);\n\n      return result;\n    },\n\n    /*\n     * Log a topic visit\n     * @param visitData {topicId:'', topicType:''}\n     * @return boolean\n     */\n    topicVisit: function(visitData) {\n      var me = this;\n      me.log('Topic visit');\n      visitData = visitData || {};\n      visitData.topicId = visitData.topicId || '';\n      visitData.topicTitle = visitData.topicTitle || '';\n      visitData.topicType = visitData.topicType || '';\n      visitData.progress = visitData.progress || 0;\n\n      // Perform the visit request\n      var result = me.performAction('topicVisit', visitData);\n\n      return result;\n    },\n\n    /**\n     * Log a topic complete\n     * @param {object} data {topicId:'', topicType:''}\n     * @return {boolean}\n     */\n    topicCompleted: function(data) {\n      var me = this;\n      me.log('Topic completed');\n      data = data || {};\n      data.topicId = data.topicId || '';\n      data.topicTitle = data.topicTitle || '';\n      data.topicType = data.topicType || '';\n      data.timeAvailable = data.timeAvailable || null;\n      data.timeCompleted = data.timeCompleted || null;\n      data.completed = data.completed !== undefined ? data.completed : false;\n\n      // Perform the visit request\n      var result = me.performAction('topicCompleted', data);\n\n      return result;\n    },\n\n    /**\n     * Log some other kind of interaction\n     * @param {object} interactionData\n     *    {\n     *      type:'',      // Type of action/interaction (started, completed, etc.)\n     *      activity: {   // The activitiy been interacted with...\n     *        id:'',      // Unique id for the activity (topicid, pageid, etc.)\n     *        title:'',   // Human readable title\n     *        type:''     // Type of activity been acted upon (course, lesson, etc.)\n     *      },\n     *      result: { }    // See this.parseResult for definition\n     *    }\n     * @param {object} settings Generic tracking settings\n     * @return {boolean}\n     */\n    interaction: function(interactionData, settings) {\n      var me = this;\n      var gomoComplete = me.state.get('gomoCourseComplete') || false;\n\n      // only send one completion statement for a course.\n      if (interactionData.activity &&\n        interactionData.activity.type &&\n        interactionData.activity.type == 'course' &&\n        interactionData.type &&\n        interactionData.type == 'completed'\n      ) {\n        if (gomoComplete) {\n          return;\n        } else {\n          me.state.add('gomoCourseComplete', true);\n          me.saveState({\n            suppressSave: true\n          });\n        }\n      }\n\n      me.log('Interaction');\n      interactionData = interactionData || {};\n      interactionData.type = interactionData.type || '';\n      interactionData.activity = interactionData.activity || {};\n      interactionData.activity.id = interactionData.activity.id || '';\n      interactionData.activity.title = gomo.utility.decodeHtml(interactionData.activity.title) || ''; // eslint-disable-line max-len\n      interactionData.activity.type = interactionData.activity.type || '';\n      interactionData.result = me.parseResult(interactionData.result);\n      // interactionData.extra = interactionData.extra || null;\n      return me.performAction('interaction', interactionData, settings);\n    },\n\n    /**\n     * Saves the state object back to the active adapters\n     * @param {object} settings Generic tracking settings\n     * @return {boolean}\n     */\n    saveState: function(settings) {\n      var me = this;\n      me.lastSave = new Date();\n      me.log('Saving state!');\n      return me.performAction('saveState', me.state, settings);\n    },\n\n    /**\n     * Set the user for use in adapters\n     * @function\n     * @param {Object} user {id:'', name:''}\n     * @param {Object} settings\n     */\n    setUser: function(user) {\n      var me = this;\n      if (user == undefined || typeof user != 'object') {\n        user = {};\n      }\n      var uuid = me.generateId();\n      user.id = user.id || uuid;\n      user.name = user.name || 'User ' + uuid;\n      // Save it...\n      me.user = user;\n      if (me.courseId) {\n        me.setCookie(\n          'gomo-' + me.courseId + '-user',\n          global.gomo.utility.Base64.encodeObject(user)\n        );\n      }\n    },\n\n    /**\n     * Get the current user. Generate one if we don't have one...\n     * @return {*}\n     */\n    getUser: function() {\n      var deferred = new $.Deferred();\n      var me = this;\n\n      // Force users to register everytime\n      if (typeof USER_REGISTRATION_EXTRA !== 'undefined' && me.config.forceRegistration) {\n        me.registerUser().then(function(user) {\n          deferred.resolve(user);\n        });\n      } else {\n        // If an adapter has already set it, then reset it as courseId may not have existed\n        // and it's not stored in cookies. Then return the value\n        if (me.user !== null && typeof me.user.id !== 'undefined') {\n          me.setUser(me.user);\n          deferred.resolve(me.user);\n        } else {\n          // Try and find user in cookies...\n          var user = {};\n          if (me.courseId) {\n            var cookieUser = me.getCookie('gomo-' + me.courseId + '-user');\n            if (cookieUser != '') {\n              user = global.gomo.utility.Base64.decodeObject(cookieUser);\n            }\n          }\n\n          if (typeof user.id == 'undefined') {\n            if (typeof USER_REGISTRATION_EXTRA !== 'undefined' && me.config.userRegistration) {\n              me.registerUser().then(function(user) {\n                deferred.resolve(user);\n              });\n            } else {\n              // Generate a unique id...\n              var uuid = me.generateId();\n              // populate user...\n              user.id = uuid;\n              user.name = 'User ' + uuid;\n              deferred.resolve(user);\n            }\n          } else {\n            deferred.resolve(user);\n          }\n        }\n      }\n\n      return deferred.promise();\n    },\n\n    /**\n     * Saves the state object back to the active adapters\n     * @param {object} settings Generic tracking settings\n     * @return {object}\n     */\n    registerUser: function() {\n      var deferred = new $.Deferred();\n      var me = this;\n      var user = {};\n\n      USER_REGISTRATION_EXTRA.preCourseLoad().then(function(data) {\n        if (data == null) {\n          // Generate a unique id...\n          var uuid = me.generateId();\n          // populate user...\n          user.id = uuid;\n          user.name = 'User ' + uuid;\n        } else {\n          // populate user...\n          user.id = data.email;\n          user.name = data.firstname + ' ' + data.surname;\n        }\n        deferred.resolve(user);\n      });\n\n      return deferred.promise();\n    },\n\n    /**\n     * Get the current user. Generate one if we don't have one...\n     * @return {*}\n     */\n    getUserId: function() {\n      var me = this;\n      var userId = false;\n\n      if (me.user && me.user.id) {\n        userId = me.user.id;\n      }\n\n      return userId;\n    },\n\n    /**\n     * Validate and set the GEOJSON object!\n     * @param {object} geoJSON\n     * @param {object} settings\n     * @return {boolean}\n     */\n    setGeoJSON: function(geoJSON, settings) {\n      var me = this;\n      try {\n        var geo = JSON.parse(geoJSON);\n        if (geo && geo.geometry) {\n          return me.performAction('setGeoJSON', geoJSON, (settings||{}));\n        }\n      } catch (e) {\n        // empty\n      }\n      return false;\n    },\n\n    /**\n     * @param {string} cname\n     * @param {string} value\n     */\n    setCookie: function(cname, value) {\n      // Don't store cookies for preview or sharelink\n      if (OUTPUT_MODE_CHECKER.booPreviewMode) {\n        return;\n      }\n      // Set expiry (30 days)\n      var expiry = new Date();\n      expiry.setTime(expiry.getTime() + (30*24*60*60*1000));\n      var expires = 'expires=' + expiry.toUTCString();\n      // Set the cookie...\n      document.cookie = cname + '=' + value + '; ' + expires;\n    },\n\n    /**\n     * @param {string} cname\n     * @return {string}\n     */\n    getCookie: function(cname) {\n      var name = cname + '=';\n      var ca = document.cookie.split(';');\n      for (var i=0; i<ca.length; i++) {\n        var c = ca[i];\n        while (c.charAt(0)==' ') c = c.substring(1);\n        if (c.indexOf(name) == 0) return c.substring(name.length, c.length);\n      }\n      return '';\n    },\n\n    /**\n     * Generate Id\n     * @return {string}\n     */\n    generateId: function() {\n      /**\n       * @return {string}\n       */\n      function s4() {\n        return Math.floor((1 + Math.random()) * 0x10000)\n          .toString(16)\n          .substring(1);\n      }\n      return s4() + s4() + '-' + s4() + '-' + s4() + '-' +\n      s4() + '-' + s4() + s4() + s4();\n    },\n\n    /**\n     * Gets the state object from to the active adapters\n     * @param {object} settings Generic tracking settings\n     * @return {boolean}\n     */\n    getState: function(settings) {\n      var me = this;\n      return me.performAction('getState', null, settings);\n    },\n\n    /**\n     * Returns the last place visited.\n     * @param {object} settings Generic tracking settings\n     * @return {boolean}\n     */\n    getLastLocation: function(settings) {\n      var me = this;\n      me.log('Get last location...');\n      return me.performAction('getLastLocation', null, settings);\n    },\n\n    /**\n     * @param {object} settings\n     * @return {boolean}\n     */\n    getScore: function(settings) {\n      var me = this;\n      return me.performAction('getScore', null, settings);\n    },\n\n    /**\n     * @param {object} settings\n     * @return {boolean}\n     */\n    getCompletionStatus: function(settings) {\n      var me = this;\n      return me.performAction('getCompletionStatus', null, settings);\n    },\n\n    /**\n     * Set the overall course score...\n     * @param {object} scoreData {min:0-100, max:0-100, raw:0-100}\n     * @param {object} settings Generic tracking settings\n     * @return {boolean}\n     */\n    score: function(scoreData, settings) {\n      var me = this;\n      me.log('Score');\n      var result = null;\n      if (scoreData) {\n        result = me.performAction('score', scoreData, settings);\n      }\n      return result;\n    },\n\n    /**\n     * Summarise all the tracking!\n     * @param summaryData {}\n     * @param settings Generic tracking settings\n     * @return boolean\n     */\n    // summarise: function(summaryData, settings){\n    //   var me = this;\n    //   me.log('Summarise');\n    //   return me.performAction('summarise', summaryData, settings);\n    // },\n\n    /**\n     * Start polling!\n     * @param {number} interval Polling interval in milliseconds\n     */\n    startPolling: function(interval) {\n      var me = this;\n      if (interval && interval > 1) {\n        me.pollingInterval = setInterval(function() {\n          me.log('Polling');\n          if ((new Date() - me.lastSave) >= interval) {\n            me.lastSave = new Date();\n            me.performAction('poll', null, null);\n          }\n        }, interval);\n      }\n    },\n\n    restartPolling: function() {\n      var me = this;\n      if (me.pollingInterval) {\n        me.log('Restart polling');\n        clearInterval(me.pollingInterval);\n        me.startPolling(me.config.pollingInterval);\n      }\n    },\n\n    /**\n     * End polling!\n     */\n    endPolling: function() {\n      var me = this;\n      if (me.pollingInterval) {\n        me.log('End polling');\n        clearInterval(me.pollingInterval);\n      }\n    },\n\n    /**\n     * Parse result\n     * The results object will conform to the one defined in TinCan v1.0.0 spec.\n     * @param {object} result The result object to be formatted.\n     * @return {object}\n     */\n    parseResult: function(result) {\n      result = result || {};\n      // Score object\n      if (result.score) {\n        result.score = result.score || {};\n        result.score.min = isNaN(+result.score.min) ? 0 : +result.score.min;\n        result.score.max = isNaN(+result.score.max) ? 0 : +result.score.max;\n        result.score.raw = isNaN(+result.score.raw) ? 0 : +result.score.raw;\n\n        if (result.score.scaled === undefined) {\n          result.score.scaled = +(result.score.raw / result.score.max).toFixed(2);\n        }\n      }\n      // Success status\n      if (result.success !== undefined) {\n        result.success = result.success ? true : false;\n      }\n      // Completion status\n      if (result.completion !== undefined) {\n        result.completion = result.completion ? true : false;\n      }\n      return result;\n    },\n\n    /**\n     * Parse the settings and ensure it conforms to the\n     * relevant settings format.\n     * @param {object} settings The settings object to be formatted.\n     * @return {object}\n     */\n    parseSettings: function(settings) {\n      settings = settings || {};\n      settings.success = settings.success || new Function();\n      settings.error = settings.error || new Function();\n      settings.suppressSave = settings.suppressSave || false;\n      return settings;\n    },\n\n    /**\n     * Wrapper for console.log\n     */\n    log: function() {\n      if (console) {\n        arguments[0] =\n          typeof arguments[0] == 'string' ? 'ContentTracking: ' + arguments[0] : arguments[0];\n        if (console.log && arguments.length) {\n          console.log(arguments[0]);\n        }\n      }\n    },\n\n    /**\n     * Returns array of keys in object.\n     * This will be replaced by _.keys when underscore lib is introduced.\n     * @param {object} obj\n     * @return {array}\n     */\n    getObjectKeys: function(obj) {\n      var type = typeof obj;\n      var arr = [];\n      if (type === 'function' || type === 'object' && !!obj) {\n        if (Object.keys) {\n          return Object.keys(obj);\n        }\n        for (var i in obj) {\n          if (obj.hasOwnProperty(i)) {\n            arr.push(i);\n          }\n        }\n      }\n      return arr;\n    },\n\n    /**\n     * Perform action on all active adapters!\n     * @param {string} method The method to be called on all adapters instances\n     * @param {object} args The arguments to be sent to each instance\n     * @param {object} settings Generic tracking settings\n     * @return {?boolean}\n     */\n    performAction: function(method, args, settings) {\n      var me = this;\n      var currentQueue = [];\n      settings = me.parseSettings(settings);\n\n      // Don't try performing actions if we've not initialised the adapters\n      if (!me.initialised) {\n        me.log('Skipped perfoming: ' + method);\n        return;\n      }\n\n      // If we're not active yet, check the method.\n      // If is not to start or set preferences then add the command to the queue\n      // and get out of here!\n      if (!me.active && (method != 'start' && method != 'setPreferences')) {\n        me.queue.push({\n          method: method,\n          args: args,\n          settings: settings\n        });\n        me.log('Added ' + method + ' to queue.');\n        return;\n      }\n\n      // Create the queue for this transaction.\n      currentQueue.push({\n        method: method,\n        args: args,\n        settings: settings\n      });\n\n      // Just do this if it's a priority method...\n      if (method == 'start' || method == 'setPreferences') {\n        // Prioritise these methods...\n        // currentQueue = currentQueue.concat(me.queue);\n      } else if (method == 'getState') {\n        // Prioritise get state!\n        currentQueue = currentQueue.concat(me.queue);\n        // Empty the array...\n        me.queue.length = 0;\n      } else {\n        // Otherwise, add to queue and process the entire queue...\n        currentQueue = me.queue.concat(currentQueue);\n        // Empty array....\n        me.queue.length = 0;\n      }\n\n      // Process the current queue!\n      var item;\n      while (item = currentQueue.shift()) {\n        me.log('Processing queue method: ' + item.method);\n        me.processAction(item.method, item.args, item.settings);\n      }\n\n      return true;\n    },\n\n    processAction: function(method, args, settings) {\n      var me = this;\n      var results = {};\n      var i;\n\n      // Performance state\n      var performance = {\n        adapters: 0,\n        success: 0,\n        error: 0,\n        complete: 0\n      };\n\n      // Determine the filter on adapters if any!\n      var filter = false;\n      if (settings.adapter && settings.adapter !== '') {\n        filter = settings.adapter;\n      }\n\n      // Get the filtered list of adapters...\n      var activeAdapters = {};\n      if (filter) {\n        if (_.has(me.adapters, filter)) {\n          activeAdapters[filter] = me.adapters[filter];\n        }\n      } else {\n        activeAdapters = me.adapters;\n      }\n\n      // Get count of active adapters with instance!\n      performance.adapters = _.size(_.pick(activeAdapters, function(adptr) {\n        return _.isObject(adptr.instance);\n      }));\n\n      // Generic action to check the performance and call the relevant callbacks\n      var performedAction = function(action, adapter, result) {\n        // me.log('Peformed action: ' + action + ' on ' + adapter + '.');\n        performance.complete++;\n        results[adapter] = result;\n\n        if (performance.complete == performance.adapters && !$.isEmptyObject(results)) {\n          // Just return first result that isn't undefined\n          var foundResult = null;\n          for (var adapterIndex in results) {\n            if (typeof results[adapterIndex] !== 'undefined' && results[adapterIndex] !== null) {\n              foundResult = results[adapterIndex];\n              break;\n            }\n          }\n\n          if (performance.success > 0 && performance.success == performance.complete) {\n            settings.success(foundResult);\n          } else {\n            settings.error(foundResult);\n          }\n        }\n      };\n\n      // Loop all adapters and perform action\n      if (performance.adapters == 0) {\n        settings.error(null);\n        return false;\n      }\n\n      for (i in activeAdapters) {\n        if (activeAdapters[i] && activeAdapters[i].instance) {\n          var adapter = activeAdapters[i].instance;\n          try {\n            adapter[method].apply(adapter, [\n              args,\n              {\n                success: function(result) {\n                  performance.success++;\n                  performedAction(method, i, result);\n                },\n                error: function(result) {\n                  performance.error++;\n                  performedAction(method, i, result);\n                  var message =\n                    gomo.localiser.get('TRACKING_ERROR_MESSAGE') + ' \"' + method + '\" : ' + i;\n\n                  // Log to the console\n                  console.log(message);\n\n                  // Ignore if alerts are suppressed or connection checker already failed\n                  if (\n                    me.alertErrors &&\n                    ALERT_TRACKING_ERRORS &&\n                    gomo.connectionChecker.isConnectionActive() !== false\n                  ) {\n                    // Prevent further alerts until the user chooses to continue\n                    me.alertErrors = false;\n                    var failedTrackingMessage = gomo.localiser.get('TRACKING_ERROR_MESSAGE');\n                    var alertType = 'warning';\n                    var buttons = [\n                      {\n                        label: gomo.localiser.get('TRACKING_ERROR_IGNORE'),\n                        type: 'secondary',\n                        action: CONTENT_TRACKING.ignoreErrors\n                      },\n                      {\n                        label: gomo.localiser.get('TRACKING_ERROR_CONTINUE'),\n                        type: 'primary',\n                        action: CONTENT_TRACKING.continueAlerts\n                      }\n                    ];\n                    gomo.alertManager.create(alertType, false, failedTrackingMessage, buttons);\n                  }\n                },\n                suppressSave: settings.suppressSave || false\n              }\n            ]);\n          } catch (e) {\n            typeof ErrorHandler != 'undefined' && ErrorHandler['catch'] && ErrorHandler['catch'](e); // eslint-disable-line max-len\n            me.log('Critical error performing \"' + method + '\" on ' + i);\n            me.log(e);\n            performance.error++;\n            performedAction(adapter, i, null);\n          }\n        }\n      }\n\n      return true;\n    },\n\n    /**\n     * Ignore tracking errors\n     * @function\n     */\n    ignoreErrors: function() {\n      CONTENT_TRACKING.alertErrors = false;\n    },\n\n    /**\n     * Continue tracking errors\n     * @function\n     */\n    continueAlerts: function() {\n      CONTENT_TRACKING.alertErrors = true;\n    },\n\n    /**\n     * Set tracking preferences...\n     * @function\n     * @param {object} preferences\n     */\n    setPreferences: function(preferences) {\n      var me = this;\n      if (preferences) {\n        for (var i in preferences) { // eslint-disable-line guard-for-in\n          me.performAction('setPreferences', preferences[i], {\n            adapter: i\n          });\n        }\n      }\n    },\n\n    saveVariable: function(variableData) {\n      var me = this;\n      var variables = me.state.get('variables') || [];\n      var variableKey = _.findIndex(variables, {strVariableName: variableData.strVariableName});\n      if (variableKey > -1) {\n        // If the variable exists then update it if necessary.\n        if (variables[variableKey].strVariableValue !== variableData.strVariableValue) {\n          variables[variableKey].strVariableValue = variableData.strVariableValue;\n        }\n      } else {\n        // Only store name and value to save space\n        var formattedVariableData = {\n          strVariableName: variableData.strVariableName,\n          strVariableValue: variableData.strVariableValue\n        };\n        variables.push(formattedVariableData);\n      }\n      me.state.add('variables', variables);\n      me.saveState({\n        suppressSave: true\n      });\n      // Save a cookie if we have no active adapter\n      if (!me.adapters) {\n        me.setCookie(\n          'gomo-' + me.courseId + '-variables',\n          global.gomo.utility.Base64.encodeObject(variables)\n        );\n      }\n    }\n  };\n\n  return new ContentTracking();\n})(global.$, global.CONTENT_TRACKING_ADAPTERS);\n"},function(n,e,t){t(0)(t(93))},function(n,e){n.exports="/* globals OBJ_NAV_BUTTONS, OBJ_CORE_BUTTONS, BOO_PAGE_COUNT_POSITION_TOP_STRAP,\nBOO_PAGE_COUNT_POSITION_NAV, BOO_PAGE_COUNT_POSITION_SCREEN, EM, $, PAGE_COUNT_WITH_NAVIGATION */\n\n/**\n * NavigationProxy\n * @author Adam Fox\n */\nvar global = this;\n\n// Check for NavigationManager dependency\nif (global.NavigationManager === undefined) {\n  console.log('ERROR: NavigationManager class has not been defined');\n}\n\n// Check for NavigationGroup dependency\nif (global.NavigationGroup === undefined) {\n  console.log('ERROR: NavigationGroup class has not been defined');\n}\n// Check for NavigationControl dependency\nif (global.NavigationControl === undefined) {\n  console.log('ERROR: NavigationControl class has not been defined');\n}\n\nglobal.NavigationProxy = (function(NavigationManager, NavigationGroup, NavigationControl) {\n  /**\n   * NavigationProxy\n   * @constructor\n   */\n  function NavigationProxy() {\n    // Legacy public properties\n    this.strObjID =\n      'The navigation proxy - takes the current gomo data structure - reformats and handles it.';\n    this._objCurrDOM = null;\n    this.progressId = 'extra-progress_bar';\n  }\n\n  /**\n   * Extend the NavigationProxy\n   */\n  NavigationProxy.prototype = {\n    svgSpritesheet: false,\n\n    init: function(svgSpritesheet) {\n      var me = this;\n      me.svgSpritesheet = svgSpritesheet;\n      me.svgIdCheckCache = {};\n    },\n\n    // Legacy event\n    // Conforms to current gomo event definition and is currenly called accordingly\n    handleEvent_primeDOMReferences: function(DOM) {\n      var me = this;\n      me._objCurrDOM = DOM;\n    },\n\n    // Legacy event\n    // Conforms to current gomo event definition and is currenly called accordingly\n    handleEvent_registerNavMenu: function() {\n      var me = this;\n\n      // Build the definition!\n      var RegisteredControls = [];\n      var definition;\n      var control;\n\n      // From OBJ_NAV_BUTTONS!\n      for (var x in OBJ_NAV_BUTTONS) {\n        if (Object.prototype.hasOwnProperty.call(OBJ_NAV_BUTTONS, x)) {\n          definition = OBJ_NAV_BUTTONS[x];\n          if (definition) {\n            control = me.buildControlDefinition(definition);\n            RegisteredControls.push(control);\n          }\n        }\n      }\n\n      // Add in OBJ_CORE_BUTTONS\n      for (var z in OBJ_CORE_BUTTONS) {\n        if (Object.prototype.hasOwnProperty.call(OBJ_CORE_BUTTONS, z)) {\n          definition = OBJ_CORE_BUTTONS[z];\n          control = me.buildControlDefinition(definition);\n          var controlPosition = null;\n          // Find out if we already have this control!\n          if (RegisteredControls.length) {\n            for (var y in RegisteredControls) {\n              if (RegisteredControls[y].id == definition.strExtrasId) {\n                controlPosition = y;\n                break;\n              }\n            }\n          }\n\n          // Add control to the list in the appropriate location!\n          var foundProgress = false;\n          if (control && control.id) {\n            // Look for progress bar\n            foundProgress = control.id == me.progressId ? true : foundProgress;\n\n            // Add registered control\n            if (controlPosition == null) {\n              RegisteredControls.push(control);\n            } else {\n              RegisteredControls[controlPosition] = control;\n            }\n          }\n        }\n      }\n\n      // No Progress Bar?\n      if (\n        !foundProgress &&\n        (BOO_PAGE_COUNT_POSITION_TOP_STRAP ||\n          BOO_PAGE_COUNT_POSITION_NAV ||\n          BOO_PAGE_COUNT_POSITION_SCREEN)\n      ) {\n        var progress = new NavigationControl({\n          id: me.progressId,\n          type: 'progress',\n          label: me.progressId,\n          index: 0,\n          extra: me.progressId,\n          link: '',\n          partial: 'progress_generalTemplateC',\n          position: 0,\n          visible: true,\n          defaultItem: true,\n          alternative: {\n            partial: '',\n            label: ''\n          }\n        });\n        RegisteredControls.push(progress);\n      }\n\n      NavigationManager.registerControls(RegisteredControls);\n    },\n\n    // Legacy event\n    // Conforms to current gomo event definition and is currenly called accordingly\n    handleEvent_rebuildNavMenu: function(objScreenData) {\n      var me = this;\n      if (typeof objScreenData != 'object' && typeof objScreenData.objNavigationItems != 'object') {\n        return;\n      }\n\n      // Build the definition!\n      var definition = me.buildNavigationDefinition(objScreenData.objNavigationItems);\n\n      // Set the current navigation structure!\n      NavigationManager.setCurrentNavigation(definition);\n    },\n\n    buildNavigationDefinition: function(definition) {\n      // Define navigation definition\n      var me = this;\n      var navigationDefinition = [];\n      var topBar = new NavigationGroup({id: 'top', type: 'toolbar'});\n      var bottomBar = new NavigationGroup({id: 'bottom', type: 'toolbar'});\n      var screenNav = new NavigationGroup({id: 'screen', type: 'group'});\n      var foundProgress = false;\n\n      for (var i in definition) {\n        if (Object.prototype.hasOwnProperty.call(definition, i)) {\n          var control = me.buildControlDefinition(definition[i]);\n          if (control.id) {\n            // Determine the group this control should appear in!\n            // If this has not been defined then assume the bottom bar, because we are using old data!\n            var group = definition[i].strGroup === undefined ? 'bottom' : definition[i].strGroup;\n\n            // Look for progress bar and set its group type.\n            foundProgress = control.id === me.progressId ? true : foundProgress;\n            if (control.id === me.progressId) {\n              control.type =\n                PAGE_COUNT_WITH_NAVIGATION ?\n                  'screen_navigation':\n                  'progress';\n            }\n\n            // If the control type is screen_navigation then it will need to belong\n            // to the screen navigation group.\n            if (control.type !== undefined && control.type == 'screen_navigation') {\n              group = 'screen';\n            }\n\n            // Add to the appropriate group!!\n            switch (group) {\n              case 'screen':\n                screenNav.addControl(control);\n                break;\n              case 'top':\n                topBar.addControl(control);\n                break;\n              case 'bottom':\n              default:\n                bottomBar.addControl(control);\n                break;\n            }\n          }\n        }\n      }\n\n      // Do we need to add a progress bar?\n      if (\n        !foundProgress &&\n        (BOO_PAGE_COUNT_POSITION_TOP_STRAP ||\n          BOO_PAGE_COUNT_POSITION_NAV ||\n          BOO_PAGE_COUNT_POSITION_SCREEN)\n      ) {\n        // Find the registered one!\n        var registeredControl = NavigationManager.getRegisteredControlById(me.progressId);\n        if (registeredControl && registeredControl.id == me.progressId) {\n          // Add to top/bottom bar\n          switch (true) {\n            case BOO_PAGE_COUNT_POSITION_TOP_STRAP:\n              registeredControl.position = 3; // stick it in the middle!\n              topBar.addControl(registeredControl);\n              break;\n            case BOO_PAGE_COUNT_POSITION_NAV:\n              registeredControl.position = bottomBar.length + 1; // stick it at the end!\n              bottomBar.addControl(registeredControl);\n              break;\n            case BOO_PAGE_COUNT_POSITION_SCREEN:\n            default:\n              screenNav.addControl(registeredControl);\n              break;\n          }\n        }\n      }\n\n      // Navigation definition!\n      navigationDefinition.push(topBar);\n      navigationDefinition.push(bottomBar);\n      navigationDefinition.push(screenNav);\n\n      // New definition!\n      // console.log(navigationDefinition);\n\n      return JSON.stringify(navigationDefinition);\n    },\n\n    buildControlDefinition: function(definition) {\n      var me = this;\n      if (definition) {\n        var extraId = definition.strExtrasId === undefined ? '' : definition.strExtrasId;\n        // Transform the extra id - for mixed data\n        switch (extraId) {\n          case 'menuButton':\n            extraId = 'extra-menu';\n            break;\n          case 'nextButton':\n            extraId = 'extra-next';\n            break;\n          case 'backButton':\n            extraId = 'extra-back';\n            break;\n        }\n        var link = '';\n        if (definition.arrActions) {\n          for (var i in definition.arrActions) {\n            if (Object.prototype.hasOwnProperty.call(definition.arrActions, i)) {\n              var action = definition.arrActions[i];\n              if (\n                action.objParameters &&\n                action.objParameters.strScreenID &&\n                action.objParameters.strScreenID != ''\n              ) {\n                link = action.objParameters.strScreenID;\n              }\n            }\n          }\n        }\n\n        var registeredControl = NavigationManager.getRegisteredControlById(extraId);\n        if (!registeredControl) {\n          registeredControl = {\n            type: '',\n            position: 0\n          };\n        }\n\n        // Check the authors editor visibility setting and the display conditions to determine visibility\n        var finalVisibility = true;\n        // if the editor is set to hidden, then never show it\n        if (definition.booButtonShown !== true || definition.booIsDisplayed !== true) {\n          finalVisibility = false;\n        }\n\n        // If the page count should be shown with the screen navigation change its type so it\n        // renders in the correct group.\n        if (\n          definition.strExtrasId &&\n          definition.strExtrasId === me.progressId &&\n          PAGE_COUNT_WITH_NAVIGATION\n        ) {\n          definition.strType = 'screen_navigation';\n        }\n\n        var control = new NavigationControl({\n          id: extraId,\n          type: definition.strType === undefined ? registeredControl.type : definition.strType,\n          label: definition.strCustomLabel === undefined ? '' : definition.strCustomLabel,\n          index: definition.intButtonIndex === undefined ? 0 : definition.intButtonIndex,\n          extra: extraId,\n          link: link,\n          partial: definition.strHtmlFragment === undefined ? '' : definition.strHtmlFragment,\n          position:\n            definition.intPosition === undefined\n              ? registeredControl.position\n              : definition.intPosition,\n          visible: finalVisibility,\n          defaultItem:\n            definition.booDefaultDisplayButton === undefined\n              ? false\n              : definition.booDefaultDisplayButton,\n          alternative: {\n            partial:\n              definition.strAltHtmlFragment === undefined ? 0 : definition.strAltHtmlFragment,\n            label: definition.strAltCustomLabel === undefined ? 0 : definition.strAltCustomLabel,\n            svgId: definition.strAltCustomLabel\n              ? extraId + '-' + definition.strAltCustomLabel\n              : extraId\n          },\n          additionalData: definition.objCustomData === undefined ? {} : definition.objCustomData\n        });\n        return control;\n      }\n      return null;\n    },\n\n    findIconInSvgSpritesheet: function(id) {\n      var me = this;\n      if (!me.svgSpritesheet) {\n        return false;\n      }\n\n      if (typeof me.svgIdCheckCache[id] === 'undefined') {\n        me.svgIdCheckCache[id] = false;\n        if ($(me.svgSpritesheet).find('#'+id).length > 0) {\n          me.svgIdCheckCache[id] = true;\n        }\n      }\n\n      return me.svgIdCheckCache[id];\n    }\n  };\n\n  // Return and instance - singleton\n  return new NavigationProxy();\n})(global.NavigationManager, global.NavigationGroup, global.NavigationControl);\n\n// Register this instance with the EventManager!\nEM.register(global.NavigationProxy);\n"},function(n,e,t){t(0)(t(95))},function(n,e){n.exports='/* eslint-disable */\n/**\n* @title Master Renderer\n* @description To be described.\n*\n*\n* @author GoMo\n* @version 2.0 17/12/12\n* @version 2.1 08/11/13 - JH - Added \'rerender\' method for use on screen resizing.\n*/\n\nvar MASTER_RENDERER =\n{\n\tstrObjID : "Page Renderer",\n\tstrObjDescription : "Renders the general page, content specific rendering handled by additional template rendering .js files.",\n\n\tobjDOM : null,\n\n\t_strContentHolderID : "screenHolderL",\n\t_strSmartphoneScrollWrapper : "scroller",\n\t_domContentHolderID : null,\n\t_domBodyTag : null,\n\t_domSmartphoneScrollWrapper : null,\n\n\t_objRenderExtensions : {"page":null},\n\t_booRenderOnExtension : false,\n\n\t_strCurrOutputModeClass : OUTPUT_MODE_CHECKER.strCurrentMode,\n\n\tstrInterfaceImagePath : null,\n  strResourceBasePath : null,\n  strUserGroupId: null,\n\n\tobjImageMetaDataHash : null,\n\tobjVideoMetaDataHash : null,\n\tobjSharedImageMetaDataHash : null,\n\n\t_strImageFiles : \'imageFiles\',\n\t_strAudioFiles : \'audiofiles\',\n\t_strVideoFiles : \'videoFiles\',\n\n\tobjTemplateHolder : null,\n\tobjLocaliser : null,\n\n\tobjCurrentRenderedItem : null,\n\n\thandleEvent_primeDOMReferences : function (_objWhatDOM)\n\t{\n\t\tthis.objDOM = _objWhatDOM;\n\t\tthis.objTemplateHolder = TEMPLATE_MANANGER;\n\t\tthis.objLocaliser = LOCALISER;\n\n\t\tthis._domContentHolderID = this.objDOM.getElementById(this._strContentHolderID);\n\t\tthis._domBodyTag = this.objDOM.getElementsByTagName("body")[0];\n\t},\n\n\thandleEvent_outputModeChanged : function (_objOutputChangeData)\n\t{\n\t\tthis._strCurrOutputModeClass = _objOutputChangeData[\'strNewOutputMode\'];\n\n\t\tif (this.objCurrentRenderedItem)\n\t\t{\n\t\t\tif (this.objCurrentRenderedItem.strObjType == "topic")\n\t\t\t{\n\t\t\t\tthis._booRefreshNavigation = true;\n\t\t\t}\n\t\t\tPOPUP_MANANGER.unlockPopups();\n\t\t\tif (!_objOutputChangeData[\'booSurpressReRendering\'])\n\t\t\t{\n\t\t\t\t// Do this to allow all other events to propogate before re-rendering.\n\t\t\t\tif(gomo.translationManager){\n\t\t\t\t\tgomo.translationManager.resetTopicData();\n\t\t\t\t}\n\t\t\t\tSUB_SCREEN_RENDERER.resetRenderedSubscreens();\n\t\t\t\t// Trigger assets to reset themselves after rerender, if they support it\n\t\t\t\tASSET_INTERACTIONS.preRerenderedTopic();\n\t\t\t\twindow.setTimeout(function(){\n\t\t\t\t\tMASTER_RENDERER.renderItem(null, true);\n\t\t\t\t},0);\n\t\t\t}\n\t\t}\n\t},\n\n\thandleEvent_setResourcesPath : function (path) {\n\t\tthis.strInterfaceImagePath = path;\n\t\tthis.strResourceBasePath = path;\n\t},\n\n\tgetResourcesPath: function (resourcePath) {\n\t\tif (resourcePath === \'\') {\n\t\t\treturn \'\';\n\t\t}\n\t\treturn this.strResourceBasePath;\n\t},\n\n\thandleEvent_broadcastResourceMetaData : function (_objWhatImageMetaData)\n\t{\n\t\tthis.objImageMetaDataHash = this._parseIntoHashTable(_objWhatImageMetaData.files[this._strImageFiles]);\n\t\tthis.objVideoMetaDataHash = this._parseIntoHashTable(_objWhatImageMetaData.files[this._strVideoFiles]);\n\t},\n\n\thandleEvent_screenSizeChanged : function ()\n\t{\n\t\tthis._rerenderItems();\n\t},\n\n\thandleEvent_broadcastSharedResourceData : function (_objWhatMetaData)\n \t{\n\t\tif (!_objWhatMetaData) {\n \t\t\treturn;\n\t\t} \n\n\t\tif (_objWhatMetaData.imageFiles) {\n      var imageMetaData = this._parseIntoHashTable(_objWhatMetaData.imageFiles);\n\t\t\tif (imageMetaData) {\n\t\t\t\tfor (var _strCurrImageFilename in imageMetaData) {\n\t\t\t\t\t// Only add items that aren\'t present\n\t\t\t\t\tif (!this.objImageMetaDataHash[_strCurrImageFilename]) {\n\t\t\t\t\t\tthis.objImageMetaDataHash[_strCurrImageFilename] = imageMetaData[_strCurrImageFilename];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (_objWhatMetaData.videoFiles) {\n\t\t\tvar videoMetaData = this._parseIntoHashTable(_objWhatMetaData.videoFiles);\n\t\t\tif (videoMetaData) {\n\t\t\t\tfor (var _strCurrImageFilename in videoMetaData) {\n\t\t\t\t\t// Only add items that aren\'t present\n\t\t\t\t\tif (!this.objVideoMetaDataHash[_strCurrImageFilename]) {\n\t\t\t\t\t\tthis.objVideoMetaDataHash[_strCurrImageFilename] = videoMetaData[_strCurrImageFilename];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \t},\n\n\trenderItem : function (_objWhatData, rerenderedItem)\n\t{\n\t\tthis.setCurrentRenderItem(_objWhatData);\n\n\t\tvar _booTriggerMenuAnimation = false;\n\t\tvar _booCheckShowLastPagePopup = false;\n\n\t\tvar _objCurrentItemData = this.getCurrentRenderItemData();\n\n\t\tvar _htmItemContent = _objCurrentItemData["htmItemContent"];\n\n\t\tif (typeof(SETTINGS_EXTRA) != \'undefined\')\n\t\t{\n\t\t\t_htmItemContent = SETTINGS_EXTRA.parseForSettingsClasses(_htmItemContent);\n\t\t}\n\n\t\t// Cleanup any outstanding handles.\n\t\tif(typeof ISCROLL_INTERFACE != \'undefined\')\n\t\t{\n\t\t\tISCROLL_INTERFACE.recycleScroller(this._domContentHolderID);\n\t\t}\n\n\t\tthis._domContentHolderID.innerHTML = _htmItemContent;\n\n\t\tEM.trigger("newlyRenderedItemInDocument");\n\n\t\tif(rerenderedItem){\n\t\t\tASSET_INTERACTIONS.postRerenderedTopic();\n\t\t}\n\t\telse{\n\t\t\tASSET_INTERACTIONS.postRenderedTopic();\n\t\t}\n\n\t\tvar popupTranslations = {\'group\':\'topic\', \'searchClass\':\'localisationWrapper\'};\n\t\tvar subscreenTranslations = {\'group\':\'subscreen\', \'searchClass\':\'subscreenLocalisationWrapper\', \'depthSuppressor\':true};\n\t\t// Not needed anymore. Assets take care of their own\n\t\t//gomo.translationManager.translateLocalisations(this._domContentHolderID, popupTranslations);\n\t\t// This needs to be handled on a per subscreen basis\n\t\t//gomo.translationManager.translateLocalisations(this._domContentHolderID, subscreenTranslations);\n\t\t\n\t\t//We need to translate LOCALISATION at an asset level\n\t\tgomo.translationManager.updateBoundLocalisations();\n\n\t\t//Run the screen size check to rerender elements on demand.\n\t\tOUTPUT_MODE_CHECKER.manualScreenSizeCheck();\n\n\t\tif (_objCurrentItemData["triggerMenuAnimation"])\n\t\t{\n\t\t\tEM.trigger("animateMenuItems");\n\t\t}\n\t\tif (_objCurrentItemData["checkShowLastPagePopup"])\n\t\t{\n\t\t\tEM.trigger("checkShowLastPagePopup");\n\t\t}\n\n\t\tif (_objCurrentItemData["scrollerID"] && typeof ISCROLL_INTERFACE != \'undefined\')\n\t\t{\n\t\t\t//REFACTOR NOTE: does this need to parse the whole obj or can it be the ID?\n\t\t\tISCROLL_INTERFACE.parseChildDOMElements(this.objDOM);\n\t\t}\n\n\t\tif (this._booRefreshNavigation)\n\t\t{\n\t\t\tthis._booRefreshNavigation = false;\n\t\t\tEM.trigger("goToPage", "0");\n\t\t}\n\t},\n\n\tgetCurrentRenderItemData : function ()\n\t{\n\t\tvar _objReturn = {\n\t\t\t"htmItemContent" : "",\n\t\t\t"scrollerID" : false,\n\t\t\t"triggerMenuAnimation" : false,\n\t\t\t"checkShowLastPagePopup" : false\n\t\t};\n\n\t\t_objReturn["htmItemContent"] = TOPIC_RENDERER.renderTopic(this.objCurrentRenderedItem);\n\t\t_objReturn["arrHeightsToSubtractFromContent"] = ["navWrapperL"];\n\n\t\t_objReturn["htmItemContent"] = _objReturn["htmItemContent"].replace(/resources\\/trans.gif\\?/g, this.getTransGifPath());\n\t\tif (!PREVIEW_DATA.editorMode) {\n\t\t\tvar _regBaseResourcesPath = new RegExp(ROOT_PATH, "gi");\n\t\t\t_objReturn["htmItemContent"] = _objReturn["htmItemContent"].replace(_regBaseResourcesPath, "");\n\t\t}\n\t\treturn _objReturn;\n\t},\n\n\tgetTransGifPath : function () {\n\t\tif (PREVIEW_DATA.authoringMode) {\n\t\t\t// Authoring mode for this file needs to be relative as it\'s in the theme folder\n\t\t\treturn \'resources/\';\n\t\t}\n\t\treturn this.strInterfaceImagePath;\n\t},\n\n\tcleanUpResourcePaths : function (domItem) {\n\t\tdomItem = domItem.replace(/resources\\/trans.gif\\?/g, this.getTransGifPath());\n\t\tvar _regBaseResourcesPath = new RegExp(ROOT_PATH, \'gi\');\n\t\tdomItem = domItem.replace(_regBaseResourcesPath, \'\');\n\t\treturn domItem;\n\t},\n\t\n\tsetCurrentRenderItem : function(_objWhatData)\n\t{\n\t\tif (_objWhatData)\n\t\t{\n\t\t\tthis.objCurrentRenderedItem = _objWhatData;\n\t\t}\n\t},\n\n\tgetImageProperties : function (_strWhatImageFilename)\n\t{\n\t\tif (window[\'VARIABLES_HOLDER\'])\n \t\t{\n \t\t\t//TODO: setup filename updates\n\t\t\t//_strWhatImageFilename = VARIABLES_HOLDER.getFilenameForMetaDataCheck(_strWhatImageFilename);\n \t\t}\n\t\t\n\t\t _strWhatImageFilename = decodeURIComponent(_strWhatImageFilename);\n\t\t \n\t\tif (this.objImageMetaDataHash[_strWhatImageFilename])\n\t\t{\n\t\t\treturn this.objImageMetaDataHash[_strWhatImageFilename];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (BOO_ALERT_MISSING_META_DATA)\n\t\t\t{\n\t\t\t\t//alert("ERROR: Unable to find image meta data for the file \'" + _strWhatImageFilename + "\', MASTER_RENDERER.getImageProperties() master_renderer.js");\n\t\t\t\tLOCALISER.l_alert("MASTER_RENDERER_MISSING_IMAGE_METADATA_WARNING", [_strWhatImageFilename]);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t},\n\n\tgetVideoProperties : function (_strWhatVideoFilename)\n\t{\n\t\tif (window[\'VARIABLES_HOLDER\'])\n \t\t{\n \t\t\t//TODO: setup filename updates\n            //_strWhatImageFilename = VARIABLES_HOLDER.getFilenameForMetaDataCheck(_strWhatImageFilename);\n \t\t}\n\n\t\tif (this.objVideoMetaDataHash[_strWhatVideoFilename])\n\t\t{\n\t\t\treturn this.objVideoMetaDataHash[_strWhatVideoFilename];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (BOO_ALERT_MISSING_META_DATA)\n\t\t\t{\n\t\t\t\talert("Missing Video metadata for " + _strWhatVideoFilename);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t},\n\n\tfixPNGs : function ()\n\t{\n\t\tif (/MSIE (\\d+\\.\\d+);/.test(navigator.userAgent))\n\t\t{\n\t\t\tvar count = 0;\n\t\t\tvar _arrImagesCollection = this.objDOM.getElementsByTagName("img");\n\t\t\twhile (count < _arrImagesCollection.length)\n\t\t\t{\n\t\t\t\tvar _domCurrImg = _arrImagesCollection[count];\n\t\t\t\tif (_domCurrImg.src.indexOf(".png") != -1)\n\t\t\t\t{\n\t\t\t\t\tthis._fixPNG(_domCurrImg)\n\t\t\t\t}\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t},\n\n\t//This will eventually rerender everything that may change on screenSize change\n\t_rerenderItems : function ()\n\t{\n\t\tif (this.objCurrentRenderedItem)\n\t\t{\n\t\t\tif (MOBILE_DRAWER_MENU && gomo.outputChecker.isSmartPhone()) {\n\t\t\t\tgomo.drawerMenu.buildMenu(this.objCurrentRenderedItem);\n\t\t\t} else {\n\t\t\t\tgomo.drawerMenu.removeMenuFromDom();\n\t\t\t\tTOP_STRAP_RENDERER.rerenderNav(this.objCurrentRenderedItem);\n\t\t\t\tBOTTOM_STRAP_RENDERER.rerenderNav(this.objCurrentRenderedItem);\n\t\t\t}\n\t\t\tSUB_SCREEN_RENDERER.rerenderSubScreen(this.objCurrentRenderedItem);\n\t\t\tEM.trigger(\'rebuiltNavMenu\', this.objCurrentRenderedItem);\n\t\t}\n\t},\n\n\t_fixPNG : function (_domWhatImage)\n\t{\n\t\t_domWhatImage.style.width = _domWhatImage.offsetWidth + "px";\n\t\t_domWhatImage.style.height = _domWhatImage.offsetHeight + "px";\n\t\t_domWhatImage.style.filter = "progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\'" + _domWhatImage.src + "\', sizingMethod=\'scale\')";\n\t\t_domWhatImage.src = "../images/trans.gif";\n\t},\n\n\t_parseIntoHashTable : function (_objWhatRawMetaData)\n\t{\n\t\tvar _objMetaDataHash = {};\n\t\tif (_objWhatRawMetaData)\n\t\t{\n\t\t\tvar _arrFiles = _objWhatRawMetaData;\n\t\t\tvar count = 0;\n\t\t\twhile (count < _arrFiles.length)\n\t\t\t{\n\t\t\t\tvar _objCurrData = _arrFiles[count];\n\t\t\t\tvar _strCurrFilename = _objCurrData[\'strFilename\'];\n\t\t\t\t_objMetaDataHash[_strCurrFilename] = _objCurrData;\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\telse if (BOO_ALERT_EMPTY_META_DATA)\n\t\t{\n\t\t\talert("WARNING: This course appears to have missing meta data. MASTER_RENDER._parseIntoHashTable().")\n\t\t}\n\t\treturn _objMetaDataHash;\n\t}\n}\n\nEM.register(MASTER_RENDERER);'},function(n,e,t){t(0)(t(97))},function(n,e){n.exports='/**\n* @title Topic Renderer\n* @description To be described.\n*\n*\n* @author GoMo\n* @version 2.0 17/12/12\n*/\n\nvar TOPIC_RENDERER =\n{\n\tstrObjID : "The topic renderer",\n\tstrObjDescription : "This object is responsible for determining the topic type, creating the screens and displaying the topic on the page.",\n\n\t_strTopicTemplateIDSuffix : "TopicWrapperC",\n\t_strTutorialMenuTemplateId: "tutorialTopicMenuC",\n\t_strTutorialMenuItemTemplateId: "tutorialTopicMenuItemC",\n\n\t_strTransitionTypeClassSuffix : "TransitionC",\n\n\t_objCurrData : null,\n\n\trenderTopic : function (_objWhatCourseData) {\n\t\tthis._objCurrData = _objWhatCourseData;\n\t\tvar _htmPageTemplate = TEMPLATE_MANANGER.getTemplate(_objWhatCourseData.strObjTopicModel + this._strTopicTemplateIDSuffix).htmData;\n\t\tif (MOBILE_DRAWER_MENU && gomo.outputChecker.isSmartPhone()) {\n\t\t\t_htmPageTemplate = _htmPageTemplate.replace("XX_TOP_STRAP_XX", \'\');\n\t\t\t_htmPageTemplate = _htmPageTemplate.replace("XX_TOPIC_NAV_XX", \'\');\n\t\t} else {\n\t\t\t_htmPageTemplate = _htmPageTemplate.replace("XX_TOP_STRAP_XX", this._getTopStrap());\n\t\t\t_htmPageTemplate = _htmPageTemplate.replace("XX_TOPIC_NAV_XX", this._getNavStrap());\n\t\t}\n\t\t_htmPageTemplate = _htmPageTemplate.replace("XX_SCREENS_XX", this._getScreens());\n\t\t_htmPageTemplate = _htmPageTemplate.replace("XX_ID_TYPE_XX", this._getIdType());\n\t\t_htmPageTemplate = _htmPageTemplate.replace("XX_META_TYPE_XX", this._getIdType());\n\n\t\tvar continuousScrolling = "";\n\t\tvar showLockedScreenPlaceholder = "";\n\t\tif(BOO_DYNAMIC_CONTINUOUS_SCROLLING){\n\t\t\tcontinuousScrolling = "continousScrolling";\n\t\t\t_htmPageTemplate = _htmPageTemplate.replace(/XX_TRANSITION_TYPE_CLASS_XX/g, CONTINUOUS_SCROLLING_TRANSITION_TYPE + this._strTransitionTypeClassSuffix);\n\n\t\t\tif (BOO_SHOW_LOCKED_SCREEN_PLACEHOLDER) {\n\t\t\t\tshowLockedScreenPlaceholder = "showLockedScreenPlaceholder"\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\t_htmPageTemplate = _htmPageTemplate.replace(/XX_TRANSITION_TYPE_CLASS_XX/g, STR_DYNAMIC_TRANSITION_TYPE + this._strTransitionTypeClassSuffix);\n\t\t}\n\n\t\t_htmPageTemplate = _htmPageTemplate.replace(/XX_CONINUOUS_SCROLLING_CLASS_XX/g, continuousScrolling);\n\t\t_htmPageTemplate = _htmPageTemplate.replace(/XX_SHOW_LOCKED_SCREEN_PLACEHOLDER_XX/g, showLockedScreenPlaceholder);\n\n\t\treturn _htmPageTemplate;\n\t},\n\n\t_getTopStrap : function ()\n\t{\n\t\tswitch (this._objCurrData.strObjType)\n\t\t{\n\t\t\tcase "topic":\n\t\t\t\treturn TOP_STRAP_RENDERER.getStrap(this._objCurrData);\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t//Meta Topic\n\t\t\t\treturn "";\n\t\t\tbreak;\n\t\t}\t\t\n\t},\n\n\t_getScreens : function ()\n\t{\n\t\tvar _htmScreenData = "";\n\t\tvar _arrScreenData = this._objCurrData.arrScreens;\n\t\tvar _objScreenData = {};\n\t\t\n\t\tfor(var i=0; i < _arrScreenData.length; i++) {\n\t\t\t_objScreenData = _arrScreenData[i];\n\t\t\t\t_htmScreenData += SCREEN_RENDERER.renderScreen(_objScreenData, i);\n\t\t}\n\n\t\treturn _htmScreenData;\n\t},\n\n\t_getNavStrap : function ()\n\t{\t\t\n\t\tswitch (this._objCurrData.strObjType)\n\t\t{\n\t\t\tcase "topic":\n\t\t\t\t//return "Nav strapping";\n\t\t\t\tEM.trigger(\'rebuildNavMenu\', this._objCurrData.strObjTopicModel);\n\t\t\t\treturn BOTTOM_STRAP_RENDERER.getStrap(this._objCurrData);\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t//Meta Topic\n\t\t\t\treturn "";\n\t\t\tbreak;\n\t\t}\n\t},\n\n\t_getIdType : function ()\n\t{\t\t\n\t\tswitch (this._objCurrData.strObjType)\n\t\t{\n\t\t\tcase "topic":\n\t\t\t\treturn "";\n\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t//Meta Topic\n\t\t\t\treturn this._objCurrData.strObjType;\n\t\t\tbreak;\n\t\t}\n\t},\n\n\tdebug : function (strMessage, intPriority, objCallerObject, booCalleeChain)\n\t{\n\t\tif (DEBUG)\n\t\t{\n\t\t\tDEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n\t\t}\n\t}\n}'},function(n,e,t){t(0)(t(99))},function(n,e){n.exports="/* global $, SCREEN_INTERACTIONS, STR_PAGE_SEPERATOR, EM, TEMPLATE_MANANGER, NavigationManager,\nMustache, NAVIGATION_SVG_ICONS, DEBUG, BOO_ACTIVE_PAGINATION_LINKS, BOO_SHOW_RELOAD_BUTTON,\nLOCALISER, USE_SPLIT_HEADER, EMPTY_CONTROL_WHITESPACE, SPLIT_HEADER_A_NAV_ITEMS,\nJOINT_CONTROL_BAR_HEADER, _ */\n\n/**\n * @title Top Strap Renderer\n * @description Renders the header navigation.\n *\n *\n * @author GoMo\n * @version 2.0 17/12/12\n */\n\nvar TOP_STRAP_RENDERER = {\n  strObjID: 'The top strap renderer',\n  strObjDescription: '',\n\n  _strMenuTopStrapTemplateIDSuffix: 'MenuTopStrapC',\n  _strTopicTopStrapTemplateIDSuffix: 'TopicTopStrapC',\n  _strReloadButtonClass: 'reloadPageButtonC',\n\n  _strPageNumSeperator: STR_PAGE_SEPERATOR,\n\n  _strapParentId: 'screenHolderL',\n  _strapStyleVisible: 'strapTop',\n  _strapStyleHidden: 'strapTopHidden',\n  _screenStrapVisibleStyle: 'hasTopStrap',\n  _screenSplitHeaderVisibleStyle: 'header--split',\n\n  _noOfSpaces: 5,\n\n  isVisible: false,\n\n  handleEvent_paginationAction: function(_objOptions) {\n    if (BOO_ACTIVE_PAGINATION_LINKS) {\n      var _objActionOptions = {};\n      _objActionOptions.objActions = [];\n      _objActionOptions.objActions[0] = {};\n      _objActionOptions.objActions[0].strActionGroup = 'navigation';\n      _objActionOptions.objActions[0].strType = _objOptions.strType;\n      _objActionOptions.objActions[0].objParameters = {};\n      _objActionOptions.objActions[0].objParameters.target_id = _objOptions.strAssetID;\n      _objActionOptions.objOptionalExtraData = {};\n      _objActionOptions.objOptionalExtraData.domLink = _objOptions.domLink;\n\n      EM.trigger('screenAssetInteracting');\n      EM.trigger('processActions', _objActionOptions);\n    }\n  },\n\n  getStrap: function(_objWhatCourseData) {\n    var me = this;\n    var _htmStrap = false;\n\n    // Hide strap until we have detrmined it needs to be shown!\n    me.isVisible = false;\n\n    switch (_objWhatCourseData.strObjType) {\n      case 'topic':\n        _htmStrap = this._getTopicStrap(_objWhatCourseData);\n        break;\n      default:\n        // Meta Topic\n        return '';\n    }\n    var reloadButton = '';\n    if (BOO_SHOW_RELOAD_BUTTON) {\n      reloadButton = TEMPLATE_MANANGER.getTemplate(this._strReloadButtonClass).htmData;\n      me.isVisible = true;\n    }\n    // Replace the reload page button\n    if (_htmStrap) {\n      _htmStrap = _htmStrap.replace('XX_RELOAD_PAGE_BUTTON_XX', reloadButton);\n    }\n\n    // Get controls for the header.\n    var toolbarData = {};\n    if (JOINT_CONTROL_BAR_HEADER) {\n      toolbarData.headerControls = me.getControls('top');\n      toolbarData.footerControls = me.getControls('bottom');\n    } else {\n      toolbarData = me.getControls('top');\n    }\n\n    // Render the header in the correct style.\n    if (\n      USE_SPLIT_HEADER &&\n      SPLIT_HEADER_A_NAV_ITEMS &&\n      toolbarData.controls &&\n      !gomo.outputChecker.isSmartPhone()\n    ) {\n      // Split header layout render for desktop and tablet.\n      _htmStrap = me.buildSplitHeader(toolbarData, _htmStrap);\n    } else if (\n      JOINT_CONTROL_BAR_HEADER &&\n      !gomo.outputChecker.isSmartPhone()\n    ) {\n      // Joint header and footer layout render for desktop and tablet.\n      _htmStrap = me.buildJointHeader(toolbarData);\n    } else {\n      // Regular style header layout render.\n      // Get the controls template for single header.\n      var toolbarHTML = TEMPLATE_MANANGER.getTemplate('controlsListTemplateC').htmData;\n      // Render the header.\n      toolbarHTML = Mustache.render(toolbarHTML, toolbarData);\n      _htmStrap = _htmStrap.replace(/XX_CONTROLS_XX/g, toolbarHTML);\n      _htmStrap = _htmStrap.replace(/XX_STRAP_STYLE_XX/g, this._getNavigationStrapStyle(me));\n    }\n\n    // Localise the nav.\n    if (_htmStrap && _htmStrap !=='') {\n      _htmStrap = LOCALISER.parseForLocalisableMarkup(_htmStrap);\n    }\n\n    return _htmStrap;\n  },\n\n  _getNavigationStrapStyle: function(that, toolbarGroup) {\n    var style = '';\n    if (that.isVisible) {\n      style += that._strapStyleVisible;\n    } else {\n      style += that._strapStyleHidden;\n    }\n\n    if (typeof NAVIGATION_SVG_ICONS !== 'undefined' && NAVIGATION_SVG_ICONS) {\n      style += ' svgIcons';\n    }\n\n    // Accessible mode is not available on mobile or tablet so add a class to help hide the header\n    // if the theme requires it.\n    if (\n      (gomo.outputChecker.isSmartPhone() || gomo.outputChecker.isTablet()) &&\n      toolbarGroup &&\n      toolbarGroup.controls &&\n      toolbarGroup.controls.length === 1 &&\n      toolbarGroup.controls[0].id === 'extra-accessible'\n    ) {\n      style += ' header--empty';\n    }\n    return style;\n  },\n\n  rerenderNav: function(objCurrentRenderedItem) {\n    var me = this;\n    if (SCREEN_INTERACTIONS.getCurrentScreenData()) {\n      EM.trigger('rebuildNavMenu', SCREEN_INTERACTIONS.getCurrentScreenData());\n    }\n\n    $('#reloadPageButtonHolderL').remove();\n\n    // Replace the top strap contents.\n    var newStrap = TOP_STRAP_RENDERER.getStrap(objCurrentRenderedItem);\n    var currentStrap = $('#topStrapL');\n    if ((USE_SPLIT_HEADER || JOINT_CONTROL_BAR_HEADER) && $('.header').length) {\n      if ($('.header').length === 1) {\n        $('.header').replaceWith(newStrap).html();\n      } else if ($('.header').length > 1) {\n        $('.header:last').remove();\n        $('.header:first').replaceWith(newStrap).html();\n      }\n    } else {\n      currentStrap.replaceWith(newStrap);\n    }\n\n    // Update progress count\n    if (typeof SCREEN_INTERACTIONS.getCurrentScreenData() !== 'undefined') {\n      EM.trigger('rebuiltNavMenu', SCREEN_INTERACTIONS.getCurrentScreenData().objParent);\n    }\n\n    // Set strap visibility.\n    var strapParent = $('#topStrapL').parent();\n    if ((JOINT_CONTROL_BAR_HEADER || USE_SPLIT_HEADER) && $('.header').length) {\n      strapParent = $('.header').parent();\n    }\n    var visibilityClass =\n      USE_SPLIT_HEADER && SPLIT_HEADER_A_NAV_ITEMS && !gomo.outputChecker.isSmartPhone()\n        ? me._screenSplitHeaderVisibleStyle\n        : me._screenStrapVisibleStyle;\n    if (me.isVisible) {\n      strapParent.addClass(visibilityClass);\n    } else {\n      strapParent.removeClass(visibilityClass);\n    }\n\n    var hasTouch = 'ontouchstart' in window;\n    if (!hasTouch) {\n      strapParent.addClass('noTouch');\n    }\n\n    EM.trigger('navigationRendered', 'top');\n  },\n\n  _getMenuStrap: function(_objWhatCourseData) {\n    var _htmNavStrap = TEMPLATE_MANANGER.getTemplate(\n      _objWhatCourseData.strObjType + this._strMenuTopStrapTemplateIDSuffix\n    ).htmData;\n    // Carry out further manipulations here as required\n    return _htmNavStrap;\n  },\n\n  _getTopicStrap: function(_objWhatCourseData) {\n    var _htmNavStrap = false;\n    if (USE_SPLIT_HEADER && SPLIT_HEADER_A_NAV_ITEMS && !gomo.outputChecker.isSmartPhone()) {\n      _htmNavStrap = TEMPLATE_MANANGER.getTemplate('splitHeaderPlaceholder').htmData;\n    } else {\n      _htmNavStrap = TEMPLATE_MANANGER.getTemplate(\n        _objWhatCourseData.strObjTopicModel + this._strTopicTopStrapTemplateIDSuffix\n      ).htmData;\n    }\n    return _htmNavStrap;\n  },\n\n  debugMsg: function(strMessage, intPriority, objCallerObject, booCalleeChain) {\n    if (DEBUG) {\n      DEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n    }\n  },\n\n  getControls: function(groupName) {\n    var me = this;\n    var toolbarGroup = NavigationManager.getNavigationGroupById(groupName);\n    var toolbarData = {controls: []};\n\n    // If we have a valid group\n    if (toolbarGroup && toolbarGroup.getControls) {\n      var index = 0;\n      var controls = toolbarGroup.getControls();\n      // Loop through until all spaces and fill them with controls!\n      while (toolbarData.controls.length < me._noOfSpaces) {\n        var html = '';\n        for (var i in controls) {\n          if (Object.prototype.hasOwnProperty.call(controls, i)) {\n            var control = controls[i];\n            if (\n              (control.position == 0 && !control.processed) ||\n              control.position == toolbarData.controls.length + 1\n            ) {\n              control.processed = true;\n              html = control.render();\n              me.isVisible = true;\n              break;\n            }\n          }\n        }\n        var whitespace = EMPTY_CONTROL_WHITESPACE ? '' : '&nbsp';\n        toolbarData.controls.push({\n          index: ++index,\n          prefix: 'top',\n          html: html || whitespace,\n          hidden: html ? false : true\n        });\n      }\n    }\n    return toolbarData;\n  },\n\n  buildSplitHeader: function(toolbarData, _htmStrap) {\n    var headerAData = {\n      id: 'a',\n      controls: false\n    };\n    var headerBData = {\n      id: 'b',\n      controls: false\n    };\n    var headerAControls = [];\n    var headerBControls = [];\n    // Build arrays of controls for each header. Ignore empty controls.\n    for (var x=0; x<toolbarData.controls.length; x++) {\n      if (x < SPLIT_HEADER_A_NAV_ITEMS) {\n        if (toolbarData.controls[x].html !== '') {\n          headerAControls.push(toolbarData.controls[x]);\n        }\n      }\n      if (x >= SPLIT_HEADER_A_NAV_ITEMS) {\n        if (toolbarData.controls[x].html !== '') {\n          headerBControls.push(toolbarData.controls[x]);\n        }\n      }\n    }\n\n    // Add controls to header data ready for render.\n    if (headerAControls.length) {\n      headerAData.controls = headerAControls;\n    }\n    if (headerBControls.length) {\n      headerBData.controls = headerBControls;\n    }\n\n    // Get split header template.\n    var splitHeaderTemplate = TEMPLATE_MANANGER.getTemplate('splitHeader').htmData;\n    // Render the headers if they have controls.\n    var headerA = '';\n    var headerB = '';\n    if (headerAData.controls) {\n      headerA = Mustache.render(splitHeaderTemplate, headerAData);\n      _htmStrap = headerA;\n    }\n    if (headerBData.controls) {\n      headerB = Mustache.render(splitHeaderTemplate, headerBData);\n      _htmStrap += headerB;\n    }\n    return _htmStrap;\n  },\n\n  buildJointHeader: function(toolbarData) {\n    if (!toolbarData) return '';\n    // Get joint header template.\n    var jointHeaderTemplate = TEMPLATE_MANANGER.getTemplate('jointHeader').htmData;\n    // Render the joint header.\n    var headerData = {\n      hasHeaderControls: false,\n      hasFooterControls: false,\n      headerHidden: false\n    };\n    if (\n      toolbarData &&\n      toolbarData.headerControls &&\n      toolbarData.headerControls.controls &&\n      toolbarData.headerControls.controls.length\n    ) {\n      headerData.headerControls = toolbarData.headerControls.controls;\n      headerData.hasHeaderControls = true;\n    }\n    if (\n      toolbarData &&\n      toolbarData.footerControls &&\n      toolbarData.footerControls.controls &&\n      toolbarData.footerControls.controls.length\n    ) {\n      headerData.footerControls = toolbarData.footerControls.controls;\n      headerData.hasFooterControls = true;\n    }\n\n    headerData.headerHidden =\n      typeof _.find(headerData.headerControls, {hidden: false}) === 'undefined' &&\n      typeof _.find(headerData.footerControls, {hidden: false}) === 'undefined';\n\n    return Mustache.render(jointHeaderTemplate, headerData);\n  }\n};\n\nEM.register(TOP_STRAP_RENDERER);\n"},function(n,e,t){t(0)(t(101))},function(n,e){n.exports="/* global $, jQuery, SCREEN_INTERACTIONS, STR_PAGE_SEPERATOR, CONTINUOUS_SCROLLING_TRANSITION_TYPE,\nSTR_DYNAMIC_TRANSITION_TYPE, EM, BOO_DYNAMIC_CONTINUOUS_SCROLLING, CORE, TOPIC_INTERACTIONS,\nTEMPLATE_MANANGER, NavigationManager, Mustache, NAVIGATION_SVG_ICONS, DEBUG, FOOTER_LOGO,\nSIMPLE_FOOTER_NAV, LOCALISER, FLOATING_FOOTER, EMPTY_CONTROL_WHITESPACE, JOINT_CONTROL_BAR_HEADER */\n\n/**\n* @title Bottom Strap Renderer\n* @description Renders the footer navigation.\n*\n*\n* @author GoMo\n* @version 2.0 17/12/12\n*/\n\nvar BOTTOM_STRAP_RENDERER =\n{\n  strObjID: 'The bottom strap renderer',\n  strObjDescription: '',\n\n  _strNavTemplateTemplaceID: 'navWrapperTemplateC',\n  _strNavWithNoFooterTemplaceID: 'navWrapperWithNoFooterTemplateC',\n  _strPageNumSeperator: STR_PAGE_SEPERATOR,\n  _strTransitionTypeClassSuffix: 'TransitionC',\n\n  _strapStyleVisible: 'strapBottom',\n  _strapStyleHidden: 'strapBottomHidden',\n  _screenStrapVisibleStyle: 'hasBottomStrap',\n  _screenFloatingFooterStyle: 'footer--floating',\n\n  _noOfSpaces: 5,\n\n  isVisible: false,\n\n  handleEvent_preNavigate: function() {\n  },\n\n  getStrap: function(_objWhatCourseData) {\n    var _strNavTypePreffix = _objWhatCourseData.strObjTopicModel + 'Topic';\n    var _strComponentDataKey = _objWhatCourseData.strObjTopicModel;\n\n    var _htmNavigationStrap = this._getNavigationStrap(\n      _objWhatCourseData,\n      _strNavTypePreffix,\n      _strComponentDataKey\n    );\n\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n      _htmNavigationStrap = _htmNavigationStrap.replace(\n        /XX_TRANSITION_TYPE_CLASS_XX/g,\n        CONTINUOUS_SCROLLING_TRANSITION_TYPE + this._strTransitionTypeClassSuffix\n      );\n    } else {\n      _htmNavigationStrap = _htmNavigationStrap.replace(\n        /XX_TRANSITION_TYPE_CLASS_XX/g,\n        STR_DYNAMIC_TRANSITION_TYPE + this._strTransitionTypeClassSuffix\n      );\n    }\n    return _htmNavigationStrap;\n  },\n\n  rerenderNav: function(objCurrentRenderedItem) {\n    var me = this;\n    if (SCREEN_INTERACTIONS.getCurrentScreenData()) {\n      EM.trigger('rebuildNavMenu', SCREEN_INTERACTIONS.getCurrentScreenData());\n    }\n\n    jQuery('#roleNavigationButtonWrapperL').remove();\n\n    var strap = $('#navWrapperL');\n    var strapParent = strap.parent();\n    strap.replaceWith(\n      me.getStrap(objCurrentRenderedItem)\n    );\n\n    // Update progress count\n    if (typeof SCREEN_INTERACTIONS.getCurrentScreenData() !== 'undefined') {\n      EM.trigger('rebuiltNavMenu', SCREEN_INTERACTIONS.getCurrentScreenData().objParent);\n    }\n\n    // Inform parent of strap visibility.\n    var visibilityClass =\n      FLOATING_FOOTER && !gomo.outputChecker.isSmartPhone()\n        ? me._screenFloatingFooterStyle\n        : me._screenStrapVisibleStyle;\n    if (me.isVisible && !JOINT_CONTROL_BAR_HEADER) {\n      strapParent.addClass(visibilityClass);\n    } else {\n      strapParent.removeClass(visibilityClass);\n    }\n\n    var hasTouch = 'ontouchstart' in window;\n    if (!hasTouch) {\n      strap.addClass('noTouch');\n    }\n\n    var _intCurrentScreen = CORE.objCurrCourseObject.intNavigationIndex + 1;\n    var _objScreenId = CORE.objCurrCourseObject.arrScreens[_intCurrentScreen - 1].strObjID;\n\n    TOPIC_INTERACTIONS.updateNavigation(\n      _intCurrentScreen,\n      CORE.objCurrCourseObject.arrScreens.length,\n      _objScreenId\n    );\n    EM.trigger('navigationRendered', 'bottom');\n  },\n\n  _getNavigationStrap: function(_objWhatCourseData, _strWhatNavClassPrefix, _strComponentDataKey) {\n    var me = this;\n    me.isVisible = false;\n    var _htmNavStrap = '';\n\n    // If using the joint header we don't need to render a footer, just the screen nav.\n    var templateID =\n      JOINT_CONTROL_BAR_HEADER ?\n        this._strNavWithNoFooterTemplaceID :\n        this._strNavTemplateTemplaceID;\n\n    _htmNavStrap = TEMPLATE_MANANGER.getTemplate(templateID).htmData;\n\n    // Build the screen navigation. Back and next.\n    var screenNav = NavigationManager.getNavigationGroupById('screen');\n    var screenNavHTML = '';\n    if (screenNav && screenNav.renderControls) {\n      screenNavHTML = screenNav.renderControlsByType('screen_navigation');\n    }\n\n    // Build the footer controls  if they are required.\n    if (!JOINT_CONTROL_BAR_HEADER) {\n      var toolbarGroup = NavigationManager.getNavigationGroupById('bottom');\n      var toolbarData = {controls: []};\n\n      // If we have a valid group\n      if (toolbarGroup && toolbarGroup.getControls) {\n        var index = 0;\n        var controls = toolbarGroup.getControls();\n        // Loop through until all spaces and fill them with controls!\n        while (toolbarData.controls.length < me._noOfSpaces) {\n          var html = '';\n          for (var i in controls) {\n            if (Object.prototype.hasOwnProperty.call(controls, i)) {\n              var control = controls[i];\n              if (\n                (control.position == 0 && !control.processed) ||\n                control.position == toolbarData.controls.length+1\n              ) {\n                control.processed = true;\n                html = control.render();\n                me.isVisible = true;\n                break;\n              }\n            }\n          }\n          index++;\n          var whitespace = EMPTY_CONTROL_WHITESPACE ? '' : '&nbsp';\n          toolbarData.controls.push({\n            containerStart: (\n              index == 2 && FOOTER_LOGO === 'none' && !SIMPLE_FOOTER_NAV ? 'originalSpacer' : ''\n            ),\n            containerEnd: (index == me._noOfSpaces),\n            index: index,\n            prefix: 'bottom',\n            html: html || whitespace,\n            hidden: html ? false : true\n          });\n        }\n      }\n\n      // Render the footer and screen navigation.\n      var toolbarHTML = TEMPLATE_MANANGER.getTemplate('controlsListTemplateC').htmData;\n      toolbarHTML = Mustache.render(toolbarHTML, toolbarData);\n      _htmNavStrap = _htmNavStrap.replace(/XX_SCREEN_NAVIGATION_XX/g, screenNavHTML);\n      _htmNavStrap = _htmNavStrap.replace('XX_CONTROLS_XX', toolbarHTML);\n      _htmNavStrap = _htmNavStrap.replace(/XX_NAVIGATION_TYPE_XX/g, _strWhatNavClassPrefix);\n      _htmNavStrap = _htmNavStrap.replace(\n        /XX_STRAP_STYLE_XX/g, this._getNavigationStrapStyle(me, toolbarGroup)\n      );\n    } else {\n      // The joint header is in use so render screen nav only.\n      me.isVisible = true;\n      var screenNavData = {\n        screenNavHtml: screenNavHTML\n      };\n      _htmNavStrap = Mustache.render(_htmNavStrap, screenNavData);\n    }\n\n    // Localise the nav\n    _htmNavStrap = LOCALISER.parseForLocalisableMarkup(_htmNavStrap);\n\n    return _htmNavStrap;\n  },\n\n  _getNavigationStrapStyle: function(that, toolbarGroup) {\n    var style = '';\n    if (that.isVisible) {\n      style += that._strapStyleVisible;\n    } else {\n      style += that._strapStyleHidden;\n    }\n\n    if (typeof NAVIGATION_SVG_ICONS !== 'undefined' && NAVIGATION_SVG_ICONS) {\n      style += ' svgIcons';\n    }\n\n    // Accessible mode is not available on mobile or tablet so add a class to help hide the footer\n    // if the theme requires it.\n    if (\n      (gomo.outputChecker.isSmartPhone() || gomo.outputChecker.isTablet()) &&\n      toolbarGroup &&\n      toolbarGroup.controls &&\n      toolbarGroup.controls.length === 1 &&\n      toolbarGroup.controls[0].id === 'extra-accessible'\n    ) {\n      style += ' footer--empty';\n    }\n    return style;\n  },\n\n  debugMsg: function(strMessage, intPriority, objCallerObject, booCalleeChain) {\n    if (DEBUG) {\n      DEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n    }\n  }\n};\n\nif (window['EM']) {\n  EM.register(BOTTOM_STRAP_RENDERER);\n}\n"},function(n,e,t){t(0)(t(103))},function(n,e){n.exports="/* globals OUTPUT_MODE_CHECKER, BOO_SHOW_SCREEN_ID, ASSET_INTERACTIONS, EM,\nSCREEN_INTERACTIONS, BOO_SHOW_TOPIC_TITLE, BOO_SHOW_SCREEN_TITLE_MENUTOPIC,\nTOP_STRAP_RENDERER, SUB_SCREEN_RENDERER, DEBUG, CORE, BOO_SHOW_SCREEN_TITLE_PRIMARYTOPIC,\nBOO_SHOW_TOPIC_TITLE_PRIMARYTOPIC, BOO_SHOW_SCREEN_TITLE, BOO_SHOW_TOPIC_TITLE_MENUTOPIC,\nBOO_DYNAMIC_CONTINUOUS_SCROLLING, TEMPLATE_MANANGER, LAYOUT_RENDERER, ASSET_RENDERER,\nBOO_TILE_SCREEN_BACKGROUNDS, _, BOO_SHOW_SCREEN_TITLE_OUTSIDE_CONTENT\n */\n/**\n * @title Screen Renderer\n * @description This object is responsible for determining the content screen type, retreiving the\n * relevant HTML fragaments and populating said content screen with the data object passed to it.\n * NOTE: The 'screen type' in this instance doesn't refer to normal template types, but the\n * topic type.\n *\n * @author GoMo\n * @version 2.0 17/12/12\n */\n\nvar SCREEN_RENDERER = {\n  strObjID: 'The screen renderer',\n  strObjDescription:\n    'This object is responsible for determining the content screen type, retreiving the relevant' +\n    'HTML fragaments and populating said content screen with the data object passed to it.' +\n    'NOTE: The \\'screen type\\' in this instance doesn\\'t refer to normal template types, but the' +\n    'topic type.',\n\n  _strScreenTemplateIDSuffix: 'ScreenWrapperC',\n  _strLockedScreenTemplateIDSuffix: 'LockedScreenContentC',\n  _strHiddenScreenIDClass: 'hiddenScreenIDC',\n  _strRowTemplate: 'standardRowC',\n  _strFirstRowTemplate: 'firstRowC',\n  _strFirstRowWithTitleTemplate: 'firstRowWithTitleC',\n  _strBlankScreenColumnTemplate: 'blankScreenColumnC',\n  _strBlankScreenColumnWithTitleTemplate: 'blankScreenColumnWithTitleC',\n  _strColumnTemplate: 'standardColumnC',\n  _strFirstColumnTemplate: 'firstColumnC',\n  _strFirstColumnOfFirstRowNoScreenTitleTemplate: 'firstColumnOfFirstRowNoScreenTitleC',\n  _strFirstColumnOfFirstRowTemplate: 'firstColumnOfFirstRowC',\n  _objColumnTypePrefixs: {1: 'one', 2: 'two', 3: 'three', 4: 'four', 5: 'five', 6: 'six'},\n  _strColumnTypeSuffix: 'ColumnScreenC',\n\n  _strCompletableScreenClass: 'completableScreenC',\n  _strNonCompletableScreenClass: 'nonCompletableScreenC',\n\n  _strDisplayedScreenClass: 'displayedScreenMarkerC',\n  _strHiddenScreenClass: 'hiddenScreenMarkerC',\n\n  _objCurrScreenData: null,\n\n  _strCurrOutputModeClass: OUTPUT_MODE_CHECKER.strCurrentMode,\n\n  _objColumnUsageByMode: {graphicalC: true, accessibleC: true, tabletC: true, smartphoneC: false},\n\n  handleEvent_outputModeChanged: function(_objOutputChangeData) {\n    this._strCurrOutputModeClass = _objOutputChangeData['strNewOutputMode'];\n  },\n\n  renderScreen: function(_objWhatScreenCourseObject, _intPageIndex) {\n    this._objCurrScreenData = _objWhatScreenCourseObject;\n    var _strTopicType = _objWhatScreenCourseObject.objParent.strObjTopicModel;\n    var _htmScreenTemplate = TEMPLATE_MANANGER.getTemplate(\n      _strTopicType + this._strScreenTemplateIDSuffix\n    ).htmData;\n    _htmScreenTemplate = _htmScreenTemplate.replace(\n      /XX_SCREEN_ID_XX/g,\n      this._objCurrScreenData.strObjID\n    );\n\n    if (BOO_SHOW_SCREEN_ID) {\n      _htmScreenTemplate = _htmScreenTemplate.replace('XX_SCREEN_ID_VISIBILITY_XX', '');\n    } else {\n      _htmScreenTemplate = _htmScreenTemplate.replace(\n        'XX_SCREEN_ID_VISIBILITY_XX',\n        this._strHiddenScreenIDClass\n      );\n    }\n\n    if (this._objCurrScreenData.booIsDisplayed) {\n      var strBackgroundColour = '';\n      var strBackgroundOpacity = 1;\n      if (_objWhatScreenCourseObject.objRawData.strScreenBackgroundColor) {\n        strBackgroundColour = _objWhatScreenCourseObject.objRawData.strScreenBackgroundColor;\n      }\n      if (_objWhatScreenCourseObject.objRawData.strBackgroundOpacity) {\n        strBackgroundOpacity = parseFloat(\n          _objWhatScreenCourseObject.objRawData.strBackgroundOpacity\n        );\n      }\n\n      this._objCurrScreenData.strBackgroundImg = this._getScreenRawBackgroundImgURL(\n        _objWhatScreenCourseObject\n      );\n      this._objCurrScreenData.strBackgroundColour = strBackgroundColour;\n      this._objCurrScreenData.strBackgroundOpacity = strBackgroundOpacity;\n      this._objCurrScreenData.objVideo = this._getScreenBackgroundVideo(_objWhatScreenCourseObject);\n\n      // Update background images for continuous scrolling\n      if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n        var opts = {forceTitledBackgroundImgs: true, disableStyleDefinition: false};\n\n        var backgroundStyle = this.getScreenBackgroundCSS(this._objCurrScreenData, opts);\n        if (!backgroundStyle) {\n          backgroundStyle = '';\n        }\n        /* Sorry for this method. IE8/9 won't let you add style=\"\" to an element without a valid\n        * (arbitrary) style.\n        * So the iframed element is cleaned up and unusable. We have to set a class name which we\n        * remove and close the classname string off after. JH\n        * */\n        _htmScreenTemplate = _htmScreenTemplate.replace(\n          'XX_OPTIONAL_BACKGROUND_STYLE_XX\"',\n          '\" ' + backgroundStyle\n        );\n      } else {\n        _htmScreenTemplate = _htmScreenTemplate.replace('XX_OPTIONAL_BACKGROUND_STYLE_XX\"', '\"');\n      }\n      // Update background videos for continuous scrolling\n      if (\n        BOO_DYNAMIC_CONTINUOUS_SCROLLING &&\n        this._objCurrScreenData.objVideo &&\n        SCREEN_INTERACTIONS._canPlayVideoBackground(this._objCurrScreenData.objVideo)\n      ) {\n        var videoBackground = this.setBackgroundVideo(\n          this._objCurrScreenData,\n          this._objCurrScreenData.strObjID\n        );\n        if (_intPageIndex === 0 && !CORE.booCourseInteractedWith) {\n          videoBackground = videoBackground.replace('video', 'video muted');\n        }\n        _htmScreenTemplate = _htmScreenTemplate.replace(\n          'XX_SCREEN_VIDEO_BACKGROUND_XX',\n          videoBackground\n        );\n      } else {\n        _htmScreenTemplate = _htmScreenTemplate.replace('XX_SCREEN_VIDEO_BACKGROUND_XX', '');\n      }\n      // ### OVERRIDE in favour of new layout system\n      var _htmScreenContents = '';\n      if (this._objCurrScreenData.arrChildLayouts) {\n        var count = 0;\n        while (count < this._objCurrScreenData.arrChildLayouts.length) {\n          var _objCurrLayoutWrapper = this._objCurrScreenData.arrChildLayouts[count];\n          _htmScreenContents += LAYOUT_RENDERER.renderLayoutBlock(\n            _objCurrLayoutWrapper,\n            this._objCurrScreenData,\n            false,\n            count\n          );\n          count++;\n        }\n        var _objScreenContent = {\n          htmMainScreenContent: _htmScreenContents,\n          htmSubScreenContent: this._getSubScreens()\n        };\n      }\n      count = 0;\n      var _htmScreenNonColumnContents = '';\n\n      if (this._objCurrScreenData.objParent.strObjTopicModel != 'meta') {\n        _objScreenContent['htmNonColumnScreenContent'] = _htmScreenNonColumnContents;\n        _htmScreenTemplate = _htmScreenTemplate.replace(\n          'XX_NON_COLUMN_SCREEN_CONTENT_XX',\n          _objScreenContent['htmNonColumnScreenContent']\n        );\n      }\n      while (count < this._objCurrScreenData.arrAssets.length) {\n        _htmScreenNonColumnContents += ASSET_RENDERER.renderNonColumnAsset(\n          this._objCurrScreenData.arrAssets[count],\n          false\n        );\n        count++;\n      }\n\n      _htmScreenTemplate = _htmScreenTemplate.replace(\n        'XX_DISPLAY_CONDITION_STATE_XX',\n        this._strDisplayedScreenClass\n      );\n      _htmScreenTemplate = _htmScreenTemplate.replace(\n        'XX_SCREEN_CONTENT_XX',\n        _objScreenContent['htmMainScreenContent']\n      );\n      _htmScreenTemplate = _htmScreenTemplate.replace(\n        'XX_SUB_SCREEN_CONTENT_XX',\n        this._renderSubScreenCollection(_objScreenContent['htmSubScreenContent'])\n      );\n      _htmScreenTemplate = this._renderTitle(_htmScreenTemplate, _intPageIndex);\n\n      var developerClass = '';\n      if (\n        _objWhatScreenCourseObject.objRawData.objDeveloperOptions &&\n        _objWhatScreenCourseObject.objRawData.objDeveloperOptions.objAdvancedStyling &&\n        _objWhatScreenCourseObject.objRawData.objDeveloperOptions.objAdvancedStyling\n          .strCustomCSSClasses\n      ) {\n        developerClass =\n          _objWhatScreenCourseObject.objRawData.objDeveloperOptions.objAdvancedStyling\n            .strCustomCSSClasses;\n      }\n      _htmScreenTemplate = _htmScreenTemplate.replace('XX_DEVELOPER_CLASS_XX', developerClass);\n    } else {\n      _htmScreenTemplate = _htmScreenTemplate.replace(\n        'XX_DISPLAY_CONDITION_STATE_XX',\n        this._strHiddenScreenClass\n      );\n\n      var _htmHiddenScreenContent = TEMPLATE_MANANGER.getTemplate(\n        _strTopicType + this._strLockedScreenTemplateIDSuffix\n      ).htmData;\n\n      _htmHiddenScreenContent = _htmHiddenScreenContent.replace(\n        'XX_LOCKED_SCREEN_MESSAGE_XX', gomo.localiser.get('LOCKED_SCREEN_MESSAGE')\n      );\n\n      _htmScreenTemplate = _htmScreenTemplate.replace('XX_SCREEN_VIDEO_BACKGROUND_XX', '');\n      _htmScreenTemplate = _htmScreenTemplate.replace('XX_NON_COLUMN_SCREEN_CONTENT_XX', '');\n      _htmScreenTemplate = _htmScreenTemplate.replace('XX_NON_CONTENT_SCREENTITLE_XX', '');\n      _htmScreenTemplate = _htmScreenTemplate.replace(\n        'XX_SCREEN_CONTENT_XX', _htmHiddenScreenContent\n      );\n      _htmScreenTemplate = _htmScreenTemplate.replace('XX_SUB_SCREEN_CONTENT_XX', '');\n    }\n\n    var _booIsCompletableScreen = this.getCompletableStatus(this._objCurrScreenData);\n    // store for subscreen use later\n    this._objCurrScreenData.booIsCompletableScreen = _booIsCompletableScreen;\n    if (_booIsCompletableScreen) {\n      _htmScreenTemplate = _htmScreenTemplate.replace(\n        'XX_IS_COMPLETABLE_SCREEN_XX',\n        this._strCompletableScreenClass\n      );\n    } else {\n      _htmScreenTemplate = _htmScreenTemplate.replace(\n        'XX_IS_COMPLETABLE_SCREEN_XX',\n        this._strNonCompletableScreenClass\n      );\n    }\n\n    return _htmScreenTemplate;\n  },\n\n  getScreenBackgroundCSS: function(_objWhatScreenCourseObject, opts) {\n    var _booCssOverride = false;\n    var _strBackgroundImg = this._getScreenstrBackgroundImg(_objWhatScreenCourseObject);\n    var _strBackgroundColour = '';\n    var _strBackgroundOpacity = 1;\n\n    var disableStyleDefinition = false;\n    var forceTitledBackgroundImgs = false;\n    if (opts) {\n      if (opts.disableStyleDefinition) {\n        disableStyleDefinition = opts.disableStyleDefinition;\n      }\n      if (opts.forceTitledBackgroundImgs) {\n        forceTitledBackgroundImgs = opts.forceTitledBackgroundImgs;\n      }\n    }\n\n    if (_objWhatScreenCourseObject.objRawData.strScreenBackgroundColor) {\n      _strBackgroundColour = _objWhatScreenCourseObject.objRawData.strScreenBackgroundColor;\n    }\n\n    if (_objWhatScreenCourseObject.objRawData.strBackgroundOpacity) {\n      _strBackgroundOpacity = parseFloat(\n        _objWhatScreenCourseObject.objRawData.strBackgroundOpacity\n      );\n    } else {\n      _strBackgroundOpacity = 1;\n    }\n\n    var _strBackgroundCSS = 'style=\\'';\n    if (disableStyleDefinition) {\n      _strBackgroundCSS = '';\n    }\n\n    _strBackgroundCSS += _strBackgroundImg;\n\n    if (\n      _objWhatScreenCourseObject.objRawData.objNormalBackgroundSrc &&\n      _objWhatScreenCourseObject.objRawData.objNormalBackgroundSrc.strSrc &&\n      _objWhatScreenCourseObject.objRawData.objNormalBackgroundSrc.strSrc != ''\n    ) {\n      if (!BOO_TILE_SCREEN_BACKGROUNDS && !forceTitledBackgroundImgs) {\n        _strBackgroundCSS += 'background-repeat:no-repeat;';\n      }\n      _booCssOverride = true;\n    }\n\n    // Remove the default bg color. We do this because if it's an opacity of 1 then LESS will\n    // convert it to a value which IE8 will render along with the ms-filter.\n    if (_strBackgroundColour != '' || _strBackgroundImg != '') {\n      if (\n        OUTPUT_MODE_CHECKER.strWhatBrowserTypeClass == 'ie8C' ||\n        OUTPUT_MODE_CHECKER.strWhatBrowserTypeClass == 'ie8CompatibilityModeC'\n      ) {\n        _strBackgroundCSS += 'background-color:transparent;';\n      }\n    }\n\n    if (_strBackgroundColour != '') {\n      if (\n        OUTPUT_MODE_CHECKER.strWhatBrowserTypeClass == 'ie8C' ||\n        OUTPUT_MODE_CHECKER.strWhatBrowserTypeClass == 'ie8CompatibilityModeC'\n      ) {\n        var _strComponentColour = CORE.hexToRgb(_strBackgroundColour);\n        var _arrColourSplit = _strComponentColour.split(',');\n        var _intComponentRangedOpacity = Math.round(255 * _strBackgroundOpacity);\n        var _strRGBAasHex = CORE.rgbToHex(\n          _arrColourSplit[0],\n          _arrColourSplit[1],\n          _arrColourSplit[2],\n          _intComponentRangedOpacity\n        );\n        _strBackgroundCSS +=\n          '-ms-filter: \"progid:DXImageTransform.Microsoft.gradient(startColorstr=' +\n          _strRGBAasHex +\n          ', endColorstr=' +\n          _strRGBAasHex +\n          ');\"';\n      } else {\n        var _strColour = CORE.hexToRgb(_strBackgroundColour);\n        _strBackgroundCSS +=\n          'background-color:rgba(' + _strColour + ', ' + _strBackgroundOpacity + ');';\n      }\n\n      _booCssOverride = true;\n    }\n\n    if (_booCssOverride) {\n      if (!disableStyleDefinition) {\n        _strBackgroundCSS += '\\'';\n      }\n      return _strBackgroundCSS;\n    } else {\n      return false;\n    }\n  },\n\n  getCompletableStatus: function(_objWhatScreenData) {\n    var _arrScreenAssets = _objWhatScreenData.arrAssets;\n    var count = 0;\n    var _booFoundCompletableAsset = false;\n    while (count < _arrScreenAssets.length) {\n      var _objCurrAsset = _arrScreenAssets[count];\n      var _strAssetType = _objCurrAsset.strAssetType;\n      var _booIsCurrentAssetCompletable = false;\n\n      if (gomo.assetManager.isRegistered(_strAssetType)) {\n        var asset = gomo.assetManager.findInstance(_objCurrAsset.strObjID);\n        if (asset) {\n          _booIsCurrentAssetCompletable = asset.isCompletable();\n        }\n      } else {\n        if (ASSET_INTERACTIONS['is_' + _strAssetType + '_AssetCompletable']) {\n          _booIsCurrentAssetCompletable = ASSET_INTERACTIONS[\n            'is_' + _strAssetType + '_AssetCompletable'\n          ](_objCurrAsset);\n        }\n      }\n\n      if (_booIsCurrentAssetCompletable) {\n        _booFoundCompletableAsset = true;\n        break;\n      }\n      count++;\n    }\n\n    // Check the subscreens, not technically required currently but subscreens might be triggered\n    // by an extra or some other process.\n    if (!_booFoundCompletableAsset && _objWhatScreenData.arrSubScreens) {\n      var _arrSubScreens = _objWhatScreenData.arrSubScreens;\n      count = 0;\n      while (count < _arrSubScreens.length) {\n        var _objCurrSubScreen = _arrSubScreens[count];\n        var _booSubScreenContainsCompletableAsset = this.getCompletableStatus(_objCurrSubScreen);\n        if (_booSubScreenContainsCompletableAsset) {\n          _booFoundCompletableAsset = true;\n          break;\n        }\n        count++;\n      }\n    }\n    return _booFoundCompletableAsset;\n  },\n\n  _renderTitle: function(_htmScreenTemplate, _intPageIndex) {\n    var _htmScreenTitle = this._getScreenTitle(_intPageIndex);\n    if (_htmScreenTitle) {\n      if (BOO_SHOW_SCREEN_TITLE_OUTSIDE_CONTENT) {\n        var _htmTitleTemplate = TEMPLATE_MANANGER.getTemplate('nonScreenContentHeaderC').htmData;\n        _htmTitleTemplate = _htmTitleTemplate.replace('XX_SCREEN_TITLE_XX', _htmScreenTitle);\n        _htmScreenTemplate = _htmScreenTemplate.replace(\n          'XX_NON_CONTENT_SCREENTITLE_XX',\n          _htmTitleTemplate\n        );\n        _htmScreenTemplate = _htmScreenTemplate.replace(\n          'XX_SCREEN_TITLE_VISIBILITY_XX',\n          'hiddenElementC'\n        );\n      } else {\n        _htmScreenTemplate = _htmScreenTemplate.replace('XX_NON_CONTENT_SCREENTITLE_XX', '');\n        _htmScreenTemplate = _htmScreenTemplate.replace('XX_SCREEN_TITLE_XX', _htmScreenTitle);\n        _htmScreenTemplate = _htmScreenTemplate.replace('XX_SCREEN_TITLE_VISIBILITY_XX', '');\n      }\n    } else {\n      _htmScreenTemplate = _htmScreenTemplate.replace(\n        'XX_SCREEN_TITLE_VISIBILITY_XX',\n        'hiddenElementC'\n      );\n      _htmScreenTemplate = _htmScreenTemplate.replace('XX_NON_CONTENT_SCREENTITLE_XX', '');\n    }\n\n    return _htmScreenTemplate;\n  },\n\n  _renderSubScreenCollection: function(_domSubscreenContent) {\n    if (_domSubscreenContent != 'undefined') {\n      return _domSubscreenContent;\n    } else {\n      return '';\n    }\n  },\n\n  _getScreenTitle: function(_intPageIndex) {\n    var _strTopicId = this._objCurrScreenData.objParent.strObjID;\n    var _strScreenId = this._objCurrScreenData.strObjID;\n    var _booShowTopicTitle = false;\n    var _booShowScreenTitle = false;\n    var _htmScreenTitle = '';\n\n    // Is Primary Topic\n    if (_strTopicId === CORE.objPrimaryTopicLoader.strTopicID) {\n      if (BOO_SHOW_TOPIC_TITLE_PRIMARYTOPIC) {\n        _booShowTopicTitle = true;\n      }\n\n      if (BOO_SHOW_SCREEN_TITLE_PRIMARYTOPIC) {\n        _booShowScreenTitle = true;\n      }\n    } else if (_strTopicId === CORE.objMenuLoader.strTopicID) {\n      // Is Menu Topic\n      if (BOO_SHOW_TOPIC_TITLE_MENUTOPIC) {\n        _booShowTopicTitle = true;\n      }\n\n      if (BOO_SHOW_SCREEN_TITLE_MENUTOPIC) {\n        _booShowScreenTitle = true;\n      }\n    } else {\n      // Is generic Topic\n      if (BOO_SHOW_TOPIC_TITLE) {\n        _booShowTopicTitle = true;\n      }\n\n      if (BOO_SHOW_SCREEN_TITLE) {\n        _booShowScreenTitle = true;\n      }\n    }\n\n    if (_booShowTopicTitle) {\n      _htmScreenTitle +=\n        '<div id=\\'topicTitleId_' +\n        _strScreenId +\n        '\\' class=\\'topicTitleC\\' data-bind=\\'gomotext: strTitle\\'>' +\n        this._objCurrScreenData.objParent.strTitle +\n        '</div>';\n      gomo.translationManager.setScreenElement(\n        'topicTitleId_' + _strScreenId,\n        _strTopicId,\n        {strTitle: this._objCurrScreenData.objParent.strTitle},\n        'topic'\n      );\n    }\n    if (_booShowScreenTitle) {\n      _htmScreenTitle +=\n        '<div id=\\'screenTitleId_' +\n        _strScreenId +\n        '\\' class=\\'screenTitleC\\' data-bind=\\'gomotext: strTitle\\'>' +\n        this._objCurrScreenData.strTitle +\n        '</div>';\n      gomo.translationManager.setScreenElement(\n        'screenTitleId_' + _strScreenId,\n        _strScreenId,\n        {strTitle: this._objCurrScreenData.strTitle},\n        'screen'\n      );\n    }\n\n    return _htmScreenTitle;\n  },\n\n  _getScreenPosition: function(_intPageIndex) {\n    var _htmScreenPosition =\n      '<div class=\\'pageNumberScreenC\\'><div class=\\'pageNumberInnerC\\'>' +\n      TOP_STRAP_RENDERER.getPageCount(this._objCurrScreenData.objParent, _intPageIndex) +\n      '</div></div>';\n\n    return _htmScreenPosition;\n  },\n\n  _getScreenstrBackgroundImg: function(_objWhatScreenCourseObject) {\n    var _strBackgroundCSS = '';\n    if (\n      _objWhatScreenCourseObject.objRawData.objNormalBackgroundSrc &&\n      _objWhatScreenCourseObject.objRawData.objNormalBackgroundSrc.strSrc\n    ) {\n      _strBackgroundCSS += 'background-image:';\n      _strBackgroundCSS += this._getScreenRawBackgroundImgURL(_objWhatScreenCourseObject);\n      _strBackgroundCSS += ';';\n    }\n\n    return _strBackgroundCSS;\n  },\n\n  setBackgroundVideo: function(_objScreenData, screenId) {\n    var htmVideoTemplate = SCREEN_INTERACTIONS.buildVideoElement(_objScreenData.objVideo, screenId);\n    return htmVideoTemplate;\n  },\n\n  _getScreenRawBackgroundImgURL: function(_objWhatScreenCourseObject) {\n    var _strRawBGImageURL = '';\n    if (\n      _objWhatScreenCourseObject.objRawData.objNormalBackgroundSrc &&\n      _objWhatScreenCourseObject.objRawData.objNormalBackgroundSrc.strSrc\n    ) {\n      _strRawBGImageURL +=\n        'url(\"' +\n        gomo.utility.getSrcPath(\n          _objWhatScreenCourseObject.objRawData.objNormalBackgroundSrc.strSrc\n        ) +\n        _objWhatScreenCourseObject.objRawData.objNormalBackgroundSrc.strSrc +\n        '\")';\n    }\n    return _strRawBGImageURL;\n  },\n\n  _getScreenBackgroundVideo: function(_objWhatScreenCourseObject) {\n    var objVideos = null;\n\n    if (\n      _objWhatScreenCourseObject.objRawData.objBackgroundVideo &&\n      (_objWhatScreenCourseObject.objRawData.objBackgroundVideo.mp4 != '' ||\n        _objWhatScreenCourseObject.objRawData.objBackgroundVideo.webm != '')\n    ) {\n      if (_objWhatScreenCourseObject.objRawData.objBackgroundVideo.mp4 != '') {\n        objVideos = {\n          mp4:\n            gomo.utility.getSrcPath(_objWhatScreenCourseObject.objRawData.objBackgroundVideo.mp4) +\n            _objWhatScreenCourseObject.objRawData.objBackgroundVideo.mp4\n        };\n      } else {\n        objVideos = {\n          mp4: null\n        };\n      }\n\n      if (_objWhatScreenCourseObject.objRawData.objBackgroundVideo.webm != '') {\n        objVideos.webm =\n          gomo.utility.getSrcPath(_objWhatScreenCourseObject.objRawData.objBackgroundVideo.webm) +\n          _objWhatScreenCourseObject.objRawData.objBackgroundVideo.webm;\n      } else {\n        objVideos.webm = null;\n      }\n\n      // Loop background videos, default to true.\n      if (_.isBoolean(_objWhatScreenCourseObject.objRawData.objBackgroundVideo.loop)) {\n        objVideos.loop = _objWhatScreenCourseObject.objRawData.objBackgroundVideo.loop;\n      } else {\n        objVideos.loop = true;\n      }\n    }\n\n    return objVideos;\n  },\n\n  _getSubScreens: function() {\n    var _arrSubScreensData = this._objCurrScreenData.arrSubScreens;\n    var _domSubScreens = '';\n\n    for (var i = 0; i < _arrSubScreensData.length; i++) {\n      var _objCurrSubScreen = _arrSubScreensData[i];\n      if (!_objCurrSubScreen.objRawData.booAssetOwnedSubscreen) {\n        if (\n          _objCurrSubScreen.strType == 'standard' ||\n          _objCurrSubScreen.strType.indexOf('reveal') != -1\n        ) {\n          _domSubScreens += SUB_SCREEN_RENDERER.renderSubScreen(_objCurrSubScreen, false);\n        } else {\n          _domSubScreens += SUB_SCREEN_RENDERER.renderSubScreen(\n            _objCurrSubScreen,\n            _objCurrSubScreen.strType\n          );\n        }\n      }\n    }\n\n    return _domSubScreens;\n  },\n\n  debug: function(strMessage, intPriority, objCallerObject, booCalleeChain) {\n    if (DEBUG) {\n      DEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n    }\n  }\n};\n\nEM.register(SCREEN_RENDERER);\n"},function(n,e,t){t(0)(t(105))},function(n,e){n.exports='/**\n* @title Layout Renderer\n* @description Set the placement of Assets within the Player\n*\n*\n* @author JH\n* @version 2.0 18/12/13\n*/\n\nvar LAYOUT_RENDERER =\n{\n\tstrObjID : "The Layout Manager.",\n\t_strLayoutBlockTemplateID : "layoutBlockC",\n\t_strLayoutColumnTemplateID : "layoutColumnC",\n\t_columnPrefix : "col",\n\tcolumnStylesPostProcess : [],\n\n\thandleEvent_primeDOMReferences : function (_objWhatDOM)\n\t{\n\t\tthis._objCurrDOM = _objWhatDOM;\n\t},\n\n\thandleEvent_registerLayoutItems : function()\n\t{\n\t\tthis.objRegisteredButtons = OBJ_NAV_BUTTONS;\n\t},\n\n\trenderLayoutBlock : function (_objLayoutDataWrapper, _objParentScreen, _booIsNewBlock, _intBlockIndex)\n\t{\n\t\tvar _htmLayoutBlockTemplate = TEMPLATE_MANANGER.getTemplate(this._strLayoutBlockTemplateID).htmData;\n\t\t_htmLayoutBlockTemplate = _htmLayoutBlockTemplate.replace(/XX_LAYOUT_ID_XX/g, _objLayoutDataWrapper.strObjID);\n\n\t\tvar _booIsTitleBlock = false;\n\t\tvar _strTopicId = TOPIC_MANAGER.getTopicId(_objParentScreen.strObjID);\n\n\t\tvar _htmTitles = "";\n\t\t//If we\'re in a topic title block, check for user config on Topic/Screen Titles\n\t\tif(_intBlockIndex == 0\n\t\t\t&& _objParentScreen.objParent.strObjTopicModel != "meta"\n\t\t\t&& _objParentScreen.strObjType != "subscreen")\n\t\t{\n\t\t\tvar _objTitleData = this._getTitleBlock(_strTopicId);\n\t\t\t_booIsTitleBlock = _objTitleData._booIsTitleBlock;\n\t\t\t_htmTitles = _objTitleData._htmTitles;\n\t\t}\n\n\t\tvar developerClass = "";\n\t\tif(_objLayoutDataWrapper.objLayoutData.objDeveloperOptions\n\t\t\t&& _objLayoutDataWrapper.objLayoutData.objDeveloperOptions.objAdvancedStyling\n\t\t\t&& _objLayoutDataWrapper.objLayoutData.objDeveloperOptions.objAdvancedStyling.strCustomCSSClasses)\n\t\t{\n\t\t\tdeveloperClass = _objLayoutDataWrapper.objLayoutData.objDeveloperOptions.objAdvancedStyling.strCustomCSSClasses;\n\t\t}\n\t\t_htmLayoutBlockTemplate = _htmLayoutBlockTemplate.replace("XX_DEVELOPER_CLASS_XX", developerClass);\t\n\n\t\tvar _htmColumnContent = "";\n\t\tvar count = 0;\n\t\tvar intColumnWidth = (12/_objLayoutDataWrapper.intColumns);\n\t\twhile (count < _objLayoutDataWrapper.intColumns)\n\t\t{\n\t\t\t// Get the *full* list inc. non-displayed items so placeholders can be rendered\n\t\t\tvar _arrCurrRelatedAssets = _objLayoutDataWrapper.getRelatedAssets(count, true);\n\n\t\t\t// Re-get to allow the first/last states to be set correctly, return value is not used.\n\t\t\t_objLayoutDataWrapper.getRelatedAssets(count, false);\n\n\t\t\tvar _strColumnId = this._getColumnId(_objLayoutDataWrapper.strObjID, count);\n\t\t\tLAYOUT_INTERACTIONS.setLayoutWidthObjList(_objLayoutDataWrapper, _arrCurrRelatedAssets, _strColumnId);\n\n\t\t\tvar _htmCurrColumnTemplate = TEMPLATE_MANANGER.getTemplate(this._strLayoutColumnTemplateID).htmData;\n\t\t\t_htmCurrColumnTemplate = _htmCurrColumnTemplate.replace(/XX_COLUMN_ID_XX/g, _strColumnId);\n\t\t\t_htmCurrColumnTemplate = _htmCurrColumnTemplate.replace(/XX_COLUMN_INDEX_XX/g, count);\n\t\t\t_htmCurrColumnTemplate = _htmCurrColumnTemplate.replace(/XX_COLUMN_WIDTH_XX/g, intColumnWidth);\n\t\t\tthis.columnStylesPostProcess.push(this._columnWrapperStyle(_strColumnId,_objLayoutDataWrapper, count));\n\n\t\t\tif (_objParentScreen.strObjType == "screen")\n\t\t\t{\n\t\t\t\t_htmCurrColumnTemplate = _htmCurrColumnTemplate.replace(/ class="layoutColumnC"/g, \' class="layoutColumnC" style="\' + this._columnStyle(_objLayoutDataWrapper, count) + \'"\');\n\t\t\t}\n\n\t\t\tvar _htmColumnAssetContents = "";\n\t\t\tvar iCount = 0;\n\n\t\t\tif ((_arrCurrRelatedAssets.length < 1) && ((!_booIsTitleBlock) || (_booIsTitleBlock && (count > 0))))\n\t\t\t{\n\t\t\t\t_htmCurrColumnTemplate = _htmCurrColumnTemplate.replace(/XX_ASSET_CHECK_XX/g, " emptyLayoutC");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_htmCurrColumnTemplate = _htmCurrColumnTemplate.replace(/XX_ASSET_CHECK_XX/g, "");\n\t\t\t}\n\n\t\t\twhile (iCount < _arrCurrRelatedAssets.length)\n\t\t\t{\n\t\t\t\tvar _objCurrAssetData = _arrCurrRelatedAssets[iCount];\n\n\t\t\t\tvar _objRenderData = {};\n\t\t\t\t_objRenderData.objWhatAssetCourseObject = _objCurrAssetData;\n\t\t\t\t_objRenderData.booPreviewMode = false;\n\t\t\t\t_objRenderData.strScreenId = _objParentScreen.strObjID;\n\n\t\t\t\tvar assetType = _objCurrAssetData[\'strAssetType\'];\n\t\t\t\tif(gomo.assetManager.isRegistered(assetType)) {\n\t\t\t\t\tvar asset = gomo.assetManager.add(assetType, _objRenderData);\n\t\t\t\t\t_htmColumnAssetContents += asset.render();\n\t\t\t\t} else {\n\t\t\t\t\t_htmColumnAssetContents += ASSET_RENDERER.renderAsset(_objRenderData);\n\t\t\t\t}\n\t\t\t\tiCount++;\n\t\t\t}\n\t\t\t//Only apply the title to the first column\n\t\t\tif (count == 0)\n\t\t\t{\n\t\t\t\t_htmColumnAssetContents = _htmTitles + _htmColumnAssetContents;\n\t\t\t}\n\t\t\t_htmCurrColumnTemplate = _htmCurrColumnTemplate.replace(/XX_LAYOUT_COLUMN_ASSET_CONTENT_XX/g, _htmColumnAssetContents);\n\n\t\t\t_htmColumnContent += _htmCurrColumnTemplate;\n\t\t\tcount++;\n\t\t}\n\t\t_htmLayoutBlockTemplate = _htmLayoutBlockTemplate.replace(/XX_LAYOUT_COLUMNS_XX/g, _htmColumnContent);\n\t\t_htmLayoutBlockTemplate = _htmLayoutBlockTemplate.replace(/XX_COLUMN_COUNT_XX/g, _objLayoutDataWrapper.intColumns);\n\n\t\tif (_booIsNewBlock)\n\t\t{\n\t\t\t_htmLayoutBlockTemplate = _htmLayoutBlockTemplate.replace(/XX_IS_EXPANDING_BLOCK_XX/g, this._strLayoutBlockToExpandClass);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_htmLayoutBlockTemplate = _htmLayoutBlockTemplate.replace(/XX_IS_EXPANDING_BLOCK_XX/g, "");\n\t\t}\n\n\t\t_htmLayoutBlockTemplate = _htmLayoutBlockTemplate.replace(/XX_SCREEN_ID_XX/g, _objParentScreen.strObjID);\n\t\t_htmLayoutBlockTemplate = _htmLayoutBlockTemplate.replace(/XX_LAYOUT_ID_XX/g, _objLayoutDataWrapper.strObjID);\n\t\t_htmLayoutBlockTemplate = _htmLayoutBlockTemplate.replace(/XX_BLOCK_INDEX_XX/g, _intBlockIndex);\n\n\t\t_htmLayoutBlockTemplate = _htmLayoutBlockTemplate.replace(/XX_NUMBER_OF_COLUMNS_XX/g, _objLayoutDataWrapper.intColumns);\n\n\t\treturn _htmLayoutBlockTemplate;\n\t},\n\n\thandleEvent_newlyRenderedItemInDocument : function()\n\t{\n\t\tvar count = 0;\n\t\twhile(count < this.columnStylesPostProcess.length)\n\t\t{\n\t\t\tif(this.columnStylesPostProcess[count].columnId)\n\t\t\t{\n\t\t\t\t$(\'#\'+this.columnStylesPostProcess[count].columnId).css(this.columnStylesPostProcess[count].cssType,this.columnStylesPostProcess[count].cssValue);\n\t\t\t}\n\t\t\tcount++;\n\t\t}\n\t\tthis.columnStylesPostProcess = [];\n\t},\n\n\t_getTitleBlock : function (_strTopicId)\n\t{\n\t\tvar _objTitleData = {};\n\t\t_objTitleData._htmTitles = "";\n\t\t_objTitleData._booIsTitleBlock = false;\n\n\t\t//Is Primary Topic\n\t\tif(_strTopicId === CORE.objPrimaryTopicLoader.strTopicID)\n\t\t{\n\t\t\tif(BOO_SHOW_TOPIC_TITLE_PRIMARYTOPIC || BOO_SHOW_SCREEN_TITLE_PRIMARYTOPIC)\n\t\t\t{\n\t\t\t\t_objTitleData._htmTitles = TEMPLATE_MANANGER.getTemplate("firstColumnOfFirstRowC").htmData;\n\t\t\t\t_objTitleData._booIsTitleBlock = true;\n\t\t\t}\n\t\t}\n\t\t//Is Menu Topic\n\t\telse if(_strTopicId === CORE.objMenuLoader.strTopicID)\n\t\t{\n\t\t\tif(BOO_SHOW_TOPIC_TITLE_MENUTOPIC || BOO_SHOW_SCREEN_TITLE_MENUTOPIC)\n\t\t\t{\n\t\t\t\t_objTitleData._htmTitles = TEMPLATE_MANANGER.getTemplate("firstColumnOfFirstRowC").htmData;\n\t\t\t\t_objTitleData._booIsTitleBlock = true;\n\t\t\t}\n\t\t}\n\t\t//Is generic Topic\n\t\telse \n\t\t{\t\n\t\t\tif(BOO_SHOW_SCREEN_TITLE || BOO_SHOW_TOPIC_TITLE)\n\t\t\t{\n\t\t\t\t_objTitleData._htmTitles = TEMPLATE_MANANGER.getTemplate("firstColumnOfFirstRowC").htmData;\n\t\t\t\t_objTitleData._booIsTitleBlock = true;\n\t\t\t}\n\t\t}\n\n\t\treturn _objTitleData;\n\t},\n\n\t_getColumnId : function (strLayoutId, intColumnCount)\n\t{\n\t\tvar strColumnId = strLayoutId + this._columnPrefix + intColumnCount;\n\n\t\treturn strColumnId;\n\t},\n\n\t_columnStyle : function (_objLayoutDataWrapper, intColumnCount)\n\t{\n\t\tvar _strStyle = "";\n\t\tvar _strColumnKey = "";\n\n\t\tswitch (intColumnCount)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\t_strColumnKey = "objColumn1Styles";\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t_strColumnKey = "objColumn2Styles";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t_strColumnKey = "objColumn3Styles";\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t_strColumnKey = "objColumn4Styles";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (_objLayoutDataWrapper\n\t\t    && _objLayoutDataWrapper.objLayoutData\n\t\t    && _objLayoutDataWrapper.objLayoutData.objStylingData\n\t\t    && _objLayoutDataWrapper.objLayoutData.objStylingData[_strColumnKey])\n\t\t{\n\t\t\tvar objStyle = _objLayoutDataWrapper.objLayoutData.objStylingData[_strColumnKey];\n\t\t\tvar _strOpacity = "1";\n\n\t\t\tif (objStyle.strBackgroundOpacity)\n\t\t\t{\n\t\t\t\t_strOpacity = objStyle.strBackgroundOpacity;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_strOpacity = 1;\n\t\t\t}\n\n\t\t\tif (objStyle.strBackgroundColour)\n\t\t\t{\n\t\t\t\tif ((OUTPUT_MODE_CHECKER.strWhatBrowserTypeClass == "ie8C") || (OUTPUT_MODE_CHECKER.strWhatBrowserTypeClass == "ie8CompatibilityModeC") && (!objStyle.strBackgroundImage || objStyle.strBackgroundImage == ""))\n\t\t\t\t{\n\t\t\t\t\tif (objStyle.strBackgroundImage)\n\t\t\t\t\t{\n\t\t\t\t\t\t_strStyle += "-ms-filter: \'progid:DXImageTransform.Microsoft.gradient(startColorstr=#00000000, endColorstr=#00000000)\';";\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar _strComponentColour = CORE.hexToRgb(objStyle.strBackgroundColour);\n\t\t\t\t\t\tvar _arrColourSplit = _strComponentColour.split(",");\n\t\t\t\t\t\tvar _intComponentRangedOpacity = Math.round(255 * _strOpacity);\n\t\t\t\t\t\tvar _strRGBAasHex = CORE.rgbToHex(_arrColourSplit[0], _arrColourSplit[1], _arrColourSplit[2], _intComponentRangedOpacity);\n\t\t\t\t\t\t_strStyle += "-ms-filter: \'progid:DXImageTransform.Microsoft.gradient(startColorstr=" + _strRGBAasHex + ", endColorstr=" + _strRGBAasHex + ")\';";\n\t\t\t\t\t}\n\t\t\t\t\t// Remove the default bg color. We do this because if it\'s an opacity of 1 then LESS will\n\t\t\t\t\t// convert it to a value which IE8 will render along with the ms-filter.\n\t\t\t\t\t_strStyle += "background-color:transparent;";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar _strColour = CORE.hexToRgb(objStyle.strBackgroundColour);\n\t\t\t\t\t_strStyle += "background-color:rgba(" + _strColour + ", " + _strOpacity + ");";\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (objStyle.strBackgroundImage)\n\t\t\t{\n\t\t\t\t_strStyle += "background-image:url(\'resources/" + objStyle.strBackgroundImage + "\');";\n\t\t\t\t//Remove bg colour if it exists\n\t\t\t\t_strStyle += "-ms-filter: \'progid:DXImageTransform.Microsoft.gradient(startColorstr=#00000000, endColorstr=#00000000)\';";\n\t\t\t}\t\t\t\n\t\t\t//_strStyle += _objLayoutDataWrapper.strStyle;\n\t\t}\n\n\t\treturn _strStyle;\n\t},\n\n\t_columnWrapperStyle : function (_strColumnId, _objLayoutDataWrapper, intColumnCount)\n\t{\n\t\tvar columnStyles = {};\n\t\tvar _strColumnKey = "";\n\n\t\tswitch (intColumnCount)\n\t\t{\n\t\t\tcase 0:\n\t\t\t\t_strColumnKey = "objColumn1Styles";\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\t_strColumnKey = "objColumn2Styles";\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\t_strColumnKey = "objColumn3Styles";\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\t_strColumnKey = "objColumn4Styles";\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\treturn;\n\t\t}\n\n\t\tif (_objLayoutDataWrapper\n\t\t    && _objLayoutDataWrapper.objLayoutData\n\t\t    && _objLayoutDataWrapper.objLayoutData.objStylingData\n\t\t    && _objLayoutDataWrapper.objLayoutData.objStylingData[_strColumnKey])\n\t\t{\n\t\t\tvar objStyle = _objLayoutDataWrapper.objLayoutData.objStylingData[_strColumnKey];\t\t\t\n\t\t\tcolumnStyles.columnId = _strColumnId;\n\n\t\t\tif (objStyle.intPercentageWidth\n\t\t\t\t&& objStyle.intPercentageWidth !== "")\n\t\t\t{\n\t\t\t\tcolumnStyles.cssType ="width";\n\t\t\t\tcolumnStyles.cssValue = objStyle.intPercentageWidth+"%";\n\t\t\t}\n\t\t}\n\n\t\treturn columnStyles;\n\t},\n\n\tdebug : function (strMessage, intPriority, objCallerObject, booCalleeChain)\n\t{\n\t\tif (DEBUG)\n\t\t{\n\t\t\tDEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n\t\t}\n\t}\n}\n\nEM.register(LAYOUT_RENDERER);\n'},function(n,e,t){t(0)(t(107))},function(n,e){n.exports="/* eslint-disable no-redeclare */\n/* globals TEMPLATE_MANANGER, jQuery, LOCALISER, VARIABLES_HOLDER, BOO_HIGHLIGHT_CORRECT_ANSWER,\nDEBUG, OBJ_SCALE_FACTOR_BY_MODE, OBJ_INDIVIDUAL_ASSET_SCALING_BY_MODE, OBJ_REF, EM */\n\n/**\n * @title Asset renderer\n * @description This object is the base class containing generic functions pertaining to asset rendering. All the actual asset specific rendering functions are added to this class from \\_js\\asset_extensions via the extender.js.\n *\n * @author JohnC\n * @version 2.0 08-11-10\n */\n\nvar ASSET_RENDERER = {\n  strObjID: 'The asset renderer',\n  _objAssetTemplates: null,\n  _objSubAssetTemplates: null,\n  _objCurrDOM: null,\n\n  objAssetSupportByType: {},\n  objAssetAnimations: {},\n\n  /* REFACTOR NOTE; normalise property name accross all objects */\n  _strCurrOutputModeClass: 'graphicalC',\n\n  _strImportedStyleSuffix: 'ImportedC',\n\n  _strAssetWrapperID: 'assetContentWrapperC',\n\n  _strFirstAssetClass: 'firstAssetC',\n  _strMiddleAssetClass: 'middleAssetC',\n  _strLastAssetClass: 'lastAssetC',\n\n  _strSelectedOptionClass: 'selectedOptionC',\n  _strUnselectedOptionClass: 'unSelectedOptionC',\n\n  _strCorrectOptionMarkerClass: 'correctOptionMarkerC',\n\n  _htmAssetWrapper: null,\n\n  _strCurrResourcePath: '',\n\n  _arrAssetHTMLTemplateIDs: [],\n  _arrSubAssetHTMLTemplateIDs: [\n    ['confirm_button', 'confirmButtonC'],\n    ['reset_button', 'resetButtonC'],\n    ['model_answer_button', 'modelAnswerButtonC'],\n    ['my_answer_button', 'myAnswerButtonC']\n  ],\n\n  // _strUnsupportedAssetMessage : \"<p class='unsupportedAssetMessageC'>This 'XX_ASSET_TYPE_XX' asset isn't currently supported in this output mode or is awaiting full testing. Please contact your Lead Developer or the GoMo team for advice.</p>\",\n  _strUnsupportedAssetMessage:\n    '<p class=\\'unsupportedAssetMessageC\\'>' +\n    // eslint-disable-next-line no-undef\n    LOCALISER.get('ASSET_RENDERER_UNSUPPORTED_ASSET_TYPE_ERROR') +\n    '</p>',\n\n  objOutOfBoundaryAsset: {},\n\n  _strDisplayedAssetClass: 'displayedAssetMarkerC',\n  _strHiddenAssetClass: 'hiddenAssetMarkerC',\n\n  handleEvent_primeDOMReferences: function(_objWhatDOM) {\n    // Set DOM on new asset manager...\n    if (gomo && gomo.assetManager) {\n      gomo.assetManager.setDOM(_objWhatDOM);\n    }\n\n    if (!this._objCurrDOM) {\n      this._objCurrDOM = _objWhatDOM;\n    }\n  },\n\n  handleEvent_outputModeChanged: function(_objOutputChangeData) {\n    this._strCurrOutputModeClass = _objOutputChangeData['strNewOutputMode'];\n  },\n\n  handleEvent_reportAssetSupportData: function() {\n    // var _strReportText = \"ASSET SUPPORT REPORT\\n\";\n    // eslint-disable-next-line no-undef\n    var _strReportText = LOCALISER.get('ASSET_RENDERER_ASSET_SUPPORT_TITLE') + '\\n';\n    // eslint-disable-next-line guard-for-in\n    for (var _strAssetTypeKey in this.objAssetSupportByType) {\n      var _objCurrAssetData = this.objAssetSupportByType[_strAssetTypeKey];\n      _strReportText += '\\n' + _strAssetTypeKey + ':\\n\\n';\n      // eslint-disable-next-line guard-for-in\n      for (var _strCurrOutputMode in _objCurrAssetData) {\n        _strReportText +=\n          _strAssetTypeKey +\n          '::' +\n          _strCurrOutputMode +\n          ': ' +\n          _objCurrAssetData[_strCurrOutputMode] +\n          '\\n';\n      }\n    }\n    alert(_strReportText);\n  },\n\n  addAssetSupportData: function(_strWhatAssetType, _objWhatSupportData) {\n    if (!this.objAssetSupportByType[_strWhatAssetType]) {\n      // Copy the value into a new object as the base variable will be re-assigned to the next extension that loads.\n      this.objAssetSupportByType[_strWhatAssetType] = {};\n      // eslint-disable-next-line guard-for-in\n      for (var _strCurrOutputMode in _objWhatSupportData) {\n        this.objAssetSupportByType[_strWhatAssetType][_strCurrOutputMode] =\n          _objWhatSupportData[_strCurrOutputMode];\n      }\n    }\n    // else\n    // {\n    // alert(\"ERROR: An attempt was made to register asset support data for '\" + _strWhatAssetType + \"', however I've already got data for that. Please check the names used to register assets. ASSET_RENDERER.addAssetSupportData() asset_renderer.js\");\n    // LOCALISER.l_alert(\"ASSET_RENDERER_DUPLICATE_ASSET_SUPPORT_DATA_ERROR\", [_strWhatAssetType]);\n    // }\n  },\n\n  getAssetDOMId: function(_objWhatRawAssetData) {\n    var _strAssetDOMID =\n      _objWhatRawAssetData.strType + 'Asset_YY' + _objWhatRawAssetData.strID + 'YY_WrapperL';\n    return _strAssetDOMID;\n  },\n\n  getAssetWrapperDOMId: function(_objWhatRawAssetData) {\n    var _strAssetDOMID = 'assetWrapperFor_YY' + _objWhatRawAssetData.strID + 'YY_L';\n    return _strAssetDOMID;\n  },\n\n  getAssetDOMElement: function(_objWhatRawAssetData) {\n    var _strAssetDOMID = this.getAssetDOMId(_objWhatRawAssetData);\n    var _objAssetDOMElement = this._objCurrDOM.getElementById(_strAssetDOMID);\n    if (_objAssetDOMElement) {\n      return _objAssetDOMElement;\n    } else {\n      console.log(\n        'ASSET_RENDERER.getAssetDOMElement() unable to find dom element #' + _strAssetDOMID\n      );\n      return false;\n    }\n  },\n\n  getGenericAssetDOMWrapper: function(_objWhatRawAssetData, _booSuppressUndefinedError) {\n    var _strAssetDOMID = this.getAssetWrapperDOMId(_objWhatRawAssetData);\n    var _domAssetDOMElement = this._objCurrDOM.getElementById(_strAssetDOMID);\n    if (_domAssetDOMElement) {\n      return _domAssetDOMElement;\n    } else {\n      if (!_booSuppressUndefinedError) {\n        console.log(\n          'ASSET_RENDERER.getGenericAssetDOMWrapper() unable to find dom element #' + _strAssetDOMID\n        );\n      }\n      return false;\n    }\n  },\n\n  doesAssetSupportOutputMode: function(_strWhatAssetType) {\n    if (this.objAssetSupportByType[_strWhatAssetType]) {\n      var _objCurrAssetsSupportData = this.objAssetSupportByType[_strWhatAssetType];\n      if (_objCurrAssetsSupportData[this._strCurrOutputModeClass]) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  // REFACTOR NOTE: Function has grown far to long and requires review and splitting apart.\n  renderAsset: function(_objRenderData, _booSurpressGenericAssetWrapping) {\n    var _objWhatAssetCourseObject = _objRenderData.objWhatAssetCourseObject;\n    var _strWhatResourcePath = _objRenderData.strWhatResourcePath;\n    // eslint-disable-next-line no-unused-vars\n    var _booPreviewMode = _objRenderData.booPreviewMode;\n    var _booIsFirstAsset = _objWhatAssetCourseObject.booIsFirstAssetInColumn;\n    var _booIsLastAsset = _objWhatAssetCourseObject.booIsLastAssetInColumn;\n\n    this._strCurrResourcePath = _strWhatResourcePath;\n    // eslint-disable-next-line no-unused-vars\n    var _objWhatRawAssetData = _objWhatAssetCourseObject.objRawData;\n    if (!this._htmAssetWrapper) {\n      this._htmAssetWrapper = TEMPLATE_MANANGER.getTemplate(this._strAssetWrapperID).htmData;\n    }\n    this._populateAssetTemplateObject();\n    this._populateSubAssetTemplatesObject();\n\n    // Don't build an html output for the asset if it isn't going to be rendered\n    var _objAssetContent = {};\n    if (_objWhatAssetCourseObject.booIsDisplayed) {\n      _objAssetContent = this._getAssetContent(_objWhatAssetCourseObject, _objRenderData);\n    }\n\n    this._addAssetAnimationPreRender(\n      _objWhatAssetCourseObject.objRawData,\n      _objRenderData.strScreenId\n    );\n\n    if (!_booSurpressGenericAssetWrapping) {\n      var _htmAssetWrapper = this._wrapAssetContent(\n        _objWhatAssetCourseObject,\n        _objAssetContent,\n        _booIsFirstAsset,\n        _booIsLastAsset\n      );\n    } else {\n      // eslint-disable-next-line no-redeclare\n      var _htmAssetWrapper = _objAssetContent.htmAssetContent;\n    }\n\n    return _htmAssetWrapper;\n  },\n\n  renderNonColumnAsset: function(_objWhatAssetCourseObject, _booPreviewMode) {\n    var _htmNonColumnAsset = '';\n\n    var _booSupported = this.doesAssetSupportOutputMode(\n      _objWhatAssetCourseObject.objRawData.strType\n    );\n    if (_booSupported) {\n      if (this['_' + _objWhatAssetCourseObject.strAssetType + '_renderNonColumnAsset']) {\n        _htmNonColumnAsset = this[\n          '_' + _objWhatAssetCourseObject.strAssetType + '_renderNonColumnAsset'\n        ](_objWhatAssetCourseObject, _booPreviewMode);\n      }\n    } else {\n      _htmNonColumnAsset = this._strUnsupportedAssetMessage.replace(\n        /XX_ASSET_TYPE_XX/g,\n        _objWhatAssetCourseObject.objRawData['@type']\n      );\n    }\n    return _htmNonColumnAsset;\n  },\n\n  sanitiseAltText: function(_strWhatAltText) {\n    if (!_strWhatAltText || !_strWhatAltText.replace) {\n      return _strWhatAltText;\n    }\n    _strWhatAltText = _strWhatAltText.replace(/&#x0027;/g, '\\'');\n    _strWhatAltText = _strWhatAltText.replace(/&quot;/g, '\"');\n    return _strWhatAltText;\n  },\n\n  resetAssetWrapperForcedMode: function(_objAssetRawData, _strForcedMode) {\n    var _domElement = this.getAssetDOMElement(_objAssetRawData);\n    // Check the element is found\n    if (_domElement) {\n      var _strReplace = '';\n      var _strClassName = _domElement.parentNode.className;\n      if (_strClassName.indexOf('forcesmallC') != -1) {\n        _strReplace = 'forcesmallC';\n      }\n      if (_strClassName.indexOf('forcemediumC') != -1) {\n        _strReplace = 'forcemediumC';\n      }\n      if (_strClassName.indexOf('forcelargeC') != -1) {\n        _strReplace = 'forcelargeC';\n      }\n      _strClassName = _strClassName.replace(_strReplace, 'force' + _strForcedMode + 'C');\n      _domElement.parentNode.className = _strClassName;\n    }\n  },\n\n  assetSizeOutOfBounds: function(objReturnValue) {\n    var objUpdateValue = objReturnValue.objUpdateValue;\n    var _objWhatAssetCourseObject = objReturnValue.objOptionalFunParameter;\n    var _strAssetWrapperDOMID = this.getAssetWrapperDOMId(_objWhatAssetCourseObject.objRawData);\n\n    if (objUpdateValue.strCurrentLayoutSize == 'medium') {\n      // eslint-disable-next-line no-undef\n      for (_strAssetId in this.objOutOfBoundaryAsset) {\n        // eslint-disable-next-line no-undef\n        if (_strAssetId == _objWhatAssetCourseObject.strObjID) {\n          jQuery('#' + _strAssetWrapperDOMID + ' .blankingElementC').removeClass(\n            'visibleBlankingC'\n          );\n          jQuery('#' + _strAssetWrapperDOMID + ' .blankingElementC').html('');\n        }\n      }\n    } else if (objUpdateValue.strCurrentLayoutSize == 'large') {\n      this.objOutOfBoundaryAsset[_objWhatAssetCourseObject.strObjID];\n      this.objOutOfBoundaryAsset[_objWhatAssetCourseObject.strObjID] = 'large';\n\n      jQuery('#' + _strAssetWrapperDOMID + ' .blankingElementC').addClass('visibleBlankingC');\n      jQuery('#' + _strAssetWrapperDOMID + ' .blankingElementC').html(\n        _objWhatAssetCourseObject.strAssetType + ' asset too small for Column width'\n      );\n    } else if (objUpdateValue.strCurrentLayoutSize == 'small') {\n      this.objOutOfBoundaryAsset[_objWhatAssetCourseObject.strObjID];\n      this.objOutOfBoundaryAsset[_objWhatAssetCourseObject.strObjID] = 'small';\n\n      jQuery('#' + _strAssetWrapperDOMID + ' .blankingElementC').addClass('visibleBlankingC');\n      jQuery('#' + _strAssetWrapperDOMID + ' .blankingElementC').html(\n        _objWhatAssetCourseObject.strAssetType + ' asset too large for Column width'\n      );\n    }\n  },\n\n  getAssetPositionClasses: function(_booIsFirstAsset, _booIsLastAsset) {\n    var _strClassString;\n\n    if (_booIsFirstAsset && _booIsLastAsset) {\n      _strClassString = this._strFirstAssetClass + ' ' + this._strLastAssetClass;\n    } else if (_booIsFirstAsset) {\n      _strClassString = this._strFirstAssetClass;\n    } else if (_booIsLastAsset) {\n      _strClassString = this._strLastAssetClass;\n    } else {\n      _strClassString = this._strMiddleAssetClass;\n    }\n    return _strClassString;\n  },\n\n  _getAssetContent: function(_objWhatAssetCourseObject, _objRenderData) {\n    var _objWhatRawAssetData = _objWhatAssetCourseObject.objRawData;\n    var _objAssetContent = {};\n\n    var _booSupported = this.doesAssetSupportOutputMode(_objWhatRawAssetData.strType);\n    if (_booSupported) {\n      if (this['_render_' + _objWhatRawAssetData.strType + '_Asset']) {\n        if (this['_rerenderSetup_' + _objWhatRawAssetData.strType + '_Asset']) {\n          this['_rerenderSetup_' + _objWhatRawAssetData.strType + '_Asset'](\n            _objWhatAssetCourseObject\n          );\n        }\n\n        _objAssetContent = this['_render_' + _objWhatRawAssetData.strType + '_Asset'](\n          _objRenderData\n        );\n        if (typeof _objAssetContent == 'string') {\n          /* REFACTOR NOTE: The assets should be passing the correct data to the render.\n           * These should be updated and this functions can be removed. */\n          _objAssetContent = {htmAssetContent: _objAssetContent};\n        }\n        if (_objWhatAssetCourseObject.strOutputMode) {\n          _objAssetContent.objOptions = {\n            strForceOutputMode: _objWhatAssetCourseObject.strOutputMode\n          };\n        }\n      } else {\n        // this.debug(\"ASSET_RENDERER.renderAsset(), ERROR: Unknown asset type of \" + _objWhatRawAssetData[\"@type\"] + \".\", 3);\n        _objAssetContent.htmAssetContent = '';\n        var _strDebugMessage = LOCALISER.get('ASSET_RENDERER_UNKNOWN_ASSET_TYPE_DEBUG', [\n          _objWhatRawAssetData.strType\n        ]);\n        this.debug(_strDebugMessage, 3);\n      }\n    } else {\n      _objAssetContent.htmAssetContent = this._strUnsupportedAssetMessage.replace(\n        /XX_ASSET_TYPE_XX/g,\n        _objWhatRawAssetData.strType\n      );\n    }\n\n    return _objAssetContent;\n  },\n\n  _wrapAssetContent: function(\n    _objWhatAssetCourseObject,\n    _objAssetContent,\n    _booIsFirstAsset,\n    _booIsLastAsset\n  ) {\n    var _objWhatRawAssetData = _objWhatAssetCourseObject.objRawData;\n    var _htmAssetWrapper = '';\n\n    if (_objAssetContent.htmAssetContent != '') {\n      _htmAssetWrapper = this._htmAssetWrapper;\n      _objAssetContent.htmAssetContent += '<span class=\"blankingElementC\"></span>';\n\n      if (_objWhatAssetCourseObject.booIsDisplayed) {\n        var _strAssetPositioningClass = this.getAssetPositionClasses(\n          _booIsFirstAsset,\n          _booIsLastAsset\n        );\n      } else {\n        var _strAssetPositioningClass = '';\n      }\n\n      _htmAssetWrapper = _htmAssetWrapper.replace(\n        'XX_ASSET_POSITIONING_XX',\n        _strAssetPositioningClass\n      );\n\n      var developerClass = '';\n      if (\n        _objWhatAssetCourseObject.objRawData.objDeveloperOptions &&\n        _objWhatAssetCourseObject.objRawData.objDeveloperOptions.objAdvancedStyling &&\n        _objWhatAssetCourseObject.objRawData.objDeveloperOptions.objAdvancedStyling\n          .strCustomCSSClasses\n      ) {\n        developerClass =\n          _objWhatAssetCourseObject.objRawData.objDeveloperOptions.objAdvancedStyling\n            .strCustomCSSClasses;\n      }\n\n      _htmAssetWrapper = _htmAssetWrapper.replace('XX_DEVELOPER_CLASS_XX', developerClass);\n      _htmAssetWrapper = _htmAssetWrapper.replace(\n        'XX_ASSET_POSITIONING_XX',\n        _strAssetPositioningClass\n      );\n\n      var _strForceOutputMode = '';\n      if (_objAssetContent.objOptions && _objAssetContent.objOptions.strForceOutputMode) {\n        _strForceOutputMode = 'force' + _objAssetContent.objOptions.strForceOutputMode + 'C';\n      }\n      _htmAssetWrapper = _htmAssetWrapper.replace(\n        'XX_FORCE_ASSET_OUTPUT_MODE_XX',\n        _strForceOutputMode\n      );\n\n      if (_objWhatAssetCourseObject.booIsDisplayed) {\n        _htmAssetWrapper = _htmAssetWrapper.replace(\n          'XX_DISPLAY_CONDITION_STATE_XX',\n          this._strDisplayedAssetClass\n        );\n        _htmAssetWrapper = _htmAssetWrapper.replace(\n          'XX_ASSET_CONTENT_XX',\n          _objAssetContent.htmAssetContent\n        );\n      } else {\n        _htmAssetWrapper = _htmAssetWrapper.replace(\n          'XX_DISPLAY_CONDITION_STATE_XX',\n          this._strHiddenAssetClass\n        );\n        _htmAssetWrapper = _htmAssetWrapper.replace('XX_ASSET_CONTENT_XX', '');\n      }\n\n      _htmAssetWrapper = _htmAssetWrapper.replace(\n        'XX_ASSET_ID_XX',\n        'YY' + _objWhatRawAssetData.strID + 'YY'\n      );\n    }\n\n    return _htmAssetWrapper;\n  },\n\n  _addAssetAnimationPreRender: function(_objWhatRawAssetData, strScreenId) {\n    if (typeof this.objAssetAnimations[strScreenId] == 'undefined') {\n      this.objAssetAnimations[strScreenId] = {};\n    }\n    if (\n      _objWhatRawAssetData.objDisplayAnimation &&\n      (_objWhatRawAssetData.objDisplayAnimation.strAnimationType != 'null' &&\n        _objWhatRawAssetData.objDisplayAnimation.strAnimationType != 'none' &&\n        _objWhatRawAssetData.objDisplayAnimation.strAnimationType != '')\n    ) {\n      var _objAnimations = {\n        strType: _objWhatRawAssetData.objDisplayAnimation.strAnimationType,\n        intDelay: _objWhatRawAssetData.objDisplayAnimation.intAnimationDelay,\n        intDuration: _objWhatRawAssetData.objDisplayAnimation.intAnimationDuration,\n        booAnimateOnEveryVisit: _objWhatRawAssetData.objDisplayAnimation.booAnimateOnEveryVisit,\n        booAnimated: false\n      };\n      this.objAssetAnimations[strScreenId][_objWhatRawAssetData.strID] = _objAnimations;\n    }\n  },\n\n  /* REFACTOR NOTE: only populate sub template if correct render mode is selected */\n  _populateAssetTemplateObject: function() {\n    this._objAssetTemplates = {};\n    var count = 0;\n    while (count < this._arrAssetHTMLTemplateIDs.length) {\n      var _arrCurrTemplateData = this._arrAssetHTMLTemplateIDs[count];\n      var _htmCurrAssetHTMLTemplate = TEMPLATE_MANANGER.getTemplate(_arrCurrTemplateData[1])\n        .htmData;\n\n      this._objAssetTemplates[_arrCurrTemplateData[0]] = _htmCurrAssetHTMLTemplate;\n      count++;\n    }\n  },\n\n  _populateSubAssetTemplatesObject: function() {\n    this._objSubAssetTemplates = {};\n    var count = 0;\n    while (count < this._arrSubAssetHTMLTemplateIDs.length) {\n      var _arrCurrTemplateData = this._arrSubAssetHTMLTemplateIDs[count];\n      var _htmCurrSubAssetHTMLTemplate = TEMPLATE_MANANGER.getTemplate(_arrCurrTemplateData[1])\n        .htmData;\n      this._objSubAssetTemplates[_arrCurrTemplateData[0]] = _htmCurrSubAssetHTMLTemplate;\n      count++;\n    }\n  },\n\n  _replaceImportedStyle: function(_strWhatClassnames, _strNewStyle) {\n    var _arrClassSplit = _strWhatClassnames.split(' ');\n    var count = 0;\n    while (count < _arrClassSplit.length) {\n      var _strCurrClass = _arrClassSplit[count];\n      if (_strCurrClass.indexOf(this._strImportedStyleSuffix) != -1) {\n        _arrClassSplit[count] = _strNewStyle + this._strImportedStyleSuffix;\n      }\n      count++;\n    }\n    var _strNewClassnames = _arrClassSplit.join(' ');\n    return _strNewClassnames;\n  },\n\n  _checkDOMChainForClass: function(_domWhatElement, _strTargetClass, _strStopClass) {\n    while (\n      _domWhatElement &&\n      _domWhatElement.tagName != 'body' &&\n      _domWhatElement.tagName != 'html'\n    ) {\n      if (_domWhatElement.className) {\n        if (_domWhatElement.className.indexOf(_strTargetClass) > -1) {\n          return _domWhatElement;\n        }\n\n        if (_strStopClass && _domWhatElement.className.indexOf(_strStopClass) > -1) {\n          return false;\n        }\n      }\n      _domWhatElement = _domWhatElement.parentNode;\n    }\n    return false;\n  },\n\n  _generateQuestionButtons: function(_objWhatRawAssetData, _booShowConfirmButton) {\n    var _htmButtonTemplates =\n      this._objSubAssetTemplates['confirm_button'] +\n      this._objSubAssetTemplates['reset_button'] +\n      this._objSubAssetTemplates['model_answer_button'] +\n      this._objSubAssetTemplates['my_answer_button'];\n    _htmButtonTemplates = _htmButtonTemplates.replace(\n      /XX_PARENT_ASSET_ID_XX/g,\n      _objWhatRawAssetData.strID\n    );\n    _htmButtonTemplates = _htmButtonTemplates.replace(\n      /XX_PARENT_ASSET_TYPE_XX/g,\n      _objWhatRawAssetData.strType\n    );\n\n    if (_booShowConfirmButton == true) {\n      _htmButtonTemplates = _htmButtonTemplates.replace(\n        /XX_CONFIRM_STATE_INITIAL_XX/g,\n        'visibleButtonC'\n      );\n    } else {\n      _htmButtonTemplates = _htmButtonTemplates.replace(\n        /XX_CONFIRM_STATE_INITIAL_XX/g,\n        'hiddenButtonC nonConfirmButtonQuestionC'\n      );\n    }\n\n    return _htmButtonTemplates;\n  },\n\n  _showCorrectOptionMarker: function(_objWhatOptionData) {\n    if (_objWhatOptionData['@correct'] == 'y' && BOO_HIGHLIGHT_CORRECT_ANSWER) {\n      return TEMPLATE_MANANGER.getTemplate(this._strCorrectOptionMarkerClass).htmData;\n    }\n    return '';\n  },\n\n  insertFormattedHtml: function(_strWhatText) {\n    // This function is duplicated in gomo.utility so this one is deprecated.\n    if (_strWhatText) {\n      _strWhatText = gomo.utility.formatHTML(_strWhatText, this._strCurrResourcePath);\n    }\n    return _strWhatText;\n  },\n\n  _generateHotspotCSS: function(\n    _objWhatHotspotData,\n    _floWhatScaleFactor,\n    _intImageWidth,\n    _booInvertTopLeftCoords\n  ) {\n    var _intTop = Math.round(_objWhatHotspotData.intTop * (_floWhatScaleFactor / 100)) + 1;\n    if (this._intAssetWrapperWidth > _intImageWidth) {\n      var _intLeft =\n        Math.round(_objWhatHotspotData.intLeft * (_floWhatScaleFactor / 100)) +\n        Math.round((this._intAssetWrapperWidth - _intImageWidth) / 2) +\n        1;\n    } else {\n      // eslint-disable-next-line no-redeclare\n      var _intLeft = Math.round(_objWhatHotspotData.intLeft * (_floWhatScaleFactor / 100)) + 1;\n    }\n    var _intWidth = Math.round(_objWhatHotspotData.intWidth * (_floWhatScaleFactor / 100));\n    var _intHeight = Math.round(_objWhatHotspotData.intHeight * (_floWhatScaleFactor / 100));\n\n    if (_booInvertTopLeftCoords) {\n      return 'style=\"top:-' + _intTop + 'px; left:-' + _intLeft + 'px;\"';\n    } else {\n      return (\n        'style=\"top:' +\n        _intTop +\n        'px; left:' +\n        _intLeft +\n        'px; width:' +\n        _intWidth +\n        'px; height:' +\n        _intHeight +\n        'px\"'\n      );\n    }\n  },\n\n  _generatePercentileHotspotWrapperCSS: function(\n    _objWhatHotspotData,\n    _intImageWidth,\n    _intImageHeight\n  ) {\n    var _intTop = (_objWhatHotspotData['intTop'] / _intImageHeight) * 100;\n    var _intLeft = (_objWhatHotspotData['intLeft'] / _intImageWidth) * 100;\n\n    var _intWidth = (_objWhatHotspotData.intWidth / _intImageWidth) * 100;\n    var _intHeight = (_objWhatHotspotData.intHeight / _intImageHeight) * 100;\n\n    var _strCSSText =\n      'style=\"top:' +\n      _intTop +\n      '%; left:' +\n      _intLeft +\n      '%; width:' +\n      _intWidth +\n      '%; height:' +\n      _intHeight +\n      '%\"';\n    var _objReturnData = {\n      strCSSText: _strCSSText,\n      objCoordsData: {\n        objInPixels: {\n          intTop: _objWhatHotspotData['intTop'],\n          intLeft: _objWhatHotspotData['intLeft'],\n          intWidth: _objWhatHotspotData.intWidth,\n          intHeight: _objWhatHotspotData.intHeight\n        },\n        objInPercentage: {\n          intTop: _intTop,\n          intLeft: _intLeft,\n          intWidth: _intWidth,\n          intHeight: _intHeight\n        }\n      }\n    };\n\n    return _objReturnData;\n  },\n\n  _generatePercentileHotspotImageCSS: function(\n    _objWhatHotspotData,\n    _intImageWidth,\n    _intImageHeight,\n    _objParentWrapperCoordsData,\n    _booCleanStyleDataValuePairs\n  ) {\n    var _intWrapperHeight = _objParentWrapperCoordsData['objInPixels']['intHeight'];\n    var _intWrapperWidth = _objParentWrapperCoordsData['objInPixels']['intWidth'];\n\n    var _intHeightFactorOfBaseImage = _intImageHeight / _intWrapperHeight;\n    var _intWidthFactorOfBaseImage = _intImageWidth / _intWrapperWidth;\n\n    var _intTop = parseFloat(\n      '-' + (_objWhatHotspotData['intTop'] / _intImageHeight) * 100 * _intHeightFactorOfBaseImage\n    );\n    var _intLeft = parseFloat(\n      '-' + (_objWhatHotspotData['intLeft'] / _intImageWidth) * 100 * _intWidthFactorOfBaseImage\n    );\n\n    var _intWidth = _intWidthFactorOfBaseImage * 100;\n    var _intHeight = _intHeightFactorOfBaseImage * 100;\n\n    if (_booCleanStyleDataValuePairs) {\n      return (\n        'top:' +\n        _intTop +\n        '%; left:' +\n        _intLeft +\n        '%; width:' +\n        _intWidth +\n        '%; height:' +\n        _intHeight +\n        '%'\n      );\n    } else {\n      return (\n        'style=\"top:' +\n        _intTop +\n        '%; left:' +\n        _intLeft +\n        '%; width:' +\n        _intWidth +\n        '%; height:' +\n        _intHeight +\n        '%\"'\n      );\n    }\n  },\n\n  _calculateImageSizes: function(_strScale, _strWidth) {\n    var _intScale = parseInt((Number(_strScale) / 100) * Number(_strWidth));\n    return _intScale.toString();\n  },\n\n  _getScaleFactor: function(_objWhatRawAssetData, _objWhatAssetCourseObject) {\n    // If the asset doesn't have a scale factor add a default value.\n    if (!_objWhatRawAssetData.intScale) {\n      _objWhatRawAssetData.intScale = 100;\n    }\n\n    if (_objWhatAssetCourseObject.objParent.intColumns) {\n      var _strNumberOfColumns = _objWhatAssetCourseObject.objParent.intColumns.toString();\n    } else if (_objWhatAssetCourseObject.objParent.strObjID.indexOf('sub') > -1) {\n      // eslint-disable-next-line no-redeclare\n      var _strNumberOfColumns = 'sub';\n      // eslint-disable-next-line no-unused-vars\n      var _objParentScreen = _objWhatAssetCourseObject.objParent.objParent.objParent;\n      if (_objWhatAssetCourseObject.objParent.intColumns) {\n        _strNumberOfColumns += _objWhatAssetCourseObject.objParent.intColumns;\n      } else {\n        _strNumberOfColumns += '1';\n      }\n    } else {\n      // eslint-disable-next-line no-redeclare\n      var _strNumberOfColumns = '1';\n    }\n\n    if (OBJ_INDIVIDUAL_ASSET_SCALING_BY_MODE[this._strCurrOutputModeClass]) {\n      var _floScaleFactor =\n        _objWhatRawAssetData.intScale *\n        OBJ_SCALE_FACTOR_BY_MODE[_strNumberOfColumns][this._strCurrOutputModeClass];\n    } else {\n      // eslint-disable-next-line no-redeclare\n      var _floScaleFactor =\n        100 * OBJ_SCALE_FACTOR_BY_MODE[_strNumberOfColumns][this._strCurrOutputModeClass];\n    }\n    return _floScaleFactor;\n  },\n\n  debug: function(strMessage, intPriority, objCallerObject, booCalleeChain) {\n    if (DEBUG) {\n      DEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n    }\n  }\n};\n\nEM.register(ASSET_RENDERER);\n// AUTO_DOC.register(ASSET_RENDERER, ASSET_RENDERER.strObjID);\n"},function(n,e,t){t(0)(t(109))},function(n,e){n.exports="/* globals  TEMPLATE_MANANGER, SCREEN_RENDERER, SUB_SCREEN_RENDERER, SUB_SCREEN_INTERACTIONS,\nEM, SCREEN_INTERACTIONS, CORE, ASSET_INTERACTIONS, ASSET_RENDERER, _,\nALLOW_SUBSCREEN_TYPE_AUTO_OVERRIDES, OUTPUT_MODE_CHECKER, FORCE_POPOVER_SUBSCREENS, LAYOUT_RENDERER,\nDEBUG */\n\n/**\n * @title Subscreen Renderer\n * @description Renders a subscreen.\n *\n *\n * @author GoMo\n * @version 2.0 17/12/12\n */\n\nvar SUB_SCREEN_RENDERER = { // eslint-disable-line no-unused-vars\n  strObjID: 'The sub-screen renderer',\n  strObjDescription:\n    'This object is responsible for determining the sub screen type (based on the parent asset '+\n    'type), retreiving the relevant HTML fragaments and populating said sub-screen with the data '+\n    'object passed to it.',\n\n  _strSubScreenTemplateIDSuffix: 'SubScreenWrapperC',\n  elementIdPrefix: 'subScreenWrapper_',\n  elementIdSuffix: 'L',\n  standardSubscreenType: 'reveal',\n  objScreenSizeCompatibilityBlacklist: {\n    balloon: {arrBlackList: ['small'], strFallback: 'modal'},\n    popover: {arrBlackList: ['small'], strFallback: 'popup'}\n  },\n  _objTempStoreSubScreenContent: {},\n  renderedSubscreens: {},\n\n  _objCurrSubScreenData: null,\n\n  renderSubScreen: function(_objWhatSubScreenCourseObject, _strOverRideSubScreenType) {\n    this._objCurrSubScreenData = _objWhatSubScreenCourseObject;\n    var subscreenRawData = _objWhatSubScreenCourseObject.objRawData;\n\n    // If strSubscreenType == null, default to reveal as standard\n    if (subscreenRawData.strSubscreenType === 'null') {\n      _objWhatSubScreenCourseObject.strType = subscreenRawData.strType = this.standardSubscreenType;\n    }\n\n    // Ignore the subscreen render request if it already exists\n    if (\n      this.renderedSubscreens[this._objCurrSubScreenData.strObjID] &&\n      _strOverRideSubScreenType == false\n    ) {\n      // console.log(\"Existing Subscreen so ignored for \"+this._objCurrSubScreenData.strObjID);\n      return '';\n    } else {\n      this.renderedSubscreens[this._objCurrSubScreenData.strObjID] = true;\n      // console.log(\"*** CREATING Subscreen \"+this._objCurrSubScreenData.strObjID);\n    }\n\n    // REFACTOR NOTE: This is a temporary workaround to normalise the values. It fixes an issue\n    // with switching from graphical to accessible\n    if (_objWhatSubScreenCourseObject.strType == 'balloon' || this.isPopoverOverride()) {\n      _objWhatSubScreenCourseObject.strType = 'popover';\n      _strOverRideSubScreenType = 'popover';\n    }\n    if (_objWhatSubScreenCourseObject.strType == 'modal') {\n      _objWhatSubScreenCourseObject.strType = 'popup';\n      _strOverRideSubScreenType = 'popup';\n    }\n\n    _strOverRideSubScreenType = this.subScreenTypeSizeOverride(_strOverRideSubScreenType);\n\n    var _htmSubScreenTemplate;\n    if (_strOverRideSubScreenType != false && _strOverRideSubScreenType != 'null') {\n      var _strSubScreenTemplateID = _strOverRideSubScreenType + this._strSubScreenTemplateIDSuffix;\n      _htmSubScreenTemplate = TEMPLATE_MANANGER.getTemplate(_strSubScreenTemplateID).htmData;\n    } else {\n      _htmSubScreenTemplate = TEMPLATE_MANANGER.getTemplate('generic' +\n        this._strSubScreenTemplateIDSuffix).htmData;\n    }\n\n    // Must come here before ID replacements.\n    var _strScreenBackgroundCSS =\n      SCREEN_RENDERER.getScreenBackgroundCSS(_objWhatSubScreenCourseObject);\n    if (_strScreenBackgroundCSS) {\n      if (_htmSubScreenTemplate.indexOf('popover-content') > -1) {\n        _htmSubScreenTemplate = _htmSubScreenTemplate.replace(\n          'class=\"popover-content\"',\n          _strScreenBackgroundCSS + ' class=\"popover-content\" '\n        );\n      } else if (_htmSubScreenTemplate.indexOf('modal-content') > -1) {\n        _htmSubScreenTemplate = _htmSubScreenTemplate.replace(\n          'class=\"modal-content\"',\n          _strScreenBackgroundCSS + ' class=\"modal-content\" '\n        );\n      } else {\n        _htmSubScreenTemplate = _htmSubScreenTemplate.replace(\n          'id=\"subScreenWrapper_',\n          _strScreenBackgroundCSS + ' id=\"subScreenWrapper_'\n        );\n      }\n    }\n\n    _htmSubScreenTemplate = _htmSubScreenTemplate.replace(\n      /XX_SUB_SCREEN_ID_XX/g,\n      this._objCurrSubScreenData.strObjID\n    );\n    _htmSubScreenTemplate = _htmSubScreenTemplate.replace(\n      /XX_SUB_SCREEN_TITLE_XX/gi,\n      this._cleanseSubscreenTitle(this._objCurrSubScreenData.strTitle)\n    );\n    _htmSubScreenTemplate = _htmSubScreenTemplate.replace(\n      'XX_SUB_SCREEN_CONTENT_XX',\n      this._generateSubScreenContent()\n    );\n\n    // Set developer class names if any are present.\n    if (subscreenRawData &&\n      subscreenRawData.objDeveloperOptions &&\n      subscreenRawData.objDeveloperOptions.objAdvancedStyling &&\n      subscreenRawData.objDeveloperOptions.objAdvancedStyling.strCustomCSSClasses) {\n      _htmSubScreenTemplate = _htmSubScreenTemplate.replace(\n        /XX_DEVELOPER_CLASS_XX/g,\n        subscreenRawData.objDeveloperOptions.objAdvancedStyling.strCustomCSSClasses\n      );\n    } else {\n      _htmSubScreenTemplate = _htmSubScreenTemplate.replace(/XX_DEVELOPER_CLASS_XX/g, '');\n    }\n\n    return _htmSubScreenTemplate;\n  },\n\n  rerenderSubScreen: function(objCurrentRenderedItem) {\n    var _objCurrSubScreen;\n    var countAsset = 0;\n    if (SUB_SCREEN_INTERACTIONS._strIdCurrentShownSubScreen) {\n      // switch off animations before destroying the elements\n      var opts = {animations: false};\n      SUB_SCREEN_INTERACTIONS.setHideSubScreensAssetsOptions(opts);\n      EM.trigger('closeSubScreen', {\n        strSubScreenID: SUB_SCREEN_INTERACTIONS._strIdCurrentShownSubScreen\n      });\n      // switch off hideasset options now they've been closed\n      SUB_SCREEN_INTERACTIONS.setHideSubScreensAssetsOptions(false);\n    }\n    var intCount = 0;\n    while (intCount < objCurrentRenderedItem.arrScreens.length) {\n      var _arrSubScreensData = objCurrentRenderedItem.arrScreens[intCount].arrSubScreens;\n      var domScreen =\n        SCREEN_INTERACTIONS.getScreenWrapper(objCurrentRenderedItem.arrScreens[intCount].strObjID);\n      var domSubScreenCollection = CORE.getElementsByClassName(\n        domScreen,\n        'subScreenCollectionC'\n      )[0];\n\n      var _domSubScreens = '';\n\n      for (var i = 0; i < _arrSubScreensData.length; i++) {\n        // We don't want to rebuild asset owned subscreens in the subscreencollects element. But\n        // we want to keep the cloned subscreens as they aren't consumed.\n        if (\n          !_arrSubScreensData[i].objRawData.booAssetOwnedSubscreen ||\n          (_arrSubScreensData[i].objRawData.booAssetOwnedSubscreen &&\n            _arrSubScreensData[i].objRawData.cloned)\n        ) {\n          _objCurrSubScreen = _arrSubScreensData[i];\n\n          _objCurrSubScreen.rerenderedSubscreen = true;\n\n          // If the subscreen hasn't been rendered yet, don't rerender it\n          if (this.renderedSubscreens[_objCurrSubScreen.strObjID] !== true) {\n            continue;\n          }\n\n          var domCurrSubScreen =\n            SUB_SCREEN_INTERACTIONS.getSubScreenDOMElement(_objCurrSubScreen.strObjID);\n          if (typeof domCurrSubScreen == 'undefined') {\n            return;\n          }\n\n          countAsset = 0;\n          while (countAsset < _objCurrSubScreen.arrAssets.length) {\n            ASSET_INTERACTIONS.preRerenderedAsset(_objCurrSubScreen.arrAssets[countAsset], true);\n            countAsset++;\n          }\n\n          var domCurrSubScreenContent =\n            SUB_SCREEN_INTERACTIONS.getSubScreenContentDOMElement(_objCurrSubScreen.strObjID);\n          this._objTempStoreSubScreenContent[_objCurrSubScreen.strObjID] = {\n            htmSubScreenContent: domCurrSubScreenContent.innerHTML\n          };\n\n          this.renderedSubscreens[_objCurrSubScreen.strObjID] = false;\n          var domSubScreenParent = domCurrSubScreen.parentNode;\n          domSubScreenParent.removeChild(domCurrSubScreen);\n\n          // Unregister the subscreen in translations\n          gomo.dataBinding.unregister(_objCurrSubScreen.strObjID);\n          // unregister subscreen localisation translations\n          gomo.translationManager.unregisterLocalisation('subscreen', _objCurrSubScreen.strObjID);\n\n          if (\n            _objCurrSubScreen.strType == 'standard' ||\n            _objCurrSubScreen.strType.indexOf('reveal') != -1\n          ) {\n            _domSubScreens += this.renderSubScreen(_objCurrSubScreen, false);\n          } else {\n            _domSubScreens += this.renderSubScreen(_objCurrSubScreen, _objCurrSubScreen.strType);\n          }\n\n          delete this._objTempStoreSubScreenContent[this._objCurrSubScreenData.strObjID];\n        }\n      }\n      domSubScreenCollection.innerHTML = _domSubScreens;\n      // Reset subscreen bindings\n      for (var j = 0; j < _arrSubScreensData.length; j++) {\n        // We don't want to rebuild asset owned subscreens in the subscreencollects element. But\n        // we want to keep the cloned subscreens as they aren't consumed.\n        if (\n          !_arrSubScreensData[j].objRawData.booAssetOwnedSubscreen ||\n          (_arrSubScreensData[j].objRawData.booAssetOwnedSubscreen &&\n            _arrSubScreensData[j].objRawData.cloned)\n        ) {\n          _objCurrSubScreen = _arrSubScreensData[j];\n\n          _objCurrSubScreen.rerenderedSubscreen = true;\n\n          countAsset = 0;\n          while (countAsset < _objCurrSubScreen.arrAssets.length) {\n            // Don't attempt to bind assets which aren't rendered due to display conditions\n            if (_objCurrSubScreen.arrAssets[countAsset].booIsDisplayed) {\n              var _objWhatRawAssetData = _objCurrSubScreen.arrAssets[countAsset].objRawData;\n              var _domCurrentAsset = ASSET_RENDERER.getAssetDOMElement(_objWhatRawAssetData);\n\n              if (_domCurrentAsset) {\n                // Unregister the old asset and reset globally below\n                gomo.dataBinding.unregister(_objWhatRawAssetData.strID);\n              }\n            }\n            countAsset++;\n          }\n        }\n      }\n      intCount++;\n    }\n    // Add translations to all subscreens and assets in topic, if not set\n    gomo.translationManager.updateBoundFields();\n    gomo.translationManager.updateBoundLocalisations();\n  },\n\n  subScreenTypeSizeOverride: function(_strOverRideSubScreenType, _strOptionalPreviousSize) {\n    var _strUpdatedOverRideSubScreenType = _strOverRideSubScreenType;\n    if (\n      typeof ALLOW_SUBSCREEN_TYPE_AUTO_OVERRIDES == 'undefined' ||\n      ALLOW_SUBSCREEN_TYPE_AUTO_OVERRIDES == true\n    ) {\n      var _strBlacklistItem;\n      for (_strBlacklistItem in this.objScreenSizeCompatibilityBlacklist) {\n        if (_strBlacklistItem == _strOverRideSubScreenType) {\n          var count = 0;\n          // Some subscreens will have opened in another mode and will need to close in that mode\n          // too.\n          var _strCurrentScreenSize = '';\n          if (\n            typeof _strOptionalPreviousSize != 'undefined' &&\n            _strOptionalPreviousSize != OUTPUT_MODE_CHECKER.strCurrentScreenSize\n          ) {\n            _strCurrentScreenSize = _strOptionalPreviousSize;\n          } else {\n            _strCurrentScreenSize = OUTPUT_MODE_CHECKER.strCurrentScreenSize;\n          }\n\n          while (\n            count <\n            this.objScreenSizeCompatibilityBlacklist[_strOverRideSubScreenType]['arrBlackList']\n              .length\n          ) {\n            if (\n              _strCurrentScreenSize ==\n              this.objScreenSizeCompatibilityBlacklist[_strOverRideSubScreenType]['arrBlackList'][\n                count\n              ]\n            ) {\n              _strUpdatedOverRideSubScreenType = this.objScreenSizeCompatibilityBlacklist[\n                _strOverRideSubScreenType\n              ].strFallback;\n            }\n            count++;\n          }\n        }\n      }\n    }\n    return _strUpdatedOverRideSubScreenType;\n  },\n\n  isPopoverOverride: function() {\n    if (typeof FORCE_POPOVER_SUBSCREENS !== 'undefined' && FORCE_POPOVER_SUBSCREENS) {\n      // Assets that own the subscreen will exact back a certain type so these can't be changed\n      if (this._objCurrSubScreenData.objRawData.booAssetOwnedSubscreen) {\n        return false;\n      }\n      return true;\n    }\n    return false;\n  },\n\n  resetRenderedSubscreens: function(subscreenIds) {\n    var me = this;\n    if (subscreenIds) {\n      if (!_.isArray(subscreenIds)) {\n        subscreenIds = [subscreenIds];\n      }\n      _.each(subscreenIds, function(id) {\n        delete me.renderedSubscreens[id];\n      });\n    } else {\n      me.renderedSubscreens = {};\n    }\n  },\n\n  _generateSubScreenContent: function() {\n    var _htmContentData = '';\n    if (this._objTempStoreSubScreenContent[this._objCurrSubScreenData.strObjID]) {\n      _htmContentData = this._objTempStoreSubScreenContent[this._objCurrSubScreenData.strObjID]\n        .htmSubScreenContent;\n    } else {\n      var count = 0;\n      while (count < this._objCurrSubScreenData.arrChildLayouts.length) {\n        var _objCurrLayoutWrapper = this._objCurrSubScreenData.arrChildLayouts[count];\n        _htmContentData += LAYOUT_RENDERER.renderLayoutBlock(\n          _objCurrLayoutWrapper,\n          this._objCurrSubScreenData,\n          false,\n          count\n        );\n        count++;\n      }\n    }\n    return _htmContentData;\n  },\n\n  _cleanseSubscreenTitle: function(subscreenTitle) {\n    var cleansedTitle = 'Subscreen';\n    if (subscreenTitle && subscreenTitle !== ''\n    && subscreenTitle !== ' ') {\n      cleansedTitle = subscreenTitle;\n    }\n    return cleansedTitle;\n  },\n\n  _getSubScreenAlingment: function(_objWhatParentAsset) {\n    var _objWhatParentScreen = _objWhatParentAsset.objParent;\n    if (_objWhatParentScreen.intColumns == 1) {\n      return this._strBottomCenterSubScreenClass;\n    } else {\n      if (_objWhatParentAsset.intColumnAffinity == 1) {\n        return this._strRightMiddleSubScreenClass;\n      } else if (_objWhatParentAsset.intColumnAffinity == 0) {\n        return this._strBottomCenterSubScreenClass;\n      } else {\n        return this._strLeftMiddleSubScreenClass;\n      }\n    }\n  },\n\n  debug: function(strMessage, intPriority, objCallerObject, booCalleeChain) {\n    if (DEBUG) {\n      DEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n    }\n  }\n};\n"},function(n,e,t){t(0)(t(111))},function(n,e){n.exports='/**\n* @title Version Choice Interactions\n* @description To be described. \n*\n*\n* @author GoMo\n* @version 2.0 17/12/12\n*/\n\nvar VERSION_CHOICE_INTERACTIONS =\n{\n\tstrObjID : "The version choice screen interactions",\n\tstrObjDescription : "This object is responsible for processing the version choice events",\n\n\thandleEvent_chooseVersion : function(_strWhatVersionChoice)\n\t{\n\t\t//alert("_strWhatVersionChoice: " + _strWhatVersionChoice)\n\t\tEM.trigger("userVersionChoice", {\'strWhatVersionChoice\':_strWhatVersionChoice, \'booSurpressReRender\':true});\n\t\t\n\t\t//Entry suqence doesn\'t exist in the new loader setup.\n\t\t//EM.trigger("continueEntrySequence");\n\t},\n\n\n\tdebug : function (strMessage, intPriority, objCallerObject, booCalleeChain)\n\t{\n\t\tif (DEBUG)\n\t\t{\n\t\t\tDEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n\t\t}\n\t}\n}\n\nEM.register(VERSION_CHOICE_INTERACTIONS);'},function(n,e,t){t(0)(t(113))},function(n,e){n.exports="/* global $, TOPIC_MANAGER, SCREEN_INTERACTIONS, EM, CORE, OBJ_REF, OUTPUT_MODE_CHECKER */\n/* global BOO_MASTER_SCREEN_NEXT_BUTTON_LOCK, LOCALISER, DEBUG, CONTENT_TRACKING */\n/* global SUB_SCREEN_RENDERER, OBJ_SCREEN_CHECKING_HEARTBEAT_BY_MODE */\n/* global BOO_SMARTPHONE_HIDE_NAV_FOR_POPUPS, INT_DEFAULT_BASE_PASS, INT_DEFAULT_GOOD_PASS, _ */\n/* eslint-disable max-len */\n\n/**\n * @title Topic Interactions\n * @description To be described.\n *\n *\n * @author GoMo\n * @version 2.0 17/12/12\n */\n\nvar TOPIC_INTERACTIONS =\n{\n  strObjID: 'Topic interactions',\n  strObjDescription: 'Handles the topic related interactions such as showing pages and adjusting the navigation.',\n\n  booInTopic: false,\n\n  // REFACTOR NOTE : remove orientation (search for duplicate refactors)\n  // _strOrientationModeID : \"orientationModeL\",\n  _strContentHolderID: 'pageWrapperL',\n  _strBrowserResizeMessageID: 'browserResizedMessageL',\n\n  _strPortraitModeClass: 'portraitModeC',\n  _strLandscapeMode: 'landscapeModeC',\n\n  _objWhatDOM: null,\n\n  _booLockedButtonStatus: false,\n\n  _strLockedButtonClass: ' lockedButtonC',\n  _strInactiveButtonClass: 'disabledButtonC',\n  _strActiveButtonClass: 'activeButtonC',\n\n  _strBackButtonID: 'backButtonL',\n  _strNextButtonID: 'nextButtonL',\n\n  _strCurrTopicModel: '',\n\n  _objElementReferences: {},\n\n  _booRecheckPending: false,\n\n  _strBaseNavigationOverride: 'EM.trigger(\\'preNavigate\\', \\'goToPage\\'); return EM.trigger(\\'goToPage\\', \\'XX_NAVIGATION_TARGET_XX\\')',\n\n  _booInImageZoom: false,\n\n  _objResizeOrientationCheckTimer: null,\n  _objDeviceRecheckTimer: null,\n  _objResizeOrientationHeartbeatInterval: null,\n\n  _intConstantAvailHeight: null,\n  _intConstantAvailWidth: null,\n  _intSmallestLikelyKeyboardHeight: 100,\n\n  _intResizeOrientationHeartbeatTime: 2000,\n\n  handleEvent_primeDOMReferences: function(_objWhatDOM) {\n    this._objWhatDOM = _objWhatDOM;\n  },\n\n  handleEvent_setTopicModelType: function(_strWhatTopicModel) {\n    // alert(\"handleEvent_setTopicModelType\");\n    this._strCurrTopicModel = _strWhatTopicModel;\n    this.booInTopic = true;\n  },\n\n  handleEvent_showNextButtonFromAsset: function() {\n    var _objCurrTopic = TOPIC_MANAGER.getCurrentTopic();\n    var _objCurrScreenData = SCREEN_INTERACTIONS.getCurrentScreenData();\n    if (((_objCurrTopic.intNavigationIndex + 1) < _objCurrTopic.arrScreens.length) && (_objCurrScreenData.booScreenComplete)) {\n      this._activateButton(this._strNextButtonID);\n    }\n  },\n\n  // REFACTOR NOTE : this and \"handleEvent_deviceOrientationChange\" should move into it's own object at somepoint.\n\n  // REFACTOR NOTE : This method seemed to be redundant; iPhone and iPad both catch from the \"onorientationchange\" event\n  handleEvent_browserResize: function() {\n    if (!window['onorientationchange']) {\n      if (!this._objResizeOrientationCheckTimer) {\n        this._objResizeOrientationCheckTimer = window.setTimeout(function() {\n          EM.trigger('deviceOrientationChange');\n        }, 500);\n      }\n    }\n  },\n\n  // REFACTOR NOTE : remove orientation (search for duplicate refactors)\n  /*\n  handleEvent_deviceOrientationChange : function()\n  {\n    if (this._objResizeOrientationCheckTimer)\n    {\n      window.clearTimeout(this._objResizeOrientationCheckTimer);\n      this._objResizeOrientationCheckTimer = null;\n    }\n    if ((BOO_IGNORE_RESIZE_EVENTS)\n      || ((( (typeof VIDEO_JS_INTERFACE != 'undefined') && VIDEO_JS_INTERFACE.isVideoPlaying() )\n          || ((typeof ASSET_INTERACTIONS.isVideoPlaying != 'undefined')\n          && ASSET_INTERACTIONS.isVideoPlaying()) ) && (OUTPUT_MODE_CHECKER.isSmartPhone()\n          || OUTPUT_MODE_CHECKER.isTablet() ))\n      || (OUTPUT_MODE_CHECKER.isBlackberryPhone() ))\n    {\n      return;\n    }\n\n    var _strScreenOrientation = this._getScreenSizeBasedOrientation();\n\n    if (_strScreenOrientation  != \"softKeyboardOpen\")\n    {\n      if (_strScreenOrientation == \"portrait\")\n      {\n        //alert(\"portrait\");\n        EM.trigger(\"changeToPortaitMode\");\n      }\n      else\n      {\n        //alert(\"changeToLandscapeMode\");\n        EM.trigger(\"changeToLandscapeMode\");\n      }\n    }\n\n    // Some devices don't update the screen sizes until after the orientation change is completed.\n    if (!this._booRecheckPending)\n    {\n      this._booRecheckPending = true;\n      this._objDeviceRecheckTimer = window.setTimeout(\"TOPIC_INTERACTIONS.recheckDeviceOrientation();\", 1000);\n    }\n    else\n    {\n      this._booRecheckPending = false;\n    }\n  },\n\n  handleEvent_changeToPortaitMode : function()\n  {\n    // Workaround for IE, which trigger's the resize event spuriously during the page load\n    if (!this._objWhatDOM)\n    {\n        return;\n    }\n    if (this._booInImageZoom)\n    {\n        return;\n    }\n    var _domOrientationModeTag = this._objWhatDOM.getElementById(this._strOrientationModeID);\n\n    // If we're on an iPhone and we're changing back to portrait from landscape mode; trigger the refreshing of relevant assets\n    if ((_domOrientationModeTag.className == this._strLandscapeMode) && (OUTPUT_MODE_CHECKER.isSmartPhone() && OUTPUT_MODE_CHECKER.isIOSDevice()))\n    {\n      //alert(\"Landscape to portrait switch for iPhone.\\n_domOrientationModeTag.className: \" + _domOrientationModeTag.className + \"\\nOUTPUT_MODE_CHECKER.isSmartPhone(): \" + OUTPUT_MODE_CHECKER.isSmartPhone() + \"\\nOUTPUT_MODE_CHECKER.isIOSDevice():\" + OUTPUT_MODE_CHECKER.isIOSDevice());\n      EM.trigger(\"refreshVolatileAssetsForIOS\", \"iPhone\");\n    }\n\n    if ((_domOrientationModeTag.className == this._strLandscapeMode) && (OUTPUT_MODE_CHECKER.isSmartPhone()) && (!OUTPUT_MODE_CHECKER.isBlackberryPhone()))\n    {\n      EM.trigger(\"updateBrowserHeight\");\n    }\n\n    if(typeof ISCROLL_INTERFACE != 'undefined')\n    {\n      ISCROLL_INTERFACE.refreshIScrolls();\n    }\n\n    _domOrientationModeTag.className = this._strPortraitModeClass;\n  },\n\n  handleEvent_changeToLandscapeMode : function()\n  {\n    // Workaround for IE, which trigger's the resize event spuriously during the page load\n    if (!this._objWhatDOM)\n    {\n        return;\n    }\n    if (this._booInImageZoom)\n    {\n        return;\n    }\n\n    var _domOrientationModeTag = this._objWhatDOM.getElementById(this._strOrientationModeID);\n\n    // If we're on an iPad and we're changing back to landscape from portrait mode; trigger the refreshing of relevant assets\n    if ((_domOrientationModeTag.className == this._strPortraitModeClass) && (OUTPUT_MODE_CHECKER.isTablet() && OUTPUT_MODE_CHECKER.isIOSDevice()))\n    {\n      //alert(\"Portrait to landscape switch for iPad.\\n_domOrientationModeTag.className: \" + _domOrientationModeTag.className + \"\\nOUTPUT_MODE_CHECKER.isTablet(): \" + OUTPUT_MODE_CHECKER.isTablet() + \"\\nOUTPUT_MODE_CHECKER.isIOSDevice():\" + OUTPUT_MODE_CHECKER.isIOSDevice());\n      EM.trigger(\"refreshVolatileAssetsForIOS\", \"iPad\");\n    }\n\n  window.setTimeout(function(){\n    if(typeof ISCROLL_INTERFACE != 'undefined')\n    {\n      ISCROLL_INTERFACE.refreshIScrolls()\n    }\n  }, 0);\n\n    _domOrientationModeTag.className = this._strLandscapeMode;\n  },\n  */\n\n  handleEvent_zoomImage: function() {\n    this._booInImageZoom = true;\n  },\n\n  handleEvent_unzoomImage: function() {\n    this._booInImageZoom = false;\n    setTimeout(function() {\n      EM.trigger('browserResize');\n    }, 0);\n  },\n\n  handleEvent_prepForTopicExit: function() {\n    var _objCurrTopic = CORE.objCurrCourseObject;\n    var count = 0;\n    while (count < _objCurrTopic.arrScreens.length) {\n      var _objCurrScreen = _objCurrTopic.arrScreens[count];\n      SCREEN_INTERACTIONS.resetScreensAssets(_objCurrScreen.strObjID, true);\n      count++;\n    }\n    SUB_SCREEN_RENDERER.resetRenderedSubscreens();\n\n    this.booInTopic = false;\n  },\n\n  handleEvent_gotoTutorialMenuItem: function(_strWhatMenuItemID) {\n    var _objWhatCourseItem = OBJ_REF.get(_strWhatMenuItemID);\n    var _objCurrCourseItem = TOPIC_MANAGER.getCurrentTopic();\n    if (_objWhatCourseItem && (_objWhatCourseItem !== _objCurrCourseItem)) {\n      EM.trigger('popupButtonClicked', {'strPopupID': 'popup_topic', 'strTopicID': _strWhatMenuItemID});\n    }\n  },\n\n  handleEvent_questionMaxAttemptsReached: function() {\n    if (this._booCanActivateNavButton('next')) {\n      this._activateButton(this._strNextButtonID);\n    }\n\n    // JC Removed as assessments don't generaly show the back button ever\n    /*\n    if(this._booCanActivateNavButton(\"back\"))\n    {\n      this._activateButton(this._strBackButtonID);\n    }\n    */\n  },\n\n  handleEvent_preNavigate: function(_objNavigationData) {\n    if (this.booInTopic) {\n      if (_objNavigationData.strWhatModifier) {\n        var nextTopicId = TOPIC_MANAGER.getTopicId(_objNavigationData.strWhatModifier);\n        var _objCurrCourseItem = TOPIC_MANAGER.getCurrentTopic();\n        // make sure we are not staying in the same topic\n        if (nextTopicId && nextTopicId !== _objCurrCourseItem.strObjID) {\n          var _arrScreens = _objCurrCourseItem.arrScreens;\n          var count = 0;\n          while (count < _arrScreens.length) {\n            var _objCurrScreen = _arrScreens[count];\n            SCREEN_INTERACTIONS.resetScreensAssets(_objCurrScreen.strObjID, true);\n            count++;\n          }\n\n          if (this['_reset_' + CORE.objCurrCourseObject.strObjTopicModel + '_NavigationModel']) {\n            this['_reset_' + CORE.objCurrCourseObject.strObjTopicModel + '_NavigationModel']();\n          }\n\n          this.booInTopic = false;\n          OUTPUT_MODE_CHECKER.resetScreenSizeCheckObj();\n          EM.trigger('prepForTopicExit');\n        }\n      }\n    }\n  },\n\n  // REFACTOR NOTE: Done as an event in preparation for refactoring this function into the Screen Size manager\n  handleEvent_checkStartOrientationCheckHeartBeat: function() {\n    var _strCurrPrimaryOutputModeKey = OUTPUT_MODE_CHECKER.strCurrentMode;\n    var _strCurrDeviceTypeKey = OUTPUT_MODE_CHECKER.strWhatOSClass;\n\n    var _booStartTimer = false;\n\n    if (OBJ_SCREEN_CHECKING_HEARTBEAT_BY_MODE[_strCurrPrimaryOutputModeKey] && OBJ_SCREEN_CHECKING_HEARTBEAT_BY_MODE[_strCurrPrimaryOutputModeKey][_strCurrDeviceTypeKey]) {\n      _booStartTimer = OBJ_SCREEN_CHECKING_HEARTBEAT_BY_MODE[_strCurrPrimaryOutputModeKey][_strCurrDeviceTypeKey];\n    }\n    // alert(\"_strCurrPrimaryOutputModeKey: \" + _strCurrPrimaryOutputModeKey + \"\\n_strCurrDeviceTypeKey: \" + _strCurrDeviceTypeKey + \"\\n_booStartTimer: \" + _booStartTimer);\n\n    if (_booStartTimer) {\n      this._objResizeOrientationHeartbeatInterval = window.setInterval(\n        function() {\n          TOPIC_INTERACTIONS.recheckDeviceOrientation();\n          EM.trigger('updateBrowserHeight');\n        },\n        this._intResizeOrientationHeartbeatTime\n      );\n    }\n  },\n\n  handleEvent_groupVariableUpdated: function(_objEventData) {\n    var _objCurrCourseItem = TOPIC_MANAGER.getCurrentTopic();\n    if (_objCurrCourseItem) {\n      var _arrScreens = _objCurrCourseItem.arrScreens;\n      var count = 0;\n      while (count < _arrScreens.length) {\n        var _objCurrScreen = _arrScreens[count];\n        SCREEN_INTERACTIONS.updateVariableReferences(_objCurrScreen, _objEventData);\n        count++;\n      }\n    }\n  },\n\n  recheckDeviceOrientation: function() {\n    EM.trigger('deviceOrientationChange');\n  },\n\n  clearRunningTimers: function() {\n    if (this._objResizeOrientationCheckTimer) {\n      window.clearTimeout(this._objResizeOrientationCheckTimer);\n    }\n    if (this._objDeviceRecheckTimer) {\n      window.clearTimeout(this._objDeviceRecheckTimer);\n    }\n    if (this._objResizeOrientationHeartbeatInterval) {\n      window.clearInterval(this._objResizeOrientationHeartbeatInterval);\n    }\n  },\n\n  switchToScreen: function(_strWhatScreenID, _intCurrPage, _intTotalPages, _strDirection, _objOptionalData) {\n    // alert(\"_strDirection:\" + _strDirection);\n\n    // WBI.log(\"TOPIC_INTERACTIONS.switchToScreen(); - END\");\n    SCREEN_INTERACTIONS.switchToScreen(_strWhatScreenID, _strDirection, _objOptionalData);\n\n    this._updateNavigation(_intCurrPage, _intTotalPages, _strWhatScreenID);\n    // WBI.log(\"TOPIC_INTERACTIONS.switchToScreen(); - END\");\n  },\n\n  addAnsweredQuestionAssetToTopic: function(_objWhatAsset, additionalTrackingData) {\n    EM.trigger('questionAssetAnswered', _objWhatAsset);\n    var screenTitle = _objWhatAsset.objParent && _objWhatAsset.objParent.strTitle ? _objWhatAsset.objParent.strTitle : _objWhatAsset.strTitle;\n    additionalTrackingData = additionalTrackingData || {};\n\n    if (CONTENT_TRACKING.config &&\n      CONTENT_TRACKING.config.appendTimestampsToInteractions &&\n      additionalTrackingData.id) {\n      additionalTrackingData.id += '-' + additionalTrackingData.response.timeResponse.getTime();\n    }\n\n    CONTENT_TRACKING.interaction($.extend(true, additionalTrackingData, {\n      type: 'answered',\n      activity: {\n        id: _objWhatAsset.strObjID,\n        title: screenTitle,\n        type: (additionalTrackingData.activity && additionalTrackingData.activity.type)\n          ? additionalTrackingData.activity.type\n          : 'question',\n        choices: (additionalTrackingData && additionalTrackingData.choices &&\n          !_.isEmpty(additionalTrackingData.choices) ? additionalTrackingData.choices: null),\n        source: (additionalTrackingData && additionalTrackingData.source)\n          ? additionalTrackingData.source\n          : null,\n        target: (additionalTrackingData && additionalTrackingData.target)\n          ? additionalTrackingData.target\n          : null\n      },\n      result: {\n        success: _objWhatAsset.booIsCorrect || false\n        /* score: {\n          min: 0,\n          max: 1,\n          raw: _objWhatAsset.booIsCorrect ? 1 : 0\n        }*/\n      }\n    }));\n  },\n\n  removeAnsweredQuestionAssetToTopic: function(_objWhatAsset) {\n    EM.trigger('questionAssetReset', _objWhatAsset);\n  },\n\n  addViewedQuestionAssetToTopic: function(_objWhatAsset) {\n    EM.trigger('questionAssetViewed', _objWhatAsset);\n  },\n\n  getAnsweredQuestionAssets: function() {\n    var _objCurrTopicDataWrapper = TOPIC_MANAGER.getCurrentTopic();\n\n    var _objTopicAnsweredQuestionAssets = _objCurrTopicDataWrapper.objAnsweredQuestions;\n    var _objTopicViewedQuestionAssets = _objCurrTopicDataWrapper.objViewedQuestions;\n\n    // NOTE: This function could simply return the viewed questions as they would equate to\n    // the same thing. However the duel storage allows for more flexible dev. later on, as\n    // answered questions may be mutated by adding them to answered list.\n    var _objCombinedList = {};\n    for (var _strCurrID in _objTopicViewedQuestionAssets) {\n      if (!_objTopicAnsweredQuestionAssets[_strCurrID]) {\n        _objCombinedList[_strCurrID] = _objTopicViewedQuestionAssets[_strCurrID];\n      } else {\n        _objCombinedList[_strCurrID] = _objTopicAnsweredQuestionAssets[_strCurrID];\n      }\n    }\n\n    return _objCombinedList;\n  },\n\n  // REFACTOR: I think this is redundant now. Needs confirmation and then deleting. JH\n  getPassMarks: function() {\n    var _objAssessmentIntroAsset = TOPIC_MANAGER.getAssessmentIntroAsset();\n    var _intGoodPass;\n    var _intBasePass;\n    if ((_objAssessmentIntroAsset.objRawData['@highpassmark']) && (_objAssessmentIntroAsset.objRawData['@highpassmark'] != '') && (!isNaN(parseInt(_objAssessmentIntroAsset.objRawData['@highpassmark'])))) {\n      _intGoodPass = parseInt(_objAssessmentIntroAsset.objRawData['@highpassmark']);\n    } else {\n      _intGoodPass = INT_DEFAULT_GOOD_PASS;\n    }\n    if ((_objAssessmentIntroAsset.objRawData['@passmark']) && (_objAssessmentIntroAsset.objRawData['@passmark'] != '') && (!isNaN(parseInt(_objAssessmentIntroAsset.objRawData['@passmark'])))) {\n      _intBasePass = parseInt(_objAssessmentIntroAsset.objRawData['@passmark']);\n    } else {\n      _intBasePass = INT_DEFAULT_BASE_PASS;\n    }\n    return {'intGoodPass': _intGoodPass, 'intBasePass': _intBasePass};\n  },\n\n  hideAll: function() {\n    var _domPageWrapper = this._objWhatDOM.getElementById(this._strContentHolderID);\n    _domPageWrapper.className = _domPageWrapper.className.replace('shownPageWrapperC', 'hiddenPageWrapperC');\n  },\n\n  showAll: function() {\n    var _domPageWrapper = this._objWhatDOM.getElementById(this._strContentHolderID);\n    _domPageWrapper.className = _domPageWrapper.className.replace('hiddenPageWrapperC', 'shownPageWrapperC');\n  },\n\n  // REFACTOR NOTE: Move this functionality out of here and use the screen size managers version.\n  getScreenSize: function(_strWhatAxis) {\n    return window['inner' + _strWhatAxis];\n  },\n\n  // REFACTOR NOTE: Move this functionality out of here and use the screen size managers version.\n  getWindowSize: function(_strWhatAxis) {\n    var _intWinSize = 0;\n\n    if (typeof(window.innerWidth) == 'number') {\n      // Non-IE\n      _intWinSize = window['inner' + _strWhatAxis];\n    } else if ((document.documentElement) && (document.documentElement.clientHeight)) {\n      // IE 6+ in 'standards compliant mode'\n      _intWinSize = document.documentElement['client' + _strWhatAxis];\n    } else if ((document.body) && (document.body.clientHeight)) {\n      // IE 4 compatible\n      _intWinSize = document.body['client' + _strWhatAxis];\n    }\n    return _intWinSize;\n  },\n\n  // REFACTOR NOTE: The refs to topic models should be removed.\n  updateNavigation: function(_intCurrentPage, _intTotalPages, _strWhatScreenID) {\n    this._update_linear_NavigationModel(_intCurrentPage, _intTotalPages, _strWhatScreenID);\n  },\n\n  // REFACTOR NOTE: Move this functionality out of here and use the screen size managers version?\n  _getScreenSizeBasedOrientation: function() {\n    // var _intScreenRawWidth = window.screen.width;\n    // var _intScreenRawHeight = window.screen.height;\n    // alert(\"_intScreenRawWidth: \" + _intScreenRawWidth + \"\\n_intScreenRawHeight: \" + _intScreenRawHeight);\n\n    var _intScreenAvailWidth = window.screen.availWidth;\n    var _intScreenAvailHeight = window.screen.availHeight;\n    // alert(\"\\n\\n_intScreenAvailWidth: \" + _intScreenAvailWidth + \"\\n_intScreenAvailHeight: \" + _intScreenAvailHeight)\n\n    if ( OUTPUT_MODE_CHECKER.booPreviewMode && OUTPUT_MODE_CHECKER.isSmartPhone() ) {\n      return 'portrait';\n    }\n\n    var _booHasSoftKeyboardOpened = this._booHasSoftKeyboardOpened(_intScreenAvailWidth, _intScreenAvailHeight);\n    if (_booHasSoftKeyboardOpened) {\n      return 'softKeyboardOpen';\n    }\n\n    var _intClientWidth = document.documentElement.clientWidth;\n    var _intClientHeight = document.documentElement.clientHeight;\n\n    // alert(\"_intScreenRawWidth: \" + _intScreenRawWidth + \"\\n_intScreenRawHeight: \" + _intScreenRawHeight + \"\\n\\n_intScreenAvailWidth: \" + _intScreenAvailWidth + \"\\n_intScreenAvailHeight: \" + _intScreenAvailHeight + \"\\n\\n_intClientWidth: \" + _intClientWidth + \"\\n_intClientHeight: \" + _intClientHeight)\n\n    var _intWidth = _intClientWidth;\n    var _intHeight = _intClientHeight;\n\n    if (_intWidth > _intHeight) {\n      return 'landscape';\n    }\n    if (_intWidth < _intHeight) {\n      return 'portrait';\n    }\n    if (OUTPUT_MODE_CHECKER.isTablet() || OUTPUT_MODE_CHECKER.isSmartPhone()) {\n      alert('Code is currently not optimized for a square screen. \\nFile: topic_interaction.js \\nMethod: _getScreenSizeBasedOrientation()');\n    }\n    return 'square';\n  },\n\n  /* This is currently only known to work on Android Smartphone 2.2.\n   * It's not working on android tablets 3.2 and 3.1.1.\n   * Any further requirements would need to be tested. */\n  _booHasSoftKeyboardOpened: function(_intScreenAvailWidth, _intScreenAvailHeight) {\n    if (this._intConstantAvailHeight == null) {\n      this._intConstantAvailHeight = _intScreenAvailHeight;\n    }\n    if (this._intConstantAvailWidth == null) {\n      this._intConstantAvailWidth = _intScreenAvailWidth;\n    }\n\n    // increase height if the original height was incorrect\n    if (this._intConstantAvailHeight < _intScreenAvailHeight) {\n      this._intConstantAvailHeight = _intScreenAvailHeight;\n    }\n\n    if (((this._intConstantAvailHeight - this._intSmallestLikelyKeyboardHeight) > _intScreenAvailHeight) && (this._intConstantAvailWidth == _intScreenAvailWidth)) {\n      return true;\n    }\n\n    return false;\n  },\n\n  _booCanActivateNavButton: function(_strWhatNavButton) {\n    var _objCurrCourseObject = CORE.getCurrentCourseObject();\n    var _intScreenCount = _objCurrCourseObject.arrScreens.length;\n    var _intCurrNavIndex = _objCurrCourseObject.intNavigationIndex;\n\n    switch (_strWhatNavButton) {\n      case 'next':\n        if (_intCurrNavIndex != (_intScreenCount-1)) {\n          return true;\n        } else {\n          return false;\n        }\n      /*\n      break;\n\n      case \"back\":\n\n        if(_intCurrNavIndex == 0)\n        {\n          return false;\n        }\n        else\n        {\n          return true;\n        }\n      break;*/\n    }\n  },\n\n  _updateNavigation: function(_intCurrPage, _intTotalPages, _strWhatScreenID) {\n    if (this['_update_' + this._strCurrTopicModel + '_NavigationModel']) {\n      this['_update_' + this._strCurrTopicModel + '_NavigationModel'](_intCurrPage, _intTotalPages, _strWhatScreenID);\n\n      if ( BOO_MASTER_SCREEN_NEXT_BUTTON_LOCK && OUTPUT_MODE_CHECKER._strUserVersionChoice != 'accessibleC' ) {\n        // disable by default and recheck for completion when all the assets have loaded.\n        this._booLockedButtonStatus = true;\n        this._lockButton(this._strNextButtonID);\n      }\n    } else {\n      // alert(\"ERROR: An unknown topic model of '\" + this._strCurrTopicModel + \"' was found in TOPIC_INTERACTIONS._updateNavigation(), topic_interactions.js\");\n      LOCALISER.l_alert('TOPIC_INTERACTIONS_UNKNOWN_TOPIC_NAVIGATION_MODEL_ERROR', [this._strCurrTopicModel]);\n    }\n  },\n\n  _update_linear_NavigationModel: function(_intCurrPage, _intTotalPages, _objScreenDataId) {\n    var _objScreenData = CORE.objCurrCourseObject.findScreen(_objScreenDataId);\n    if (_.isUndefined(_objScreenData.objNavigationItems)) return;\n    var _objBackButton = _objScreenData.objNavigationItems.objBackButtonConfiguration;\n    var _objNextButton = _objScreenData.objNavigationItems.objNextButtonConfiguration;\n    var _objBackAction = {'strType': 'goto_previous_screen'};\n    var _objNextAction = {'strType': 'goto_next_screen'};\n\n    // Back button display conditions\n    if (_objBackButton\n      && _objBackButton.arrActions\n      && _objBackButton.arrActions[0]) {\n      _objBackAction = _objBackButton.arrActions[0];\n    }\n\n    if (_intCurrPage == 1\n      && _objBackAction.strType == 'goto_previous_screen') {\n      this._deactivateButton(this._strBackButtonID);\n    } else {\n      this._activateButton(this._strBackButtonID);\n    }\n\n    // Next button display conditions\n    if (_objNextButton\n      && _objNextButton.arrActions\n      && _objNextButton.arrActions[0]) {\n      _objNextAction = _objNextButton.arrActions[0];\n    }\n\n    if (_intCurrPage == _intTotalPages\n      && _objNextAction.strType == 'goto_next_screen') {\n      this._deactivateButton(this._strNextButtonID);\n    } else {\n      this._activateButton(this._strNextButtonID);\n    }\n  },\n\n  hidePageNavigation: function() {\n    if ( BOO_SMARTPHONE_HIDE_NAV_FOR_POPUPS ) {\n      if (OUTPUT_MODE_CHECKER.isSmartPhone() || OUTPUT_MODE_CHECKER.isTablet() ) {\n        var _domNextNavElement = this._objWhatDOM.getElementById('nextButtonL');\n        var _domBackNavElement = this._objWhatDOM.getElementById('backButtonL');\n\n        if (_domNextNavElement) {\n          _domNextNavElement.style.display = 'none';\n        }\n        if (_domBackNavElement) {\n          _domBackNavElement.style.display = 'none';\n        }\n      }\n    }\n  },\n\n  showPageNavigation: function() {\n    if ( BOO_SMARTPHONE_HIDE_NAV_FOR_POPUPS ) {\n      if (OUTPUT_MODE_CHECKER.isSmartPhone() || OUTPUT_MODE_CHECKER.isTablet() ) {\n        var _domNextNavElement = this._objWhatDOM.getElementById('nextButtonL');\n        var _domBackNavElement = this._objWhatDOM.getElementById('backButtonL');\n\n        if (_domNextNavElement) {\n          _domNextNavElement.style.display = 'inline-block';\n        }\n        if (_domBackNavElement) {\n          _domBackNavElement.style.display = 'inline-block';\n        }\n      }\n    }\n  },\n\n  _update_tutorial_NavigationModel: function(_intCurrPage, _intTotalPages) {\n    this._update_linear_NavigationModel(_intCurrPage, _intTotalPages);\n  },\n\n  _update_scenario_NavigationModel: function(_intCurrPage, _intTotalPages) {\n    this._update_linear_NavigationModel(_intCurrPage, _intTotalPages);\n  },\n\n  _lockButton: function(_strWhatButtonID) {\n    var _domButtonRef = this._getDOMRef(_strWhatButtonID);\n    if (_domButtonRef) {\n      _domButtonRef.className = (_domButtonRef.className + this._strLockedButtonClass);\n      EM.trigger('updateMasterLock', true);\n    }\n  },\n\n  _unlockButton: function(_strWhatButtonID) {\n    var _domButtonRef = this._getDOMRef(_strWhatButtonID);\n    _domButtonRef.className = _domButtonRef.className.replace(this._strLockedButtonClass, '');\n    this._booLockedButtonStatus == false;\n    EM.trigger('updateMasterLock', false);\n  },\n\n  _deactivateButton: function(_strWhatButtonID) {\n    var _domButtonRef = this._getDOMRef(_strWhatButtonID);\n    if (_domButtonRef) {\n      _domButtonRef.className = _domButtonRef.className.replace(this._strActiveButtonClass, this._strInactiveButtonClass);\n      if (this._booLockedButtonStatus == true) {\n        this._unlockButton(_strWhatButtonID);\n      }\n    }\n  },\n\n  _activateButton: function(_strWhatButtonID) {\n    var _domButtonRef = this._getDOMRef(_strWhatButtonID);\n    if (_domButtonRef) {\n      _domButtonRef.className = _domButtonRef.className.replace(this._strInactiveButtonClass, this._strActiveButtonClass);\n      if (this._booLockedButtonStatus == true) {\n        this._unlockButton(_strWhatButtonID);\n      }\n    }\n  },\n\n  _overrideNavigationButtonAction: function(_strWhatButtonID, _strWhatNavAction) {\n    var _domButtonRef = this._getDOMRef(_strWhatButtonID);\n    if (_domButtonRef) {\n      var _strOnClickEvents = this._strBaseNavigationOverride.replace('XX_NAVIGATION_TARGET_XX', _strWhatNavAction);\n      _domButtonRef.onclick = new Function(_strOnClickEvents);\n    }\n  },\n\n  _getDOMRef: function(_strWhatID) {\n    this._objElementReferences[_strWhatID] = this._objWhatDOM.getElementById(_strWhatID);\n    return this._objElementReferences[_strWhatID];\n  },\n\n  debug: function(strMessage, intPriority, objCallerObject, booCalleeChain) {\n    if (DEBUG) {\n      DEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n    }\n  }\n};\n\nEM.register(TOPIC_INTERACTIONS);\n"},function(n,e,t){t(0)(t(115))},function(n,e){n.exports="/* globals BOO_DYNAMIC_CONTINUOUS_SCROLLING, TOPIC_MANAGER, SCROLLING_MANAGER, EM, $,\nSTR_DYNAMIC_TRANSITION_TYPE, ISCROLL_INTERFACE, BOO_MASTER_SCREEN_NEXT_BUTTON_LOCK, CORE,\nASSET_INTERACTIONS, VARIABLES_HOLDER, INT_VISITED, INT_COMPLETED, ErrorHandler, SUB_SCREEN_RENDERER,\nBOO_RESET_SCREEN_COMPLETION_STATE, BOO_RESET_NON_ASSESSMENT_ASSET_STATES, LAYOUT_INTERACTIONS,\nINT_UNVISITED, OUTPUT_MODE_CHECKER, TOP_STRAP_RENDERER, BOTTOM_STRAP_RENDERER, SCREEN_RENDERER,\nBOO_ANIMATE_SCREENS, ANIMATOR_INTERFACE_2, INT_TRANSITION_TIMER, svg4everybody,\nINT_BACKGROUND_FADE_DURATION, TEMPLATE_MANANGER, SUB_SCREEN_INTERACTIONS, _, GOMO_PREVIEW,\nDISPLAY_CONDITIONS_INTERACTIONS, MASTER_RENDERER, BOO_TURN_OFF_CONTINUOUS_SCROLL_ASSET_RESET,\nMOBILE_DRAWER_MENU */\n\n/*\n * @title Screen Interactions\n * @description To be described.\n *\n *\n * @author GoMo\n * @version 2.0 17/12/12\n * @versino 1.1 18/12/12 James Hough - add 'hiddenC' class name to hidden screens in\n * 'screenAnimationComplete'\n * @REFACTOR NOTE: Clean up the usage of _resetScreensAssets() and resetScreensAssets().\n */\n\nvar SCREEN_INTERACTIONS = {\n  strObjID: 'Screen interactions',\n  strObjDescription:\n    'Handles the common interactions, acts as a holder for the specific screen' +\n    'related interactions.',\n\n  _strScreenIDPrefix: 'screenWrapper_',\n  _strScreenIDSuffix: 'L',\n  _strHiddenScreenClass: 'hiddenScreenC',\n  _strShownScreenClass: 'shownScreenC',\n  _strLockedScreenClass: 'lockedScreenC',\n  _strEnabledInstructionClass: 'enabledInstructionC',\n  _strDisabledInstructionClass: 'disabledInstructionC',\n  _strInitialInstructionClass: 'instructionImportedC',\n  _strNextButton: 'nextButtonL',\n  _strBackButton: 'backButtonL',\n  _booScreenSwipeEnabled: true,\n\n  _objScreenCompletionStateClasses: {\n    0: 'notStartedScreenStateC',\n    1: 'visitedScreenStateC',\n    2: 'completedScreenStateC'\n  },\n\n  _strNotInteractedClass: 'screenNotInteractedWithC',\n  _strInteractedClass: 'screenInteractedWithC',\n\n  _strCurrContentWrapperID: 'contentWrapperL',\n  // REFACTOR NOTE: should be able to remove this if the handleEvent_screenAnimationComplete\n  // isn't required\n  _objAnimationHandles: {},\n  _objScreenVisibilityStates: {},\n  _strCurrDirection: 1,\n  _strAnimationAsset: 'screen',\n  // JC Seems depreciated\n  // _objDeviceWidth : {'intDesktopWidth' : 955, 'intSmartphoneWidth' : 320},\n  // _objDeviceHeight : {'intDesktopWidth' : 655, 'intSmartphoneWidth' : 480},\n\n  _strTempScrollerID: null,\n  _strTempAssetToScrollToID: null,\n\n  _objWhatDOM: null,\n\n  _strCurrOutputModeClass: 'graphicalC',\n\n  _strLastScreenID: '',\n  strCurrentScreenId: '',\n\n  objUnlockTimer: false,\n  _booInTopic: false,\n  _booInitialScreenLoad: false,\n  _booMasterNavigationLocked: false,\n  // prevent user interaction while screens are not 'displayReady'\n  _booScreenLocked: false,\n\n  _questionAssetType: 'question',\n\n  handleEvent_primeDOMReferences: function(_objWhatDOM) {\n    this._objWhatDOM = _objWhatDOM;\n  },\n\n  handleEvent_setTopicModelType: function(_strWhatTopicModel) {\n    this._strCurrTopicModel = _strWhatTopicModel;\n    this._booInTopic = true;\n  },\n\n  handleEvent_outputModeChanged: function(_objOutputChangeData) {\n    this._strCurrOutputModeClass = _objOutputChangeData['strNewOutputMode'];\n  },\n\n  handleEvent_changeContentWrapperID: function(_strNewContentWrapperID) {\n    this._strCurrContentWrapperID = _strNewContentWrapperID;\n  },\n\n  handleEvent_showCurrentPage: function(_booForceReRender) {\n    this._booInTopic = true;\n\n    // Initialise each cvisible screen in the topic.\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n      var topicScreens = TOPIC_MANAGER.getCurrentTopic().arrScreens;\n      var visibleScreens = SCROLLING_MANAGER.getVisibleScreenList();\n\n      for (var i = 0; i < topicScreens.length; i++) {\n        this._resetScreensAssets(topicScreens[i].strObjID, false);\n        this._performPreShowActions(topicScreens[i].strObjID);\n      }\n\n      // Run post shown events on all screens visible to the user.\n      for (var j = 0; j < visibleScreens.length; j++) {\n        this._showScreensPostRenderAssets(visibleScreens[j]);\n      }\n    }\n  },\n\n  handleEvent_navigationAction: function(_strActionId) {\n    var _objScreenData = this.getCurrentScreenData();\n\n    if (_strActionId == 'extra-next' || _strActionId == 'extra-back') {\n      _objScreenData.strOrigin = _strActionId;\n    }\n\n    for (var _strScreenButton in _objScreenData.objNavigationItems) {\n      if (\n        Object.prototype.hasOwnProperty.call(_objScreenData.objNavigationItems, _strScreenButton)\n      ) {\n        var _strScreenButtonId = _objScreenData.objNavigationItems[_strScreenButton].strExtrasId;\n        // This is for broken data, mixing old data with new data!\n        // Will be phased out and then needs removing!\n        var newExtraId = _strScreenButtonId;\n        switch (newExtraId) {\n          case 'nextButton':\n            newExtraId = 'extra-next';\n            break;\n          case 'backButton':\n            newExtraId = 'extra-back';\n            break;\n          case 'menuButton':\n            newExtraId = 'extra-menu';\n            break;\n        }\n\n        if (\n          newExtraId == _strActionId &&\n          _objScreenData.objNavigationItems[_strScreenButton].arrActions\n        ) {\n          var _arrActions = _objScreenData.objNavigationItems[_strScreenButton].arrActions;\n          _strActionId = _strScreenButton;\n        }\n      }\n    }\n\n    if (_arrActions) {\n      var _objActionOptions = {};\n      _objActionOptions.objActions = _arrActions;\n      _objActionOptions.objOptionalExtraData = _objScreenData;\n\n      // Example feed back for completion of subscreen display.\n      // _objActionOptions.objOptionalExtraData.funTriggerCallBack = function(){alert('Nav Action\n      // complete for ' + _strActionId)};\n\n      EM.trigger('processActions', _objActionOptions);\n    }\n  },\n\n  handleEvent_enableScreenSwipe: function() {\n    this._booScreenSwipeEnabled = true;\n  },\n\n  handleEvent_disableScreenSwiping: function() {\n    this._booScreenSwipeEnabled = false;\n  },\n\n  handleEvent_swipeLeft: function() {\n    if (this._booScreenSwipeEnabled && STR_DYNAMIC_TRANSITION_TYPE == 'horizontalSlide') {\n      if (gomo.translationManager.isRtlLanguage) {\n        this._activateButton(this._strBackButton);\n      } else {\n        this._activateButton(this._strNextButton);\n      }\n    }\n  },\n\n  handleEvent_swipeRight: function() {\n    if (this._booScreenSwipeEnabled && STR_DYNAMIC_TRANSITION_TYPE == 'horizontalSlide') {\n      if (gomo.translationManager.isRtlLanguage) {\n        this._activateButton(this._strNextButton);\n      } else {\n        this._activateButton(this._strBackButton);\n      }\n    }\n  },\n\n  handleEvent_swipeUp: function() {\n    if (this._booScreenSwipeEnabled && STR_DYNAMIC_TRANSITION_TYPE == 'verticalSlide') {\n      this._activateButton(this._strNextButton);\n    }\n  },\n\n  handleEvent_swipeDown: function() {\n    if (this._booScreenSwipeEnabled && STR_DYNAMIC_TRANSITION_TYPE == 'verticalSlide') {\n      this._activateButton(this._strBackButton);\n    }\n  },\n\n  handleEvent_modeStateAction: function(_strActionType) {\n    var _objScreenData = this.getCurrentScreenData();\n    var _arrActions = [\n      {\n        strType: 'setAccessibilityState',\n        strActionGroup: 'variables',\n        objParameters: {\n          strStateToSetTo: 'toggle'\n        },\n        strObjectType: 'action'\n      }\n    ];\n\n    if (_objScreenData) {\n      var _objActionOptions = {};\n      _objActionOptions.objActions = _arrActions;\n      _objActionOptions.objOptionalExtraData = _objScreenData;\n\n      EM.trigger('processActions', _objActionOptions);\n    }\n  },\n\n  handleEvent_preLoadTopicObject: function() {\n    this._objScreenVisibilityStates = {};\n    if (typeof ISCROLL_INTERFACE != 'undefined') {\n      ISCROLL_INTERFACE.recycleScroller(this._objWhatDOM);\n    }\n  },\n\n  handleEvent_refreshVolatileAssetsForIOS: function() {\n    if (this._booInTopic) {\n      var _strCurrScreenID = this.getLastScreenID();\n\n      this._hideScreensPostRenderAssets(_strCurrScreenID);\n      this._showScreensPostRenderAssets(_strCurrScreenID);\n    }\n  },\n\n  handleEvent_screenAnimationComplete: function(_objOptions) {\n    var _strScreenID = _objOptions.strWhatSubScreenElementID;\n    // WBI.log(\"handleEvent_screenAnimationComplete(), ID: \" + _strScreenID);\n    var _booAllAnimationsStill = true;\n\n    if (_booAllAnimationsStill) {\n      EM.trigger('updateAnimationLock', false);\n    }\n\n    var _domWhatScreenElement = this._objWhatDOM.getElementById(_strScreenID);\n\n    if (\n      _objOptions.strType &&\n      _objOptions.strType == 'shown' &&\n      _domWhatScreenElement != undefined &&\n      _domWhatScreenElement.style != undefined\n    ) {\n      // Post message to preview\n      if (OUTPUT_MODE_CHECKER.booPreviewMode && GOMO_PREVIEW) {\n        GOMO_PREVIEW.sendCurrentScreen({\n          topicId: TOPIC_MANAGER.getCurrentTopic().strObjID,\n          screenId: this.getCurrentScreenData().strObjID\n        });\n      }\n\n      // Switch off Transition as it's positioned off screen via CSS when screen isn't shown.\n      _domWhatScreenElement.style.webkitTransform = 'none';\n      _domWhatScreenElement.style.mozTransform = 'none';\n      _domWhatScreenElement.style.oTransform = 'none';\n      _domWhatScreenElement.style.msTransform = 'none';\n      _domWhatScreenElement.style.transform = 'none';\n\n      // Remove vertical scroll css.\n      var screenElement = _domWhatScreenElement;\n      if (this._strCurrDirection && this._strCurrDirection === '1') {\n        screenElement = $(_domWhatScreenElement).prev()[0];\n      }\n      ANIMATOR_INTERFACE_2.removeVerticalSlideCss(screenElement);\n    }\n\n    if (this._objScreenVisibilityStates[_strScreenID]) {\n      this._showScreensPostRenderAssets(_strScreenID);\n\n      this._addIScrollToScreen(_domWhatScreenElement);\n      if (typeof ISCROLL_INTERFACE != 'undefined') {\n        ISCROLL_INTERFACE.refreshIScrolls();\n      }\n      // WBI.log(\"Screen was shown, iScrolls et al updated.\\nTranslation CSS: \" +\n      // _domWhatScreenElement.style.webkitTransform );\n\n      if (BOO_MASTER_SCREEN_NEXT_BUTTON_LOCK) {\n        // this will force _changeScreenCompletionState() to set showNextButtonFromAsset if\n        // screen is complete.\n        this._booInitialScreenLoad = true;\n        this._booInitialScreenLoad = false;\n      }\n\n      this._checkScreenCompletionStatus();\n\n      EM.trigger('screenDisplayReady', _objOptions);\n    } else if (_domWhatScreenElement) {\n      if (typeof ISCROLL_INTERFACE != 'undefined') {\n        ISCROLL_INTERFACE.recycleScroller(_domWhatScreenElement);\n      }\n      _domWhatScreenElement.className = _domWhatScreenElement.className.replace(\n        this._strShownScreenClass,\n        this._strHiddenScreenClass\n      );\n      // WBI.log(\"Screen was hidden, iScrolls recycled.\\nTranslation CSS: \" +\n      // _domWhatScreenElement.style.webkitTransform );\n    }\n  },\n\n  handleEvent_screenDisplayReady: function(_objOptions) {\n    if (CORE.booFirstCourseScreenDisplayed == false) {\n      EM.trigger('firstCourseScreenDisplayed');\n    }\n\n    // Run Actions Callback\n    if (_objOptions.funCallBack && _objOptions.booTriggeredByActionsObj) {\n      _objOptions.funCallBack();\n    }\n\n    // Unlock the screen for user input\n    this.setScreenLock(false);\n\n    this.setScreenTitle();\n  },\n\n  handleEvent_updateAnimationLock: function(_booAnimationLockState) {\n    this._booAnimationLockState = _booAnimationLockState;\n    // If we're locking animations then we need to lock the screen\n    if (_booAnimationLockState) {\n      this.setScreenLock(true);\n    }\n  },\n\n  handleEvent_updateMasterLock: function(_booMasterLockState) {\n    this._booMasterNavigationLocked = _booMasterLockState;\n  },\n\n  setScreenLock: function(screenLocked) {\n    this._booScreenLocked = screenLocked;\n  },\n\n  setScreenTitle: function() {\n    var screenData = this.getCurrentScreenData();\n    if (!screenData) return;\n\n    // Topic title is not updated in screen data so check the translation data first otherwise\n    // use screen data.\n    var topicTitle = '';\n    if (gomo.translationManager.getTopicTitle() !== '') {\n      topicTitle = gomo.translationManager.getTopicTitle();\n    } else {\n      topicTitle =\n        screenData.objParent && screenData.objParent.strTitle ? screenData.objParent.strTitle : '';\n    }\n\n    // Screen title is updated on translation so use screen data. Screen title is blank in cont\n    // scroll topics.\n    var screenTitle =\n      screenData.strTitle && !BOO_DYNAMIC_CONTINUOUS_SCROLLING ? screenData.strTitle : '';\n\n    var seperatorChar = topicTitle === '' || screenTitle === '' ? '' : ' - ';\n    var title = topicTitle + seperatorChar + screenTitle;\n\n    document.title = gomo.utility.decodeHtml(title);\n  },\n\n  isScreenLocked: function() {\n    return this._booScreenLocked;\n  },\n\n  handleEvent_preNavigate: function() {\n    if (this._booMasterNavigationLocked) {\n      return;\n    }\n    // WBI.log(\"SCREEN_INTERACTIONS.handleEvent_preNavigate(); - START\");\n    if (this._booInTopic) {\n      var _objWhatScreenData = this._getScreenData(this._strLastScreenID);\n      var count = 0;\n      while (count < _objWhatScreenData.arrAssets.length) {\n        var _objCurrAsset = _objWhatScreenData.arrAssets[count];\n        ASSET_INTERACTIONS.stopAsset(_objCurrAsset);\n        count++;\n      }\n    }\n    // WBI.log(\"SCREEN_INTERACTIONS.handleEvent_preNavigate(); - END\");\n  },\n\n  handleEvent_setLastScreenID: function(_strLastScreenID) {\n    this._strLastScreenID = _strLastScreenID;\n  },\n\n  handleEvent_assetVisibilityUpdated: function(opts) {\n    var changedElements = false;\n    if (opts && opts.arrDisplayStateChangedAssets) {\n      changedElements = opts.arrDisplayStateChangedAssets;\n    }\n    this._checkScreenCompletionStatus();\n    gomo.tabManager.refreshTabIndexes('displayConditions', changedElements);\n    gomo.parallaxManager.refreshParallax();\n  },\n\n  handleEvent_screenVisibilityUpdated: function() {\n    gomo.parallaxManager.refreshParallax();\n  },\n\n  handleEvent_screenAssetInteracting: function(_objWhatAsset) {\n    var opts = {\n      'objOptionalExtraData': _objWhatAsset\n    };\n    EM.trigger('processActions', opts);\n    this._updateScreenInteractedStatus();\n    this._updateAssetCompletedStatus();\n    this._checkScreenCompletionStatus();\n    try {\n      VARIABLES_HOLDER.screenAssetInteractingUpdated(_objWhatAsset);\n    } catch (e) {\n      typeof ErrorHandler != 'undefined' && ErrorHandler['catch'] && ErrorHandler['catch'](e);\n    }\n  },\n\n  handleEvent_reportScreenCompletionStatus: function(_objWhatStatusData) {\n    var _intCompletionStatus = _objWhatStatusData['intStatus'];\n\n    if (_intCompletionStatus == INT_VISITED) {\n      if (this._booInitialScreenLoad == false) {\n        this._changeScreenCompletionState(INT_VISITED);\n      }\n    } else {\n      this._changeScreenCompletionState(INT_COMPLETED);\n      if (BOO_MASTER_SCREEN_NEXT_BUTTON_LOCK) {\n        EM.trigger('showNextButtonFromAsset');\n      }\n    }\n  },\n\n\n  handleEvent_updateTopicTracking: function() {\n    var screenData = this.getCurrentScreenData();\n    _.each(screenData.arrAssets, function(assetData) {\n      ASSET_INTERACTIONS.updateTopicTracking(assetData);\n    });\n  },\n\n  hideAllScreens: function() {\n    var _objDOMElement = this._getCurrentContentWrapper();\n    var _arrShownScreens = CORE.getElementsByClassName(_objDOMElement, this._strShownScreenClass);\n\n    this._hideScreens(_arrShownScreens);\n  },\n\n  switchToScreen: function(_strWhatScreenID, _strDirection, _objOptionalData) {\n    // Continuous scroll screens do not reset to prevent scrolling issues, so don't reset\n    // interaction and completed states.\n    if (\n      BOO_RESET_SCREEN_COMPLETION_STATE &&\n      !(BOO_DYNAMIC_CONTINUOUS_SCROLLING && BOO_TURN_OFF_CONTINUOUS_SCROLL_ASSET_RESET)\n    ) {\n      this._resetScreenInteractedState(_strWhatScreenID);\n      this._resetScreenCompletionState(_strWhatScreenID);\n    }\n\n    this._strLastScreenID = _strWhatScreenID;\n    if (_strDirection == null && typeof _objOptionalData != 'undefined') {\n      if (_objOptionalData.strOrigin != 'unknown') {\n        if (_objOptionalData.strOrigin == 'extra-next') {\n          _strDirection = '1';\n        } else if (_objOptionalData.strOrigin == 'extra-back') {\n          _strDirection = '-1';\n        }\n      }\n    }\n    this._strCurrDirection = _strDirection;\n\n    var _booFirstScreen = true;\n    var _objDOMElement = this._getCurrentContentWrapper();\n    var _arrShownScreens = CORE.getElementsByClassName(_objDOMElement, this._strShownScreenClass);\n    var count = 0;\n    if (count < _arrShownScreens.length) {\n      _booFirstScreen = false;\n    }\n\n    this._hideScreens(_arrShownScreens);\n\n    // ### REFACTOR NOTE: This method was calling hidesubscreens as well as\n    // SUBSCREEN_INTERACTIONS.preNavigate(). As this version runs after the\n    // screen is closed it's not as useful and doesn't have screendata access.\n    // SUB_SCREEN_INTERACTIONS.hideSubScreens();\n    var _domScreenWrapper = this.getScreenWrapper(_strWhatScreenID);\n    // gomo will auto scroll a screen if an asset in another screen is interacted with\n    var triggeredFromGomo = false;\n    if (typeof _objOptionalData !== 'undefined'\n      && _objOptionalData.triggeredFromGomo == true) {\n      triggeredFromGomo = true;\n    }\n    if (BOO_RESET_NON_ASSESSMENT_ASSET_STATES && !triggeredFromGomo) {\n      var _booForceReset = true;\n      this._resetScreensAssets(_strWhatScreenID, _booForceReset);\n    }\n\n    this._showScreen(_domScreenWrapper, _objOptionalData, _booFirstScreen);\n    // WBI.log(\"SCREEN_INTERACTIONS.switchToScreen(); - END\");\n  },\n\n  returnFocusToScreen: function(_strOptionalAssetID) {\n    var _domShownScreen = this.getShownScreenElement();\n    if (!_domShownScreen) {\n      _domShownScreen = this._objWhatDOM.getElementById('contentWrapperL');\n    }\n\n    if (typeof ISCROLL_INTERFACE != 'undefined') {\n      ISCROLL_INTERFACE.enableScroller(_domShownScreen);\n    }\n  },\n\n  takeFocusFromScreen: function() {\n    var _domShownScreen = this.getShownScreenElement();\n    if (!_domShownScreen) {\n      _domShownScreen = this._objWhatDOM.getElementById('contentWrapperL');\n    }\n\n    if (_domShownScreen) {\n      if (typeof ISCROLL_INTERFACE != 'undefined') {\n        ISCROLL_INTERFACE.disableScroller(_domShownScreen);\n      }\n    }\n  },\n\n  // Triggered if _handleSwipe() determines that a new page should be displayed\n  //\n  // Accepts 1 parameter:\n  //  - ID of the button to be activated\n  //\n  // Returns: Nothing\n  // Proceeds to: this._sendClick()\n  _activateButton: function(_strButtonId) {\n    var _domActivateButton = this._objWhatDOM.getElementById(_strButtonId);\n\n    // If there is no next button, try and find the skip button on the splash screen\n    if (_domActivateButton == null && _strButtonId == this._strNextButton) {\n      _domActivateButton = this._objWhatDOM.getElementById(this._strSkipButton);\n    }\n\n    if (_domActivateButton != null) {\n      // If the selected button is disabled, (on the first or last page of a topic), activate the\n      // menu button instead\n      if (this._isButtonEnabled(_domActivateButton)) {\n        this._sendClick(_domActivateButton);\n      } else {\n        // Add final fallback / \"no progress\" indicator here\n      }\n    }\n  },\n\n  // Handles the actual 'click', parameter, as determined by _activateButton()\n  //\n  // Accepts 1 parameter:\n  //  - ID of the button to be activated\n  //\n  // Returns: Nothing\n  // Proceeds to: Activate the button that corresponds to the swipe gesture, determined by\n  // previous functions\n  _sendClick: function(_objButton) {\n    // If the click() method is not available or supported, we need to find another way to 'click'\n    // the selected element, by grabbing the onclick value as a string and evaling it.\n    // if ((typeof(_objButton.click) == 'undefined') || (true))\n    if (typeof _objButton.click == 'undefined') {\n      _objButton.onclick.call(_objButton);\n    } else {\n      _objButton.click();\n    }\n  },\n\n  _isButtonEnabled: function(_domWhatButtonElement) {\n    if (_domWhatButtonElement.className.indexOf(this._strDisabledClass) == -1) {\n      return true;\n    }\n    return false;\n  },\n\n  refreshCurrentIScrollComponent: function() {\n    var _domWhatScreen = this.getShownScreenElement();\n    if (typeof ISCROLL_INTERFACE != 'undefined') {\n      ISCROLL_INTERFACE.refreshIScrolls(_domWhatScreen);\n    }\n  },\n\n  getScreenWrapperID: function(_strWhatScreenID) {\n    return this._strScreenIDPrefix + _strWhatScreenID + this._strScreenIDSuffix;\n  },\n\n  getScreenWrapper: function(_strWhatScreenID) {\n    return this._objWhatDOM.getElementById(this.getScreenWrapperID(_strWhatScreenID));\n  },\n\n  resetScreensAssets: function(_strWhatScreenID, _booForceReset) {\n    var _domScreenBackgroundHolder = this._objWhatDOM.getElementById('screenBackgroundHolderL');\n    if (_domScreenBackgroundHolder) {\n      _domScreenBackgroundHolder.style.backgroundImage = '';\n      _domScreenBackgroundHolder.style.backgroundColor = '';\n    }\n\n    var _objWhatScreenData = this._getScreenData(_strWhatScreenID);\n    var count = 0;\n    if (_objWhatScreenData && _objWhatScreenData.booIsDisplayed !== false) {\n      while (count < _objWhatScreenData.arrAssets.length) {\n        var _objCurrAsset = _objWhatScreenData.arrAssets[count];\n        ASSET_INTERACTIONS.resetAsset(_objCurrAsset, _booForceReset);\n        count++;\n      }\n    }\n    LAYOUT_INTERACTIONS.resetLayoutWidthObjList();\n  },\n\n  prepareCurrentScreenForPopupLayers: function(_intColumnToIgnored) {\n    var _domCurrentScreenLayer = this.getShownScreenElement();\n    if (_domCurrentScreenLayer) {\n      var _strCurrScreenID = _domCurrentScreenLayer.id\n        .replace(this._strScreenIDPrefix, '')\n        .replace(this._strScreenIDSuffix, '');\n      var _objCurrScreenDataWrapper = this._getScreenData(_strCurrScreenID);\n      if (_objCurrScreenDataWrapper) {\n        var _arrAssetCollectionToBeObscured = this._getAssetsToBeObscured(\n          _objCurrScreenDataWrapper,\n          _intColumnToIgnored\n        );\n        var count = 0;\n        while (count < _arrAssetCollectionToBeObscured.length) {\n          ASSET_INTERACTIONS.obscureAssetForPopup(_arrAssetCollectionToBeObscured[count]);\n          count++;\n        }\n      }\n    }\n  },\n\n  restoreCurrentScreenFromPopupLayers: function(_intColumnToIgnored) {\n    var _domCurrentScreenLayer = this.getShownScreenElement();\n    if (_domCurrentScreenLayer) {\n      var _strCurrScreenID = _domCurrentScreenLayer.id\n        .replace(this._strScreenIDPrefix, '')\n        .replace(this._strScreenIDSuffix, '');\n      var _objCurrScreenDataWrapper = this._getScreenData(_strCurrScreenID);\n      if (_objCurrScreenDataWrapper) {\n        var _arrAssetCollectionToBeObscured = this._getAssetsToBeObscured(\n          _objCurrScreenDataWrapper,\n          _intColumnToIgnored\n        );\n        var count = 0;\n        while (count < _arrAssetCollectionToBeObscured.length) {\n          ASSET_INTERACTIONS.restoreAssetFromPopup(_arrAssetCollectionToBeObscured[count]);\n          count++;\n        }\n      }\n    }\n  },\n\n  setInTopic: function(_booInTopic) {\n    this._booInTopic = _booInTopic;\n  },\n\n  // GENERIC METHODS\n  /*\n   * AR: Added getCurrentScreenData function for use with the help popup\n   */\n  getCurrentScreenData: function() {\n    return this._getScreenData(this._strLastScreenID);\n  },\n\n  getLastScreenID: function() {\n    return this._strLastScreenID;\n  },\n\n  getShownScreenElement: function() {\n    for (var _strCurrScreenID in this._objScreenVisibilityStates) {\n      if (this._objScreenVisibilityStates[_strCurrScreenID]) {\n        var _domVisibleScreen = this._objWhatDOM.getElementById(_strCurrScreenID);\n        // Check we havn't managed to get garbage in the visible screens HASH.\n        if (_domVisibleScreen) {\n          return _domVisibleScreen;\n        }\n      }\n    }\n    // alert(\"ERROR: No visible screens found, SCREEN_INTERACTIONS.getShownScreenElement(),\n    // screen_interactions.js\");\n    return false;\n  },\n\n  // Blackberry only methods to hide the inner content of the screens\n  hideCurrentScreenContent: function() {\n    var _domCurrentScreenWrapper = this.getShownScreenElement();\n    var _domCurrentScreenContent = CORE.getElementsByClassName(\n      _domCurrentScreenWrapper,\n      'scrollWrapperC'\n    )[0];\n    _domCurrentScreenContent.style.display = 'none';\n  },\n\n  // Blackberry only methods to show the inner content of the screens\n  showCurrentScreenContent: function() {\n    var _domCurrentScreenWrapper = this.getShownScreenElement();\n    var _domCurrentScreenContent = CORE.getElementsByClassName(\n      _domCurrentScreenWrapper,\n      'scrollWrapperC'\n    )[0];\n    _domCurrentScreenContent.style.display = 'block';\n  },\n\n  updateVariableReferences: function(_objWhatScreen, _objEventData) {\n    var _arrAssets = _objWhatScreen.arrAssets;\n    var count = 0;\n    while (count < _arrAssets.length) {\n      var _objCurrAsset = _arrAssets[count];\n      ASSET_INTERACTIONS.updateAssetVariableLinks(_objCurrAsset, _objEventData);\n      count++;\n    }\n  },\n\n  _resetScreensAssets: function(_strWhatScreenID, _booForceReset) {\n    var _objWhatScreenData = this._getScreenData(_strWhatScreenID);\n    if (!_objWhatScreenData.booIsDisplayed) return;\n    var count = 0;\n    while (count < _objWhatScreenData.arrAssets.length) {\n      var _objCurrAsset = _objWhatScreenData.arrAssets[count];\n      ASSET_INTERACTIONS.resetAsset(_objCurrAsset, _booForceReset);\n      count++;\n    }\n  },\n\n  _getScreenData: function(_strWhatScreenID) {\n    var _objWhatScreen = false;\n    var _objCurrTopicData = TOPIC_MANAGER.getCurrentTopic();\n    if (_objCurrTopicData.findScreen) {\n      _objWhatScreen = _objCurrTopicData.findScreen(_strWhatScreenID);\n    }\n    return _objWhatScreen;\n  },\n\n  _changeScreenCompletionState: function(_intWhatState) {\n    var _objScreenData = this.getCurrentScreenData();\n    var _domCurrScreenLayer = this.getShownScreenElement();\n\n    if (_domCurrScreenLayer) {\n      if (_intWhatState == INT_VISITED) {\n        _domCurrScreenLayer.className = _domCurrScreenLayer.className.replace(\n          this._objScreenCompletionStateClasses[INT_UNVISITED],\n          this._objScreenCompletionStateClasses[INT_VISITED]\n        );\n        _domCurrScreenLayer.className = _domCurrScreenLayer.className.replace(\n          this._objScreenCompletionStateClasses[INT_COMPLETED],\n          this._objScreenCompletionStateClasses[INT_VISITED]\n        );\n      } else {\n        _domCurrScreenLayer.className = _domCurrScreenLayer.className.replace(\n          this._objScreenCompletionStateClasses[INT_UNVISITED],\n          this._objScreenCompletionStateClasses[INT_COMPLETED]\n        );\n        _domCurrScreenLayer.className = _domCurrScreenLayer.className.replace(\n          this._objScreenCompletionStateClasses[INT_VISITED],\n          this._objScreenCompletionStateClasses[INT_COMPLETED]\n        );\n\n        _objScreenData.booScreenComplete = true;\n      }\n      this._updateFirstAndLastAssetFlags(_domCurrScreenLayer);\n      // refresh iscroll to allow for different height instruction texts.\n      ISCROLL_INTERFACE.refreshIScrolls();\n    }\n  },\n\n  _updateFirstAndLastAssetFlags: function(_domCurrScreenLayer) {\n    var _arrCurrentColumns = CORE.getElementsByClassName(_domCurrScreenLayer, 'screenColumnC');\n    var count = 0;\n    while (count < _arrCurrentColumns.length) {\n      var _domCurrColumn = _arrCurrentColumns[count];\n      var iCount = 0;\n      var _arrCurrColumnsAssets = CORE.getElementsByClassName(\n        _domCurrColumn,\n        'genericAssetWrapperC'\n      );\n      var _domFirstVisibleAsset = false;\n      var _domLastVisibleAsset = false;\n      while (iCount < _arrCurrColumnsAssets.length) {\n        var _domCurrAssetWrapper = _arrCurrColumnsAssets[iCount];\n        // Wipe any existing first/last classes\n        _domCurrAssetWrapper.className = _domCurrAssetWrapper.className.replace('firstAssetC', '');\n        _domCurrAssetWrapper.className = _domCurrAssetWrapper.className.replace('lastAssetC', '');\n\n        if (this._isDisplayedAsset(_domCurrAssetWrapper)) {\n          if (!_domFirstVisibleAsset) {\n            _domFirstVisibleAsset = _domCurrAssetWrapper;\n          }\n          _domLastVisibleAsset = _domCurrAssetWrapper;\n        }\n        iCount++;\n      }\n\n      _domFirstVisibleAsset.className += ' firstAssetC';\n      _domLastVisibleAsset.className += ' lastAssetC';\n      count++;\n    }\n  },\n\n  _isDisplayedAsset: function(_domWhatAssetWrapper) {\n    var _arrChildNodes = _domWhatAssetWrapper.childNodes;\n    var count = 0;\n    var _domFirstProperChild = null;\n    while (count < _arrChildNodes.length) {\n      var _domCurrChild = _arrChildNodes[count];\n      if (_domCurrChild.nodeType != 3 && _domCurrChild.nodeType != 8) {\n        _domFirstProperChild = _domCurrChild;\n        break;\n      }\n      count++;\n    }\n\n    if (_domFirstProperChild) {\n      var _objComputedStyle =\n        _domWhatAssetWrapper.currentStyle || getComputedStyle(_domWhatAssetWrapper, null);\n      var _objFirstChildsComputedStyle =\n        _domFirstProperChild.currentStyle || getComputedStyle(_domFirstProperChild, null);\n      if (\n        _objComputedStyle['display'] != 'none' &&\n        _objFirstChildsComputedStyle['display'] != 'none'\n      ) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  _resetScreenInteractedState: function(_strScreenID) {\n    var _objScreenData = this._getScreenData(_strScreenID);\n    var _domCurrScreenLayer = this.getShownScreenElement();\n\n    if (_domCurrScreenLayer) {\n      _domCurrScreenLayer.className = _domCurrScreenLayer.className.replace(\n        this._strInteractedClass,\n        this._strNotInteractedClass\n      );\n    }\n\n    // Reset screen state to default when user navigates back to it\n    if (_objScreenData.screenInteractedState != 0) {\n      _objScreenData.screenInteractedState = 0;\n      EM.trigger('reportScreenInteractedStatus', _objScreenData);\n    }\n  },\n\n  _resetScreenCompletionState: function(_strScreenID) {\n    var _objScreenData = this._getScreenData(_strScreenID);\n    var _domCurrScreenLayer = this.getShownScreenElement();\n\n    if (_objScreenData) {\n      _objScreenData.booScreenComplete = false;\n    }\n    if (_domCurrScreenLayer) {\n      _domCurrScreenLayer.className = _domCurrScreenLayer.className.replace(\n        this._objScreenCompletionStateClasses[INT_VISITED],\n        this._objScreenCompletionStateClasses[INT_UNVISITED]\n      );\n      _domCurrScreenLayer.className = _domCurrScreenLayer.className.replace(\n        this._objScreenCompletionStateClasses[INT_COMPLETED],\n        this._objScreenCompletionStateClasses[INT_UNVISITED]\n      );\n    }\n\n    _objScreenData.screenInteractedState = 0;\n  },\n\n  _showScreensPostRenderAssets: function(_strWhatScreenID) {\n    var _objWhatScreenData = this._getScreenData(_strWhatScreenID);\n    if (!_objWhatScreenData.booIsDisplayed) return;\n    var count = 0;\n    while (count < _objWhatScreenData.arrAssets.length) {\n      var _objCurrAsset = _objWhatScreenData.arrAssets[count];\n      ASSET_INTERACTIONS.showPostRenderAsset(_objCurrAsset);\n      count++;\n    }\n  },\n\n  _performPreShowActions: function(_strWhatScreenID) {\n    // Run the screen size check to rerender elements on demand.\n    OUTPUT_MODE_CHECKER.manualScreenSizeCheck();\n\n    var _objWhatScreenData = this._getScreenData(_strWhatScreenID);\n    var _domScreenWrapper = this.getScreenWrapper(_strWhatScreenID);\n    if (!_objWhatScreenData || !_objWhatScreenData.booIsDisplayed) return;\n    _domScreenWrapper.className = _domScreenWrapper.className.replace(\n      'notStartedScreenStateC',\n      'preShownScreenStateC'\n    );\n    var count = 0;\n    while (count < _objWhatScreenData.arrAssets.length) {\n      var _objCurrAsset = _objWhatScreenData.arrAssets[count];\n      ASSET_INTERACTIONS.performPreShowActions(_objCurrAsset);\n      count++;\n    }\n    ASSET_INTERACTIONS.animateAssets(_strWhatScreenID);\n    _domScreenWrapper.className = _domScreenWrapper.className.replace(\n      'preShownScreenStateC',\n      'notStartedScreenStateC'\n    );\n\n    EM.trigger('rebuildNavMenu', _objWhatScreenData);\n    if (MOBILE_DRAWER_MENU && gomo.outputChecker.isSmartPhone()) {\n      gomo.drawerMenu.buildMenu(_objWhatScreenData.objParent);\n    } else {\n      TOP_STRAP_RENDERER.rerenderNav(_objWhatScreenData.objParent);\n      BOTTOM_STRAP_RENDERER.rerenderNav(_objWhatScreenData.objParent);\n    }\n    EM.trigger('rebuiltNavMenu', _objWhatScreenData.objParent);\n  },\n\n  _hideScreensPostRenderAssets: function(_strWhatScreenID) {\n    var _objWhatScreenData = this._getScreenData(_strWhatScreenID);\n    var count = 0;\n    if (_objWhatScreenData) {\n      while (count < _objWhatScreenData.arrAssets.length) {\n        var _objCurrAsset = _objWhatScreenData.arrAssets[count];\n        ASSET_INTERACTIONS.hidePostRenderAsset(_objCurrAsset);\n        count++;\n      }\n    }\n  },\n\n  _getAssetsToBeObscured: function(_objCurrScreenDataWrapper, _intColumnToIgnored) {\n    var _arrAssetsToReturn = [];\n    var count = 0;\n    while (count < _objCurrScreenDataWrapper.arrAssets.length) {\n      var _objCurrAsset = _objCurrScreenDataWrapper.arrAssets[count];\n      if (!_intColumnToIgnored || _objCurrAsset.intColumnAffinity != _intColumnToIgnored) {\n        _arrAssetsToReturn.push(_objCurrAsset);\n      }\n      count++;\n    }\n    return _arrAssetsToReturn;\n  },\n\n  _getCurrentPage: function() {\n    var _strCurrentScreenID = this._getCurrentScreen();\n    var _domScreen = this.getScreenWrapper(_strCurrentScreenID.strObjID);\n    return _domScreen;\n  },\n\n  _updateScreenInteractedStatus: function() {\n    var _domCurrScreenLayer = this.getShownScreenElement();\n    _domCurrScreenLayer.className = _domCurrScreenLayer.className.replace(\n      this._strNotInteractedClass,\n      this._strInteractedClass\n    );\n\n    var _objScreenData = this._getCurrentScreen();\n    // Leave completed screens as completed\n    if (_objScreenData.screenInteractedState != 2) {\n      _objScreenData.screenInteractedState = 1;\n      EM.trigger('reportScreenInteractedStatus', _objScreenData);\n    }\n  },\n\n  _updateAssetCompletedStatus: function() {\n    var assetsToCheck = [];\n\n    // Get screen data\n    var _objScreenData = this._getCurrentScreen();\n\n    // Add assets from the screen\n    assetsToCheck = _.map(_objScreenData.arrAssets);\n\n    // Check for assets inside subscreens and include those too\n    if (_objScreenData.arrSubScreens && _objScreenData.arrSubScreens.length > 0) {\n      var subscreens = _objScreenData.arrSubScreens;\n      _.each(subscreens, function(subscreen) {\n        if (subscreen.arrAssets && subscreen.arrAssets.length > 0) {\n          var subscreenAssets = subscreen.arrAssets;\n          _.each(subscreenAssets, function(asset) {\n            assetsToCheck.push(asset);\n          });\n        }\n      });\n    }\n\n    // Check each asset for completion and mark as complete if true\n    for (var i = 0; i < assetsToCheck.length; i++) {\n      var _objCurrAssetData = assetsToCheck[i];\n      _objCurrAssetData.booComplete = ASSET_INTERACTIONS.checkAssetCompletion(_objCurrAssetData);\n    }\n  },\n\n  _checkScreenCompletionStatus: function() {\n    var _objScreenData = this._getCurrentScreen();\n    var _arrAssetData = _objScreenData.arrAssets;\n\n    var _objCompletionReportData = {};\n    var _booScreenCompleted = true;\n    var _booIsCompleteableScreen = SCREEN_RENDERER.getCompletableStatus(_objScreenData);\n    var _booScreenCorrect = true;\n\n    // The screen has completable assets, find them and get overall completion status.\n    if (_booIsCompleteableScreen) {\n      var _intQuestionAssets = 0;\n      var _intCorrectAssets = 0;\n\n      // Loop all assets and count the questions.\n      for (var i = 0; i < _arrAssetData.length; i++) {\n        var _objCurrAssetData = _arrAssetData[i];\n        if (\n          _objCurrAssetData.booIsDisplayed &&\n          _objCurrAssetData.strAssetGroup == this._questionAssetType\n        ) {\n          _intQuestionAssets++;\n          if (_arrAssetData[i].booIsCorrect == true) {\n            _intCorrectAssets++;\n          }\n        }\n      }\n\n      // Check screen correctness\n      _booScreenCorrect = _intQuestionAssets == _intCorrectAssets;\n\n      // Loop all assets and check for completion\n      for (var j = 0; j < _arrAssetData.length; j++) {\n        _objCurrAssetData = _arrAssetData[j];\n        var _booAssetComplete = false;\n        var _strAssetType = _objCurrAssetData.strAssetType;\n        var _booIsCurrentAssetCompletable = false;\n\n        // Check if it's complete\n        // Kept this order of checking complete before checking if it's completable from\n        // previous logic...\n        _booAssetComplete = ASSET_INTERACTIONS.checkAssetCompletion(_objCurrAssetData);\n\n        // Do we have new style asset?\n        if (gomo.assetManager.isRegistered(_strAssetType)) {\n          var asset = gomo.assetManager.findInstance(_objCurrAssetData.strObjID);\n          if (asset) {\n            // Check if this asset is completable...\n            _booIsCurrentAssetCompletable = asset.isCompletable();\n          }\n          // Use old event style\n        } else {\n          if (ASSET_INTERACTIONS['is_' + _strAssetType + '_AssetCompletable']) {\n            // Check if this asset is completable...\n            _booIsCurrentAssetCompletable = ASSET_INTERACTIONS[\n              'is_' + _strAssetType + '_AssetCompletable'\n            ](_objCurrAssetData);\n          }\n        }\n\n        // If it's not competable, skip to the next asset.\n        if (!_booIsCurrentAssetCompletable) {\n          continue;\n        }\n\n        // If we found any incomplete assets then set the screen incomplete\n        if (!_booAssetComplete) {\n          _booScreenCompleted = false;\n          break;\n        }\n      }\n    }\n\n    if (!_booScreenCompleted) {\n      _objCompletionReportData = {\n        intStatus: INT_VISITED,\n        strScreenID: _objScreenData.strObjID\n      };\n    } else {\n      _objCompletionReportData = {\n        intStatus: INT_COMPLETED,\n        strScreenID: _objScreenData.strObjID\n      };\n      _objScreenData.screenInteractedState = 2;\n    }\n\n    _objScreenData.screenCorrectState = _booScreenCorrect;\n\n    EM.trigger('reportScreenCompletionStatus', _objCompletionReportData);\n    EM.trigger('reportScreenInteractedStatus', _objScreenData);\n    EM.trigger('reportScreenCorrectStatus', _objScreenData);\n  },\n\n  _getCurrentScreen: function() {\n    var _objCurrTopicData = TOPIC_MANAGER.getCurrentTopic();\n    return _objCurrTopicData.arrScreens[_objCurrTopicData.intNavigationIndex];\n  },\n\n  _hideScreens: function(_arrShownScreens) {\n    var count = 0;\n    while (count < _arrShownScreens.length) {\n      var _domCurrScreenWrapper = _arrShownScreens[count];\n      this._hideScreen(_domCurrScreenWrapper);\n      count++;\n    }\n  },\n\n  _hideScreen: function(_domWhatScreenElement) {\n    var _strScreenID = _domWhatScreenElement.id\n      .replace(this._strScreenIDPrefix, '')\n      .replace(this._strScreenIDSuffix, '');\n\n    var _objScreenData = this._getScreenData(_strScreenID);\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING && _objScreenData.objVideo) {\n      var opts = {\n        screenId: _objScreenData.strObjID,\n        triggerMode: 'pause'\n      };\n      SCREEN_INTERACTIONS.toggleVideo(opts);\n    }\n\n    this._hideScreensPostRenderAssets(_strScreenID);\n    var _strTransitionType = 'gomo.' + STR_DYNAMIC_TRANSITION_TYPE;\n\n    /* REFACTOR NOTE: put the default animator settings (pre _objAnimateData)into\n     * a global object in config. Then place an object at the top of this class\n     * with overrides. These overrides can then be altered per project with a\n     * config_override.js\n     **/\n    var _objOptionalCallbackData = {};\n    _objOptionalCallbackData.strType = 'hidden';\n    _objOptionalCallbackData.strWhatSubScreenElementID = _domWhatScreenElement.id;\n\n    if (\n      (!gomo.outputChecker.animationEnabled && !BOO_DYNAMIC_CONTINUOUS_SCROLLING) ||\n      !BOO_ANIMATE_SCREENS ||\n      !OUTPUT_MODE_CHECKER.canHandleAnimationType(this._strAnimationAsset)\n    ) {\n      // Switch this screens visibility off first as accessible mode will run the callback\n      // instantly and check to see if this screen is visible\n      this._objScreenVisibilityStates[_domWhatScreenElement.id] = false;\n      _domWhatScreenElement.className = _domWhatScreenElement.className.replace(\n        this._strShownScreenClass,\n        this._strHiddenScreenClass\n      );\n      _domWhatScreenElement.style.left = '0px';\n      _domWhatScreenElement.style.display = 'none';\n      EM.trigger('screenAnimationComplete', _objOptionalCallbackData);\n    } else {\n      if (this._objScreenVisibilityStates[_domWhatScreenElement.id]) {\n        EM.trigger('updateAnimationLock', true);\n\n        var _strTransition = this._getTransitionType('hide', _strTransitionType);\n\n        var funComplete = function() {\n          EM.trigger('screenAnimationComplete', _objOptionalCallbackData);\n        };\n        ANIMATOR_INTERFACE_2.assignRegisteredAnimation(_domWhatScreenElement, _strTransition, {\n          duration: INT_TRANSITION_TIMER,\n          complete: funComplete\n        });\n      }\n      this._objScreenVisibilityStates[_domWhatScreenElement.id] = false;\n    }\n  },\n\n  _showScreen: function(_domWhatScreenElement, _objOptionalData, _booFirstScreen) {\n    var _intDelay = INT_TRANSITION_TIMER / 2;\n    if (_booFirstScreen) {\n      _intDelay = 0;\n    }\n\n    var _strTransitionType = 'gomo.' + STR_DYNAMIC_TRANSITION_TYPE;\n    var _objScreenData = this.getCurrentScreenData();\n    var opts;\n\n    this._manageBackgroundTransitions(_objScreenData);\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING && _objScreenData.objVideo) {\n      opts = {\n        screenId: _objScreenData.strObjID,\n        triggerMode: 'play'\n      };\n      SCREEN_INTERACTIONS.toggleVideo(opts);\n    }\n\n    _domWhatScreenElement.className = _domWhatScreenElement.className.replace(\n      this._strHiddenScreenClass,\n      this._strShownScreenClass\n    );\n\n    var _strScreenID = _domWhatScreenElement.id.replace('screenWrapper_', '');\n\n    if (_strScreenID.substring(_strScreenID.length - 1) == 'L') {\n      _strScreenID = _strScreenID.substring(0, _strScreenID.length - 1);\n    }\n\n    this.strCurrentScreenId = _strScreenID;\n\n    this._performPreShowActions(_strScreenID);\n\n    this._objScreenVisibilityStates[_domWhatScreenElement.id] = true;\n    var _objOptionalCallbackData = {};\n    _objOptionalCallbackData.strType = 'shown';\n    _objOptionalCallbackData.strWhatSubScreenElementID = _domWhatScreenElement.id;\n    if (\n      typeof _objOptionalData !== 'undefined' &&\n      typeof _objOptionalData.funCallBack !== 'undefined'\n    ) {\n      _objOptionalCallbackData.funCallBack = _objOptionalData.funCallBack;\n      _objOptionalCallbackData.booTriggeredByActionsObj =\n        _objOptionalData.booTriggeredByActionsObj || false;\n    }\n    // Apply the transitions to the screen depending on the topic type\n    opts = {};\n    opts._domWhatScreenElement = _domWhatScreenElement;\n    opts._objOptionalData = _objOptionalData;\n    opts._booFirstScreen = _booFirstScreen;\n    opts._objOptionalCallbackData = _objOptionalCallbackData;\n    opts._intDelay = _intDelay;\n    opts._strTransitionType = _strTransitionType;\n    opts._strScreenID = _strScreenID;\n\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n      if (opts._booFirstScreen) {\n        // Allow page to render before applying calculations\n        setTimeout(function() {\n          gomo.parallaxManager.init();\n        }, 0);\n      }\n      this._showScreenApplyTransitionContinousScrolling(opts);\n    } else {\n      this._showScreenApplyTransition(opts);\n    }\n\n    this._doPostShowEvents();\n    this._updateFirstAndLastAssetFlags(_domWhatScreenElement);\n\n    this._addIScrollToScreen(_domWhatScreenElement);\n\n    // Update SVG icons on IE8 IE9, IE10 and IE11, don't polyfil external content in ie8 as it\n    // breaks.\n    if (OUTPUT_MODE_CHECKER.booIsIE()) {\n      if (OUTPUT_MODE_CHECKER.booIsIE8()) {\n        svg4everybody({\n          polyfill: false\n        });\n      } else {\n        svg4everybody({\n          polyfill: true\n        });\n      }\n    }\n  },\n\n  _showScreenApplyTransition: function(opts) {\n    var _domWhatScreenElement = opts._domWhatScreenElement;\n    var _objOptionalData = opts._objOptionalData;\n    var _objOptionalCallbackData = opts._objOptionalCallbackData;\n    var _intDelay = opts._intDelay;\n    var _strTransitionType = opts._strTransitionType;\n    var _strScreenID = opts._strScreenID;\n\n    if (\n      gomo.outputChecker.animationEnabled &&\n      BOO_ANIMATE_SCREENS &&\n      OUTPUT_MODE_CHECKER.canHandleAnimationType(this._strAnimationAsset)\n    ) {\n      var _strTransition = null;\n      _strTransition = this._getTransitionType('show', _strTransitionType);\n\n      if (_strTransition) {\n        EM.trigger('updateAnimationLock', true);\n\n        // Scroll screens back to the top as they all share the same contentWrapper scroll bar\n        $('#contentWrapperL')\n          .stop(true, true)\n          .delay(_intDelay)\n          .animate(\n            {\n              scrollTop: 0\n            },\n            INT_TRANSITION_TIMER / 2\n          );\n\n        var funComplete = function() {\n          EM.trigger('screenAnimationComplete', _objOptionalCallbackData);\n        };\n        // Vertical scroll needs some extra css to show a clean animation by hiding the\n        // page overflow.\n        if (_strTransition.indexOf('verticalSlide') > -1) {\n          var screenElement = _domWhatScreenElement;\n          if (this._strCurrDirection && this._strCurrDirection === '1') {\n            screenElement = $(_domWhatScreenElement).prev()[0];\n          }\n          ANIMATOR_INTERFACE_2.addVerticalSlideCss(screenElement);\n        }\n        ANIMATOR_INTERFACE_2.assignRegisteredAnimation(_domWhatScreenElement, _strTransition, {\n          delay: _intDelay,\n          duration: INT_TRANSITION_TIMER,\n          complete: funComplete\n        });\n      }\n    } else {\n      this._showScreensPostRenderAssets(_strScreenID);\n      _domWhatScreenElement.style.left = '0px';\n      _domWhatScreenElement.style.display = 'block';\n      _domWhatScreenElement.style.opacity = '1';\n      var _objOptions = {};\n      _objOptions.objOptionalCallbackData = _objOptionalData;\n      EM.trigger('screenDisplayReady', _objOptions);\n      EM.trigger('screenAnimationComplete', _objOptionalCallbackData);\n    }\n\n    var _domScrollWrapper = CORE.getElementsByClassName(_domWhatScreenElement, 'screenContentC')[0];\n    _domScrollWrapper.scrollTop = 0;\n  },\n\n  _showScreenApplyTransitionContinousScrolling: function(opts) {\n    var _domWhatScreenElement = opts._domWhatScreenElement;\n    var _objOptionalData = opts._objOptionalData;\n    var _objOptionalCallbackData = opts._objOptionalCallbackData;\n    var _intDelay = opts._intDelay;\n    var _strScreenID = opts._strScreenID;\n\n    _objOptionalCallbackData._booFirstScreen = opts._booFirstScreen;\n\n    if (\n      gomo.outputChecker.animationEnabled &&\n      BOO_ANIMATE_SCREENS &&\n      OUTPUT_MODE_CHECKER.canHandleAnimationType(this._strAnimationAsset)\n    ) {\n      var _strTransition = null;\n      if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n        var animationDuration = 0;\n        // Only animate when navigated to.\n        // Otherwise it's the system forcing the event for screen data updates and rerender\n\n        if (_objOptionalData && _objOptionalData.scrollTo !== false) {\n          animationDuration = INT_TRANSITION_TIMER;\n\n          // iScroll requires a different scroll action to load the screen\n          if (OUTPUT_MODE_CHECKER.applyScrolling()) {\n            // If the reference doesn't exist, try setting it - there is a timeout in setting it\n            // so we have to reproduce it here\n            if (typeof ISCROLL_INTERFACE._objIScrollReferences['contentWrapperL'] == 'undefined') {\n              // If we're navigating then we can assume the topic is already rendered and force the\n              // parse instantly\n              var forceInstantParse = true;\n              ISCROLL_INTERFACE.parseForContinuousScrollContentWrapper(forceInstantParse);\n              window.setTimeout(function() {\n                // If the reference still doesn't exist, then return out of this funtion\n                if (\n                  typeof ISCROLL_INTERFACE._objIScrollReferences['contentWrapperL'] == 'undefined'\n                ) {\n                  return;\n                }\n                ISCROLL_INTERFACE._objIScrollReferences['contentWrapperL'].scrollToElement(\n                  _domWhatScreenElement\n                );\n              }, 100);\n            } else {\n              if (_objOptionalData && _objOptionalData.strObjID) {\n                SCROLLING_MANAGER.previousScrollScreenLoad = _objOptionalData.strObjID;\n              }\n              ISCROLL_INTERFACE._objIScrollReferences['contentWrapperL'].scrollToElement(\n                _domWhatScreenElement\n              );\n            }\n          } else {\n            var offsetTopAnimation = $(_domWhatScreenElement)[0].offsetTop;\n            $('#contentWrapperL').animate(\n              {\n                scrollTop: offsetTopAnimation\n              },\n              animationDuration,\n              'swing',\n              function() {\n                // Set focus to current screen\n                gomo.tabManager.setFocusToCurrentScreen();\n                // If anything rendered at a different size we may need to refine the scrollTop after the animation duration\n                if (offsetTopAnimation !== $(_domWhatScreenElement)[0].offsetTop) {\n                  $('#contentWrapperL').scrollTop( $(_domWhatScreenElement)[0].offsetTop );\n                }\n              }\n            );\n          }\n        }\n        setTimeout(function() {\n          EM.trigger('screenAnimationComplete', _objOptionalCallbackData);\n        }, animationDuration);\n      } else {\n        _strTransition = 'transition.fadeIn';\n        ANIMATOR_INTERFACE_2.applyOpacityToElement(_domWhatScreenElement, {\n          opacity: 0,\n          duration: 0\n        });\n      }\n\n      if (_strTransition) {\n        EM.trigger('updateAnimationLock', true);\n\n        // Scroll screens back to the top as they all share the same contentWrapper scroll bar\n        $('#contentWrapperL')\n          .stop(true, true)\n          .delay(_intDelay)\n          .animate(\n            {\n              scrollTop: 0\n            },\n            INT_TRANSITION_TIMER / 2\n          );\n\n        // We need to unlock the screen transition instantly as users can scroll and need to be\n        // able to load new data\n        EM.trigger('screenAnimationComplete', _objOptionalCallbackData);\n        var funComplete = null;\n        ANIMATOR_INTERFACE_2.assignRegisteredAnimation(_domWhatScreenElement, _strTransition, {\n          delay: _intDelay,\n          duration: INT_TRANSITION_TIMER,\n          complete: funComplete\n        });\n      }\n    } else {\n      // Continuious scrolling\n      if (\n        BOO_DYNAMIC_CONTINUOUS_SCROLLING &&\n        _objOptionalData &&\n        _objOptionalData.scrollTo !== false\n      ) {\n        $('#contentWrapperL').animate(\n          {\n            scrollTop: $(_domWhatScreenElement)[0].offsetTop\n          },\n          0\n        );\n      }\n\n      this._showScreensPostRenderAssets(_strScreenID);\n      _domWhatScreenElement.style.left = '0px';\n      _domWhatScreenElement.style.display = 'block';\n      _domWhatScreenElement.style.opacity = '1';\n      var _objOptions = {};\n      _objOptions.objOptionalCallbackData = _objOptionalData;\n      EM.trigger('screenDisplayReady', _objOptions);\n      EM.trigger('screenAnimationComplete', _objOptionalCallbackData);\n    }\n\n    if (OUTPUT_MODE_CHECKER.applyScrolling()) {\n      // We don't need to do any tidy up for iscroll display in continuous scrolling mode\n    } else {\n      // move the screen to the top of the scroll wrapper\n      var _domScrollWrapper = CORE.getElementsByClassName(\n        _domWhatScreenElement,\n        'screenContentC'\n      )[0];\n      _domScrollWrapper.scrollTop = 0;\n    }\n  },\n\n  _manageBackgroundTransitions: function(_objScreenData) {\n    // Continuous scrolling screens take care of their own backgrounds\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n      // Clean out any remaining backgrounds\n      $('#screenBackgroundHolderL').html('');\n      var _domScreenBackgroundHolder = SCREEN_INTERACTIONS._objWhatDOM.getElementById(\n        'screenBackgroundHolderL'\n      );\n      _domScreenBackgroundHolder.style.backgroundColor = '';\n      _domScreenBackgroundHolder.style.backgroundImage = '';\n\n      var _domScreenBackgroundFadeHolder = SCREEN_INTERACTIONS._objWhatDOM.getElementById(\n        'screenBackgroundFadeControlHolderL'\n      );\n      _domScreenBackgroundFadeHolder.style.backgroundColor = '';\n      _domScreenBackgroundFadeHolder.style.backgroundImage = '';\n\n      return;\n    }\n\n    var _intBackgroundFadeDuration = 0;\n    if (gomo.outputChecker.animationEnabled && BOO_ANIMATE_SCREENS) {\n      _intBackgroundFadeDuration = INT_BACKGROUND_FADE_DURATION;\n    }\n\n    this._manageVideoBackgroundTransitions(_objScreenData, _intBackgroundFadeDuration);\n    this._manageAudioBackgroundTransitions(_objScreenData, _intBackgroundFadeDuration);\n  },\n\n  _manageVideoBackgroundTransitions: function(_objScreenData, _intBackgroundFadeDuration) {\n    // Hide video if it exists\n    if ($('#screenBackgroundHolderL').has('video').length) {\n      var _domScreenBackgroundHolder = this._objWhatDOM.getElementById('screenBackgroundHolderL');\n      ANIMATOR_INTERFACE_2.applyOpacityToElement(_domScreenBackgroundHolder, {\n        opacity: 0,\n        duration: _intBackgroundFadeDuration\n      });\n      setTimeout(function() {\n        $('#screenBackgroundHolderL').html('');\n        if (SCREEN_INTERACTIONS._canPlayVideoBackground(_objScreenData.objVideo)) {\n          SCREEN_INTERACTIONS._setVideoBackground(\n            _objScreenData.objVideo,\n            _intBackgroundFadeDuration\n          );\n        }\n      }, _intBackgroundFadeDuration);\n    } else if (SCREEN_INTERACTIONS._canPlayVideoBackground(_objScreenData.objVideo)) {\n      // show video straight away if it didn't exist\n      SCREEN_INTERACTIONS._setVideoBackground(_objScreenData.objVideo, _intBackgroundFadeDuration);\n    }\n  },\n\n  _manageAudioBackgroundTransitions: function(_objScreenData, _intBackgroundFadeDuration) {\n    var _domScreenBackgroundHolder;\n    var _domScreenBackgroundFadeControlHolder;\n    // Only display images if videos don't exist\n    if (\n      _objScreenData.strBackgroundImg &&\n      (SCREEN_INTERACTIONS._canPlayVideoBackground(_objScreenData.objVideo) == false ||\n        !OUTPUT_MODE_CHECKER.canHandleVideoBackground())\n    ) {\n      _domScreenBackgroundHolder = this._objWhatDOM.getElementById('screenBackgroundHolderL');\n      _domScreenBackgroundFadeControlHolder = SCREEN_INTERACTIONS._objWhatDOM.getElementById(\n        'screenBackgroundFadeControlHolderL'\n      );\n      _domScreenBackgroundHolder.style.backgroundImage = _objScreenData.strBackgroundImg;\n      var _strBackGroundColour = '#fff';\n      if (_objScreenData.strBackgroundColour) {\n        _strBackGroundColour = _objScreenData.strBackgroundColour;\n      }\n      _domScreenBackgroundHolder.style.backgroundColor = _strBackGroundColour;\n      ANIMATOR_INTERFACE_2.applyOpacityToElement(_domScreenBackgroundHolder, {\n        opacity: _objScreenData.strBackgroundOpacity,\n        duration: _intBackgroundFadeDuration\n      });\n      ANIMATOR_INTERFACE_2.applyOpacityToElement(_domScreenBackgroundFadeControlHolder, {\n        opacity: _objScreenData.strBackgroundOpacity,\n        delay: _intBackgroundFadeDuration\n      });\n\n      setTimeout(function() {\n        var _domScreenBackgroundHolder = SCREEN_INTERACTIONS._objWhatDOM.getElementById(\n          'screenBackgroundHolderL'\n        );\n        var _domScreenBackgroundFadeControlHolder = SCREEN_INTERACTIONS._objWhatDOM.getElementById(\n          'screenBackgroundFadeControlHolderL'\n        );\n\n        _domScreenBackgroundFadeControlHolder.style.backgroundImage =\n          _domScreenBackgroundHolder.style.backgroundImage;\n        _domScreenBackgroundFadeControlHolder.style.backgroundColor =\n          _domScreenBackgroundHolder.style.backgroundColor;\n        ANIMATOR_INTERFACE_2.applyOpacityToElement(_domScreenBackgroundHolder, {\n          opacity: 0,\n          duration: INT_TRANSITION_TIMER\n        });\n      }, _intBackgroundFadeDuration);\n    } else if (_objScreenData.strBackgroundColour) {\n      _domScreenBackgroundHolder = this._objWhatDOM.getElementById('screenBackgroundHolderL');\n      _domScreenBackgroundFadeControlHolder = SCREEN_INTERACTIONS._objWhatDOM.getElementById(\n        'screenBackgroundFadeControlHolderL'\n      );\n      _domScreenBackgroundHolder.style.backgroundColor = _objScreenData.strBackgroundColour;\n      _domScreenBackgroundHolder.style.backgroundImage = '';\n      ANIMATOR_INTERFACE_2.applyOpacityToElement(_domScreenBackgroundHolder, {\n        opacity: _objScreenData.strBackgroundOpacity,\n        duration: _intBackgroundFadeDuration\n      });\n      ANIMATOR_INTERFACE_2.applyOpacityToElement(_domScreenBackgroundFadeControlHolder, {\n        opacity: _objScreenData.strBackgroundOpacity,\n        delay: _intBackgroundFadeDuration\n      });\n      setTimeout(function() {\n        var _domScreenBackgroundHolder = SCREEN_INTERACTIONS._objWhatDOM.getElementById(\n          'screenBackgroundHolderL'\n        );\n        var _domScreenBackgroundFadeControlHolder = SCREEN_INTERACTIONS._objWhatDOM.getElementById(\n          'screenBackgroundFadeControlHolderL'\n        );\n\n        _domScreenBackgroundFadeControlHolder.style.backgroundColor =\n          _domScreenBackgroundHolder.style.backgroundColor;\n        _domScreenBackgroundFadeControlHolder.style.backgroundImage = '';\n        ANIMATOR_INTERFACE_2.applyOpacityToElement(_domScreenBackgroundHolder, {\n          opacity: 0\n        });\n      }, _intBackgroundFadeDuration);\n    } else {\n      _domScreenBackgroundFadeControlHolder = SCREEN_INTERACTIONS._objWhatDOM.getElementById(\n        'screenBackgroundFadeControlHolderL'\n      );\n      ANIMATOR_INTERFACE_2.applyOpacityToElement(_domScreenBackgroundFadeControlHolder, {\n        opacity: 0,\n        duration: _intBackgroundFadeDuration\n      });\n      _domScreenBackgroundFadeControlHolder = SCREEN_INTERACTIONS._objWhatDOM.getElementById(\n        'screenBackgroundFadeControlHolderL'\n      );\n      if (_domScreenBackgroundFadeControlHolder.style.backgroundImage != '') {\n        setTimeout(function() {\n          _domScreenBackgroundFadeControlHolder.style.backgroundImage = '';\n        }, _intBackgroundFadeDuration);\n      } else if (_domScreenBackgroundFadeControlHolder.style.backgroundColor != '') {\n        setTimeout(function() {\n          _domScreenBackgroundFadeControlHolder.style.backgroundColor = '';\n        }, _intBackgroundFadeDuration);\n      }\n    }\n  },\n\n  _getTransitionType: function(_strScreenAnimate, _strType) {\n    var _strTransition = '';\n    var strDirection = '';\n\n    if (this._strCurrDirection === '-1') {\n      strDirection = 'Reverse';\n      if (\n        gomo.translationManager.isRtlLanguage &&\n        STR_DYNAMIC_TRANSITION_TYPE === 'horizontalSlide'\n      ) {\n        strDirection = 'Normal';\n      }\n    } else {\n      strDirection = 'Normal';\n      if (\n        gomo.translationManager.isRtlLanguage &&\n        STR_DYNAMIC_TRANSITION_TYPE === 'horizontalSlide'\n      ) {\n        strDirection = 'Reverse';\n      }\n    }\n\n    if (_strScreenAnimate == 'hide') {\n      _strTransition = _strType + 'Hide' + strDirection;\n    } else if (_strScreenAnimate == 'show') {\n      _strTransition = _strType + 'Show' + strDirection;\n    }\n\n    return _strTransition;\n  },\n\n  _canPlayVideoBackground: function(objVideos) {\n    if (OUTPUT_MODE_CHECKER.isDesktop() && OUTPUT_MODE_CHECKER.strCurrentMode != 'accessibleC') {\n      if (\n        objVideos != null &&\n        ((objVideos.mp4 != 'undefined' && objVideos.mp4 != 'resources/undefined') ||\n          (objVideos.webm != 'undefined' && objVideos.webm != 'resources/undefined'))\n      ) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  _getVideoSource: function(objVideos) {\n    var strSource = '';\n\n    if (objVideos.mp4) {\n      strSource = '<source src=\"' + objVideos.mp4 + '\" type=\"video/mp4\">';\n    }\n    if (objVideos.webm) {\n      strSource += '<source src=\"' + objVideos.webm + '\" type=\"video/webm\">';\n    }\n\n    return strSource;\n  },\n\n  _setVideoBackground: function(objVideos, fade) {\n    var _domScreenBackgroundHolder = this._objWhatDOM.getElementById('screenBackgroundHolderL');\n\n    var _htmVideoTemplate = SCREEN_INTERACTIONS.buildVideoElement(objVideos);\n\n    $('#screenBackgroundHolderL').html(_htmVideoTemplate);\n\n    ANIMATOR_INTERFACE_2.applyOpacityToElement(_domScreenBackgroundHolder, {\n      opacity: 1,\n      duration: fade\n    });\n  },\n\n  buildVideoElement: function(objVideos, optionalScreenId) {\n    var _htmVideoTemplate = TEMPLATE_MANANGER.getTemplate('backgroundVideoC').htmData;\n    if (optionalScreenId) {\n      _htmVideoTemplate = TEMPLATE_MANANGER.getTemplate('backgroundVideoScreenLevelC').htmData;\n      _htmVideoTemplate = _htmVideoTemplate.replace('XX_SCREEN_ID_XX', optionalScreenId);\n    }\n    _htmVideoTemplate = _htmVideoTemplate.replace(\n      'XX_SOURCE_CONTENT_XX',\n      this._getVideoSource(objVideos)\n    );\n\n    if (OUTPUT_MODE_CHECKER.isDesktop()) {\n      _htmVideoTemplate = _htmVideoTemplate.replace('XX_PLAY_BUTTON_XX', '');\n    } else {\n      _htmVideoTemplate = _htmVideoTemplate.replace(\n        'XX_PLAY_BUTTON_XX',\n        '<div id=\"playVideoBackground\" onclick=\"SCREEN_INTERACTIONS.toggleVideo()\">Video</div>'\n      );\n    }\n\n    // If user has clicked anywhere we can unmute videos. Videos are muted so chrome will autoplay.\n    if (CORE.booCourseInteractedWith) {\n      _htmVideoTemplate = _htmVideoTemplate.replace('muted', '');\n    }\n\n    // Background video looping\n    if (_.isBoolean(objVideos.loop) && !objVideos.loop) {\n      _htmVideoTemplate = _htmVideoTemplate.replace('loop', '');\n    }\n\n    return _htmVideoTemplate;\n  },\n\n  toggleVideo: function(opts) {\n    var optionalScreenId = opts.screenId || null;\n    var triggerMode = opts.triggerMode || null;\n    var classId = '';\n    if (optionalScreenId) {\n      classId = '_' + optionalScreenId;\n    }\n    var video = document.getElementById('backgroundVideo' + classId);\n\n    if (video && typeof video.play !== 'undefined') {\n      if (triggerMode) {\n        if (triggerMode == 'play') {\n          video.play();\n          return;\n        } else if (triggerMode == 'pause') {\n          video.pause();\n          return;\n        }\n      }\n\n      if (video.paused) {\n        video.play();\n      } else {\n        video.pause();\n      }\n    }\n  },\n\n  _doPostShowEvents: function() {\n    scrollTo(0, 0);\n    SUB_SCREEN_INTERACTIONS._intScrollPos = 0;\n    EM.trigger('newScreenShown', this._strLastScreenID);\n    // REFACTOR NOTE: add the below call again and test why it was miss firing on beta on topic\n    // first load\n    // ASSET_INTERACTIONS.testAssetsBoundarySize(this.getCurrentScreenData());\n  },\n\n  applyIscrollToCurrentScreen: function() {\n    var screenWrapperEl = this.getScreenWrapper(this.strCurrentScreenId);\n    this._addIScrollToScreen(screenWrapperEl);\n  },\n\n  _addIScrollToScreen: function(_domWhatScreenElement) {\n    if (typeof ISCROLL_INTERFACE != 'undefined') {\n      // We don't want to scroll the screens in continuous scrolling mode\n      if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n        ISCROLL_INTERFACE.parseForContinuousScrollContentWrapper();\n      } else {\n        ISCROLL_INTERFACE.parseChildDOMElements(_domWhatScreenElement);\n      }\n    }\n  },\n\n  _getCurrentContentWrapper: function() {\n    return this._objWhatDOM.getElementById(this._strCurrContentWrapperID);\n  },\n\n  handleEvent_updateScreenDisplayStates: function(updateData) {\n    var displayStateChangedScreens = updateData.arrDisplayStateChangedScreens;\n    var currScreenDataWrapper;\n    var screenWrapperID;\n    var screenWrapper;\n    var screenIndex;\n    var domCurrScreenWrapper;\n\n    for (var i = 0; i < displayStateChangedScreens.length; i++) {\n      currScreenDataWrapper = displayStateChangedScreens[i];\n      screenWrapperID = 'screenWrapper_' + currScreenDataWrapper.strObjID + 'L';\n      screenIndex = _.findIndex(currScreenDataWrapper.objParent.arrScreens, {\n        strObjID: currScreenDataWrapper.strObjID\n      });\n\n      // If hiding a screen unregister asset bindings for the screen so they can be reapplied.\n      if (currScreenDataWrapper && !currScreenDataWrapper.booIsDisplayed) {\n        var assetIds = [];\n        var assetsData = currScreenDataWrapper.objRawData.arrAssets;\n        assetIds = _.map(assetsData, function(asset) {\n          return asset.strID;\n        });\n        if (assetIds && gomo.dataBinding && gomo.dataBinding.unregister) {\n          // Unregister assets content translations.\n          gomo.dataBinding.unregister(assetIds);\n          // Unregister assets localisation translations.\n          _.each(assetIds, function(assetId) {\n            gomo.translationManager.unregisterLocalisation(\n              'topic',\n              assetId\n            );\n          });\n        }\n        // Also remove rendered subscreens so they re-render correctly.\n        var subscreenIds = _.map(currScreenDataWrapper.arrSubScreens, function(subscreen) {\n          return subscreen.strObjID;\n        });\n        SUB_SCREEN_RENDERER.resetRenderedSubscreens(subscreenIds);\n      }\n\n      domCurrScreenWrapper = SCREEN_RENDERER.renderScreen(currScreenDataWrapper, screenIndex);\n      // Update image paths\n      domCurrScreenWrapper = MASTER_RENDERER.cleanUpResourcePaths(domCurrScreenWrapper);\n\n      screenWrapper = $(this._objWhatDOM).find('#' + screenWrapperID);\n      // Add the rendered screen\n      SCROLLING_MANAGER.disablePolling();\n      $(screenWrapper).replaceWith(domCurrScreenWrapper);\n      // Update the screenWrapper ref\n      screenWrapper = $(this._objWhatDOM).find('#' + screenWrapperID);\n\n      // Apply custom styles and column widths\n      EM.trigger('newlyRenderedItemInDocument');\n\n      // Check if this screen is part of a cont scroll topic\n      // Then perform pre show and post render actions.\n      if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n        // We need to update the scroll manager with the new visibile screen(s)\n        SCROLLING_MANAGER.setCurrentScreens(currScreenDataWrapper.objParent);\n\n        this._performPreShowActions(currScreenDataWrapper.strObjID);\n        // Trigger animation complete. If this screen is now central then it will postRender assets\n        var animationOpts = {\n          strWhatSubScreenElementID: screenWrapperID,\n          strType: 'shown'\n        };\n\n        $(screenWrapper).find('.screenContentC')\n          .css('opacity', '0')\n          .addClass('fade-in')\n          .bind('oanimationend animationend webkitAnimationEnd', function() {\n            $(this).attr('style', '').removeClass('fade-in');\n            EM.trigger('screenAnimationComplete', animationOpts);\n          });\n      }\n      SCROLLING_MANAGER.enablePolling();\n      VARIABLES_HOLDER.updateAllVariablesForAnElement(screenWrapperID);\n    }\n\n    // We need to translate LOCALISATION at an asset level\n    ASSET_INTERACTIONS.assetDisplayStateUpdatedTasks();\n\n    this.screenDisplayStateUpdatedTasks();\n    DISPLAY_CONDITIONS_INTERACTIONS.checkLinkedObjects();\n    EM.trigger('screenVisibilityUpdated', updateData);\n  },\n\n  screenDisplayStateUpdatedTasks: function() {\n    var topicData = TOPIC_MANAGER.getCurrentTopic();\n    if (topicData) {\n      _.each(topicData.arrScreens, function(screenObject, index) {\n        var shouldBeHidden =\n          index > 0 &&\n           !screenObject.booIsDisplayed && !topicData.arrScreens[index - 1].booIsDisplayed;\n        var screenWrapperID = 'screenWrapper_' + screenObject.strObjID + 'L';\n        $(this._objWhatDOM)\n          .find('#' + screenWrapperID)\n          .toggleClass('sequentiallyHiddenScreen', shouldBeHidden);\n      }, this);\n    }\n  }\n};\n\nEM.register(SCREEN_INTERACTIONS);\n"},function(n,e,t){t(0)(t(117))},function(n,e){n.exports="/* global TOPIC_MANAGER, LAYOUT_INTERACTIONS, EM, OUTPUT_MODE_CHECKER, ISCROLL_INTERFACE */\n/* global BOO_RESET_NON_ASSESSMENT_ASSET_STATES, CORE, SUB_SCREEN_INTERACTIONS */\n/* global META_TOPIC_MANAGER, ASSET_INTERACTIONS */\n/**\n * @title Screen Interactions\n * @description To be described.\n *\n *\n * @author GoMo\n * @version 2.0 17/12/12\n * @versino 1.1 18/12/12 James Hough - add 'hiddenC' class\n * name to hidden screens in 'screenAnimationComplete'\n * @REFACTOR NOTE: Clean up the usage of _resetScreensAssets() and resetScreensAssets().\n */\n\nvar META_SCREEN_INTERACTIONS = {\n  strObjID: 'Screen interactions',\n  strObjDescription:\n    'Handles the common interactions, acts as a holder for ' +\n    'the specific screen related interactions.',\n\n  _strScreenIDPrefix: 'screenWrapper_',\n  _strScreenIDSuffix: 'L',\n  _strHiddenScreenClass: 'hiddenScreenC',\n  _strShownScreenClass: 'shownScreenC',\n\n  _strCurrContentWrapperID: 'contentWrapperL',\n\n  _objScreenVisibilityStates: {},\n\n  _objWhatDOM: null,\n\n  _strCurrOutputModeClass: 'graphicalC',\n  _strStoredCSSTransition: '',\n\n  _booInTopic: false,\n\n  handleEvent_primeDOMReferences: function(_objWhatDOM) {\n    this._objWhatDOM = _objWhatDOM;\n  },\n\n  switchToMetaScreen: function(_strWhatScreenID, _objOptionalData) {\n    var _domScreenWrapper = this.getScreenWrapper(_strWhatScreenID);\n    if (BOO_RESET_NON_ASSESSMENT_ASSET_STATES) {\n      var _booForceReset = true;\n      this._resetMetaScreensAssets(_strWhatScreenID, _booForceReset);\n    }\n\n    this._showMetaScreen(_domScreenWrapper, _objOptionalData);\n    this._addIScrollToScreen(_domScreenWrapper);\n  },\n\n  getScreenWrapperID: function(_strWhatScreenID) {\n    return this._strScreenIDPrefix + _strWhatScreenID + this._strScreenIDSuffix;\n  },\n\n  getScreenWrapper: function(_strWhatScreenID) {\n    return this._objWhatDOM.getElementById(this.getScreenWrapperID(_strWhatScreenID));\n  },\n\n  resetMetaScreensAssets: function(_strWhatScreenID, _booForceReset) {\n    var _domScreenBackgroundHolder = this._objWhatDOM.getElementById('screenBackgroundHolderL');\n    var _domScreenBackgroundFadeControlHolder = this._objWhatDOM.getElementById(\n      'screenBackgroundFadeControlHolderL'\n    );\n    if (_domScreenBackgroundHolder) {\n      _domScreenBackgroundHolder.style.backgroundImage = '';\n      _domScreenBackgroundFadeControlHolder.style.backgroundImage = '';\n    }\n\n    var _objWhatScreenData = this._getMetaScreenData(_strWhatScreenID);\n    var count = 0;\n    if (_objWhatScreenData) {\n      while (count < _objWhatScreenData.arrAssets.length) {\n        var _objCurrAsset = _objWhatScreenData.arrAssets[count];\n        ASSET_INTERACTIONS.resetAsset(_objCurrAsset, _booForceReset);\n        count++;\n      }\n    }\n    LAYOUT_INTERACTIONS.resetLayoutWidthObjList();\n  },\n\n  _showMetaScreensPostRenderAssets: function(_strWhatScreenID) {\n    var _objWhatScreenData = this._getMetaScreenData(_strWhatScreenID);\n    var count = 0;\n    while (count < _objWhatScreenData.arrAssets.length) {\n      var _objCurrAsset = _objWhatScreenData.arrAssets[count];\n      ASSET_INTERACTIONS.showPostRenderAsset(_objCurrAsset);\n      count++;\n    }\n  },\n\n  // GENERIC METHODS\n  getCurrentScreenData: function() {\n    return this._getMetaScreenData(this._strLastScreenID);\n  },\n\n  getLastScreenID: function() {\n    return this._strLastScreenID;\n  },\n\n  getShownScreenElement: function() {\n    for (var _strCurrScreenID in this._objScreenVisibilityStates) {\n      if (this._objScreenVisibilityStates[_strCurrScreenID]) {\n        var _domVisibleScreen = this._objWhatDOM.getElementById(_strCurrScreenID);\n        // Check we havn't managed to get garbage in the visible screens HASH.\n        if (_domVisibleScreen) {\n          return _domVisibleScreen;\n        }\n      }\n    }\n    return false;\n  },\n\n  updateVariableReferences: function(_objWhatScreen, _objEventData) {\n    var _arrAssets = _objWhatScreen.arrAssets;\n    var count = 0;\n    while (count < _arrAssets.length) {\n      var _objCurrAsset = _arrAssets[count];\n      ASSET_INTERACTIONS.updateAssetVariableLinks(_objCurrAsset, _objEventData);\n      count++;\n    }\n  },\n\n  _resetMetaScreensAssets: function(_strWhatScreenID, _booForceReset) {\n    var _objWhatScreenData = this._getMetaScreenData(_strWhatScreenID);\n    var count = 0;\n    while (count < _objWhatScreenData.arrAssets.length) {\n      var _objCurrAsset = _objWhatScreenData.arrAssets[count];\n      ASSET_INTERACTIONS.resetAsset(_objCurrAsset, _booForceReset);\n      count++;\n    }\n  },\n\n  _getMetaScreenData: function(_strWhatScreenID) {\n    var _objWhatScreen = false;\n    var _objCurrTopicData = META_TOPIC_MANAGER.getCurrentMetaTopic();\n    if (_objCurrTopicData.findScreen) {\n      _objWhatScreen = _objCurrTopicData.findScreen(_strWhatScreenID);\n    }\n    return _objWhatScreen;\n  },\n\n  _performMetaPreShowActions: function(_strWhatScreenID) {\n    // Run the screen size check to rerender elements on demand.\n    OUTPUT_MODE_CHECKER.manualScreenSizeCheck();\n\n    var _objWhatScreenData = this._getMetaScreenData(_strWhatScreenID);\n    var _domScreenWrapper = this.getScreenWrapper(_strWhatScreenID);\n    _domScreenWrapper.className = _domScreenWrapper.className.replace(\n      'notStartedScreenStateC',\n      'preShownScreenStateC'\n    );\n    var count = 0;\n    while (count < _objWhatScreenData.arrAssets.length) {\n      var _objCurrAsset = _objWhatScreenData.arrAssets[count];\n      ASSET_INTERACTIONS.performPreShowActions(_objCurrAsset);\n      count++;\n    }\n    _domScreenWrapper.className = _domScreenWrapper.className.replace(\n      'preShownScreenStateC',\n      'notStartedScreenStateC'\n    );\n  },\n\n  _getCurrentScreen: function() {\n    var _objCurrTopicData = TOPIC_MANAGER.getCurrentTopic();\n    return _objCurrTopicData.arrScreens[_objCurrTopicData.intNavigationIndex];\n  },\n\n  _hideScreens: function() {\n    var _objDOMElement = this._getCurrentContentWrapper();\n    var _arrShownScreens = CORE.getElementsByClassName(_objDOMElement, this._strShownScreenClass);\n    var count = 0;\n    while (count < _arrShownScreens.length) {\n      var _domCurrScreenWrapper = _arrShownScreens[count];\n      this._hideScreen(_domCurrScreenWrapper);\n      count++;\n    }\n  },\n\n  _showMetaScreen: function(_domWhatScreenElement) {\n    _domWhatScreenElement.className = _domWhatScreenElement.className.replace(\n      this._strHiddenScreenClass,\n      this._strShownScreenClass\n    );\n\n    var _strScreenID = _domWhatScreenElement.id.replace('screenWrapper_', '');\n\n    if (_strScreenID.substring(_strScreenID.length - 1) == 'L') {\n      _strScreenID = _strScreenID.substring(0, _strScreenID.length - 1);\n    }\n\n    this._performMetaPreShowActions(_strScreenID);\n    this._showMetaScreensPostRenderAssets(_strScreenID);\n    _domWhatScreenElement.style.left = '0px';\n    _domWhatScreenElement.style.display = 'block';\n  },\n\n  _doPostShowEvents: function() {\n    scrollTo(0, 0);\n    SUB_SCREEN_INTERACTIONS._intScrollPos = 0;\n    EM.trigger('newScreenShown', this._strLastScreenID);\n    // REFACTOR NOTE: add the below call again and test why it was miss\n    // firing on beta on topic first load\n    // ASSET_INTERACTIONS.testAssetsBoundarySize(this.getCurrentScreenData());\n  },\n\n  _addIScrollToScreen: function(_domWhatScreenElement) {\n    if (typeof ISCROLL_INTERFACE != 'undefined') {\n      ISCROLL_INTERFACE.parseChildDOMElements(_domWhatScreenElement);\n    }\n  },\n\n  _getCurrentContentWrapper: function() {\n    return this._objWhatDOM.getElementById(this._strCurrContentWrapperID);\n  }\n};\n\nEM.register(META_SCREEN_INTERACTIONS);\n"},function(n,e,t){t(0)(t(119))},function(n,e){n.exports='/**\n* @title Layout Interactions\n* @description To be described.\n*\n*\n* @author James Hough\n* @version 2.0\n*/\n\nvar LAYOUT_INTERACTIONS =\n{\n\tstrObjID : "Layout interactions",\n\tstrObjDescription : "Handles the common layout interactions.",\n\t_objLayoutWidthList : {},\n\n\t_strColumnIDPreffix : "col",\n\t_strEmptyColumnClass : "emptyLayoutC",\n\n\n\t_objWhatDOM : null,\n\n\thandleEvent_primeDOMReferences : function (_objWhatDOM)\n\t{\n\t\tthis._objWhatDOM = _objWhatDOM;\n\t},\n\n\thandleEvent_assetVisibilityUpdated : function (_objUpdateData)\n\t{\n\t\tvar _objRelatedLayoutIDs = _objUpdateData.objRelatedLayoutBlockIDs;\n\n\t\tfor (var _strCurrLayoutID in _objRelatedLayoutIDs)\n\t\t{\n\t\t\tvar _objCurrColumnIndexs = _objRelatedLayoutIDs[_strCurrLayoutID];\n\t\t\tfor (var _intCurrColumnIndex in _objCurrColumnIndexs)\n\t\t\t{\n\t\t\t\tthis._updateLayoutBlockVisibility(_strCurrLayoutID, _intCurrColumnIndex);\n\t\t\t}\n\t\t}\n\t},\n\n\tresetLayoutWidthObjList : function ()\n\t{\n\t\tthis._objLayoutWidthList = {};\n\t\tASSET_RENDERER.objOutOfBoundaryAsset = {};\n\t},\n\n\tsetLayoutWidthObjList : function (_objLayoutDataWrapper, _arrCurrRelatedAssets, strColumnId)\n\t{\n\t\t//When the screen is rendered this list will be processed.\n\t\tif (typeof this._objLayoutWidthList[_objLayoutDataWrapper.strObjID] == \'undefined\')\n\t\t{\n\t\t\tthis._objLayoutWidthList[_objLayoutDataWrapper.strObjID] = {};\n\t\t}\n\t\tthis._objLayoutWidthList[_objLayoutDataWrapper.strObjID][strColumnId] = {\'_arrCurrRelatedAssets\': _arrCurrRelatedAssets };\n\t},\n\n\tgetLayoutWidthObjList : function ()\n\t{\n\t\treturn this._objLayoutWidthList;\n\t},\n\n\t_updateLayoutBlockVisibility : function (_strWhatLayoutID, _intWhatColumn)\n\t{\n\t\tvar _domColumnWrapper = this._getLayoutColumnDOMWrapper(_strWhatLayoutID, _intWhatColumn);\n\t\tvar _objCurrLayoutData = OBJ_REF.get(_strWhatLayoutID);\n\t\tvar _arrVisibleAssets = _objCurrLayoutData.getRelatedAssets(_intWhatColumn);\n\n\t\tif (_arrVisibleAssets.length > 0)\n\t\t{\n\t\t\t_domColumnWrapper.className = _domColumnWrapper.className.replace(this._strEmptyColumnClass, "");\n\t\t\tvar count = 0;\n\t\t\twhile (count < _arrVisibleAssets.length)\n\t\t\t{\n\t\t\t\tvar _objCurrAsset = _arrVisibleAssets[count];\n\t\t\t\tASSET_INTERACTIONS.updateAssetColumnOrderingClasses(_objCurrAsset);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_domColumnWrapper.className = _domColumnWrapper.className + " " + this._strEmptyColumnClass;\n\t\t}\n\t},\n\n\t_getLayoutColumnDOMWrapper : function (_strWhatLayoutID, _intWhatColumn)\n\t{\n\t\t//p23i01s01lay01col0\n\t\tvar _strColumnID = _strWhatLayoutID + this._strColumnIDPreffix + _intWhatColumn;\n\t\tvar _domWhatColumnDOMElement = this._objWhatDOM.getElementById(_strColumnID);\n\n\t\tif (_domWhatColumnDOMElement)\n\t\t{\n\t\t\treturn _domWhatColumnDOMElement;\n\t\t}\n\n\t\talert("ERROR: Unable to find layout column with the ID of \'" + _strColumnID + "\'. _getLayoutColumnDOMWrapper(), layout_interactions.js");\n\t\treturn false;\n\t},\n\n\tbooTerminal : true\n};\n\nEM.register(LAYOUT_INTERACTIONS);'},function(n,e,t){t(0)(t(121))},function(n,e){n.exports="/* globals\n$, jQuery, EM, OUTPUT_MODE_CHECKER, ASSET_INTERACTIONS, SCREEN_INTERACTIONS,\nBOO_DYNAMIC_CONTINUOUS_SCROLLING, FORCE_POPOVER_SUBSCREENS, TOPIC_MANAGER, CORE, ISCROLL_INTERFACE,\nTOPIC_INTERACTIONS, BOO_ANIMATE_SUBSCREENS, STR_DYNAMIC_TRANSITION_TYPE, OBJ_REF, ASSET_RENDERER,\nSUB_SCREEN_RENDERER, SCROLLING_MANAGER, Modernizr, INT_TRANSITION_TIMER, ACTIONS_INTERACTIONS,\nANIMATOR_INTERFACE, LOCALISER, ASSET_INTERACTIONS, ASSET_INTERACTION, DEBUG, CONTENT_TRACKING,\nPOPUP_MANANGER, FLOATING_FOOTER, _\n*/\n\n/**\n * @title Sub Screen Interactions\n * @description Manage the movement of subscreens and the user selections\n *\n * @author GoMo\n * @version 2.0\n *\n * Major REFACTOR needed to bring down the footprint of the file after thirdparty subscreens\n * introduced.\n */\n\nvar SUB_SCREEN_INTERACTIONS = {\n  strObjID: 'Sub screen interactions',\n  strObjDescription: 'Handles the showing and hiding of subscreens.',\n\n  _objWhatDOM: null,\n\n  _strSubScreenIDPrefix: 'subScreenWrapper_',\n  _strSubScreenIDSuffix: 'L',\n  _strSubScreenContentIDPrefix: 'subScreenContent_',\n  _strHiddenSubScreenClass: 'hiddenSubScreenC',\n  _strShownSubScreenClass: 'shownSubScreenC',\n\n  _strBottomCenterSubScreenClass: 'bottomCenterSubScreenC',\n  _strTopCenterSubScreenClass: 'topCenterSubScreenC',\n  _strRightMiddleSubScreenClass: 'rightMiddleSubScreenC',\n  _strLeftMiddleSubScreenClass: 'leftMiddleSubScreenC',\n\n  _strNotInteractedClass: 'screenNotInteractedWithC',\n  _strInteractedClass: 'screenInteractedWithC',\n  _strCompletedClass: 'completedScreenStateC',\n  _strCompletableScreenClass: 'completableScreenC',\n  _strNonCompletableScreenClass: 'nonCompletableScreenC',\n\n  _intSubScreenOffsetTop: 0,\n\n  _objAnimationHandles: {},\n\n  _booInTopic: false,\n  _strCurrTopicModel: '',\n\n  _objModalTempWebkitTransform: {},\n\n  _strCurrParentAssetID: null,\n  _strCurrParentAssetActionSetID: null,\n  _strCurrOutputModeClass: 'graphicalC',\n  _strAnimationAsset: 'subScreen',\n\n  _objSubScreenVisibility: {},\n  _objSubScreenDomCreated: {},\n  _strScreenSizeOnOpenSubscreen: '',\n\n  _domLastShownSubScreen: null,\n  _strIdCurrentShownSubScreen: null,\n  _objCurrentThirdPartySubScreen: {},\n\n  _intScrollPos: 0,\n\n  _subscreenOpen: false,\n  _pendingSubScreenData: false,\n\n  registeredSubscreens: {},\n\n  hidePostRenderAssetsOptions: false,\n\n  _animatingSubscreens: {},\n\n  _objDefaultAnimationData: {\n    left: {\n      strType: 'css',\n      arrInitialState: {\n        style: null,\n        value: null\n      },\n      arrTargetState: {\n        style: null,\n        value: '0'\n      }\n    },\n    right: {\n      strType: 'css',\n      arrInitialState: {\n        style: null,\n        value: null\n      },\n      arrTargetState: {\n        style: null,\n        value: '0'\n      }\n    },\n    bottom: {\n      strType: 'css',\n      arrInitialState: {\n        style: null,\n        value: null\n      },\n      arrTargetState: {\n        style: null,\n        value: '0'\n      }\n    },\n    top: {\n      strType: 'css',\n      arrInitialState: {\n        style: null,\n        value: null\n      },\n      arrTargetState: {\n        style: null,\n        value: '0'\n      }\n    }\n  },\n\n  assetTypeReferrer: '',\n  assetLabelReferrer: '',\n  assetIdReferrer: '',\n  timeAvailable: null,\n\n  handleEvent_primeDOMReferences: function(_objWhatDOM) {\n    this._objWhatDOM = _objWhatDOM;\n\n    // Set key listener to close subscreens.\n    var listenForEscape = function(e) {\n      if (SUB_SCREEN_INTERACTIONS.isSubscreenAnimating()) return;\n      if (e.keyCode === 27 || e.key === 'Escape') {\n        SUB_SCREEN_INTERACTIONS.hideSubScreens();\n      }\n    };\n    window.addEventListener('keydown', listenForEscape);\n  },\n\n  handleEvent_setTopicModelType: function(_strWhatTopicModel) {\n    this._strCurrTopicModel = _strWhatTopicModel;\n    this._booInTopic = true;\n  },\n\n  handleEvent_outputModeChanged: function(_objOutputChangeData) {\n    this._strCurrOutputModeClass = _objOutputChangeData['strNewOutputMode'];\n    this._autoHideThirdPartySubScreen();\n  },\n\n  handleEvent_showSubScreen: function(_objWhatData) {\n    if (\n      this._booSubscreenExists(_objWhatData['strTargetSubScreenID']) == false ||\n      _objWhatData['strTargetSubScreenID'] == this._strIdCurrentShownSubScreen\n    ) {\n      _objWhatData.funCallBack();\n      return;\n    }\n    this._strScreenSizeOnOpenSubscreen = OUTPUT_MODE_CHECKER.strCurrentScreenSize;\n\n    if (this._subscreenOpen) {\n      this._pendingSubScreenData = _objWhatData;\n    }\n\n    // Close open subscreens and popups.\n    this.hideSubScreens();\n    POPUP_MANANGER._hidePopups();\n\n    this._strIdCurrentShownSubScreen = _objWhatData['strTargetSubScreenID'];\n    this._resetSubscreenAssets(_objWhatData['strTargetSubScreenID']);\n\n    if (!this._subscreenOpen) {\n      this._openSubscreen(_objWhatData);\n    }\n  },\n\n  _openSubscreen: function(_objWhatData) {\n    gomo.tabManager.setActiveFocus();\n    this._pendingSubScreenData = false;\n\n    if (_objWhatData['strAssetID']) {\n      var _objParentAssetDataHolder = ASSET_INTERACTIONS.getAssetData(_objWhatData['strAssetID']);\n      SCREEN_INTERACTIONS.prepareCurrentScreenForPopupLayers(\n        _objParentAssetDataHolder.intColumnAffinity\n      );\n    }\n\n    var _objSubScreenData = this._getSubScreenData(_objWhatData.strTargetSubScreenID);\n\n    /* REFACTOR NOTE: This should be modulised like the asset dev */\n    if (this._booSubscreenTypeExists(_objSubScreenData.strType) == false) {\n      _objWhatData.funCallBack();\n      return;\n    }\n\n    if (_objWhatData.funCallBack) {\n      _objSubScreenData.funCallBack = _objWhatData.funCallBack;\n    }\n\n    /* REFACTOR : build the coords data into the subscreen data within the actions class. */\n    if (_objWhatData.arrActions) {\n      _objSubScreenData.arrActions = _objWhatData.arrActions;\n    }\n\n    var _domSubScreenWrapper = this._getSubScreenDOMElement(_objWhatData['strTargetSubScreenID']);\n    this.setAnimatingSubscreen(_objWhatData['strTargetSubScreenID']);\n\n    if (typeof _objWhatData['strAdditionalStyles'] != 'undefined') {\n      if (_domSubScreenWrapper.className.indexOf(_objWhatData['strAdditionalStyles']) == -1) {\n        _domSubScreenWrapper.className += ' ' + _objWhatData['strAdditionalStyles'];\n      }\n    }\n\n    if (_objSubScreenData.strType == 'reveal') {\n      _objSubScreenData.booThirdPartyRender = false;\n      // Due to screens stretching off the page wrapper in continuous scroll mode, we need to move\n      // their location\n\n      // Desktop subscreen move in normal mode\n      if (\n        BOO_DYNAMIC_CONTINUOUS_SCROLLING == false &&\n        OUTPUT_MODE_CHECKER.applyScrolling() == false\n      ) {\n        _objSubScreenData.subscreenParent = _domSubScreenWrapper.parentNode;\n        $(_domSubScreenWrapper).appendTo('#screenHolderL');\n      } else if (\n        BOO_DYNAMIC_CONTINUOUS_SCROLLING &&\n        OUTPUT_MODE_CHECKER.applyScrolling() == false\n      ) {\n        // Desktop subscreen move in continuous scroll mode\n        _objSubScreenData.subscreenParent = _domSubScreenWrapper.parentNode;\n        $(_domSubScreenWrapper).appendTo('#contentWrapperL');\n      } else if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n        // Smartphone and tablet subscreen move\n        _objSubScreenData.subscreenParent = _domSubScreenWrapper.parentNode;\n        $(_domSubScreenWrapper).appendTo('#contentWrapperInnerL');\n\n        this.removeScrollingFromSubscreen(_domSubScreenWrapper);\n      }\n      this._showSubScreen(_domSubScreenWrapper, _objParentAssetDataHolder, _objSubScreenData);\n    } else {\n      if (_objSubScreenData.strType == 'popover') _objSubScreenData.strType = 'balloon';\n      if (_objSubScreenData.strType == 'popup') _objSubScreenData.strType = 'modal';\n\n      _objSubScreenData.booThirdPartyRender = true;\n      if (_objWhatData.domLink) {\n        _objSubScreenData.domLink = _objWhatData.domLink;\n      } else {\n        // REFACTOR: the whole subscreens interactions requires refactoring to make new types\n        // modular. This will give popover something to reference on to, default is topstrap.\n        if (_objSubScreenData.strType == 'popover' || _objSubScreenData.strType == 'balloon') {\n          console.log('WARNING: ' +\n              _objSubScreenData.strTitle +\n              ' does not support popover without a reference point. '+\n              'SUBSCREEN_INTERACTION.showsubscreen()');\n          _objSubScreenData.domLink = this._objWhatDOM.getElementById('topStrapL');\n        }\n      }\n\n      if (this.isAbsolutelyPositionedSubscreen()) {\n        var modalParentElement = '#contentWrapperInnerL';\n        _objSubScreenData.subscreenParent = _domSubScreenWrapper.parentNode;\n        // Display the subscreen type based off of live device compatibility\n        var dynamicSubScreenType = SUB_SCREEN_RENDERER.subScreenTypeSizeOverride(\n          _objSubScreenData.strType\n        );\n        // Add modals to contentWrapperL so the positioning is not affected by iscroll.\n        if (dynamicSubScreenType === 'modal') {\n          modalParentElement = '#contentWrapperL';\n          // disable topic scrolling while modal is open.\n          gomo.eventManager.legacy('disableParentIScrollInstaces');\n        }\n        $(_domSubScreenWrapper).appendTo(modalParentElement);\n        this.removeScrollingFromSubscreen(_domSubScreenWrapper);\n      }\n      this._showThirdPartySubScreen(_domSubScreenWrapper, _objSubScreenData);\n    }\n\n    // process the prerender actions after render as these subscreen types weren't available\n    // preshown\n    if (this._supportsPreRenderSupport(_objSubScreenData.strType) == false) {\n      this._showSubScreensPreRenderAssets(_objWhatData['strTargetSubScreenID']);\n    }\n\n    if (this._strCurrOutputModeClass == 'accessibleC') {\n      this.focusSubScreen(_domSubScreenWrapper);\n    }\n\n    if (this._supportsPreRenderSupport(_objSubScreenData.strType)) {\n      this._showSubScreensPreRenderAssets(_objWhatData['strTargetSubScreenID']);\n    }\n\n    SCREEN_INTERACTIONS.takeFocusFromScreen();\n\n    // add FORCE_POPOVER_SUBSCREENS support to allow an overflow on mobile devices if the\n    // subscreens overflow the screen\n    if (typeof FORCE_POPOVER_SUBSCREENS !== 'undefined' && FORCE_POPOVER_SUBSCREENS) {\n      $('#navWrapperL').fadeTo(250, 0.2);\n      $('#screenHolderL').css('overflow', 'auto');\n    }\n\n    this._strCurrParentAssetID = _objWhatData['strAssetID'];\n    this.assetIdReferrer = _objWhatData['strAssetID'];\n    this._strCurrParentAssetActionSetID = _objWhatData['strActionSetID'];\n    this.assetTypeReferrer = _objWhatData['strAssetType'] || _objWhatData['strType'];\n    this.sendEnterStatement(_objSubScreenData);\n  },\n\n  removeScrollingFromSubscreen: function(_domSubScreenWrapper) {\n    // Remove scrolling from the subscreens\n    $(_domSubScreenWrapper)\n      .find('.scrollWrapperC')\n      .addClass('TEMP_scroll_Wrapper_C');\n    $(_domSubScreenWrapper)\n      .find('.checkScrollingC')\n      .addClass('TEMP_check_Scrolling_C');\n    $(_domSubScreenWrapper)\n      .find('.TEMP_scroll_Wrapper_C')\n      .removeClass('scrollWrapperC');\n    $(_domSubScreenWrapper)\n      .find('.TEMP_check_Scrolling_C')\n      .removeClass('checkScrollingC');\n  },\n\n  restoreScrollingToSubscreen: function(_domSubScreenWrapper) {\n    // Remove scrolling from the subscreens\n    $(_domSubScreenWrapper)\n      .find('.TEMP_scroll_Wrapper_C')\n      .addClass('scrollWrapperC');\n    $(_domSubScreenWrapper)\n      .find('.TEMP_check_Scrolling_C')\n      .addClass('checkScrollingC');\n    $(_domSubScreenWrapper)\n      .find('.TEMP_scroll_Wrapper_C')\n      .removeClass('TEMP_scroll_Wrapper_C');\n    $(_domSubScreenWrapper)\n      .find('.TEMP_check_Scrolling_C')\n      .removeClass('TEMP_check_Scrolling_C');\n  },\n\n  getCurrentSubscreen: function() {\n    return this._strIdCurrentShownSubScreen;\n  },\n\n  handleEvent_preNavigate: function() {\n    if (this._strCurrParentAssetID || this._strCurrParentAssetActionSetID) {\n      this._returnFocusToAsset(this._strCurrParentAssetID, this._strCurrParentAssetActionSetID);\n    }\n    this.hideSubScreens();\n    this._strIdCurrentShownSubScreen = null;\n    this._objSubScreenVisibility = {};\n    this._objSubScreenDomCreated = {};\n    this._pendingSubScreenData = false;\n    this._subscreenOpen = false;\n    this._animatingSubscreens = {};\n  },\n\n  handleEvent_closeSubScreen: function(_objWhatSubScreenData) {\n    this._autoHideThirdPartySubScreen();\n\n    if (this._strCurrParentAssetID == false && !_objWhatSubScreenData.triggerCloseActions) {\n      SUB_SCREEN_INTERACTIONS.debug('Subscreen was closed but not found. Possible double click. '+\n      'SUB_SCREEN_INTERACTIONS.handleEvent_closeSubScreen()');\n      return;\n    }\n    var _strSubScreenID = _objWhatSubScreenData['strSubScreenID'];\n    var _objSubScreenData = this._getSubScreenData(_strSubScreenID);\n    var _domSubScreenWrapper = this._getSubScreenDOMElement(_strSubScreenID);\n\n    if (_objSubScreenData.strType == 'reveal') {\n      this._hideSubScreen(_domSubScreenWrapper, _objSubScreenData);\n    } else {\n      this._hideThirdPartySubScreen(_domSubScreenWrapper, _objSubScreenData);\n    }\n\n    this._strIdCurrentShownSubScreen = null;\n\n    // If we are hiding all subscreens and don't have a parent set don't try to return focus.\n    if (this._strCurrParentAssetID) {\n      this._returnFocusToAsset(this._strCurrParentAssetID, this._strCurrParentAssetActionSetID);\n      var _objParentAssetDataHolder = ASSET_INTERACTIONS.getAssetData(this._strCurrParentAssetID);\n      SCREEN_INTERACTIONS.restoreCurrentScreenFromPopupLayers(\n        _objParentAssetDataHolder.intColumnAffinity\n      );\n    }\n\n    this._strCurrParentAssetID = false;\n    this._strCurrParentAssetActionSetID = false;\n\n    EM.trigger('toggleBlanking', {\n      strState: 'OFF',\n      objWhatDOM: SCREEN_INTERACTIONS.getShownScreenElement()\n    });\n\n    scrollTo(0, this._intScrollPos);\n\n    // add FORCE_POPOVER_SUBSCREENS support to allow an overflow on mobile devices if the\n    // subscreens overflow the screen\n    if (typeof FORCE_POPOVER_SUBSCREENS !== 'undefined' && FORCE_POPOVER_SUBSCREENS) {\n      $('#navWrapperL').fadeTo(250, 1);\n      $('#screenHolderL').css('overflow', 'visible');\n    }\n  },\n\n  handleEvent_subscreenAnimationComplete: function(_objOptions) {\n    var _strWhatSubScreenElementID = _objOptions.strWhatSubScreenElementID;\n    var _arrAnimations = _objOptions._arrAnimations;\n    if (_strWhatSubScreenElementID) {\n      var _domWhatSubScreenElement = this._objWhatDOM.getElementById(_strWhatSubScreenElementID);\n      this.resetAnimatingSubscreen(_objOptions.strObjID);\n      if (!_domWhatSubScreenElement) {\n        return;\n      }\n\n      // HIDE - Core subscreen (not 3rd party)\n      if (\n        !this._objSubScreenVisibility[_strWhatSubScreenElementID] &&\n        _objOptions.booThirdPartyRender == false\n      ) {\n        // Reset position for dynamic scrolling screens in iscroll mode\n        SUB_SCREEN_INTERACTIONS.resetIscrollPositionForSubscreen({\n          domSubscreenWrapper: _domWhatSubScreenElement\n        });\n        // If the subscreen was moved then it will have had a subscreenParent created\n        if (_objOptions.subscreenParent) {\n          $(_domWhatSubScreenElement).appendTo(_objOptions.subscreenParent);\n          delete _objOptions.subscreenParent;\n        }\n\n        // replace the values for hidden items as they can be rendered from a different position if\n        // the screensize changes.\n        if (_arrAnimations) {\n          var _strStyle = _arrAnimations[0].style;\n          _domWhatSubScreenElement.style[_strStyle] = '';\n        }\n        _domWhatSubScreenElement.className = _domWhatSubScreenElement.className.replace(\n          this._strShownSubScreenClass,\n          this._strHiddenSubScreenClass\n        );\n        this._removeSubScreenClass(_domWhatSubScreenElement);\n      }\n      // HIDE - All subscreens\n      if (!this._objSubScreenVisibility[_strWhatSubScreenElementID]) {\n        this._subscreenOpen = false;\n        if (this._pendingSubScreenData) {\n          SUB_SCREEN_INTERACTIONS._openSubscreen(this._pendingSubScreenData);\n        }\n      }\n\n      // DISPLAY - Core subscreen (not 3rd party)\n      if (\n        this._objAnimationHandles[_domWhatSubScreenElement.id] &&\n        this._objSubScreenVisibility[_strWhatSubScreenElementID]\n      ) {\n        if (this._strCurrOutputModeClass != 'accessibleC') {\n          this.focusSubScreen(_domWhatSubScreenElement);\n        }\n        var _strScreenID = _domWhatSubScreenElement.id\n          .replace(this._strSubScreenIDPrefix, '')\n          .replace(this._strSubScreenIDSuffix, '');\n        this._showSubScreensPostRenderAssets(_strScreenID);\n        gomo.tabManager.processSubscreen(_strScreenID);\n        gomo.tabManager.focusModalContent(_domWhatSubScreenElement, _domWhatSubScreenElement);\n        this._subscreenOpen = true;\n      }\n\n      if (_objOptions.funCallBack) {\n        if (this._objSubScreenVisibility[_strWhatSubScreenElementID]) {\n          _objOptions.funCallBack();\n        }\n      }\n\n      if (!gomo.outputChecker.animationEnabled) {\n        _.each(['top', 'left', 'bottom', 'right'], function(index) {\n          if (\n            $(_domWhatSubScreenElement).hasClass(index + 'MiddleSubScreenC') ||\n            $(_domWhatSubScreenElement).hasClass(index + 'CenterSubScreenC')\n          ) {\n            if (index === 'top' && $('#screenHolderL').hasClass('hasTopStrap')) {\n              $(_domWhatSubScreenElement).css(\n                index,\n                $('#screenHolderL').find('.strapTop').height() + 'px'\n              );\n            } else {\n              $(_domWhatSubScreenElement).css(index, 0);\n            }\n          }\n        });\n      }\n    }\n  },\n\n  handleEvent_videoBlockInitialised: function() {\n    window.setTimeout('SUB_SCREEN_INTERACTIONS.refreshCurrentIScrollComponent()', 1);\n  },\n\n  /* This is needed due to the placement of subscreens outside of screens when CSS can't control\n  their position on screen. */\n  handleEvent_reportScreenCompletionStatus: function(_objCompletionReportData) {\n    var screenData = SCREEN_INTERACTIONS.getCurrentScreenData();\n    var _arrSubscreens = screenData.arrSubScreens;\n    var count = 0;\n\n    while (count < _arrSubscreens.length) {\n      var subscreenElement = this.getSubScreenDOMElement(_arrSubscreens[count].strObjID);\n\n      if (subscreenElement) {\n        subscreenElement.className = subscreenElement.className.replace(\n          this._strNotInteractedClass,\n          ''\n        );\n        subscreenElement.className = subscreenElement.className.replace(\n          this._strInteractedClass,\n          ''\n        );\n        subscreenElement.className = subscreenElement.className.replace(\n          this._strCompletedClass,\n          ''\n        );\n        subscreenElement.className = subscreenElement.className.replace(\n          this._strCompletableScreenClass,\n          ''\n        );\n\n        // Remove double whitespace and replace with single\n        subscreenElement.className = subscreenElement.className.replace(/ +(?= )/g, '');\n\n        if (_objCompletionReportData.intStatus == 0) {\n          // Not required as this state will never be try for a subscreen\n        } else if (_objCompletionReportData.intStatus == 1) {\n          subscreenElement.className = subscreenElement.className + ' ' + this._strInteractedClass;\n        } else if (_objCompletionReportData.intStatus == 2) {\n          subscreenElement.className =\n            subscreenElement.className +\n            ' ' +\n            this._strInteractedClass +\n            ' ' +\n            this._strCompletedClass;\n        }\n\n        if (screenData.booIsCompletableScreen) {\n          subscreenElement.className =\n            subscreenElement.className + ' ' + this._strCompletableScreenClass;\n        }\n      }\n      count++;\n    }\n  },\n\n  hideSubScreens: function(triggerCloseActions) {\n    try {\n      var _arrSubscreens = [];\n      // On continuous scroll we can interact with screens not in focus. We need to check the whole\n      // topic for screens\n      if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n        var topicData = TOPIC_MANAGER.getCurrentTopic();\n        var countScreens = 0;\n        while (countScreens < topicData.arrScreens.length) {\n          _arrSubscreens = _arrSubscreens.concat(topicData.arrScreens[countScreens].arrSubScreens);\n          countScreens++;\n        }\n      } else {\n        var screenData = SCREEN_INTERACTIONS.getCurrentScreenData();\n        _arrSubscreens = screenData.arrSubScreens;\n      }\n\n      var count = 0;\n\n      while (count < _arrSubscreens.length) {\n        var _domCurrSubScreenWrapper = this.getSubScreenDOMElement(_arrSubscreens[count].strObjID);\n        var _objSubScreenData = this._getSubScreenData(_arrSubscreens[count].strObjID);\n\n        if (_domCurrSubScreenWrapper) {\n          if (OUTPUT_MODE_CHECKER.strCurrentScreenSize == 'small') {\n            EM.trigger('toggleBlanking', {\n              strState: 'OFF',\n              objWhatDOM: SCREEN_INTERACTIONS.getShownScreenElement()\n            });\n          }\n\n          if (\n            (_domCurrSubScreenWrapper.className.indexOf('genericSubScreenWrapperC') > -1 &&\n              _domCurrSubScreenWrapper.className.indexOf(this._strShownSubScreenClass) > -1) ||\n              _domCurrSubScreenWrapper.className.indexOf('balloonSubScreenWrapperC') > -1 ||\n              _domCurrSubScreenWrapper.className.indexOf('modal') > -1 ||\n              _domCurrSubScreenWrapper.className.indexOf('filmstripSubScreenWrapperC ') > -1\n          ) {\n            if (_objSubScreenData.strObjID && triggerCloseActions) {\n              // The closeSubScreen function handles closing both regular and third party\n              // subscreens. It also triggers important close actions.\n              gomo.eventManager.legacy(\n                'closeSubScreen', {\n                  'strSubScreenID': _objSubScreenData.strObjID,\n                  'triggerCloseActions': true\n                }\n              );\n            } else {\n              // Call the correct hide function for different subscreen types without triggering the\n              // close actions.\n              if (_objSubScreenData.strType == 'reveal') {\n                this._hideSubScreen(_domCurrSubScreenWrapper, _objSubScreenData);\n              } else {\n                this._hideThirdPartySubScreen(_domCurrSubScreenWrapper, _objSubScreenData);\n              }\n            }\n            this._strIdCurrentShownSubScreen = null;\n          }\n        }\n        count++;\n      }\n      this._strCurrParentAssetID = false;\n      this._strCurrParentAssetActionSetID = false;\n      gomo.tabManager.focusLastScreenElement();\n    } catch (err) {\n      console.log('hideSubScreens failed : ' + err);\n    }\n  },\n\n  changeParentOfSubScreenDOMElement: function(_strWhatSubScreenID, _objNewParentDOMElement) {\n    this._changeParentOfSubScreenDOMElement(_strWhatSubScreenID, _objNewParentDOMElement);\n  },\n\n  getShownSubScreenElement: function() {\n    return this._domLastShownSubScreen;\n  },\n\n  getSubScreenDOMElement: function(_strWhatSubScreenID) {\n    return this._getSubScreenDOMElement(_strWhatSubScreenID);\n  },\n\n  getSubScreenContentDOMElement: function(_strWhatSubScreenID) {\n    return this._getSubScreenContentDOMElement(_strWhatSubScreenID);\n  },\n\n  focusSubScreen: function(_domWhatSubScreen) {\n    if (!OUTPUT_MODE_CHECKER.isDesktop() && typeof ISCROLL_INTERFACE != 'undefined') {\n      ISCROLL_INTERFACE.parseChildDOMElements(_domWhatSubScreen);\n    }\n\n    if (window.scrollY != 0) {\n      this._intScrollPos = window.scrollY;\n    }\n\n    scrollTo(0, 0);\n  },\n\n  refreshCurrentIScrollComponent: function() {\n    var _domWhatScreen = this.getShownSubScreenElement();\n    if (typeof ISCROLL_INTERFACE != 'undefined') {\n      ISCROLL_INTERFACE.refreshIScrolls(_domWhatScreen);\n    }\n  },\n\n  registerSubscreens: function(cloneFrom, cloneTo) {\n    if (typeof this.registeredSubscreens[cloneFrom] == 'undefined') {\n      this.registeredSubscreens[cloneFrom] = [];\n    }\n    if (this.registeredSubscreens[cloneFrom].indexOf(cloneTo) < 0) {\n      this.registeredSubscreens[cloneFrom].push(cloneTo);\n    }\n  },\n\n  getRegisterSubscreenClonesById: function(originalId) {\n    if (this.registeredSubscreens[originalId]) {\n      return this.registeredSubscreens[originalId];\n    } else return null;\n  },\n\n  getOriginalSubscreenId: function(cloneId) {\n    var originalId = false;\n    _.each(this.registeredSubscreens, function(value, key) {\n      if (\n        value.length > 0 &&\n        value[0] === cloneId\n      ) {\n        originalId = key;\n      }\n    });\n    return originalId;\n  },\n\n  getAllClonedSubscreenList: function() {\n    var listOfClonedSubcreens = [];\n\n    for (var subscreenId in this.registeredSubscreens) {\n      if (Object.prototype.hasOwnProperty.call(this.registeredSubscreens, subscreenId)) {\n        listOfClonedSubcreens.push(subscreenId);\n      }\n    }\n\n    return listOfClonedSubcreens;\n  },\n\n  resetRegisteredSubscreenList: function() {\n    this.registeredSubscreens = {};\n  },\n\n  _autoHideThirdPartySubScreen: function() {\n    var _objCurrentSubScreen = this._objCurrentThirdPartySubScreen;\n    if (typeof _objCurrentSubScreen.domSubscreenWrapper != 'undefined') {\n      this._hideThirdPartySubScreen(\n        _objCurrentSubScreen.domSubscreenWrapper,\n        _objCurrentSubScreen.objSubScreenData\n      );\n    }\n  },\n\n  _hideThirdPartySubScreen: function(_domSubScreenWrapper, _objSubScreenData) {\n    /* ### Some 3rd party software closes itself (such as modal) after\n      * an animation. We need to track the booVisibility of a specific subscreen\n      * so we can varify if it's open or already closed.\n    */\n    var _strScreenID;\n    if (_objSubScreenData.booVisible == true) {\n      this.sendExitStatement(_objSubScreenData);\n\n      this._strIdCurrentShownSubScreen = null;\n      // End the subscreen resize interval if the subscreen has used it\n      if (typeof _objSubScreenData.iscrollInterval !== 'undefined') {\n        clearInterval(_objSubScreenData.iscrollInterval);\n      }\n\n      _strScreenID = _domSubScreenWrapper.id\n        .replace(this._strSubScreenIDPrefix, '')\n        .replace(this._strSubScreenIDSuffix, '');\n      this._hideSubScreensPostRenderAssets(_strScreenID);\n\n      _objSubScreenData.booVisible = false;\n      this._objSubScreenVisibility[_domSubScreenWrapper.id] = false;\n      TOPIC_INTERACTIONS.showPageNavigation();\n      this._domLastShownSubScreen = null;\n\n      if (_objSubScreenData.strPreviousDisplayType == 'modal') {\n        jQuery('#' + _domSubScreenWrapper.id).modal('hide');\n        gomo.eventManager.legacy('enableParentIScrollInstaces');\n      }\n      if (_objSubScreenData.strPreviousDisplayType == 'balloon') {\n        /* Copy the subscreen dom Element back to the subscreen collection once\n        *the balloon is closed to keep the current state.\n        */\n        _strScreenID = SCREEN_INTERACTIONS.getScreenWrapperID(\n          _objSubScreenData.objParent.strObjID\n        );\n        jQuery('#' + _domSubScreenWrapper.id)\n          .clone()\n          .appendTo('#' + _strScreenID + ' .subScreenCollectionC');\n        jQuery(_objSubScreenData.domLink).popover('destroy');\n        this._objSubScreenDomCreated[_objSubScreenData.strObjID].booTypeModal = false;\n\n        // Unbind all subscreens assets to translations as we've broken any existing bindings\n        // with .popover('destroy')\n        var countAsset = 0;\n        while (countAsset < _objSubScreenData.arrAssets.length) {\n          // Don't attempt to bind assets which aren't rendered due to display conditions\n          if (_objSubScreenData.arrAssets[countAsset].booIsDisplayed) {\n            var _objWhatRawAssetData = _objSubScreenData.arrAssets[countAsset].objRawData;\n            var _domCurrentAsset = ASSET_RENDERER.getAssetDOMElement(_objWhatRawAssetData);\n\n            if (_domCurrentAsset) {\n              // Unregister the old asset and reset globally below\n              gomo.dataBinding.unregister(_objWhatRawAssetData.strID);\n            }\n          }\n          countAsset++;\n        }\n        // Add translations to all subscreens and assets in topic, if not set\n        gomo.translationManager.updateBoundFields();\n        gomo.translationManager.updateBoundLocalisations();\n\n        EM.trigger('toggleBlanking', {\n          strState: 'OFF',\n          objWhatDOM: SCREEN_INTERACTIONS.getShownScreenElement()\n        });\n      }\n    }\n  },\n\n  _hideSubScreen: function(_domWhatSubScreenElement, _objSubScreenData) {\n    this.sendExitStatement(_objSubScreenData);\n\n    EM.trigger('toggleBlanking', {\n      strState: 'OFF',\n      objWhatDOM: SCREEN_INTERACTIONS.getShownScreenElement()\n    });\n\n    var _strScreenID = _domWhatSubScreenElement.id\n      .replace(this._strSubScreenIDPrefix, '')\n      .replace(this._strSubScreenIDSuffix, '');\n    this._hideSubScreensPostRenderAssets(_strScreenID);\n    this._objSubScreenVisibility[_domWhatSubScreenElement.id] = false;\n    TOPIC_INTERACTIONS.showPageNavigation();\n\n    // End the subscreen resize interval if the subscreen has used it\n    if (typeof _objSubScreenData.iscrollInterval !== 'undefined') {\n      clearInterval(_objSubScreenData.iscrollInterval);\n    }\n\n    if (\n      !gomo.outputChecker.animationEnabled ||\n      !OUTPUT_MODE_CHECKER.canHandleAnimationType(this._strAnimationAsset) ||\n      !BOO_ANIMATE_SUBSCREENS\n    ) {\n      _domWhatSubScreenElement.className = _domWhatSubScreenElement.className.replace(\n        this._strShownSubScreenClass,\n        this._strHiddenSubScreenClass\n      );\n\n      /* REFACTOR NOTE: This can probably be removed and use existing classes for\n        * CSS rules ie '.accessible .genericLeftMiddleSubScreen' .\n        *  */\n      /* REFACTOR NOTE: put the default animator settings (pre _objAnimateData)into\n        * a global object in config. Then place an object at the top of this class\n        * with overrides. These overrides can then be altered per project with a\n        * config_override.js\n      **/\n      if (_domWhatSubScreenElement.className.indexOf('left') > 0) {\n        _domWhatSubScreenElement.className = _domWhatSubScreenElement.className.replace(\n          'accessibleLeftSubScreenC ',\n          ''\n        );\n      } else {\n        _domWhatSubScreenElement.className = _domWhatSubScreenElement.className.replace(\n          'accessibleRightSubScreenC ',\n          ''\n        );\n      }\n\n      EM.trigger('subscreenAnimationComplete', _domWhatSubScreenElement.id);\n    } else {\n      if (this._objAnimationHandles[_domWhatSubScreenElement.id]) {\n        delete this._objAnimationHandles[_domWhatSubScreenElement.id];\n\n        this._domLastShownSubScreen = _domWhatSubScreenElement;\n\n        this._objAnimateData.strType = 'seekTo(0)';\n        this._objCurrentAnimator.animate(this._objAnimateData);\n\n        this.objAnimatorJSData = null;\n        if (typeof ISCROLL_INTERFACE != 'undefined') {\n          ISCROLL_INTERFACE.recycleScroller(_domWhatSubScreenElement);\n        }\n      }\n    }\n\n    this._domLastShownSubScreen = null;\n\n    // Don't enable swipe gestures on continuous scrolling in iscroll mode - swipe gestures will\n    // try to change the screen\n    // Also don't enable on vertical scroll screens\n    if (\n      BOO_DYNAMIC_CONTINUOUS_SCROLLING == false ||\n      STR_DYNAMIC_TRANSITION_TYPE !== 'verticalSlide'\n    ) {\n      EM.trigger('enableSwipe');\n    }\n\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING && OUTPUT_MODE_CHECKER.applyScrolling() == false) {\n      // Prevent elements behind from scrolling when the top element is fixed if the user hovers\n      // over the other area. We need to prevent with CSS\n      $('.graphicalC #contentWrapperL.continousScrolling').css('overflow-y', 'auto');\n    }\n  },\n\n  _booSubscreenExists: function(_strSubScreenID) {\n    var _objWhatSubScreenData = OBJ_REF.get(_strSubScreenID);\n    if (!_objWhatSubScreenData) {\n      // TO Localise\n      console.log('ERROR: Failed to find a DOM element for the sub screen ID ' +\n          _strSubScreenID +\n          ', SUB_SCREEN_INTERACTIONS._booSubscreenExists(), sub_screen_interactions.js');\n      return false;\n    }\n    return true;\n  },\n\n  _booSubscreenTypeExists: function(_strSubScreenType) {\n    switch (_strSubScreenType) {\n      case 'reveal':\n        return true;\n      case 'popup':\n      case 'modal':\n        return true;\n      case 'popover':\n      case 'balloon':\n        return true;\n      default:\n        console.log('ERROR: Failed to find a sub screen type of ' +\n            _strSubScreenType +\n            ', SUB_SCREEN_INTERACTIONS._booSubscreenTypeExists(), sub_screen_interactions.js');\n        return false;\n    }\n  },\n\n  _resetSubscreenAssets: function(_strSubScreenID) {\n    var _objWhatSubScreenData = OBJ_REF.get(_strSubScreenID);\n\n    var count = 0;\n    while (count < _objWhatSubScreenData.arrAssets.length) {\n      var _objCurrAsset = _objWhatSubScreenData.arrAssets[count];\n      ASSET_INTERACTIONS.resetAsset(_objCurrAsset);\n      count++;\n    }\n  },\n\n  _showThirdPartySubScreen: function(_domSubScreenWrapper, _objSubScreenData) {\n    this._objSubScreenVisibility[_domSubScreenWrapper.id] = true;\n    TOPIC_INTERACTIONS.hidePageNavigation();\n    this._domLastShownSubScreen = _domSubScreenWrapper;\n    // Display the subscreen type based off of live device compatibility\n    var _strDynamicSubScreenType = SUB_SCREEN_RENDERER.subScreenTypeSizeOverride(\n      _objSubScreenData.strType\n    );\n\n    if (_strDynamicSubScreenType == 'modal') {\n      this._showModal(_domSubScreenWrapper, _objSubScreenData);\n    }\n    if (_strDynamicSubScreenType == 'balloon') {\n      this._showBalloon(_domSubScreenWrapper, _objSubScreenData);\n\n      EM.trigger('toggleBlanking', {\n        strState: 'ON',\n        objWhatDOM: SCREEN_INTERACTIONS.getShownScreenElement()\n      });\n    }\n\n    _objSubScreenData.strPreviousDisplayType = _strDynamicSubScreenType;\n\n    (this._objCurrentThirdPartySubScreen.domSubscreenWrapper = _domSubScreenWrapper),\n    (this._objCurrentThirdPartySubScreen.objSubScreenData = _objSubScreenData);\n\n    this.focusSubScreen(_domSubScreenWrapper);\n    this.timeAvailable = new Date();\n  },\n\n  _showModal: function(_domSubScreenWrapper, _objSubScreenData) {\n    _objSubScreenData.booVisible = true;\n    if (_domSubScreenWrapper.id) {\n      _objSubScreenData.strWhatSubScreenElementID = _domSubScreenWrapper.id;\n    }\n    this._objAnimationHandles[_domSubScreenWrapper.id] = true;\n\n    if (_domSubScreenWrapper.style.backgroundImage) {\n      var _strBackgroundImg = _domSubScreenWrapper.style.backgroundImage;\n      var _strBackgroundImgRepeat = _domSubScreenWrapper.style.backgroundRepeat;\n      _domSubScreenWrapper.style.backgroundImage = '';\n      _domSubScreenWrapper.style._strBackgroundImgRepeat = '';\n\n      if (jQuery(_domSubScreenWrapper).find('.modal-content')) {\n        jQuery(_domSubScreenWrapper).find('.modal-content')[0].style.background =\n          _strBackgroundImg + ' ' + _strBackgroundImgRepeat;\n        if (OUTPUT_MODE_CHECKER.booIsIE8()) {\n          jQuery(_domSubScreenWrapper).find('.modal-content')[0].style.filter = '';\n        }\n      }\n    }\n\n    if (\n      typeof this._objSubScreenDomCreated[_objSubScreenData.strObjID] == 'undefined' ||\n      typeof this._objSubScreenDomCreated[_objSubScreenData.strObjID].booTypeModal == 'undefined' ||\n      this._objSubScreenDomCreated[_objSubScreenData.strObjID].booTypeModal == false ||\n      _objSubScreenData.rerenderedSubscreen\n    ) {\n      // vh isn't especially reliable so set height here.\n      jQuery('#' + _domSubScreenWrapper.id)\n        .find('.modal-dialog')\n        .css('height', jQuery(window).innerHeight());\n      jQuery('#' + _domSubScreenWrapper.id).on('shown.bs.modal', function() {\n        EM.trigger('subscreenAnimationComplete', _objSubScreenData);\n        EM.trigger('toggleBlanking', {strState: 'ON', objWhatDOM: shownScreenElement});\n      });\n      var shownScreenElement = SCREEN_INTERACTIONS.getShownScreenElement();\n      jQuery('#' + _domSubScreenWrapper.id).on('hidden.bs.modal', function() {\n        SUB_SCREEN_INTERACTIONS._returnFocusToAsset(\n          SUB_SCREEN_INTERACTIONS._strCurrParentAssetID,\n          SUB_SCREEN_INTERACTIONS._strCurrParentAssetActionSetID\n        );\n        SUB_SCREEN_INTERACTIONS._hideThirdPartySubScreen(_domSubScreenWrapper, _objSubScreenData);\n        // If the subscreen was moved then it will have had a subscreenParent created\n        if (_objSubScreenData.subscreenParent) {\n          $(_domSubScreenWrapper).appendTo(_objSubScreenData.subscreenParent);\n          delete _objSubScreenData.subscreenParent;\n        }\n        delete SUB_SCREEN_INTERACTIONS._objAnimationHandles[_domSubScreenWrapper.id];\n        EM.trigger('subscreenAnimationComplete', _objSubScreenData);\n        EM.trigger('toggleBlanking', {strState: 'OFF', objWhatDOM: shownScreenElement});\n      });\n      this._objSubScreenDomCreated[_objSubScreenData.strObjID] = {};\n      this._objSubScreenDomCreated[_objSubScreenData.strObjID].booTypeModal = true;\n\n      // We can reset this now as we've clear any possible rerender bugs\n      _objSubScreenData.rerenderedSubscreen = false;\n    }\n\n    // After attaching the on call functions above, show the modal.\n    jQuery('#' + _domSubScreenWrapper.id).modal({show: true, backdrop: false});\n    EM.trigger('toggleBlanking', {\n      strState: 'ON',\n      objWhatDOM: SCREEN_INTERACTIONS.getShownScreenElement()\n    });\n  },\n\n  setIscrollPositionForSubscreen: function(opts) {\n    // Set position for dynamic scrolling screens in iscroll mode\n    if (this.isAbsolutelyPositionedSubscreen()) {\n      var domHeight = null;\n      var pageHeight = $('#contentWrapperInnerL').outerHeight();\n      if (opts.modal) {\n        domHeight = $(opts.modal)\n          .find('.modal-dialog')\n          .outerHeight();\n      } else if (opts.domSubscreenWrapper) {\n        // We need to set the bottom position to auto. If it's left with an absolute value then the\n        // height may be invalid\n        $(opts.domSubscreenWrapper).css('bottom', 'auto');\n        domHeight = $(opts.domSubscreenWrapper).outerHeight();\n      } else {\n        // we can't measure the height and have to quit the process\n        console.log('SUBSCREEN_INTERACTIONS.setIscrollPositionForSubscreen() Subscreen height '+\n        'couldn\\'t be measured. Aborting position setting.');\n        return;\n      }\n\n      // Get the new height based off of the content (which may grow or shrink, dynamically)\n      if (opts.modal) {\n        opts.subscreenData.elementHeight = jQuery(opts.domSubscreenWrapper)\n          .find('.modal-content')\n          .outerHeight();\n      } else {\n        opts.subscreenData.elementHeight = jQuery(opts.domSubscreenWrapper)\n          .find('.subScreenContentC')\n          .outerHeight();\n      }\n\n      var _domSubScreenWrapper = opts.domSubscreenWrapper;\n      var topPosition = null;\n\n      var currentYPosition = SCROLLING_MANAGER.getScrollPosition();\n      // Only override for non standard transform handlers\n      if (Modernizr.prefixed('transform') == 'transform') {\n        // We don't want to reposition the top of the subscreen everytime we run a check to see if\n        // the subscreen has changed size\n        if (opts.initialSetup) {\n          jQuery(_domSubScreenWrapper).css('top', currentYPosition);\n        }\n        // Get top position if we're not on initial setup - We need top position with 'px' at the\n        // end\n        topPosition = parseInt(jQuery(_domSubScreenWrapper).css('top'));\n        opts.subscreenData.topPosition = topPosition;\n\n        // Without auto on bottom, the later showSubscreen() animations/css will change the height\n        // of the subscreen significantly\n        var bottomPosition = pageHeight - (topPosition + domHeight);\n        opts.subscreenData.bottomPosition = bottomPosition;\n        jQuery(_domSubScreenWrapper).css('bottom', bottomPosition);\n      } else {\n        var screenDom = SCREEN_INTERACTIONS.getScreenWrapper(opts.subscreenData.objParent.strObjID);\n        var screenPositionTop = screenDom.getBoundingClientRect()['top'];\n        // Add padding to modal\n        screenPositionTop = screenPositionTop + -50;\n        // Reverse the negative or positive number to scroll in the right direction\n        screenPositionTop = screenPositionTop * -1;\n        jQuery(_domSubScreenWrapper).css('top', screenPositionTop);\n        // Get top position if we're not on initial setup - We need top position with 'px' at the\n        // end\n        topPosition = parseInt(jQuery(_domSubScreenWrapper).css('top'));\n      }\n\n      // Stop allowing modals build it's own scrolling\n      jQuery(_domSubScreenWrapper).css('overflow', 'hidden');\n\n      // Check that variables exist before setting scrolling limits\n      if (topPosition >= 0 && domHeight) {\n        SCROLLING_MANAGER.setMinYPosition(topPosition);\n        SCROLLING_MANAGER.setMaxYPosition(topPosition + domHeight);\n      }\n      ISCROLL_INTERFACE.disableMomentum();\n      // If the user is able to change screens from scrolling, don't reset the screen loaded data\n      SCROLLING_MANAGER.disableScreenSwitchFromScrolling();\n\n      // Make sure that the iscroll is the correct height as screen my have changed height\n      ISCROLL_INTERFACE.refreshIScrolls();\n      // If the content area is too small, then extend it to fit the subscreen\n      var contentAreaHeight = $('#contentWrapperInnerL').height();\n      var subscreenEndPosition = topPosition + domHeight;\n      if (subscreenEndPosition > contentAreaHeight) {\n        $('#contentWrapperInnerL').height(subscreenEndPosition);\n        ISCROLL_INTERFACE.refreshIScrolls();\n      }\n    }\n  },\n\n  _showBalloon: function(_domSubScreenWrapper, _objSubScreenData) {\n    _objSubScreenData.booVisible = true;\n\n    if (_domSubScreenWrapper.id) {\n      _objSubScreenData.strWhatSubScreenElementID = _domSubScreenWrapper.id;\n    }\n    this._objAnimationHandles[_domSubScreenWrapper.id] = true;\n    var position = this._getSubScreenPlacement(_objSubScreenData);\n\n    var _objOptions = {\n      html: true,\n      placement: position,\n      title: '',\n      content: _domSubScreenWrapper,\n      trigger: 'manual',\n      container: '#screenHolderL'\n    };\n\n    // If we have a target item then get it's position and set max dimensions for the popover\n    if (jQuery(_objSubScreenData.domLink).length && jQuery(_domSubScreenWrapper).length) {\n      // Popover width\n      var availableWidth = '';\n      var sourceLeftPosition = jQuery(_objSubScreenData.domLink).offset().left;\n      var sourceRightPosition = jQuery(_objSubScreenData.domLink).offset().right;\n      var sourceWidth = jQuery(_objSubScreenData.domLink).outerWidth();\n      var sourceHeight = jQuery(_objSubScreenData.domLink).outerHeight();\n      if (position === 'left') {\n        availableWidth = sourceLeftPosition;\n      } else if (position === 'right') {\n        availableWidth = sourceRightPosition;\n      } else {\n        // Set a initial top and bottom position to the smallest width\n        availableWidth = sourceLeftPosition;\n        if (sourceRightPosition < sourceLeftPosition) {\n          availableWidth = sourceRightPosition;\n        }\n        // The arrow will sit in the center of the source element\n        availableWidth = (availableWidth * 2) + (sourceWidth / 2);\n      }\n      var arrowSize = 15;\n      var maxWidth = availableWidth - arrowSize;\n      jQuery(_domSubScreenWrapper).css('max-width', maxWidth+'px');\n\n      // Popover height\n      var availableHeight = '';\n      var viewPortHeight = jQuery(window).height();\n      var sourceTopPosition = jQuery(_objSubScreenData.domLink).offset().top;\n      var sourceBottomPosition = viewPortHeight - (sourceHeight + sourceTopPosition);\n      if (position === 'top') {\n        availableHeight = sourceTopPosition;\n      } else if (position === 'bottom') {\n        availableHeight = sourceBottomPosition;\n      } else {\n        // if we have left or right then set max to the viewport\n        availableHeight = viewPortHeight;\n      }\n      var maxHeight = availableHeight - arrowSize;\n      jQuery(_domSubScreenWrapper).css('max-height', maxHeight+'px');\n    }\n\n    // REFACTOR : Make subscreens more modular\n    // position if no reference point was create for subscreen.\n    // SUBSCREEN_INTERACTION.showsubscreen()');\n    if (_objSubScreenData.domLink.id == 'topStrapL') {\n      _objOptions.placement = 'bottom';\n    }\n\n    if (\n      typeof this._objSubScreenDomCreated[_objSubScreenData.strObjID] == 'undefined' ||\n      typeof this._objSubScreenDomCreated[_objSubScreenData.strObjID].booTypeBalloon ==\n        'undefined' ||\n      this._objSubScreenDomCreated[_objSubScreenData.strObjID].booTypeBalloon == false ||\n      _objSubScreenData.rerenderedSubscreen\n    ) {\n      /* Clear the target Title so that the Popup can set it's own */\n      var _strTempTitle = '';\n      if (_objSubScreenData.domLink.title) {\n        _strTempTitle = _objSubScreenData.domLink.title;\n        _objSubScreenData.domLink.title = '';\n      }\n      jQuery(_objSubScreenData.domLink).popover(_objOptions);\n      jQuery(_objSubScreenData.domLink).on('shown.bs.popover', function() {\n        EM.trigger('subscreenAnimationComplete', _objSubScreenData);\n      });\n      jQuery(_objSubScreenData.domLink).on('hidden.bs.popover', function() {\n        delete SUB_SCREEN_INTERACTIONS._objAnimationHandles[_domSubScreenWrapper.id];\n        EM.trigger('subscreenAnimationComplete', _objSubScreenData);\n      });\n\n      if (_strTempTitle != '') {\n        _objSubScreenData.domLink.title = _strTempTitle;\n      }\n\n      this._objSubScreenDomCreated[_objSubScreenData.strObjID] = {};\n      this._objSubScreenDomCreated[_objSubScreenData.strObjID].booTypeModal = true;\n\n      // We can reset this now as we've clear any possible rerender bugs\n      _objSubScreenData.rerenderedSubscreen = false;\n    }\n    jQuery(_objSubScreenData.domLink).popover('show');\n  },\n\n  _showSubScreen: function(_domWhatSubScreenElement, _objParentAssetDataHolder, _objSubScreenData) {\n    this.timeAvailable = new Date();\n    EM.trigger('toggleBlanking', {\n      strState: 'ON',\n      objWhatDOM: SCREEN_INTERACTIONS.getShownScreenElement()\n    });\n\n    _domWhatSubScreenElement.className = _domWhatSubScreenElement.className.replace(\n      this._strHiddenSubScreenClass,\n      this._strShownSubScreenClass\n    );\n    this.focusSubScreen(_domWhatSubScreenElement);\n    this._objSubScreenVisibility[_domWhatSubScreenElement.id] = true;\n    this._setSubScreenClass(_domWhatSubScreenElement, _objSubScreenData);\n    TOPIC_INTERACTIONS.hidePageNavigation();\n    if (_domWhatSubScreenElement.id) {\n      _objSubScreenData.strWhatSubScreenElementID = _domWhatSubScreenElement.id;\n    }\n\n    // Only apply max height to desktop version. The smartphone needs to scroll the whole page\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING && OUTPUT_MODE_CHECKER.applyScrolling() == false) {\n      var pageHeight = $('.continousScrolling').height();\n      if (pageHeight) {\n        $(_domWhatSubScreenElement).css('height', pageHeight + 'px');\n      }\n\n      // Prevent elements behind from scrolling when the top element is fixed if the user hovers\n      // over the other area. We need to prevent with CSS\n      $('.graphicalC #contentWrapperL.continousScrolling').css('overflow-y', 'hidden');\n\n      // Positioning of subscreens\n      var subscreenAnimationDirection = this._getSubScreenPlacement(_objSubScreenData);\n      if (subscreenAnimationDirection == 'left' || subscreenAnimationDirection == 'right') {\n        $(_domWhatSubScreenElement).css('top', SCROLLING_MANAGER.getScrollPosition() + 'px');\n        $(_domWhatSubScreenElement).css('position', 'absolute');\n      }\n    }\n\n    SUB_SCREEN_INTERACTIONS.setIscrollPositionForSubscreen({\n      domSubscreenWrapper: _domWhatSubScreenElement,\n      subscreenData: _objSubScreenData,\n      initialSetup: true\n    });\n\n    // Set an internval to check if the subscreen content has changed size, then change the\n    // subscreen to match\n    _objSubScreenData.iscrollInterval = setInterval(function() {\n      if (\n        _objSubScreenData.elementHeight !==\n        jQuery(_domWhatSubScreenElement)\n          .find('.subScreenContentC')\n          .outerHeight()\n      ) {\n        SUB_SCREEN_INTERACTIONS.setIscrollPositionForSubscreen({\n          domSubscreenWrapper: _domWhatSubScreenElement,\n          subscreenData: _objSubScreenData\n        });\n      }\n    }, 250);\n\n    if (\n      gomo.outputChecker.animationEnabled &&\n      OUTPUT_MODE_CHECKER.canHandleAnimationType(this._strAnimationAsset) &&\n      BOO_ANIMATE_SUBSCREENS\n    ) {\n      if (!this._objAnimationHandles[_domWhatSubScreenElement.id]) {\n        /* REFACTOR NOTE: this is used to keep track of if the element is currently open.\n          * This is using past variables but should have it's own created for the new animator\n          * interface */\n        this._objAnimationHandles[_domWhatSubScreenElement.id] = true;\n\n        EM.trigger('disableSwiping');\n        var _objAnimationData = this._getSubScreenAnimation(\n          _domWhatSubScreenElement,\n          _objSubScreenData\n        );\n\n        _objSubScreenData._arrAnimations = _objAnimationData._arrAnimations;\n\n        var _intAnimateDuration = INT_TRANSITION_TIMER;\n\n        this._objCurrentAnimator = ANIMATOR_INTERFACE;\n        var _strAnimateType = 'seekTo(1)';\n        var _funOnComplete = function() {\n          EM.trigger('subscreenAnimationComplete', _objSubScreenData);\n        };\n        var _strTransition = 'easeInOut';\n\n        this._domLastShownSubScreen = _domWhatSubScreenElement;\n\n        this._objAnimateData = this._objCurrentAnimator.objAnimate(\n          _strAnimateType,\n          _domWhatSubScreenElement,\n          _objAnimationData._arrAnimations,\n          _intAnimateDuration,\n          _strTransition,\n          _funOnComplete,\n          this._strAnimationAsset\n        );\n        // Continuous scroll subscreens positions shouldn't be overriden by the animation process\n        if (this.isAbsolutelyPositionedSubscreen()) {\n          this._objAnimateData.preservePositions = true;\n        }\n        this._objCurrentAnimator.resetElementForAnimation(this._objAnimateData);\n        this._objCurrentAnimator.animate(this._objAnimateData);\n      }\n    } else {\n      var _strScreenID = _domWhatSubScreenElement.id\n        .replace(this._strSubScreenIDPrefix, '')\n        .replace(this._strSubScreenIDSuffix, '');\n      this._showSubScreensPostRenderAssets(_strScreenID);\n      EM.trigger('subscreenAnimationComplete', _objSubScreenData);\n    }\n  },\n\n  _showSubScreensPreRenderAssets: function(_strWhatSubScreenID) {\n    if (this._booInTopic) {\n      var _objWhatSubScreenData = this._getSubScreenData(_strWhatSubScreenID);\n      var count = 0;\n      while (count < _objWhatSubScreenData.arrAssets.length) {\n        var _objCurrAsset = _objWhatSubScreenData.arrAssets[count];\n        ASSET_INTERACTIONS.performPreShowActions(_objCurrAsset);\n        count++;\n      }\n      if (gomo.outputChecker.animationEnabled) {\n        ASSET_INTERACTIONS.animateAssets(_strWhatSubScreenID);\n      }\n    }\n  },\n\n  _showSubScreensPostRenderAssets: function(_strWhatSubScreenID) {\n    if (this._booInTopic) {\n      var _objWhatSubScreenData = this._getSubScreenData(_strWhatSubScreenID);\n      var count = 0;\n      while (count < _objWhatSubScreenData.arrAssets.length) {\n        var _objCurrAsset = _objWhatSubScreenData.arrAssets[count];\n        ASSET_INTERACTIONS.showPostRenderAsset(_objCurrAsset);\n        count++;\n      }\n    }\n  },\n\n  setHideSubScreensAssetsOptions: function(opts) {\n    this.hidePostRenderAssetsOptions = opts;\n  },\n\n  _hideSubScreensPostRenderAssets: function(_strWhatSubScreenID) {\n    var _objWhatSubScreenData = this._getSubScreenData(_strWhatSubScreenID);\n    var count = 0;\n    while (count < _objWhatSubScreenData.arrAssets.length) {\n      var _objCurrAsset = _objWhatSubScreenData.arrAssets[count];\n      ASSET_INTERACTIONS.hidePostRenderAsset(_objCurrAsset, this.hidePostRenderAssetsOptions);\n      count++;\n    }\n  },\n\n  /* Some subscreens get destroyed and rebuilt so pre-render actions don't work under the\n   subscreen is shown*/\n  _supportsPreRenderSupport: function(_strType) {\n    if (_strType !== 'popover' && _strType !== 'balloon') {\n      return true;\n    }\n    return false;\n  },\n\n  _getSubScreenData: function(_strWhatSubScreenID) {\n    var searchForSubscreen = function(_objScreenData) {\n      var count = 0;\n      while (count < _objScreenData.arrSubScreens.length) {\n        var _objCurrSubScreen = _objScreenData.arrSubScreens[count];\n        if (_strWhatSubScreenID == _objCurrSubScreen.strObjID) {\n          return _objCurrSubScreen;\n        }\n        count++;\n      }\n      return false;\n    };\n\n    // Check the whole topic for subscreen if continuous scrolling is enabled\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n      var topicData = TOPIC_MANAGER.getCurrentTopic();\n      if (topicData && topicData.arrScreens) {\n        var count = 0;\n        while (count < topicData.arrScreens.length) {\n          var subscreenData = searchForSubscreen(topicData.arrScreens[count]);\n          if (subscreenData) {\n            return subscreenData;\n          }\n          count++;\n        }\n      }\n    } else {\n      return searchForSubscreen(SCREEN_INTERACTIONS.getCurrentScreenData());\n    }\n  },\n\n  _changeParentOfSubScreenDOMElement: function(_strWhatSubScreenID, _objNewParentDOMElement) {\n    var _domSubScreenWrapper = this._getSubScreenDOMElement(_strWhatSubScreenID);\n    var _domClone = _domSubScreenWrapper.cloneNode(true);\n    _domSubScreenWrapper.parentNode.removeChild(_domSubScreenWrapper);\n    _objNewParentDOMElement.appendChild(_domClone);\n  },\n\n  _getSubScreenDOMElement: function(_strWhatSubScreenID) {\n    var _strSubScreenDOMID =\n      this._strSubScreenIDPrefix + _strWhatSubScreenID + this._strSubScreenIDSuffix;\n    var _domSubScreenWrapper = this._objWhatDOM.getElementById(_strSubScreenDOMID);\n    if (_domSubScreenWrapper) {\n      return _domSubScreenWrapper;\n    } else {\n      console.log('ERROR: Failed to find a DOM element for the sub screen ID \\'' +\n          _strWhatSubScreenID +\n          '\\', SUB_SCREEN_INTERACTIONS._getSubScreenDOMElement(), sub_screen_interactions.js');\n      return false;\n    }\n  },\n\n  _getSubScreenContentDOMElement: function(_strWhatSubScreenID) {\n    var _strSubScreenDOMID =\n      this._strSubScreenContentIDPrefix + _strWhatSubScreenID + this._strSubScreenIDSuffix;\n    var _domSubScreenContent = this._objWhatDOM.getElementById(_strSubScreenDOMID);\n\n    if (_domSubScreenContent == null) {\n      this.debug(_strWhatSubScreenID +\n          ' is an unknown subscreen template so we cannot retrive the content for rerendering. '+\n          'SUBSCREEN_INTERACTIONS._getSubScreenContentDOMElement()');\n    }\n\n    if (_domSubScreenContent) {\n      if (\n        CORE.getElementsByClassName(_domSubScreenContent, 'scrollWrapperC')[0] != null &&\n        (_domSubScreenContent.className != 'modal-body' &&\n          _domSubScreenContent.className != 'balloon-body')\n      ) {\n        _domSubScreenContent = CORE.getElementsByClassName(\n          _domSubScreenContent,\n          'scrollWrapperC'\n        )[0];\n      }\n      return _domSubScreenContent;\n    } else {\n      console.log(\n        'ERROR: Failed to find a DOM element for the sub screen ID ' +\n          _strWhatSubScreenID +\n          ', SUB_SCREEN_INTERACTIONS._getSubScreenContentDOMElement(), sub_screen_interactions.js'\n      );\n      return false;\n    }\n  },\n\n  _getSubScreenAnimation: function(_domWhatSubScreenElement, _objSubScreenData) {\n    var _objRawAnimationData = this._getRawSubScreenAnimation(\n      _domWhatSubScreenElement,\n      _objSubScreenData\n    );\n\n    var _arrAnimations = [];\n    _arrAnimations[0] = {\n      style: _objRawAnimationData['arrInitialState'].style,\n      value: _objRawAnimationData['arrInitialState'].value\n    };\n    _arrAnimations[1] = {\n      style: _objRawAnimationData['arrTargetState'].style,\n      value: _objRawAnimationData['arrTargetState'].value\n    };\n\n    var _objAnimatorJSData = {\n      _arrAnimations: _arrAnimations\n    };\n\n    return _objAnimatorJSData;\n  },\n\n  _setSubScreenClass: function(_domWhatSubScreenElement, _objSubScreenData) {\n    var _strPosition = this._getSubScreenPlacement(_objSubScreenData);\n    var _subScreenClass;\n\n    if (_strPosition == 'left') {\n      _subScreenClass = this._strLeftMiddleSubScreenClass;\n    } else if (_strPosition == 'right') {\n      _subScreenClass = this._strRightMiddleSubScreenClass;\n    } else if (_strPosition == 'bottom') {\n      _subScreenClass = this._strBottomCenterSubScreenClass;\n    } else if (_strPosition == 'top') {\n      _subScreenClass = this._strTopCenterSubScreenClass;\n    }\n\n    _domWhatSubScreenElement.className = _subScreenClass + ' ' + _domWhatSubScreenElement.className;\n  },\n\n  _removeSubScreenClass: function(_domWhatSubScreenElement) {\n    if (_domWhatSubScreenElement.className.indexOf(this._strLeftMiddleSubScreenClass) != -1) {\n      _domWhatSubScreenElement.className = _domWhatSubScreenElement.className.replace(\n        this._strLeftMiddleSubScreenClass + ' ',\n        ''\n      );\n    } else if (\n      _domWhatSubScreenElement.className.indexOf(this._strRightMiddleSubScreenClass) != -1\n    ) {\n      _domWhatSubScreenElement.className = _domWhatSubScreenElement.className.replace(\n        this._strRightMiddleSubScreenClass + ' ',\n        ''\n      );\n    } else if (\n      _domWhatSubScreenElement.className.indexOf(this._strBottomCenterSubScreenClass) != -1\n    ) {\n      _domWhatSubScreenElement.className = _domWhatSubScreenElement.className.replace(\n        this._strBottomCenterSubScreenClass + ' ',\n        ''\n      );\n    } else if (_domWhatSubScreenElement.className.indexOf(this._strTopCenterSubScreenClass) != -1) {\n      _domWhatSubScreenElement.className = _domWhatSubScreenElement.className.replace(\n        this._strTopCenterSubScreenClass + ' ',\n        ''\n      );\n    }\n  },\n\n  _getRawSubScreenAnimation: function(_domWhatSubScreenElement, _objSubScreenData) {\n    var _strSubScreenPlacement = this._getSubScreenPlacement(_objSubScreenData);\n    var topStrapHeight = $('#topStrapL').is(':visible') ? $('#topStrapL').outerHeight() : 0;\n    var bottomStrapHeight =\n      !FLOATING_FOOTER && $('#navWrapperL').is(':visible') ? $('#navWrapperL').outerHeight() : 0;\n    var _objAnimationBaseData;\n\n    if (\n      OUTPUT_MODE_CHECKER.strCurrentScreenSize == 'small' &&\n      this.isAbsolutelyPositionedSubscreen()\n    ) {\n      bottomStrapHeight = topStrapHeight;\n    }\n\n    switch (_strSubScreenPlacement) {\n      case 'bottom':\n        _objAnimationBaseData = this._getDefaultAnimationData(\n          _strSubScreenPlacement,\n          _domWhatSubScreenElement.offsetHeight,\n          _objSubScreenData\n        );\n        if (!this.isAbsolutelyPositionedSubscreen()) {\n          _objAnimationBaseData.arrTargetState.value =\n            _objAnimationBaseData.arrTargetState.value + bottomStrapHeight;\n        }\n        break;\n      case 'top':\n        _objAnimationBaseData = this._getDefaultAnimationData(\n          _strSubScreenPlacement,\n          _domWhatSubScreenElement.offsetHeight,\n          _objSubScreenData\n        );\n        if (!this.isAbsolutelyPositionedSubscreen()) {\n          _objAnimationBaseData.arrTargetState.value =\n            _objAnimationBaseData.arrTargetState.value + topStrapHeight;\n        }\n        break;\n      case 'left':\n      case 'right':\n        _objAnimationBaseData = this._getDefaultAnimationData(\n          _strSubScreenPlacement,\n          _domWhatSubScreenElement.offsetWidth,\n          _objSubScreenData\n        );\n        break;\n      default:\n        _objAnimationBaseData = this._getCustomSubscreenAnimationData(\n          ASSET_INTERACTIONS.objExtendedAnimationData[_strSubScreenPlacement]\n        );\n        break;\n    }\n    return _objAnimationBaseData;\n  },\n\n  _convertToAnimatorJSFormat: function(_objAnimationInfo, _strInfoType) {\n    switch (_strInfoType) {\n      case 'css':\n        return _objAnimationInfo.join('; ');\n      case 'class':\n        return _objAnimationInfo.join(' ');\n      case 'method':\n        if (ASSET_INTERACTION[_objAnimationInfo]) {\n          return ASSET_INTERACTION[_objAnimationInfo]();\n        } else {\n          LOCALISER.l_alert('SUB_SCREEN_INTERACTIONS_MISSING_CUSTOM_ANIMATION_METHOD', [\n            _objAnimationInfo\n          ]);\n        }\n        break;\n      default:\n        LOCALISER.l_alert('SUB_SCREEN_INTERACTIONS_UNKNOWN_ANIMATION_TYPE', [_strInfoType]);\n        break;\n    }\n  },\n\n  _getCustomSubscreenAnimationData: function(_objWhatAssetAnimationData, _strAlignment) {\n    var count = 0;\n    while (count < _objWhatAssetAnimationData.length) {\n      var _objCurrAnimationData = _objWhatAssetAnimationData[count];\n      if (\n        _objCurrAnimationData['strAlingment'] == _strAlignment ||\n        _objCurrAnimationData['strAlingment'] == 'custom_all'\n      ) {\n        return _objCurrAnimationData;\n      }\n      count++;\n    }\n  },\n\n  _getDefaultAnimationData: function(_strSubScreenPlacement, _intSubscreenHeight, subscreenData) {\n    var _objAnimationData = {};\n    // Render smartphone subscreen from the bottom of the screen\n    if (OUTPUT_MODE_CHECKER.strCurrentScreenSize == 'small' || OUTPUT_MODE_CHECKER.isTablet()) {\n      var subscreenStartPosition = 0;\n      var subScreenPlacement = 'bottom';\n      // Continuous scroll subscreens will have a different start location as they can be\n      // loaded from anywhere on a long topic layout. Not just from a content wrapper position\n      if (this.isAbsolutelyPositionedSubscreen()) {\n        /* if(typeof subscreenData !== 'undefined' &&\n          typeof subscreenData.bottomPosition !== 'undefined' ){\n            subscreenStartPosition = subscreenData.bottomPosition;\n        }*/\n        // We always place the absolutely positioned subscreens by top\n        if (\n          typeof subscreenData !== 'undefined' &&\n          typeof subscreenData.topPosition !== 'undefined'\n        ) {\n          subscreenStartPosition = 0;\n          subScreenPlacement = 'top';\n        }\n      }\n\n      _objAnimationData = {\n        strType: 'css',\n        arrInitialState: {\n          style: subScreenPlacement,\n          value: _intSubscreenHeight * -1\n        },\n        arrTargetState: {\n          style: subScreenPlacement,\n          value: subscreenStartPosition\n        }\n      };\n    } else {\n      _objAnimationData = {\n        strType: 'css',\n        arrInitialState: {\n          style: _strSubScreenPlacement,\n          value: _intSubscreenHeight * -1\n        },\n        arrTargetState: {\n          style: _strSubScreenPlacement,\n          value: this._objDefaultAnimationData[_strSubScreenPlacement].arrTargetState.value\n        }\n      };\n    }\n\n    return _objAnimationData;\n  },\n\n  _getSubScreenPlacement: function(_objSubScreenData) {\n    var _strPosition = '';\n    // Popovers on smartphone have to display from the bottom or they will likely be off screen\n    if (\n      _objSubScreenData.objItemPositioning &&\n      _objSubScreenData.objItemPositioning.strAlignment\n    ) {\n      _strPosition = _objSubScreenData.objItemPositioning.strAlignment;\n    } else if (\n      _objSubScreenData.objRawData &&\n      _objSubScreenData.objRawData.objItemPositioning &&\n      _objSubScreenData.objRawData.objItemPositioning.strAlignment\n    ) {\n      _strPosition = _objSubScreenData.objRawData.objItemPositioning.strAlignment;\n    } else {\n      _strPosition = 'bottom';\n    }\n\n    // If on a phone or tablet force all subscreens animate form the bottom to stop stuff breaking\n    if (OUTPUT_MODE_CHECKER.isSmartPhone() || OUTPUT_MODE_CHECKER.isTablet()) {\n      _strPosition = 'bottom';\n    }\n\n    return _strPosition;\n  },\n\n  _returnFocusToAsset: function(_strWhatAssetID, _strWhatOptionalActionSetID) {\n    // First return focus to screen on mobile to reactivate touch controls\n    if (!OUTPUT_MODE_CHECKER.isDesktop()) {\n      SCREEN_INTERACTIONS.returnFocusToScreen(_strWhatAssetID);\n    }\n\n    // Perform any actions that may need to happen when subscreen closes\n    if (_strWhatOptionalActionSetID) {\n      ACTIONS_INTERACTIONS.returnFocusToActionSet(_strWhatAssetID, _strWhatOptionalActionSetID);\n    } else if (_strWhatAssetID) {\n      ASSET_INTERACTIONS.returnFocusToAsset(_strWhatAssetID);\n    }\n\n    // Focus the last interacted element\n    gomo.tabManager.focusLastScreenElement();\n  },\n\n  setAnimatingSubscreen: function(subscreenId) {\n    this._animatingSubscreens[subscreenId] = true;\n  },\n\n  resetAnimatingSubscreen: function(subscreenId) {\n    this._animatingSubscreens[subscreenId] = false;\n  },\n\n  isSubscreenAnimating: function() {\n    for (var subscreenId in this._animatingSubscreens) {\n      if (this._animatingSubscreens[subscreenId]) {\n        return subscreenId;\n      }\n    }\n    return false;\n  },\n\n  // This returns true if the subscreen is going to be positioned somewhere other than top 0,\n  // bottom 0, left 0 or right 0\n  isAbsolutelyPositionedSubscreen: function() {\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING && OUTPUT_MODE_CHECKER.applyScrolling()) {\n      return true;\n    }\n    return false;\n  },\n\n  sendEnterStatement: function(subscreenData) {\n    var me = this;\n    if (!me.assetIdReferrer) return;\n    var assetId = me.assetIdReferrer.replace(/Y/g, '');\n    var currentScreenData = gomo.screenManager.getCurrentScreenData();\n    var currentScreenID = (\n      currentScreenData &&\n      currentScreenData.strObjID\n    ) ? currentScreenData.strObjID : '';\n    CONTENT_TRACKING.interaction({\n      type: 'experienced',\n      activity: {\n        id: subscreenData.strObjID,\n        title: subscreenData.strTitle,\n        type: 'subscreen'\n      },\n      referrer: {\n        id: assetId,\n        type: 'asset',\n        assetType: me.assetTypeReferrer\n      },\n      parent: 'page/' + currentScreenID,\n      topicGrouping: true\n    });\n  },\n\n  sendExitStatement: function(subscreenData) {\n    var me = this;\n    if (!me.assetIdReferrer) return;\n    var assetId = me.assetIdReferrer.replace(/Y/g, '');\n    var currentScreenData = gomo.screenManager.getCurrentScreenData();\n    var currentScreenID = (\n      currentScreenData &&\n      currentScreenData.strObjID\n    ) ? currentScreenData.strObjID : '';\n    CONTENT_TRACKING.interaction({\n      type: 'left',\n      activity: {\n        id: subscreenData.strObjID,\n        title: subscreenData.strTitle,\n        type: 'subscreen'\n      },\n      response: {\n        timeAvailable: me.timeAvailable,\n        timeResponse: new Date()\n      },\n      referrer: {\n        id: assetId,\n        type: 'asset',\n        assetType: me.assetTypeReferrer\n      },\n      parent: 'page/' + currentScreenID,\n      topicGrouping: true\n    });\n    me.timeAvailable = null;\n    me.assetTypeReferrer = '';\n    me.assetIdReferrer = '';\n  },\n\n  resetIscrollPositionForSubscreen: function(opts) {\n    // Reset position for dynamic scrolling screens in iscroll mode\n    if (this.isAbsolutelyPositionedSubscreen()) {\n      jQuery(opts.domSubscreenWrapper).css('top', 0);\n      // Reset the duration on close because it causes an incorrect height to be returned when the\n      // subscreen is opened again. GA-2578.\n      jQuery(opts.domSubscreenWrapper).css('transition-duration', '0ms');\n      SCROLLING_MANAGER.setMinYPosition(null);\n      SCROLLING_MANAGER.setMaxYPosition(null);\n      SCROLLING_MANAGER.enableScreenSwitchFromScrolling();\n      ISCROLL_INTERFACE.enableMomentum();\n\n      this.restoreScrollingToSubscreen(opts.domSubscreenWrapper);\n      $('#contentWrapperInnerL').height('auto');\n      ISCROLL_INTERFACE.refreshIScrolls();\n    }\n  },\n\n  debug: function(strMessage, intPriority, objCallerObject, booCalleeChain) {\n    if (DEBUG) {\n      DEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n    }\n  }\n};\n\nEM.register(SUB_SCREEN_INTERACTIONS);\n"},function(n,e,t){t(0)(t(123))},function(n,e){n.exports="/* global $, _, DEBUG, ISCROLL_INTERFACE, EM, ASSET_RENDERER */\n/* global SCREEN_INTERACTIONS, LOCALISER, CORE, BOO_ANIMATE_ASSETS_EVERY_VISIT */\n/* global ANIMATOR_INTERFACE_2, BOO_RESET_NON_ASSESSMENT_ASSET_STATES, META_TOPIC_MANAGER */\n/* global TOPIC_MANAGER, VARIABLES_HOLDER, MASTER_RENDERER, ErrorHandler, OBJ_REF */\n/* global BOO_SHOW_CORRECTNESS_ICONS_ON_CONFIRM_CLICK, SUB_SCREEN_INTERACTIONS */\n/* global LAYOUT_INTERACTIONS, FileOpener, CONTENT_TRACKING, BOO_DYNAMIC_CONTINUOUS_SCROLLING */\n/* global DISPLAY_CONDITIONS_INTERACTIONS, ACTIONS_INTERACTIONS, SCROLLING_MANAGER, BOO_RESET_ASSET_INTERACTED */\n/* global BOO_TURN_OFF_CONTINUOUS_SCROLL_ASSET_RESET, TOPIC_INTERACTIONS */\n\n/**\n * @title Asset Interactions\n * @description To be described.\n *\n *\n * @author GoMo\n * @version 2.0 17/12/12\n */\n\nvar ASSET_INTERACTIONS = {\n  strObjID: 'Asset interactions',\n  strObjDescription: 'Handles the common asset interactions, such as the showing of sub screens.',\n\n  _objWhatDOM: null,\n  _objFramesetDOM: null,\n\n  _strCurrTopicModel: '',\n\n  _strAssetSubScreenIDPrefix: 'subScreenWrapper_',\n  _strAssetSubScreenIDSuffix: 'L',\n\n  _strHiddenSubScreenClass: 'hiddenSubScreenC',\n  _strShownSubScreenClass: 'shownSubScreenC',\n\n  _strHiddenAssetMarker: 'hiddenAssetMarkerC',\n  _strDisplayedAssetMarker: 'displayedAssetMarkerC',\n\n  _strFirstAssetClass: 'firstAssetC',\n  _strMiddleAssetClass: 'middleAssetC',\n  _strLastAssetClass: 'lastAssetC',\n\n  _booAboutToExitTopic: false,\n  _assetDisplayStateUpdatedTasksFlag: false,\n\n  _objAnimationHandles: {},\n\n  _strCurrOutputMode: 'graphicalC',\n\n  _domLastAssetLinkClicked: null,\n\n  _objDynamiclyLoadedAssetData: {},\n  _strDynamiclyAssetDataLoadFailureMessage: '',\n\n  bindingHandlers: {\n    gomotext: function(el, value) {\n      $(el).html(ASSET_RENDERER.insertFormattedHtml(value || ''));\n    }\n  },\n\n  objExtendedAnimationData: {},\n  _strSelectedOptionClass: 'selectedOptionC',\n  _strUnselectedOptionClass: 'unSelectedOptionC',\n  _strOptionCorrectnessClass: 'correctnessMarkerC',\n  _strConfirmButtonClass: 'confirmButtonC',\n  _strResetButtonClass: 'resetButtonC',\n  _strModelAnswerButtonClass: 'modelAnswerButtonC',\n  _strMyAnswerButtonClass: 'myAnswerButtonC',\n\n  handleEvent_primeDOMReferences: function(_objWhatDOM) {\n    this._objWhatDOM = _objWhatDOM;\n  },\n\n  handleEvent_broadcastFramesetDOMRef: function(_objWhatFramesetDOM) {\n    this._objFramesetDOM = _objWhatFramesetDOM;\n  },\n\n  handleEvent_outputModeChanged: function(_objOutputChangeData) {\n    this._strCurrOutputMode = _objOutputChangeData['strNewOutputMode'];\n  },\n\n  handleEvent_setTopicModelType: function(_strWhatTopicModel) {\n    this._strCurrTopicModel = _strWhatTopicModel;\n    this._booAboutToExitTopic = false;\n  },\n\n  handleEvent_updateAssetDisplayStates: function(_objUpdateData) {\n    var _arrDisplayStateChangedAssets = _objUpdateData.arrDisplayStateChangedAssets;\n    var deferPostUpdateActions = _objUpdateData.deferPostUpdateActions;\n    var _objRelatedLayoutBlockIDs = {};\n\n    var _objCurrAssetDataWrapper = null;\n    var count = 0;\n    while (count < _arrDisplayStateChangedAssets.length) {\n      _objCurrAssetDataWrapper = _arrDisplayStateChangedAssets[count];\n      var _booSuppressUndefinedError = true;\n      var _domCurrAssetWrapper = null;\n      var currentAsset = this.getNewAsset(_objCurrAssetDataWrapper);\n      if (currentAsset) {\n        _domCurrAssetWrapper = gomo.assetManager.getElementFromAssetData(currentAsset.data);\n      } else {\n        _domCurrAssetWrapper = ASSET_RENDERER.getGenericAssetDOMWrapper(\n          _objCurrAssetDataWrapper.objRawData,\n          _booSuppressUndefinedError\n        );\n      }\n\n      if (!_domCurrAssetWrapper) {\n        return;\n      }\n\n      if (!_objRelatedLayoutBlockIDs[_objCurrAssetDataWrapper.objRawData.strLayoutID]) {\n        _objRelatedLayoutBlockIDs[_objCurrAssetDataWrapper.objRawData.strLayoutID] = {};\n      }\n      _objRelatedLayoutBlockIDs[_objCurrAssetDataWrapper.objRawData.strLayoutID][\n        _objCurrAssetDataWrapper.objRawData.intLayoutColumn\n      ] = true;\n\n      if (_objCurrAssetDataWrapper.booIsDisplayed) {\n        if (currentAsset) {\n          var assetHTML = currentAsset.render();\n          assetHTML = assetHTML.replace(\n            'displayedAssetMarkerC', 'displayedAssetMarkerC tempHiddenAssetC'\n          );\n          SCROLLING_MANAGER.disablePolling();\n          $(_domCurrAssetWrapper).replaceWith(assetHTML);\n          SCROLLING_MANAGER.enablePolling();\n        } else {\n          // Old Asset Stuff\n          var _objRenderData = {};\n          _objRenderData.objWhatAssetCourseObject = _objCurrAssetDataWrapper;\n          _objRenderData.booPreviewMode = false;\n\n          var _htmAssetContent = ASSET_RENDERER.renderAsset(_objRenderData);\n          _htmAssetContent = _htmAssetContent.replace(\n            'displayedAssetMarkerC', 'displayedAssetMarkerC tempHiddenAssetC'\n          );\n\n          var _domContainer = this._objWhatDOM.createElement('div');\n          _domContainer.innerHTML = _htmAssetContent;\n\n          var iCount = 0;\n          while (iCount < _domContainer.childNodes.length) {\n            var _domCurrChild = _domContainer.childNodes[iCount];\n            if (_domCurrChild.nodeType == 1) {\n              break;\n            }\n            iCount++;\n          }\n\n          _domCurrChild.innerHTML = _domCurrChild.innerHTML.replace(\n            /resources\\/trans.gif\\?/g,\n            MASTER_RENDERER.strInterfaceImagePath\n          );\n          _domCurrAssetWrapper.parentNode.replaceChild(_domCurrChild, _domCurrAssetWrapper);\n        }\n\n        this.resetAsset(_objCurrAssetDataWrapper, false);\n\n        // Check if this asset is part of the current screen or part of a cont scroll topic - but\n        // NOT part of a subscreen.\n        // Then perform pre show and post render actions. This will stop unwanted initialisation of\n        // assets.\n        if (\n          (BOO_DYNAMIC_CONTINUOUS_SCROLLING &&\n            !this.isAssetWithinHiddenSubscreens(_objCurrAssetDataWrapper)) ||\n          (this.isAssetChildOfCurrentScreen(_objCurrAssetDataWrapper)\n            && !this.isAssetWithinHiddenSubscreens(_objCurrAssetDataWrapper))\n        ) {\n          this.performPreShowActions(_objCurrAssetDataWrapper);\n          this.showPostRenderAsset(_objCurrAssetDataWrapper);\n        }\n\n        VARIABLES_HOLDER.updateAllVariablesForAnElement(_domCurrAssetWrapper.id);\n\n        // As display conditions can update during the initial load when no screen is shown,\n        // check first before attempting to animate.\n        if (SCREEN_INTERACTIONS.strCurrentScreenId) {\n          this._animateAsset(\n            SCREEN_INTERACTIONS.strCurrentScreenId,\n            _objCurrAssetDataWrapper.strObjID\n          );\n        }\n      } else {\n        this.displayConditionsHideAsset(_objCurrAssetDataWrapper);\n        _domCurrAssetWrapper.className = _domCurrAssetWrapper.className.replace(\n          this._strDisplayedAssetMarker,\n          this._strHiddenAssetMarker\n        );\n\n        // Remove it's ordering classes as it's currently invisible.\n        _domCurrAssetWrapper.className = _domCurrAssetWrapper.className\n          .replace(this._strFirstAssetClass, '')\n          .replace(this._strMiddleAssetClass, '')\n          .replace(this._strLastAssetClass, '');\n\n        _domCurrAssetWrapper.innerHTML = '';\n\n        if (gomo.dataBinding && gomo.dataBinding.unregister) {\n          // unregister assets content translations\n          gomo.dataBinding.unregister(_objCurrAssetDataWrapper.strObjID);\n          // unregister assets localisation translations\n          gomo.translationManager.unregisterLocalisation(\n            'topic',\n            _objCurrAssetDataWrapper.strObjID\n          );\n        }\n      }\n\n      // Cleanup any double spaces that may have emerged.\n      _domCurrAssetWrapper.className = _domCurrAssetWrapper.className.replace(/ {2}/g, ' ');\n\n      count++;\n    }\n\n    // There are more assets to update so we will run this once after they've completed\n    if (deferPostUpdateActions) {\n      this._assetDisplayStateUpdatedTasksFlag = true;\n    } else {\n      // Run translations on the screen for updates\n      if (\n        _arrDisplayStateChangedAssets.length > 0 &&\n        (gomo.translationManager && gomo.translationManager.updateBoundFields)\n      ) {\n        this.assetDisplayStateUpdatedTasks();\n      }\n    }\n\n    // Append the newly created hash table of adjusted Layout blocks.\n    _objUpdateData.objRelatedLayoutBlockIDs = _objRelatedLayoutBlockIDs;\n\n    EM.trigger('assetVisibilityUpdated', _objUpdateData);\n  },\n\n  // Checks if an asset is part of the current screen or part of a subscreen which is part of the\n  // current screen.\n  isAssetChildOfCurrentScreen: function(assetData) {\n    var isChild = false;\n    var currentScreenId = gomo.screenManager.getCurrentScreenData().strObjID;\n\n    if (\n      (assetData.objParent.strObjType === 'screen' &&\n      assetData.objParent.strObjID === currentScreenId) ||\n      (assetData.objParent.strObjType === 'subscreen' &&\n      assetData.objParent.objParent.strObjType === 'screen' &&\n      assetData.objParent.objParent.strObjID === currentScreenId)\n    ) {\n      isChild = true;\n    }\n\n    return isChild;\n  },\n\n  isAssetWithinHiddenSubscreens: function(assetData) {\n    var isChild = false;\n    if (assetData.objParent.strObjType === 'subscreen') {\n      if (assetData.objParent.strObjID !== SUB_SCREEN_INTERACTIONS.getCurrentSubscreen()) {\n        isChild = true;\n      }\n    }\n    return isChild;\n  },\n\n  assetDisplayStateUpdatedTasks: function() {\n    gomo.translationManager.updateBoundFields();\n    gomo.translationManager.updateBoundLocalisations();\n  },\n\n  postGroupAssetDisplayStatesUpdated: function() {\n    if (ASSET_INTERACTIONS._assetDisplayStateUpdatedTasksFlag) {\n      // reset the flag\n      ASSET_INTERACTIONS._assetDisplayStateUpdatedTasksFlag = false;\n      ASSET_INTERACTIONS.assetDisplayStateUpdatedTasks();\n    }\n  },\n\n  handleEvent_assetLinkClicked: function(_objLinkData) {\n    // {\\\"src\\\":this, \\\"type\\\":\\\"$1\\\", \\\"params\\\":\\\"$2\\\"}\n    this._domLastAssetLinkClicked = _objLinkData['src'];\n    switch (_objLinkData['type']) {\n      case 'sub':\n      case 'subscreen':\n        EM.trigger('showSubScreen', {\n          strTargetSubScreenID: _objLinkData['params']\n        });\n        break;\n      case 'link':\n      case 'url':\n        var _strLinkAddress = _objLinkData['params'];\n        if (!(~_strLinkAddress.indexOf('http') || ~_strLinkAddress.indexOf('www.'))) {\n          _strLinkAddress = 'resources/' + _strLinkAddress;\n          var isAndroid =\n            window.device && window.device.platform\n              ? window.device.platform.toLowerCase() === 'android'\n              : false;\n          if (isAndroid && FileOpener) {\n            FileOpener.open(_strLinkAddress);\n            return;\n          }\n        }\n        window.open(_strLinkAddress, '_blank');\n        break;\n      default:\n        LOCALISER.l_alert('ASSET_INTERACTIONS_UNKNOWN_LINK_TYPE_ERROR', [_objLinkData['type']]);\n        break;\n    }\n  },\n\n  // REFACTOR NOTE: This needs generising\n  handleEvent_newScreenShown: function(_strWhatScreenID) {},\n\n  handleEvent_prepForTopicExit: function() {\n    ASSET_RENDERER.objAssetAnimations = {};\n    ASSET_RENDERER.objAssetLoadOrders = {};\n\n    this._booAboutToExitTopic = true;\n  },\n\n  handleEvent_resetAssetButtonClicked: function(_objResetData) {\n    // Close all open subscreens on reset\n    SUB_SCREEN_INTERACTIONS.hideSubScreens();\n    switch (_objResetData['strAssetType']) {\n      case 'mcq':\n      case 'sfl':\n      case 'graphicalmcq':\n      case 'graphicalsfl':\n        this._resetStandardQuestion(_objResetData['strAssetID']);\n        break;\n      case 'hotspotmcq':\n        EM.trigger('hotspotMcqResetAssetButtonClicked', _objResetData['strAssetID']);\n        break;\n      default:\n        if (this['_reset_' + _objResetData['strAssetType'] + '_QuestionAsset']) {\n          this['_reset_' + _objResetData['strAssetType'] + '_QuestionAsset'](\n            _objResetData['strAssetID']\n          );\n          return;\n        }\n        LOCALISER.l_alert('ASSET_INTERACTIONS_MISSING_RESET_FUNCTIONALITY_FROM_BUTTON', [\n          _objResetData['strAssetType']\n        ]);\n        break;\n    }\n  },\n\n  handleEvent_modelAnswerAssetButtonClicked: function(_objModelAnswerData) {\n    var _objAssetData = this.getAssetData(_objModelAnswerData['strAssetID']);\n    switch (_objModelAnswerData['strAssetType']) {\n      case 'matchingpairs':\n        this._showMatchingPairsModelAnswer(_objModelAnswerData['strAssetID']);\n        this._showQuestionMyAnswerButton(_objAssetData);\n        break;\n      default:\n        if (this['_modelAnswer_' + _objModelAnswerData['strAssetType'] + '_QuestionAsset']) {\n          this['_modelAnswer_' + _objModelAnswerData['strAssetType'] + '_QuestionAsset']();\n          return;\n        }\n        LOCALISER.l_alert('ASSET_INTERACTIONS_MISSING_MODEL_ANSWER_FUNCTIONALITY_FROM_BUTTON', [\n          _objModelAnswerData['strAssetType']\n        ]);\n        break;\n    }\n  },\n\n  handleEvent_myAnswerAssetButtonClicked: function(_objMyAnswerData) {\n    var _objAssetData = this.getAssetData(_objMyAnswerData['strAssetID']);\n\n    switch (_objMyAnswerData['strAssetType']) {\n      case 'matchingpairs':\n        this._showMatchingPairsMyAnswer(_objMyAnswerData['strAssetID']);\n        this._showQuestionModelAnswerButton(_objAssetData);\n        break;\n      default:\n        if (this['_myAnswer_' + _objMyAnswerData['strAssetType'] + '_QuestionAsset']) {\n          this['_myAnswer_' + _objMyAnswerData['strAssetType'] + '_QuestionAsset']();\n          return;\n        }\n        LOCALISER.l_alert('ASSET_INTERACTIONS_MISSING_MY_ANSWER_FUNCTIONALITY_FROM_BUTTON', [\n          _objMyAnswerData['strAssetType']\n        ]);\n        break;\n    }\n  },\n\n  handleEvent_preLoadTopicObject: function() {\n    var _objTopicData = TOPIC_MANAGER.getCurrentTopic();\n    if (_objTopicData) {\n      var countScreen = 0;\n      while (countScreen < _objTopicData.arrScreens.length) {\n        var _objCurrScreen = _objTopicData.arrScreens[countScreen];\n\n        // Test screen level assets\n        var countAsset = 0;\n        while (countAsset < _objCurrScreen.arrAssets.length) {\n          var _objCurrAsset = _objCurrScreen.arrAssets[countAsset];\n          ASSET_INTERACTIONS.performPreLoadTopicActions(_objCurrAsset);\n          countAsset++;\n        }\n\n        // Test subscreen level assets\n        var countSubscreen = 0;\n        while (countSubscreen < _objCurrScreen.arrSubScreens.length) {\n          var _objCurrSubscreen = _objCurrScreen.arrSubScreens[countSubscreen];\n          var countSubAsset = 0;\n          while (countSubAsset < _objCurrSubscreen.arrAssets.length) {\n            var _objCurrSubAsset = _objCurrSubscreen.arrAssets[countSubAsset];\n            ASSET_INTERACTIONS.performPreLoadTopicActions(_objCurrSubAsset);\n            countSubAsset++;\n          }\n          countSubscreen++;\n        }\n        countScreen++;\n      }\n    }\n  },\n\n  postRenderedTopic: function() {\n    var _objTopicData = TOPIC_MANAGER.getCurrentTopic();\n    if (_objTopicData) {\n      var countScreen = 0;\n      while (countScreen < _objTopicData.arrScreens.length) {\n        var _objCurrScreen = _objTopicData.arrScreens[countScreen];\n        var shouldBeHidden = (\n          countScreen > 0 &&\n          !_objCurrScreen.booIsDisplayed &&\n          !_objTopicData.arrScreens[countScreen - 1].booIsDisplayed);\n        var screenWrapperID = 'screenWrapper_'+ _objCurrScreen.strObjID +'L';\n        $(this._objWhatDOM)\n          .find('#' + screenWrapperID)\n          .toggleClass('sequentiallyHiddenScreen', shouldBeHidden);\n\n        // Test screen level assets\n        var countAsset = 0;\n        while (countAsset < _objCurrScreen.arrAssets.length) {\n          ASSET_INTERACTIONS.postRenderedAsset(_objCurrScreen.arrAssets[countAsset]);\n          countAsset++;\n        }\n\n        // Test subscreen level assets\n        var countSubscreen = 0;\n        while (countSubscreen < _objCurrScreen.arrSubScreens.length) {\n          var _objCurrSubscreen = _objCurrScreen.arrSubScreens[countSubscreen];\n          var countSubAsset = 0;\n          while (countSubAsset < _objCurrSubscreen.arrAssets.length) {\n            ASSET_INTERACTIONS.postRenderedAsset(_objCurrSubscreen.arrAssets[countSubAsset]);\n            countSubAsset++;\n          }\n          countSubscreen++;\n        }\n        countScreen++;\n      }\n    }\n  },\n\n  preRerenderedTopic: function() {\n    var _objTopicData = TOPIC_MANAGER.getCurrentTopic();\n    if (_objTopicData) {\n      var countScreen = 0;\n      while (countScreen < _objTopicData.arrScreens.length) {\n        var _objCurrScreen = _objTopicData.arrScreens[countScreen];\n\n        // Test screen level assets\n        var countAsset = 0;\n        while (countAsset < _objCurrScreen.arrAssets.length) {\n          ASSET_INTERACTIONS.preRerenderedAsset(_objCurrScreen.arrAssets[countAsset], true);\n          countAsset++;\n        }\n\n        // Test subscreen level assets\n        var countSubscreen = 0;\n        while (countSubscreen < _objCurrScreen.arrSubScreens.length) {\n          var _objCurrSubscreen = _objCurrScreen.arrSubScreens[countSubscreen];\n          var countSubAsset = 0;\n          while (countSubAsset < _objCurrSubscreen.arrAssets.length) {\n            ASSET_INTERACTIONS.preRerenderedAsset(_objCurrSubscreen.arrAssets[countSubAsset], true);\n            countSubAsset++;\n          }\n          countSubscreen++;\n        }\n        countScreen++;\n      }\n    }\n  },\n\n  postRerenderedTopic: function() {\n    var _objTopicData = TOPIC_MANAGER.getCurrentTopic();\n    if (_objTopicData) {\n      var countScreen = 0;\n      while (countScreen < _objTopicData.arrScreens.length) {\n        var _objCurrScreen = _objTopicData.arrScreens[countScreen];\n\n        // Test screen level assets\n        var countAsset = 0;\n        while (countAsset < _objCurrScreen.arrAssets.length) {\n          ASSET_INTERACTIONS.postRerenderedAsset(_objCurrScreen.arrAssets[countAsset]);\n          countAsset++;\n        }\n\n        // Test subscreen level assets\n        var countSubscreen = 0;\n        while (countSubscreen < _objCurrScreen.arrSubScreens.length) {\n          var _objCurrSubscreen = _objCurrScreen.arrSubScreens[countSubscreen];\n          var countSubAsset = 0;\n          while (countSubAsset < _objCurrSubscreen.arrAssets.length) {\n            ASSET_INTERACTIONS.postRerenderedAsset(_objCurrSubscreen.arrAssets[countSubAsset]);\n            countSubAsset++;\n          }\n          countSubscreen++;\n        }\n        countScreen++;\n      }\n    }\n  },\n\n  // GENERIC METHODS\n  returnFocusToAsset: function(_strWhatAssetID) {\n    if (this._domLastAssetLinkClicked) {\n      this._returnFocusToGenericLink();\n      return;\n    }\n\n    var _objAssetData = this.getAssetData(_strWhatAssetID);\n\n    var asset = this.getNewAsset(_objAssetData);\n    if (asset && asset.data.booIsDisplayed) {\n      if (typeof asset.returnFocusToSelf !== 'undefined') {\n        return asset.returnFocusToSelf();\n      } else if (this['_returnFocusTo' + _objAssetData['strAssetType'].toUpperCase() + 'Asset']) {\n        // LEO have been using the old method for this so we need to support that\n        this['_returnFocusTo' + _objAssetData['strAssetType'].toUpperCase() + 'Asset'](\n          _domWhatAssetElement,\n          _objAssetData\n        );\n      } else {\n        return;\n      }\n    } else {\n      if (_objAssetData.booIsDisplayed) {\n        if (this['_returnFocusTo' + _objAssetData['strAssetType'].toUpperCase() + 'Asset']) {\n          var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objAssetData.objRawData);\n          this['_returnFocusTo' + _objAssetData['strAssetType'].toUpperCase() + 'Asset'](\n            _domWhatAssetElement,\n            _objAssetData\n          );\n        } else {\n          LOCALISER.l_alert('ASSET_INTERACTIONS_MISSING_RETURN_FOCUS_FUNCTIONALITY', [\n            _objAssetData['strAssetType']\n          ]);\n        }\n      }\n    }\n  },\n\n  getAssetData: function(_strWhatAssetID) {\n    _strWhatAssetID = _strWhatAssetID.replace(/YY/g, '');\n    var _objCurrTopicData = TOPIC_MANAGER.getCurrentTopic();\n    var _objWhatScreen = _objCurrTopicData.findScreen(_strWhatAssetID);\n    var _objWhatAsset = null;\n\n    // if it's empty then look in meta topics\n    if (typeof _objWhatScreen == 'undefined') {\n      var _objCurrMetaTopicData = META_TOPIC_MANAGER.getCurrentMetaTopic();\n      if (_objCurrMetaTopicData) {\n        _objWhatScreen = _objCurrMetaTopicData.findScreen(_strWhatAssetID);\n      }\n    }\n\n    if (_objWhatScreen) {\n      _objWhatAsset = _objWhatScreen.findAsset(_strWhatAssetID);\n    }\n\n    if (_strWhatAssetID.indexOf('sub') > -1) {\n      var _objWhatSubScreen = _objWhatScreen.findSubScreen(_strWhatAssetID);\n      var _objWhatSubScreenAsset = _objWhatSubScreen.findAsset(_strWhatAssetID);\n      return _objWhatSubScreenAsset;\n    }\n    return _objWhatAsset;\n  },\n\n  getAssetContent: function(asset) {\n    if (!_.isObject(asset)) {\n      return null;\n    }\n    var newAsset = this.getNewAsset(asset);\n    return (_.isObject(newAsset) && _.isFunction(newAsset.getContent))\n      ? newAsset.getContent()\n      : null;\n  },\n\n  resetAsset: function(_objWhatAssetData, _booForceReset) {\n    _objWhatAssetData.booInteractable = true;\n    var asset = this.getNewAsset(_objWhatAssetData);\n    if (asset) {\n      if (\n        ((BOO_RESET_NON_ASSESSMENT_ASSET_STATES && this._strCurrTopicModel != 'assessment') ||\n          _booForceReset) &&\n        asset.shouldAssetReset()\n      ) {\n        asset.reset(_booForceReset);\n      }\n    } else {\n      if (this['_reset_' + _objWhatAssetData.strAssetType + '_Asset']) {\n        if (\n          (BOO_RESET_NON_ASSESSMENT_ASSET_STATES && this._strCurrTopicModel != 'assessment') ||\n          _booForceReset\n        ) {\n          if (_objWhatAssetData.booIsDisplayed && this.shouldAssetReset(_objWhatAssetData)) {\n            this['_reset_' + _objWhatAssetData.strAssetType + '_Asset'](\n              _objWhatAssetData,\n              _booForceReset\n            );\n          }\n        }\n      } else if (this['_reset_' + _objWhatAssetData.objRawData.strGroup + '_Asset']) {\n        if (\n          (BOO_RESET_NON_ASSESSMENT_ASSET_STATES && this._strCurrTopicModel != 'assessment') ||\n          _booForceReset\n        ) {\n          if (_objWhatAssetData.booIsDisplayed) {\n            this['_reset_' + _objWhatAssetData.objRawData.strGroup + '_Asset'](\n              _objWhatAssetData,\n              _booForceReset\n            );\n          }\n        }\n      } else {\n        LOCALISER.l_alert('ASSET_INTERACTIONS_RESET_ASSET_FUNCTIONALITY', [\n          _objWhatAssetData.strAssetType,\n          _objWhatAssetData.strAssetType,\n          _objWhatAssetData.objRawData.strGroup\n        ]);\n      }\n    }\n  },\n\n  // This function helps deal with an asset which is about to be deleted and rerendered\n  preRerenderedAsset: function(_objWhatAssetData, _booForceReset) {\n    _objWhatAssetData.booInteractable = true;\n    var asset = this.getNewAsset(_objWhatAssetData);\n    if (asset) {\n      // There is no new asset rerendered function yet\n      // asset.reset(_booForceReset);\n    } else {\n      if (this['_preRerendered_' + _objWhatAssetData.strAssetType + '_Asset']) {\n        if (_objWhatAssetData.booIsDisplayed) {\n          this['_preRerendered_' + _objWhatAssetData.strAssetType + '_Asset'](\n            _objWhatAssetData,\n            _booForceReset\n          );\n        }\n      } else if (this['_preRerendered_' + _objWhatAssetData.objRawData.strGroup + '_Asset']) {\n        if (_objWhatAssetData.booIsDisplayed) {\n          this['_preRerendered_' + _objWhatAssetData.objRawData.strGroup + '_Asset'](\n            _objWhatAssetData,\n            _booForceReset\n          );\n        }\n      }\n    }\n  },\n\n  // This function helps deal with an asset which has just been rendered\n  postRenderedAsset: function(_objWhatAssetData) {\n    _objWhatAssetData.booInteractable = true;\n    var asset = this.getNewAsset(_objWhatAssetData);\n    if (asset) {\n      // There is no new asset rendered function yet\n      // asset.reset(_booForceReset);\n    } else {\n      if (this['_postRendered_' + _objWhatAssetData.strAssetType + '_Asset']) {\n        if (_objWhatAssetData.booIsDisplayed) {\n          this['_postRendered_' + _objWhatAssetData.strAssetType + '_Asset'](_objWhatAssetData);\n        }\n      } else if (this['_postRendered_' + _objWhatAssetData.objRawData.strGroup + '_Asset']) {\n        if (_objWhatAssetData.booIsDisplayed) {\n          this['_postRendered_' + _objWhatAssetData.objRawData.strGroup + '_Asset'](\n            _objWhatAssetData\n          );\n        }\n      }\n    }\n  },\n\n  // This function helps deal with an asset which has just been rerendered\n  postRerenderedAsset: function(_objWhatAssetData) {\n    _objWhatAssetData.booInteractable = true;\n    var asset = this.getNewAsset(_objWhatAssetData);\n    if (asset) {\n      // There is no new asset rerendered function yet\n      // asset.reset(_booForceReset);\n    } else {\n      if (this['_postRerendered_' + _objWhatAssetData.strAssetType + '_Asset']) {\n        if (_objWhatAssetData.booIsDisplayed) {\n          this['_postRerendered_' + _objWhatAssetData.strAssetType + '_Asset'](_objWhatAssetData);\n        }\n      } else if (this['_postRerendered_' + _objWhatAssetData.objRawData.strGroup + '_Asset']) {\n        if (_objWhatAssetData.booIsDisplayed) {\n          this['_postRerendered_' + _objWhatAssetData.objRawData.strGroup + '_Asset'](\n            _objWhatAssetData\n          );\n        }\n      }\n    }\n  },\n\n  stopAsset: function(_objWhatAssetData) {\n    // _objWhatAssetData.booInteractable = false;\n\n    switch (_objWhatAssetData.strAssetType) {\n      case 'electure':\n        // Imported function found in the image interactions extension.\n        this._stopElecture(_objWhatAssetData);\n        break;\n      case 'video':\n        this.hidePostRenderAsset(_objWhatAssetData);\n        break;\n    }\n  },\n\n  getNewAsset: function(assetData) {\n    var asset = null;\n    if (gomo.assetManager.isRegistered(assetData.strAssetType)) {\n      asset = gomo.assetManager.findInstance(assetData.strObjID);\n    }\n    return asset;\n  },\n\n  performPreLoadTopicActions: function(_objWhatAssetData) {\n    if (BOO_RESET_ASSET_INTERACTED) this._resetAssetInteracted(_objWhatAssetData);\n\n    var asset = this.getNewAsset(_objWhatAssetData);\n\n    if (_objWhatAssetData.booIsDisplayed) {\n      if (asset) {\n        asset.preloadTopic();\n      } else {\n        if (this['_performPreLoadTopicActions_' + _objWhatAssetData.strAssetType + '_Asset']) {\n          this['_performPreLoadTopicActions_' + _objWhatAssetData.strAssetType + '_Asset'](\n            _objWhatAssetData\n          );\n        }\n      }\n    }\n  },\n\n  translationProcessOnHidden: function(assetId) {\n    var _objWhatAssetData = this.getAssetData(assetId);\n    var asset = this.getNewAsset(_objWhatAssetData);\n    if (_objWhatAssetData.booIsDisplayed) {\n      if (asset) {\n        asset.translationProcessOnHidden();\n      } else {\n        if (this['_performLanguageProcessOnHidden_' + _objWhatAssetData.strAssetType + '_Asset']) {\n          this['_performLanguageProcessOnHidden_' + _objWhatAssetData.strAssetType + '_Asset'](\n            _objWhatAssetData\n          );\n        }\n      }\n    }\n  },\n\n  translationPreprocess: function(assetId) {\n    var _objWhatAssetData = this.getAssetData(assetId);\n    var asset = this.getNewAsset(_objWhatAssetData);\n    if (_objWhatAssetData.booIsDisplayed) {\n      if (asset) {\n        asset.translationPreprocess();\n      } else {\n        if (this['_performLanguagePreprocess_' + _objWhatAssetData.strAssetType + '_Asset']) {\n          this['_performLanguagePreprocess_' + _objWhatAssetData.strAssetType + '_Asset'](\n            _objWhatAssetData\n          );\n        }\n      }\n    }\n  },\n\n  translationPostprocess: function(assetId) {\n    var _objWhatAssetData = this.getAssetData(assetId);\n    var asset = this.getNewAsset(_objWhatAssetData);\n    if (_objWhatAssetData.booIsDisplayed) {\n      if (asset) {\n        asset.translationPostprocess();\n      } else {\n        if (this['_performLanguagePostprocess_' + _objWhatAssetData.strAssetType + '_Asset']) {\n          this['_performLanguagePostprocess_' + _objWhatAssetData.strAssetType + '_Asset'](\n            _objWhatAssetData\n          );\n        }\n      }\n    }\n  },\n\n  performPreShowActions: function(_objWhatAssetData) {\n    var asset = this.getNewAsset(_objWhatAssetData);\n    if (_objWhatAssetData.booIsDisplayed) {\n      _objWhatAssetData.timeAvailable = new Date();\n      _objWhatAssetData.completionStatementSent = false;\n\n      if (asset) {\n        asset.beforeShownSystemProcesses();\n        asset.beforeShown();\n      } else {\n        if (this['_performPreShowActions_' + _objWhatAssetData.strAssetType + '_Asset']) {\n          this['_performPreShowActions_' + _objWhatAssetData.strAssetType + '_Asset'](\n            _objWhatAssetData\n          );\n        }\n      }\n    }\n  },\n\n  showPostRenderAsset: function(_objWhatAssetData) {\n    var asset = this.getNewAsset(_objWhatAssetData);\n    if (_objWhatAssetData.booIsDisplayed) {\n      if (asset) {\n        asset.afterRenderShown();\n      } else {\n        if (\n          this['_doPostRenderShowActions_' + _objWhatAssetData.strAssetType + '_Asset'] &&\n          _objWhatAssetData.booIsDisplayed\n        ) {\n          this['_doPostRenderShowActions_' + _objWhatAssetData.strAssetType + '_Asset'](\n            _objWhatAssetData\n          );\n        }\n      }\n      _objWhatAssetData.initialised = true;\n    }\n  },\n\n  hidePostRenderAsset: function(_objWhatAssetData, assetOptions) {\n    var asset = this.getNewAsset(_objWhatAssetData);\n    if (_objWhatAssetData.booIsDisplayed) {\n      if (asset) {\n        asset.afterRenderHidden(assetOptions);\n      } else {\n        if (this['_doPostRenderHideActions_' + _objWhatAssetData.strAssetType + '_Asset']) {\n          this['_doPostRenderHideActions_' + _objWhatAssetData.strAssetType + '_Asset'](\n            _objWhatAssetData, assetOptions\n          );\n        }\n      }\n\n      if (this.checkAssetCompletion(_objWhatAssetData)\n        && this.isAssetCompletable(_objWhatAssetData)\n        && _objWhatAssetData.trackingCompletionDelayed) {\n        this.sendCompletionStatement(_objWhatAssetData);\n      }\n    }\n  },\n\n  shouldAssetReset: function(_objWhatAssetData) {\n    if (BOO_DYNAMIC_CONTINUOUS_SCROLLING && BOO_TURN_OFF_CONTINUOUS_SCROLL_ASSET_RESET) {\n      return !_objWhatAssetData.initialised;\n    } else {\n      return true;\n    }\n  },\n\n  displayConditionsHideAsset: function(_objWhatAssetData) {\n    var asset = this.getNewAsset(_objWhatAssetData);\n    if (asset) {\n      asset.displayConditionsHide();\n    } else {\n      if (this['_displayConditionsHide_' + _objWhatAssetData.strAssetType + '_Asset']) {\n        this['_displayConditionsHide_' + _objWhatAssetData.strAssetType + '_Asset'](\n          _objWhatAssetData\n        );\n      }\n    }\n\n    /*\n    * This is out of scope for the hotfix GRK-2840\n    * The completion step is likely needed but requires it's own investigation and\n    * testing. That will happen in ticket GRK-2850\n    *\n    if (this.checkAssetCompletion(_objWhatAssetData)\n      && this.isAssetCompletable(_objWhatAssetData)\n      && _objWhatAssetData.trackingCompletionDelayed) {\n      this.sendCompletionStatement(_objWhatAssetData);\n    }\n    */\n  },\n\n  obscureAssetForPopup: function(_objWhatAssetData) {\n    var asset = this.getNewAsset(_objWhatAssetData);\n    if (_objWhatAssetData.booIsDisplayed) {\n      if (asset) {\n        asset.obscureForPopup();\n      } else {\n        if (this['_obscureForPopup_' + _objWhatAssetData.strAssetType + '_Asset']) {\n          this['_obscureForPopup_' + _objWhatAssetData.strAssetType + '_Asset'](_objWhatAssetData);\n        }\n      }\n    }\n  },\n\n  restoreAssetFromPopup: function(_objWhatAssetData) {\n    var asset = this.getNewAsset(_objWhatAssetData);\n    if (_objWhatAssetData.booIsDisplayed) {\n      if (asset) {\n        asset.restoreFromPopup();\n      } else {\n        if (this['_restoreFromPopup_' + _objWhatAssetData.strAssetType + '_Asset']) {\n          this['_restoreFromPopup_' + _objWhatAssetData.strAssetType + '_Asset'](_objWhatAssetData);\n        }\n      }\n    }\n  },\n\n  checkAssetCompletion: function(_objWhatAssetData) {\n    if (_objWhatAssetData.booIsDisplayed) {\n      var result = false;\n      var asset = this.getNewAsset(_objWhatAssetData);\n      if (asset) {\n        result = asset.isComplete();\n      } else {\n        var method = '';\n\n        if (this['_checkCompletion_' + _objWhatAssetData.strAssetType + '_Asset']) {\n          // check completion for asset type!\n          method = '_checkCompletion_' + _objWhatAssetData.strAssetType + '_Asset';\n        } else if (this['_checkCompletion_' + _objWhatAssetData.objRawData.strGroup + '_Asset']) {\n          // check compltion for group!\n          method = '_checkCompletion_' + _objWhatAssetData.objRawData.strGroup + '_Asset';\n        }\n\n        try {\n          result = this[method](_objWhatAssetData);\n        } catch (e) {\n          console.log('Error occurred checking completion');\n          typeof ErrorHandler != 'undefined' && ErrorHandler['catch'] && ErrorHandler['catch'](e);\n        }\n      }\n\n      if (result && this.isAssetCompletable(_objWhatAssetData)\n        && !_objWhatAssetData.trackingCompletionDelayed) {\n        this.sendCompletionStatement(_objWhatAssetData);\n      }\n\n      return result;\n    }\n\n    return true;\n  },\n\n  isAssetCompletable: function(assetData) {\n    var result = false;\n    var asset = this.getNewAsset(assetData);\n\n    if (asset) {\n      result = asset.isCompletable();\n    } else if (this['is_' + assetData.strAssetType + '_AssetCompletable']) {\n      result = this['is_' + assetData.strAssetType + '_AssetCompletable'](assetData);\n    }\n\n    return result;\n  },\n\n  updateTopicTracking: function(_objWhatAssetData) {\n    var asset = this.getNewAsset(_objWhatAssetData);\n    if (_objWhatAssetData.booIsDisplayed) {\n      if (asset) {\n        asset.topicStatusChange();\n      } else {\n        if (this['_topicStatusChanged_' + _objWhatAssetData.strAssetType + '_Asset']) {\n          this['_topicStatusChanged_' + _objWhatAssetData.strAssetType + '_Asset'](\n            _objWhatAssetData\n          );\n        }\n      }\n    }\n  },\n\n  strClassPrefixAssetPosition: function(_objWhatAssetData) {\n    var _strPrefixPosition = '';\n    if (_objWhatAssetData.intColumnAffinity) {\n      switch (_objWhatAssetData.objParent.intColumns) {\n        case 1:\n          _strPrefixPosition = 'mid';\n          break;\n        case 2:\n          switch (_objWhatAssetData.intColumnAffinity) {\n            case 0:\n              _strPrefixPosition = 'left';\n              break;\n            case 1:\n              _strPrefixPosition = 'right';\n              break;\n            default:\n              _strPrefixPosition = '';\n              break;\n          }\n          break;\n        default:\n          _strPrefixPosition = '';\n          break;\n      }\n    }\n    return _strPrefixPosition;\n  },\n\n  testAssetsBoundarySize: function(_objScreenData) {\n    var _objScreenLayoutsWidths = LAYOUT_INTERACTIONS.getLayoutWidthObjList();\n\n    for (var _strLayout in _objScreenLayoutsWidths) {\n      if (_objScreenLayoutsWidths.hasOwnProperty(_strLayout)) {\n        var _objCurrentLayout = _objScreenLayoutsWidths[_strLayout];\n        for (var _strColumn in _objCurrentLayout) {\n          if (_objCurrentLayout.hasOwnProperty(_strColumn)) {\n            var _objCurrentColumn = _objCurrentLayout[_strColumn];\n            var intCount = 0;\n\n            while (intCount < _objCurrentColumn._arrCurrRelatedAssets.length) {\n              var _objWhatAssetCourseObject = _objCurrentColumn._arrCurrRelatedAssets[intCount];\n              var _objWhatRawAssetData = _objWhatAssetCourseObject.objRawData;\n\n              // Set asset size boundary\n              if (_objWhatAssetCourseObject.objAssetBoundaries) {\n                var _strTitle = _objWhatRawAssetData.strType + 'Boundaries';\n                var intMax = 999999;\n                var intMin = -1;\n                if (\n                  _objWhatAssetCourseObject.objAssetBoundaries.intLargest &&\n                  _objWhatAssetCourseObject.objAssetBoundaries.intLargest != -1\n                ) {\n                  intMax = _objWhatAssetCourseObject.objAssetBoundaries.intLargest;\n                }\n                if (_objWhatAssetCourseObject.objAssetBoundaries.intSmallest) {\n                  intMin = _objWhatAssetCourseObject.objAssetBoundaries.intSmallest;\n                }\n\n                var _funCallBack = function(objReturn) {\n                  ASSET_RENDERER.assetSizeOutOfBounds(objReturn);\n                };\n\n                gomo.outputChecker.setNewScreenSizeBoundary({\n                  strTitle: _strTitle,\n                  intLargeScreenMin: intMax,\n                  intSmallScreenMax: intMin,\n                  objRawAssetData: _objWhatRawAssetData,\n                  strDomId: _strColumn,\n                  funCallBack: _funCallBack,\n                  objOptionalFunParameter: _objWhatAssetCourseObject\n                });\n              }\n              intCount++;\n            }\n          }\n        }\n      }\n    }\n\n    // Test the list against the current element sizes\n    gomo.outputChecker.manualScreenSizeCheck();\n  },\n\n  updateAssetVariableLinks: function(_objWhatAssetDataWrapper, _objWhatEventData) {\n    if (this['_updateVariableLink_' + _objWhatAssetDataWrapper.strAssetType + '_Asset']) {\n      this['_updateVariableLink_' + _objWhatAssetDataWrapper.strAssetType + '_Asset'](\n        _objWhatAssetDataWrapper,\n        _objWhatEventData\n      );\n    }\n\n    var _arrSubScreens = _objWhatAssetDataWrapper.arrScreens;\n    var count = 0;\n    while (count < _arrSubScreens.length) {\n      var _objCurrSubScreen = _arrSubScreens[count];\n      SUB_SCREEN_INTERACTIONS.updateVariableReferences(_objCurrSubScreen, _objWhatEventData);\n      count++;\n    }\n  },\n\n  updateAssetColumnOrderingClasses: function(_objWhatAssetData) {\n    var _domOuterAssetWrapper = ASSET_RENDERER.getGenericAssetDOMWrapper(\n      _objWhatAssetData.objRawData\n    );\n    var _strAssetPositionClasses = ASSET_RENDERER.getAssetPositionClasses(\n      _objWhatAssetData.booIsFirstAssetInColumn,\n      _objWhatAssetData.booIsLastAssetInColumn\n    );\n\n    _domOuterAssetWrapper.className = _domOuterAssetWrapper.className\n      .replace(this._strFirstAssetClass, '')\n      .replace(this._strMiddleAssetClass, '')\n      .replace(this._strLastAssetClass, '');\n\n    _domOuterAssetWrapper.className += ' ' + _strAssetPositionClasses;\n\n    // Cleanup any double spaces that may have emerged.\n    _domOuterAssetWrapper.className = _domOuterAssetWrapper.className.replace(/ {2}/g, ' ');\n  },\n\n  setVariablesToGlobal: function(data) {\n    if (data.objRawData.variableFields) {\n      var count = 0;\n      var variables = {};\n      var variableFields = data.objRawData.variableFields;\n      var variablesStringify = '';\n      while (count < variableFields.length) {\n        var variableValue = this.getVariableFromAsset(data, variableFields[count]);\n        variables[variableFields[count]] = variableValue;\n        variablesStringify += variableValue;\n        count++;\n      }\n\n      var variableData = {\n        variablesStringify: variablesStringify,\n        assetId: data.objRawData.strID,\n        variables: variables,\n        initialise: true\n      };\n\n      if (gomo.variablesHolder) {\n        gomo.variablesHolder.setAssetVariable(variableData);\n      }\n    }\n  },\n\n  getVariableFromAsset: function(objRawData, assetFieldName) {\n    // When we can grab screens easily based of an id, we can enable the subscreen data option\n    return searchForValue(assetFieldName, objRawData);\n\n    /**\n     * Search for a key's value within an asset or object\n     * @param {String} assetFieldName Key to search for.\n     * @param {Object|Array} objRawData Thing to search in.\n     * @return {*} The value of the item.\n     */\n    function searchForValue(assetFieldName, objRawData) {\n      if (assetFieldName.indexOf('#') != -1 || assetFieldName.indexOf('.') != -1) {\n        var arrObjPath = null;\n        var firstPath = null;\n        var newFieldName = null;\n        if (\n          (assetFieldName.indexOf('.') != -1 &&\n            assetFieldName.indexOf('.') < assetFieldName.indexOf('#')) ||\n          assetFieldName.indexOf('#') == -1\n        ) {\n          arrObjPath = assetFieldName.split('.');\n          firstPath = arrObjPath[0];\n          newFieldName = assetFieldName.replace(firstPath + '.', '');\n          var newRawObj = objRawData[firstPath];\n\n          return searchForValue(newFieldName, newRawObj);\n        }\n        if (\n          (assetFieldName.indexOf('#') != -1 &&\n            assetFieldName.indexOf('#') < assetFieldName.indexOf('.')) ||\n          assetFieldName.indexOf('.') == -1\n        ) {\n          arrObjPath = assetFieldName.split('#');\n          firstPath = arrObjPath[0];\n          newFieldName = assetFieldName.replace(firstPath + '#.', '');\n\n          var strContent = '';\n          var arrCount = 0;\n          while (arrCount < objRawData.length) {\n            strContent += searchForValue(newFieldName, objRawData[arrCount]) + ' ';\n            arrCount++;\n          }\n          return strContent;\n        }\n      } else {\n        if (assetFieldName == 'SUBSCREEN') {\n          return 'Subscreen data is not yet supported. asset.js getVariableFromAsset()';\n        } else {\n          if (typeof objRawData !== 'undefined') {\n            return objRawData[assetFieldName];\n          } else {\n            return '';\n          }\n        }\n      }\n    }\n  },\n\n  processAssetActions: function(_objWhatAssetData) {\n    var rawData = _objWhatAssetData.objRawData;\n    var actionOptions = {};\n    actionOptions.objActions = rawData.arrActions;\n    actionOptions.objOptionalExtraData = _objWhatAssetData;\n    actionOptions.objOptionalExtraData.strAssetID = _objWhatAssetData.strObjID;\n\n    // Execute all actions\n    gomo.eventManager.legacy('processActions', actionOptions);\n  },\n\n  _resetStandardQuestion: function(_strWhatAssetID) {\n    var _objAssetData = this.getAssetData(_strWhatAssetID);\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objAssetData.objRawData);\n    var _arrOptionDOMElements = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this['_str' + _objAssetData['strAssetType'].toUpperCase() + 'OptionClass']\n    );\n    // Global function, found within this object\n    this._resetOptions(_arrOptionDOMElements, _domWhatAssetElement, _objAssetData.arrOptionStates);\n    this._showQuestionConfirmButton(_objAssetData);\n    _objAssetData.booInteractable = true;\n  },\n\n  _resetAssetInteracted: function(_objWhatAssetData) {\n    var _strVariableName = 'gomo_asset_interacted.' +\n    (_objWhatAssetData.strObjID || _objWhatAssetData.strID);\n    var _objEventData = {\n      strVariableName: _strVariableName,\n      strVariableValue: 'false',\n      strCallbackEvent: false,\n      booIsSystemVariable: true\n    };\n    EM.trigger('updateVariableValue', _objEventData);\n    EM.trigger('systemVariablesChanged', {arrChangedSystemVariables: [_strVariableName]});\n  },\n\n  _resetOptions: function(_arrWhatOptionDOMElements, _domWhatAssetElement, _arrWhatOptionStates) {\n    var count = 0;\n    while (count < _arrWhatOptionDOMElements.length) {\n      _arrWhatOptionStates[count] = false;\n      var _domCurrOptionElement = _arrWhatOptionDOMElements[count];\n      _domCurrOptionElement.className = _domCurrOptionElement.className.replace(\n        this._strSelectedOptionClass,\n        this._strUnselectedOptionClass\n      );\n      _domCurrOptionElement.checked = false;\n      // If aria-checked is checked then reset it to un-checked\n      if ($(_domCurrOptionElement).attr('aria-checked')) {\n        $(_domCurrOptionElement).attr('aria-checked', 'false');\n      }\n      this._resetOptionMarkerImage(_domCurrOptionElement, _domWhatAssetElement);\n      count++;\n    }\n  },\n\n  _randomiseOptions: function(_strWhatAssetID, _strOptionClass) {\n    var _objWhatAssetData = this.getAssetData(_strWhatAssetID);\n    var _objRawData = _objWhatAssetData.objRawData;\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objRawData);\n    var options = _domWhatAssetElement.getElementsByClassName(_strOptionClass);\n\n    var groupedOptions = _(options).groupBy(function(option) {\n      return option.parentNode.id;\n    });\n\n    _.each(groupedOptions, function(value, key) {\n      var shuffledOptions = _.shuffle(value);\n      var container = key ? document.getElementById(key) : _.first(shuffledOptions).parentNode;\n\n      _.each(shuffledOptions, function(newvalue) {\n        $(container).append(newvalue);\n      });\n    });\n  },\n\n  _resetOptionMarkerImage: function(_domCurrOptionElement, _domWhatAssetElement) {\n    var _domMarkerImage = CORE.getElementsByClassName(\n      _domCurrOptionElement,\n      this._strOptionCorrectnessClass\n    )[0];\n    // The accessible marker is in a slightly different place, so check there too.\n    if (!_domMarkerImage) {\n      _domMarkerImage = CORE.getElementsByClassName(\n        _domCurrOptionElement.parentNode,\n        this._strOptionCorrectnessClass\n      )[0];\n    }\n    // The single correctness marker might be at the route level of the asset so check there last\n    if (!_domMarkerImage) {\n      _domMarkerImage = CORE.getElementsByClassName(\n        _domWhatAssetElement.parentNode,\n        this._strOptionCorrectnessClass\n      )[0];\n    }\n\n    if (_domMarkerImage) {\n      // Reset the correctness images.\n      _domMarkerImage.className = _domMarkerImage.className.replace(\n        /incorrectAnswerC/g,\n        'unSetCorrectnessC'\n      );\n      _domMarkerImage.className = _domMarkerImage.className.replace(\n        /correctAnswerC/g,\n        'unSetCorrectnessC'\n      );\n      _domMarkerImage.alt = '';\n      // Get the generic asset wrapper that the asset sits in and remove all correctness classes.\n      $(_domWhatAssetElement)\n        .parents('.genericAssetWrapperC')\n        .find('.correct-option, .incorrect-option')\n        .removeClass('correct-option incorrect-option');\n    }\n  },\n\n  _resetUserQuestionAttempts: function(_objWhatAssetData) {\n    if (_objWhatAssetData.intUsersQuestionAttempts) {\n      _objWhatAssetData.intUsersQuestionAttempts = 0;\n    }\n  },\n\n  animateAssets: function(strCurrentScreen) {\n    if (gomo.outputChecker.animationEnabled) {\n      for (var _strKey in ASSET_RENDERER.objAssetAnimations[strCurrentScreen]) {\n        // Check this field really belongs to the object - required to pass linting\n        if (ASSET_RENDERER.objAssetAnimations[strCurrentScreen].hasOwnProperty(_strKey)) {\n          this._animateAsset(strCurrentScreen, _strKey);\n        }\n      }\n    }\n  },\n\n  _animateAsset: function(strCurrentScreen, _strKey) {\n    var animations = ASSET_RENDERER.objAssetAnimations;\n    if (!(animations && animations[strCurrentScreen] && animations[strCurrentScreen][_strKey])) {\n      return;\n    }\n    var _objAssetAnimationData = ASSET_RENDERER.objAssetAnimations[strCurrentScreen][_strKey];\n    var _objAssetData = ASSET_INTERACTIONS.getAssetData(_strKey);\n    // Check to see if animation is applyed as 'updated' assets are passed here by\n    // handleEvent_updateAssetDisplayStates() without checking\n    if (\n      _objAssetAnimationData &&\n      (_objAssetAnimationData.strAnimationType != 'null' &&\n        _objAssetAnimationData.strAnimationType != '') &&\n      _objAssetData.booIsDisplayed\n    ) {\n      if (\n        BOO_ANIMATE_ASSETS_EVERY_VISIT ||\n        _objAssetAnimationData.booAnimateOnEveryVisit ||\n        _objAssetAnimationData.booAnimated == false\n      ) {\n        _objAssetAnimationData.booAnimated = true;\n\n        var _strElementId = 'assetWrapperFor_YY' + _strKey + 'YY_L';\n        var _domAssetWrapper = document.getElementById(_strElementId);\n\n        if (_domAssetWrapper !== null) {\n          var _objAnimationOptions = {\n            delay: _objAssetAnimationData.intDelay,\n            duration: _objAssetAnimationData.intDuration\n          };\n\n          if (_objAnimationOptions.delay) {\n            var $el = $('#' + _strElementId);\n            // stop any animations on the asset from a previous screen load and clear\n            // any animation queue on the el\n            $el.velocity('stop', true);\n          }\n          ANIMATOR_INTERFACE_2.applyOpacityToElement('#' + _strElementId);\n          ANIMATOR_INTERFACE_2.assignRegisteredAnimation(\n            '#' + _strElementId,\n            _objAssetAnimationData.strType,\n            _objAnimationOptions\n          );\n        }\n      }\n    }\n  },\n\n  _showQuestionResetButton: function(_objWhatAssetData) {\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objWhatAssetData.objRawData);\n\n    if (!_domWhatAssetElement) return;\n\n    var _domConfirmButton = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strConfirmButtonClass\n    )[0];\n    var _domResetButton = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strResetButtonClass\n    )[0];\n\n    if (_.isUndefined(_domConfirmButton) || _.isUndefined(_domResetButton)) return;\n\n    _domConfirmButton.className = _domConfirmButton.className.replace(\n      'visibleButtonC',\n      'hiddenButtonC'\n    );\n    _domResetButton.className = _domResetButton.className.replace(\n      'hiddenButtonC',\n      'visibleButtonC'\n    );\n  },\n\n  _showQuestionConfirmButton: function(_objWhatAssetData) {\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objWhatAssetData.objRawData);\n\n    if (_domWhatAssetElement) {\n      var _domConfirmButton = CORE.getElementsByClassName(\n        _domWhatAssetElement,\n        this._strConfirmButtonClass\n      )[0];\n      var _domResetButton = CORE.getElementsByClassName(\n        _domWhatAssetElement,\n        this._strResetButtonClass\n      )[0];\n      var _domModelAnswerButton = CORE.getElementsByClassName(\n        _domWhatAssetElement,\n        this._strModelAnswerButtonClass\n      )[0];\n      var _domMyAnswerButton = CORE.getElementsByClassName(\n        _domWhatAssetElement,\n        this._strMyAnswerButtonClass\n      )[0];\n\n      if (\n        _.isUndefined(_domConfirmButton) ||\n        _.isUndefined(_domResetButton) ||\n        _.isUndefined(_domModelAnswerButton) ||\n        _.isUndefined(_domMyAnswerButton)\n      ) return;\n\n      _domModelAnswerButton.className = _domModelAnswerButton.className.replace(\n        'visibleButtonC',\n        'hiddenButtonC'\n      );\n      _domMyAnswerButton.className = _domMyAnswerButton.className.replace(\n        'visibleButtonC',\n        'hiddenButtonC'\n      );\n      _domConfirmButton.className = _domConfirmButton.className.replace(\n        'hiddenButtonC',\n        'visibleButtonC'\n      );\n      _domResetButton.className = _domResetButton.className.replace(\n        'visibleButtonC',\n        'hiddenButtonC'\n      );\n    }\n    this._activateButtons(_objWhatAssetData);\n  },\n\n  _showQuestionModelAnswerButton: function(_objWhatAssetData) {\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objWhatAssetData.objRawData);\n    var _domConfirmButton = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strConfirmButtonClass\n    )[0];\n    var _domModelAnswerButton = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strModelAnswerButtonClass\n    )[0];\n    var _domMyAnswerButton = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strMyAnswerButtonClass\n    )[0];\n    _domConfirmButton.className = _domConfirmButton.className.replace(\n      'visibleButtonC',\n      'hiddenButtonC'\n    );\n    _domMyAnswerButton.className = _domMyAnswerButton.className.replace(\n      'visibleButtonC',\n      'hiddenButtonC'\n    );\n    _domModelAnswerButton.className = _domModelAnswerButton.className.replace(\n      'hiddenButtonC',\n      'visibleButtonC'\n    );\n    this._activateButtons(_objWhatAssetData);\n  },\n\n  _showQuestionMyAnswerButton: function(_objWhatAssetData) {\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objWhatAssetData.objRawData);\n    var _domModelAnswerButton = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strModelAnswerButtonClass\n    )[0];\n    var _domMyAnswerButton = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strMyAnswerButtonClass\n    )[0];\n    var _domConfirmButton = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strConfirmButtonClass\n    )[0];\n    _domModelAnswerButton.className = _domModelAnswerButton.className.replace(\n      'visibleButtonC',\n      'hiddenButtonC'\n    );\n    _domMyAnswerButton.className = _domMyAnswerButton.className.replace(\n      'hiddenButtonC',\n      'visibleButtonC'\n    );\n    _domConfirmButton.className = _domConfirmButton.className.replace(\n      'visibleButtonC',\n      'hiddenButtonC'\n    );\n    this._activateButtons(_objWhatAssetData);\n  },\n\n  _deactivateButtons: function(_objWhatAssetData) {\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objWhatAssetData.objRawData);\n\n    if (!_domWhatAssetElement) return;\n\n    var _domConfirmButton = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strConfirmButtonClass\n    )[0];\n    var _domResetButton = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strResetButtonClass\n    )[0];\n\n    if (_.isUndefined(_domConfirmButton) || _.isUndefined(_domResetButton)) return;\n\n    _domConfirmButton.className = _domConfirmButton.className.replace(\n      'activeOptionButtonC',\n      'inactiveOptionButtonC'\n    );\n    _domResetButton.className = _domResetButton.className.replace(\n      'activeOptionButtonC',\n      'inactiveOptionButtonC'\n    );\n    _domConfirmButton.setAttribute('aria-disabled', 'true');\n    _domResetButton.setAttribute('aria-disabled', 'true');\n  },\n\n  _activateButtons: function(_objWhatAssetData) {\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objWhatAssetData.objRawData);\n\n    if (!_domWhatAssetElement) return;\n\n    var _domConfirmButton = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strConfirmButtonClass\n    )[0];\n    var _domResetButton = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strResetButtonClass\n    )[0];\n\n    if (_.isUndefined(_domConfirmButton) || _.isUndefined(_domResetButton)) return;\n\n    _domConfirmButton.className = _domConfirmButton.className.replace(\n      'inactiveOptionButtonC',\n      'activeOptionButtonC'\n    );\n    _domResetButton.className = _domResetButton.className.replace(\n      'inactiveOptionButtonC',\n      'activeOptionButtonC'\n    );\n    _domConfirmButton.removeAttribute('aria-disabled');\n    _domResetButton.removeAttribute('aria-disabled');\n  },\n\n  // REFACTOR NOTE: This function seems a little bloated? JC\n  _getSelectedOptions: function(_objWhatAssetCourseData, _arrOptionDOMElements) {\n    switch (this._strCurrOutputMode) {\n      case 'graphicalC':\n      case 'tabletC':\n        return this._getGraphicalSelectOptions(_objWhatAssetCourseData);\n      case 'smartphoneC':\n        if (!gomo.outputChecker.isBlackberryPhone()) {\n          return this._getGraphicalSelectOptions(_objWhatAssetCourseData);\n        } else {\n          switch (_objWhatAssetCourseData.strAssetType) {\n            case 'sfl':\n            case 'mcq':\n            case 'graphicalsfl':\n            case 'graphicalmcq':\n            case 'hotspotmcq':\n              return this._getGraphicalSelectOptions(_objWhatAssetCourseData);\n            default:\n              LOCALISER.l_alert('ASSET_INTERACTIONS_UNABLE_TO_GET_SMARTPHONE_QUESTION_OPTIONS', [\n                _objWhatAssetCourseData.strAssetType\n              ]);\n              break;\n          }\n        }\n        break;\n      case 'accessibleC':\n        switch (_objWhatAssetCourseData.strAssetType) {\n          case 'sfl':\n          case 'mcq':\n            return this._getAccessibleSelectOptions(_objWhatAssetCourseData, _.sortBy(_arrOptionDOMElements, 'id'));\n          case 'graphicalsfl':\n          case 'graphicalmcq':\n          case 'hotspotmcq':\n            return this._getGraphicalSelectOptions(_objWhatAssetCourseData);\n          default:\n            LOCALISER.l_alert('ASSET_INTERACTIONS_UNABLE_TO_GET_ACCESSIBLE_QUESTION_OPTIONS', [\n              _objWhatAssetCourseData.strAssetType\n            ]);\n            break;\n        }\n        break;\n    }\n  },\n\n  _getGraphicalSelectOptions: function(_objWhatAssetCourseData) {\n    var _arrOptionStates = _objWhatAssetCourseData.arrOptionStates;\n    if (_arrOptionStates) {\n      var _booSelectedOptionFound = false;\n      var _objStateInfo = {};\n      var count = 0;\n      while (count < _arrOptionStates.length) {\n        if (_arrOptionStates[count]) {\n          _booSelectedOptionFound = true;\n          _objStateInfo[count] = true;\n        }\n        count++;\n      }\n      if (_booSelectedOptionFound) {\n        return _objStateInfo;\n      } else {\n        return false;\n      }\n    }\n    return false;\n  },\n\n  _getAccessibleSelectOptions: function(_objWhatAssetCourseData, _arrOptionDOMElements) {\n    var _arrOptionStates = this._getAccessibleOptionStates(_arrOptionDOMElements);\n    if (_arrOptionStates) {\n      var _booSelectedOptionFound = false;\n      var _objStateInfo = {};\n      var count = 0;\n      while (count < _arrOptionStates.length) {\n        if (_arrOptionStates[count]) {\n          _booSelectedOptionFound = true;\n          _objStateInfo[count] = true;\n        }\n        count++;\n      }\n      if (_booSelectedOptionFound) {\n        return _objStateInfo;\n      } else {\n        return false;\n      }\n    }\n    return false;\n  },\n\n  _getAccessibleOptionStates: function(_arrOptionDOMElements) {\n    var _arrOptionStates = [];\n    var count = 0;\n    while (count < _arrOptionDOMElements.length) {\n      if (_arrOptionDOMElements[count].checked) {\n        _arrOptionStates[count] = true;\n      }\n      count++;\n    }\n    return _arrOptionStates;\n  },\n\n  // show tickets and crosses at the end of each option for an asset\n  _showOptionCorrectness: function(_arrOptionDOMElements, _objScoreInfo) {\n    if (BOO_SHOW_CORRECTNESS_ICONS_ON_CONFIRM_CLICK) {\n      var count = 0;\n      var _arrMarkerImages = [];\n\n      // re-init elements list order\n      var getAssetId = function(id) {\n        var no = /.*?Option([0-9]+)/g.exec(id);\n        no = no && no.length == 2 ? parseInt(no[1]) : no;\n        return isNaN(no) ? 999999 : no;\n      };\n\n      if (_.isArray(_arrOptionDOMElements)) {\n        _arrOptionDOMElements.sort(function(a, b) {\n          return getAssetId(a.id) - getAssetId(b.id);\n        });\n      }\n\n      while (count < _arrOptionDOMElements.length) {\n        var _domCurrOptionElement = _arrOptionDOMElements[count];\n        var _domMarkerImage = CORE.getElementsByClassName(\n          _domCurrOptionElement,\n          this._strOptionCorrectnessClass\n        )[0];\n        var _objCurrOptionData = _objScoreInfo['objOptionData'][count];\n        // The accessible marker is in a slightly different place, so check there too.\n        if (!_domMarkerImage) {\n          _domMarkerImage = CORE.getElementsByClassName(\n            _domCurrOptionElement.parentNode,\n            this._strOptionCorrectnessClass\n          )[0];\n        }\n\n        _arrMarkerImages[count] = _domMarkerImage;\n\n        if (_objCurrOptionData.booIsCorrect) {\n          $(_domCurrOptionElement).addClass('correct-option');\n          _domMarkerImage.className = _domMarkerImage.className.replace(\n            /unSetCorrectnessC/g,\n            'correctAnswerC'\n          );\n          _domMarkerImage.alt = LOCALISER.get('ASSET_INTERACTIONS_OPTION_CORRECT_TEXT');\n          _domMarkerImage.title = LOCALISER.get('ASSET_INTERACTIONS_OPTION_CORRECT_TEXT');\n        } else {\n          $(_domCurrOptionElement).addClass('incorrect-option');\n          _domMarkerImage.className = _domMarkerImage.className.replace(\n            /unSetCorrectnessC/g,\n            'incorrectAnswerC'\n          );\n          _domMarkerImage.alt = LOCALISER.get('ASSET_INTERACTIONS_OPTION_INCORRECT_TEXT');\n          _domMarkerImage.title = LOCALISER.get('ASSET_INTERACTIONS_OPTION_INCORRECT_TEXT');\n        }\n\n        count++;\n      }\n      EM.trigger('imageSourcesUpdated', {\n        arrImages: _arrMarkerImages\n      });\n    }\n  },\n\n  // This is used if only one correctness element can be\n  // included with an asset. Such as a select-option list.\n  _showSingleOptionCorrectness: function(_domWhatAssetElement, _objScoreInfo) {\n    if (BOO_SHOW_CORRECTNESS_ICONS_ON_CONFIRM_CLICK) {\n      var _domMarkerImage = CORE.getElementsByClassName(\n        _domWhatAssetElement,\n        this._strOptionCorrectnessClass\n      )[0];\n\n      if (_objScoreInfo.booIsCorrect) {\n        $(_domWhatAssetElement).addClass('correct-option');\n        _domMarkerImage.className = _domMarkerImage.className.replace(\n          /unSetCorrectnessC/g,\n          'correctAnswerC'\n        );\n        _domMarkerImage.alt = LOCALISER.get('ASSET_INTERACTIONS_OPTION_CORRECT_TEXT');\n        _domMarkerImage.title = LOCALISER.get('ASSET_INTERACTIONS_OPTION_CORRECT_TEXT');\n      } else {\n        $(_domWhatAssetElement).addClass('incorrect-option');\n        _domMarkerImage.className = _domMarkerImage.className.replace(\n          /unSetCorrectnessC/g,\n          'incorrectAnswerC'\n        );\n        _domMarkerImage.alt = LOCALISER.get('ASSET_INTERACTIONS_OPTION_INCORRECT_TEXT');\n        _domMarkerImage.title = LOCALISER.get('ASSET_INTERACTIONS_OPTION_INCORRECT_TEXT');\n      }\n    }\n  },\n\n  _focusConfirmButton: function(_domWhatAssetElement) {\n    var _domConfirmButton = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strConfirmButtonClass\n    )[0];\n    // IE throws a script error if you attempt to focus something that hidden.\n    try {\n      _domConfirmButton.focus();\n    } catch (_strError) {\n      typeof ErrorHandler != 'undefined' &&\n        ErrorHandler['catch'] &&\n        ErrorHandler['catch'](_strError);\n    }\n    var _domResetButton = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strResetButtonClass\n    )[0];\n    try {\n      _domResetButton.focus();\n    } catch (_strError) {\n      typeof ErrorHandler != 'undefined' &&\n        ErrorHandler['catch'] &&\n        ErrorHandler['catch'](_strError);\n    }\n  },\n\n  _getAssetSubScreenDOMElement: function(_strWhatSubScreenID) {\n    var _strSubScreenDOMID =\n      this._strAssetSubScreenIDPrefix + _strWhatSubScreenID + this._strAssetSubScreenIDSuffix;\n    var _domSubScreenWrapper = this._objWhatDOM.getElementById(_strSubScreenDOMID);\n\n    if (_domSubScreenWrapper) {\n      return _domSubScreenWrapper;\n    } else {\n      LOCALISER.l_alert('ASSET_INTERACTIONS_FAILED_TO_FIND_SUBSCREEN_DOM_ELEMENT_ERROR', [\n        _strWhatSubScreenID\n      ]);\n    }\n  },\n\n  _returnFocusToGenericLink: function() {\n    this._domLastAssetLinkClicked.focus();\n    this._domLastAssetLinkClicked = null;\n  },\n\n  addData: function(_objWhatData, _strWhatDataID) {\n    if (_objWhatData) {\n      this._objDynamiclyLoadedAssetData[_strWhatDataID] = _objWhatData;\n    } else {\n      this._strDynamiclyAssetDataLoadFailureMessage += _strWhatDataID + '\\n';\n    }\n  },\n\n  allFilesProcessed: function(_booSuccess) {\n    if (_booSuccess) {\n      EM.trigger('dynamicAssetDataLoaded');\n    } else {\n      LOCALISER.l_alert('ASSET_INTERACTIONS_DYNAMIC_ASSET_DATA_LOAD_FAIL_ERROR', [\n        this._strDynamiclyAssetDataLoadFailureMessage\n      ]);\n      this._strDynamiclyAssetDataLoadFailureMessage = '';\n    }\n  },\n\n  // ***************************** ASSET GROUP RELATED METHODS *****************************\n\n  // COMPLETION\n\n  _checkCompletion_question_Asset: function(_objWhatAssetData) {\n    var _booComplete = true;\n    var _intQuestionAttempts = parseInt(_objWhatAssetData.objRawData.strAttempts);\n    var _intUsersQuestionAttempts = _objWhatAssetData.intUsersQuestionAttempts;\n\n    if (\n      _objWhatAssetData.booIsCorrect !== true && _intQuestionAttempts > _intUsersQuestionAttempts\n    ) {\n      _booComplete = false;\n    }\n\n    return _booComplete;\n  },\n\n  _checkCompletion_presentation_Asset: function(_objWhatAssetData) {\n    // It's mainly Question assets that need reseting\n    // so this is a safe fallback for assets without a reset.\n  },\n\n  _checkCompletion_nonrendering_Asset: function(_objWhatAssetData) {},\n\n  // RESET\n  _reset_question_Asset: function(_objWhatAssetData, _booFullReset) {\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objWhatAssetData.objRawData);\n    var _arrOptionDOMElements = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this['_str' + _objWhatAssetData['strAssetType'].toUpperCase() + 'OptionClass']\n    );\n    // Global function, found within this object\n    this._resetOptions(\n      _arrOptionDOMElements,\n      _domWhatAssetElement,\n      _objWhatAssetData.arrOptionStates\n    );\n    this._resetUserQuestionAttempts(_objWhatAssetData);\n    this._showQuestionConfirmButton(_objWhatAssetData);\n    this._activateButtons(_objWhatAssetData);\n  },\n\n  _reset_standard_Asset: function(_objWhatAssetData, _booFullReset) {},\n\n  _reset_media_Asset: function(_objWhatAssetData, _booFullReset) {},\n\n  _reset_presentation_Asset: function(_objWhatAssetData, _booFullReset) {\n    // It's mainly Question assets that need reseting\n    // so this is a safe fallback for assets without a reset.\n  },\n\n  _reset_nonrendering_Asset: function(_objWhatAssetData, _booFullReset) {},\n\n  _setScrollIntoView_Asset: function(elementSelector, assetId) {\n    var el = $(elementSelector);\n    if (el.length > 0) {\n      el.data('gomoId', assetId);\n    }\n  },\n\n  _scrollIntoView_Asset: function(el, minVisibileArea, assetId, setTimeoutDelay, promiseReturn) {\n    var deferred = new $.Deferred();\n    // The user will need to see at least 15px of the input box\n    var minVisibleAreaPx = minVisibileArea || 100;\n    var extraScrollArea = 500;\n    var triggeredFromGomo = true;\n    assetId = assetId || (el && $(el).length) && $(el).data('gomoId');\n    if (!assetId) {\n      deferred.resolve(promiseReturn);\n      return;\n    }\n\n    var scrollContent = function() {\n      var assetData =\n        ASSET_INTERACTIONS.getAssetData(assetId) || gomo.assetManager.findInstance(assetId).data;\n      var screenScrollerId = null;\n      // If we can find the parent screen, we need to scroll it to focus on our asset\n      if (!(assetData.objParent && assetData.objParent.strObjType == 'screen')) {\n        deferred.resolve(promiseReturn);\n        return;\n      }\n      var screenId = assetData.objParent.strObjID;\n      var screenDomId = SCREEN_INTERACTIONS.getScreenWrapperID(screenId);\n      if (!BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n        screenScrollerId = ISCROLL_INTERFACE.getFirstScrollerChild(screenDomId);\n        if (!screenScrollerId) {\n          deferred.resolve(promiseReturn);\n          return;\n        }\n      } else {\n        // This is the default continuous scrolling element ID\n        screenScrollerId = 'contentWrapperL';\n      }\n      var maxScrollY = ISCROLL_INTERFACE.getMaxScrollY(screenScrollerId);\n      if (maxScrollY && gomo.outputChecker.isIOSDevice()) {\n        /* We need to add extra padding to the iScroller to make sure we can see what the\n        iOS input popup may be overlaying */\n        maxScrollY = maxScrollY - extraScrollArea;\n        ISCROLL_INTERFACE.setMaxScrollY(screenScrollerId, maxScrollY);\n      }\n      var assetElementId = ASSET_RENDERER.getAssetDOMId(assetData.objRawData);\n      var assetWrapperElementId = ASSET_RENDERER.getAssetWrapperDOMId(assetData.objRawData);\n      var screenScrollerElement = $('#' + screenScrollerId + ' .scrollWrapperC');\n      var screenWrapperPositionTop = screenScrollerElement.length &&\n        screenScrollerElement.position().top;\n      var topStrapElementHeight = $('#topStrapL').height();\n      if ( $('#topStrapL').css('display') === 'none') {\n        topStrapElementHeight = 0;\n      }\n      var bottomStrapElementHeight = $('#topStrapL').height();\n      if ( $('#bottomStrapL').css('display') === 'none') {\n        bottomStrapElementHeight = 0;\n      }\n\n      var focusElement;\n      if (!BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n        focusElement = $('#' + assetElementId);\n      } else {\n        focusElement = $('#' + assetWrapperElementId);\n      }\n      if (focusElement.length === 0 ||\n        focusElement.hasClass(ASSET_INTERACTIONS._strHiddenAssetMarker)) {\n        deferred.resolve(promiseReturn);\n        return;\n      }\n      var focusElementTopPosition = focusElement.position().top;\n      var focusElementHeight = focusElement.height();\n\n      var contentAreaHeight = $('#contentWrapperL').height();\n\n      var disableScrolling = false;\n      // Position of asset from top of viewport minus the topstrap\n      var assetViewportTop = focusElement.offset().top - topStrapElementHeight;\n      // If the asset render starts in the viewport and ends in the viewport\n      if ((assetViewportTop > -1) &&\n        ((assetViewportTop + focusElementHeight) < contentAreaHeight) ) {\n        disableScrolling = true;\n      }\n\n      // if the inputbox is out of view, then move it up\n      var duration = 250;\n      var newFocusPosition = null;\n      if (!BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n        if (contentAreaHeight < minVisibleAreaPx + focusElementTopPosition) {\n          newFocusPosition = screenWrapperPositionTop - focusElementTopPosition;\n          // Don't scroll all the way if it passes our maximum scroll position\n          if (maxScrollY && newFocusPosition < maxScrollY) {\n            newFocusPosition = maxScrollY;\n          }\n        }\n      } else {\n        // Calculate adjustment so asset is centered in the viewport.\n        var viewportHeight =\n          $(window).height() - topStrapElementHeight - bottomStrapElementHeight;\n        var centerAmount = (viewportHeight - focusElementHeight) / 2;\n\n        // Calculate the new scroll top position.\n        var scrollTop = $('#contentWrapperL').scrollTop();\n        if (gomo.outputChecker.applyScrolling()) {\n          scrollTop = Math.abs($('#contentWrapperInnerL').position().top);\n        }\n        newFocusPosition =\n          scrollTop +\n          focusElement.offset().top -\n          topStrapElementHeight;\n        newFocusPosition -= centerAmount;\n        // IScroll needs a negative number.\n        if (gomo.outputChecker.applyScrolling()) {\n          newFocusPosition = newFocusPosition * -1;\n        }\n      }\n      // If the asset is already in view, just activate the screen in JS\n      if (disableScrolling) {\n        SCROLLING_MANAGER.loadScreenFromScrolling(screenId, triggeredFromGomo);\n      } else {\n        SCROLLING_MANAGER.setScrollPosition(newFocusPosition);\n        SCROLLING_MANAGER.disableCenterPosition();\n        SCROLLING_MANAGER.restoreScrollPosition(screenScrollerId, duration);\n        SCROLLING_MANAGER.loadScreenFromScrolling(screenId, triggeredFromGomo);\n        SCROLLING_MANAGER.enableCenterPosition();\n      }\n      setTimeout(function() {\n        deferred.resolve(promiseReturn);\n      }, duration*1.5);\n    };\n    // Delay the scrolling of content to make sure the virtual keyboard has loaded\n    if (setTimeoutDelay !== false) {\n      setTimeout(scrollContent, 250);\n    } else {\n      scrollContent();\n    }\n\n    return deferred.promise();\n  },\n\n  _scrollIntoViewReset_Asset: function() {\n    if (!gomo.outputChecker.applyScrolling()) {\n      return;\n    }\n    ISCROLL_INTERFACE.refreshIScrolls();\n  },\n\n  sendCompletionStatement: function(assetData) {\n    if (!assetData.completionStatementSent) {\n      var rawData = assetData.objRawData;\n      var statement = {\n        type: 'completed',\n        activity: {\n          id: rawData.strID,\n          title: rawData.strLabel,\n          type: 'asset'\n        },\n        result: {\n          completion: true\n        },\n        response: {\n          timeAvailable: assetData.timeAvailable,\n          timeResponse: new Date()\n        },\n        parent: 'page/' + gomo.screenManager.getCurrentScreenData().strObjID,\n        topicGrouping: true,\n        assetType: rawData.strType\n      };\n      CONTENT_TRACKING.interaction(statement);\n      assetData.completionStatementSent = true;\n    }\n  },\n\n  checkEnabledState: function(assetData) {\n    // Ensure we have a valid data object\n    if (typeof(assetData) == 'undefined'\n    || !assetData['arrActions']\n    || typeof(OBJ_REF) == 'undefined') {\n      return true;\n    }\n\n    var actions = assetData.arrActions || [];\n    // Ensure the action has a valid format\n    var validateAction = function(action) {\n      if (typeof(action) !== 'undefined' && action['strType'] == 'internal_link') {\n        if (action['objParameters'] && action.objParameters['target_id']) {\n          return true;\n        }\n      }\n      return false;\n    };\n\n    /*\n    * Method to return a target or attempt to silently load\n    */\n    var getTarget = function(targetID) {\n      if (ACTIONS_INTERACTIONS._is_linear_navigation(targetID)) {\n        var sourceAssetScreenId = '';\n        if (assetData['strID']) {\n          sourceAssetScreenId = assetData.strID.split('a')[0];\n          sourceAssetScreenId = sourceAssetScreenId.split('sub')[0];\n          targetID = TOPIC_MANAGER.getNextOrPreviousScreenId(sourceAssetScreenId, targetID);\n        } else if (assetData['strObjID']) {\n          sourceAssetScreenId = assetData.strObjID.split('a')[0];\n          sourceAssetScreenId = sourceAssetScreenId.split('sub')[0];\n          targetID = TOPIC_MANAGER.getNextOrPreviousScreenId(sourceAssetScreenId, targetID);\n        }\n      }\n      var target = OBJ_REF.get(targetID);\n      if (target === false && targetID) {\n        var topicId = targetID.split('s')[0];\n        TOPIC_MANAGER.silentlyLoadTopicObject({'strTopicID': topicId});\n        target = OBJ_REF.get(targetID);\n      }\n      return target;\n    };\n\n    /*\n    * Method to return rawData of screens that aren't stored in OBJ_REF\n    */\n    var getRawScreenTarget = function(targetID) {\n      var target = OBJ_REF.get(targetID);\n      if (target || !targetID || targetID.indexOf('s') === -1) {\n        return false;\n      }\n\n      var topicId = targetID.split('s')[0];\n      var rawTopicData = OBJ_REF.get(topicId).objRawTopicData;\n      if (rawTopicData && rawTopicData.arrScreens && rawTopicData.arrScreens.length) {\n        var screenCount;\n        for (screenCount = 0; screenCount < rawTopicData.arrScreens.length; screenCount++) {\n          var screenData = rawTopicData.arrScreens[screenCount];\n          if (screenData.strID\n            && screenData.strID === targetID) {\n            target = screenData;\n            break;\n          }\n        }\n      }\n      return target;\n    };\n\n    /*\n    * Method to filter hidden links\n    */\n    var filterHiddenLinkActions = function(action) {\n      if (validateAction(action)) {\n        var target = getTarget(action.objParameters.target_id);\n\n        // Is the link a screen and is it hidden?\n        if (target && target.strObjType === 'screen') {\n          return !target.booIsDisplayed;\n        }\n      }\n      return false;\n    };\n\n    /*\n     * Method to filter actions\n     * this will only return actions which are internal_links\n     * and where the target doesn't exist\n     */\n    var filterInternalBrokenLinkActions = function(action) {\n      if (validateAction(action)) {\n        var target = getTarget(action.objParameters.target_id);\n\n        // Can the target not be found?\n        if (!target) {\n          // Only search for the raw screen if we can't find the target directly\n          var rawScreenTarget = getRawScreenTarget(action.objParameters.target_id);\n          // Assume dynamic screens exist as we haven't set them yet\n          if (rawScreenTarget && rawScreenTarget.strType === 'dynamicContentScreen') {\n            return false;\n          }\n          return true;\n        }\n      }\n      return false;\n    };\n\n    // Get the valid link actions\n    var linkActions = actions.filter(validateAction);\n    // Are there actions other than just internal links?\n    if (actions.length > linkActions.length) {\n      return true;\n    }\n    // Get links to hidden screens\n    var linksToHiddenScreens = linkActions.filter(filterHiddenLinkActions);\n    var brokenInternalLinks = linkActions.filter(filterInternalBrokenLinkActions);\n    // Are all the screens hidden or broken targets?\n    if (linkActions.length === linksToHiddenScreens.length\n      || linkActions.length === brokenInternalLinks.length) {\n      DISPLAY_CONDITIONS_INTERACTIONS.setObjectsLinkedDisplayedState(assetData, false);\n      return false;\n    }\n    DISPLAY_CONDITIONS_INTERACTIONS.setObjectsLinkedDisplayedState(assetData, true);\n    return true;\n  },\n\n  switchAssetState: function(assetData, enabled) {\n    var asset = this.getNewAsset(assetData);\n    if (asset) {\n      asset.switchState();\n    } else if (this['_switchState_' + assetData.strType + '_Asset']) {\n      this['_switchState_' + assetData.strType + '_Asset'](assetData, enabled);\n    }\n  },\n\n  // ***************************************************************************************\n\n  debug: function(strMessage, intPriority, objCallerObject, booCalleeChain) {\n    if (DEBUG) {\n      DEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n    }\n  }\n};\n\nEM.register(ASSET_INTERACTIONS);\n"},function(n,e,t){t(0)(t(125))},function(n,e){n.exports='var DECONTAMINATER =\n{\n\tstrObjID : "",\n\tstrObjDescription : "",\n\n\t_objCurrNonWhiteListChars : {},\n\n\t_regCurrWhiteListRegExp : null,\n\n\t_arrHexChars : [\'0\',\'1\',\'2\',\'3\',\'4\',\'5\',\'6\',\'7\',\'8\',\'9\',\'a\',\'b\',\'c\',\'d\',\'e\',\'f\'],\n\n\tclean : function (_strWhatText)\n\t{\n\t\t//this._createWhiteListRegExp();\n\t\tthis._objCurrNonWhiteListChars = {};\n\n\t\t// Replace the base lookup char\'s\n\t\t_strWhatText = this._processReplaces(_strWhatText, ARR_BASE_CHARACTER_REPLACEMENTS);\n\n\t\t// If present, replace the extended set from PHP\n\t\tif (window[\'ARR_INJECTED_CHARACTER_REPLACEMENTS\'])\n\t\t{\n\t\t\t_strWhatText = this._processReplaces(_strWhatText, ARR_INJECTED_CHARACTER_REPLACEMENTS);\n\t\t}\n\n\t\tthis._generateNonWhiteListItemsLookup(_strWhatText);\n\t\t_strWhatText = this._removeNonWhiteListChars(_strWhatText);\n\t\tvar _objReplacedCharacters = this._collateBarCharactersReport();\n\n\t\treturn {"strText": _strWhatText, "objReplacedCharacters" : _objReplacedCharacters};\n\t},\n\n\toutputStringWithCodes : function (_strWhatString)\n\t{\n\t\tvar count = 0;\n\t\twhile (count < _strWhatString.length)\n\t\t{\n\t\t\tvar _chaCurrLetter = _strWhatString[count];\n\t\t\tthis._debug("\'" + _chaCurrLetter + "\' = " + _chaCurrLetter.charCodeAt(0));\n\t\t\tcount++;\n\t\t}\n\t},\n\n// JC: Depcriated but leave for now\n/*\n\t_createWhiteListRegExp : function ()\n\t{\n\t\tif (!this._regCurrWhiteListRegExp)\n\t\t{\n\t\t\tvar _strRegExpBase = "";\n\t\t\tvar _strToSplit = STR_ADDITIONAL_WHITELIST_CHARACTERS;\n\t\t\tvar _arrCharsToEncode = _strToSplit.split("");\n\t\t\tvar _arrEncodedChars = [];\n\t\t\tvar count = 0;\n\t\t\twhile(count < _arrCharsToEncode.length)\n\t\t\t{\n\t\t\t\tvar _chaCurrCharacterToEncode = _arrCharsToEncode[count];\n\t\t\t\tvar _intCurrCharCode = _chaCurrCharacterToEncode.charCodeAt(0);\n\t\t\t\tvar _hexCurrCharCode = _intCurrCharCode.toString(16);\n\t\t\t\twhile (_hexCurrCharCode.length < 4)\n\t\t\t\t{\n\t\t\t\t\t_hexCurrCharCode = "0" + _hexCurrCharCode;\n\t\t\t\t}\n\n\t\t\t\t_arrEncodedChars.push("\\\\x" + _hexCurrCharCode);\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\tvar _strEncodedChars = _arrEncodedChars.join("");\n\n\t\t\tthis._regCurrWhiteListRegExp = new RegExp(REG_INITIAL_PATTERN + _strEncodedChars + REG_TAIL_PATTERN, "g");\n\t\t}\n\t},\n*/\n\t_processReplaces : function(_strWhatText, _arrWhatReplaces)\n\t{\n\t\tvar count = 0;\n\t\twhile (count < _arrWhatReplaces.length)\n\t\t{\n\t\t\tvar _objCurrReplace = _arrWhatReplaces[count];\n\t\t\t//_chaEscapedTarget = "\\\\" + _objCurrReplace[\'regFind\'];\n\t\t\t//var _regCurrRegExp = new RegExp(_chaEscapedTarget, "g");\n\t\t\tvar _regCurrRegExp = _objCurrReplace[\'regFind\'];\n\t\t\tvar _strCurrReplacement = _objCurrReplace[\'strReplace\'];\n\n\t\t\t_strWhatText = _strWhatText.replace(_regCurrRegExp, _strCurrReplacement);\n\t\t\tcount++;\n\t\t}\n\t\treturn _strWhatText;\n\t},\n\n\t_generateNonWhiteListItemsLookup : function (_strWhatText)\n\t{\n\t\tvar _arrCurrResult;\n\t\twhile ((_arrCurrResult = REG_NON_WHITELIST_CHARS.exec(_strWhatText)) != null)\n\t\t{\n\t\t\tvar _chaCurrMatch = _arrCurrResult[0];\n\t\t\tif (!this._objCurrNonWhiteListChars[_chaCurrMatch])\n\t\t\t{\n\t\t\t\tthis._objCurrNonWhiteListChars[_chaCurrMatch] = 0;\n\t\t\t}\n\t\t\tthis._objCurrNonWhiteListChars[_chaCurrMatch]++;\n\t\t}\n\t},\n\n\t_removeNonWhiteListChars : function(_strWhatText)\n\t{\n\t\tfor (var _chaCurrTarget in this._objCurrNonWhiteListChars)\n\t\t{\n\t\t\t//if (_chaCurrTarget == "\\\\")\n\t\t\t//{\n\t\t\t_chaEscapedTarget = "\\\\" + _chaCurrTarget;\n\t\t\t//}\n\t\t\tvar _regCurrRegExp = new RegExp(_chaEscapedTarget, "g");\n\t\t\tvar _strReplaceEntity = this._encodeNonWhitelistCharacter(_chaCurrTarget);\n\t\t\t_strWhatText = _strWhatText.replace(_regCurrRegExp, _strReplaceEntity);\n\t\t}\n\n\t\t//var _booMatchFound = _strWhatText.match(REG_NON_WHITELIST_CHARS)\n\t\t//if (_booMatchFound)\n\t\t//{\n\t\t//\t_strWhatText = this._removeNonWhiteListChars(_strWhatText);\n\t\t//}\n\n\t\t_strWhatText = this._removeDoubleEscaping(_strWhatText);\n\t\treturn _strWhatText;\n\t},\n\n\t// Copies the list into a new object so it can still be used even when the next\n\t// clean() call is made.\n\t_collateBarCharactersReport : function()\n\t{\n\t\tvar _objCharsReplaced = {};\n\t\tfor (var _chaCurrTarget in this._objCurrNonWhiteListChars)\n\t\t{\n\t\t\t_objCharsReplaced[_chaCurrTarget] = this._objCurrNonWhiteListChars[_chaCurrTarget];\n\t\t}\n\t\treturn _objCharsReplaced;\n\t},\n\n\t_encodeNonWhitelistCharacter : function (_chaWhatCharacter)\n\t{\n\t\tvar _intCharCode = _chaWhatCharacter.charCodeAt(0);\n\t\tif (_intCharCode > 37)\n\t\t{\n\t\t\tvar _intCurrValue = _intCharCode;\n\n\t\t\tvar _hexValue4 = _intCurrValue % 16;\n\n\t\t\t_intCurrValue = Math.floor(_intCurrValue / 16);\n\t\t\tvar _hexValue3 = _intCurrValue % 16;\n\n\t\t\t_intCurrValue = Math.floor(_intCurrValue / 16);\n\t\t\tvar _hexValue2 = _intCurrValue % 16;\n\n\t\t\t_intCurrValue = Math.floor(_intCurrValue / 16);\n\t\t\tvar _hexValue1 = _intCurrValue % 16;\n\n\t\t\treturn "&#x"+ this._arrHexChars[_hexValue1] + this._arrHexChars[_hexValue2] + this._arrHexChars[_hexValue3] + this._arrHexChars[_hexValue4] + ";";\n\t\t}\n\t\treturn "";\n\t},\n\n\t_removeDoubleEscaping : function (_strWhatText)\n\t{\n\t\t//_strWhatText = _strWhatText.replace(/&amp;amp;/g, "&amp;");\n\t\t//_strWhatText = _strWhatText.replace(/&#x0026;/g, "&amp;");\n\t\t_strWhatText = _strWhatText.replace(/(&amp;|&#x0026;)([A-Za-z^;]+|#x[\\dA-Fa-f^;]+|#[\\d^;]+);/g, "&$2;");\n\t\treturn _strWhatText;\n\t},\n\n\t_debug : function (_strWhatMessage)\n\t{\n\t\tif (this._booDebugMessages && window[\'console\'] && window[\'console\'][\'log\'])\n\t\t{\n\t\t\tconsole.log(_strWhatMessage);\n\t\t}\n\t},\n\n\tbooTerminal : true\n}\n\n//var REG_NON_WHITELIST_CHARS = /[^\\w\\!\\\\$\\%\\^\\*\\(\\)\\-\\_\\+\\=\\[\\]\\;\\.\\,\\\\\\/\\{\\}\\:\\@\\?\\#\\~\\|\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ \\n\\r\\t]{1}/g; // "\nvar REG_NON_WHITELIST_CHARS = /[^\\w\\!\\\\$\\%\\^\\*\\(\\)\\-\\_\\+\\=\\[\\]\\;\\.\\,\\\\\\/\\{\\}\\:\\@\\?\\#\\~\\|\\ \\n\\r\\t]{1}/g; // "\n\nvar ARR_INJECTED_CHARACTER_REPLACEMENTS =\n[\n];\n\nvar ARR_BASE_CHARACTER_REPLACEMENTS =\n[\n\t{\n\t\t"regFind" : /</g,\n\t\t"strReplace" : "&lt;"\n\t},\n\t{\n\t\t"regFind" : />/g,\n\t\t"strReplace" : "&gt;"\n\t},\n\t{\n\t\t"regFind" : new RegExp(String.fromCharCode(8230), "g"),\n\t\t"strReplace" : "..."\n\t},\n\t{\n\t\t"regFind" : new RegExp(String.fromCharCode(8211), "g"),\n\t\t"strReplace" : "-"\n\t},\n\t{\n\t\t"regFind" : new RegExp(String.fromCharCode(8220), "g"),\n\t\t"strReplace" : \'"\'\n\t},\n\t{\n\t\t"regFind" : new RegExp(String.fromCharCode(8221), "g"),\n\t\t"strReplace" : \'"\'\n\t},\n\t{\n\t\t"regFind" : new RegExp(String.fromCharCode(8216), "g"),\n\t\t"strReplace" : "\'"\n\t},\n\t{\n\t\t"regFind" : new RegExp("", "g"),\n\t\t"strReplace" : "\'"\n\t},\n\t{\n\t\t"regFind" : new RegExp(String.fromCharCode(163), "g"),\n\t\t"strReplace" : "&pound;"\n\t},\n\t{\n\t\t"regFind" : new RegExp(String.fromCharCode(233), "g"),\n\t\t"strReplace" : "&eacute;"\n\t},\n\t{\n\t\t"regFind" : new RegExp(String.fromCharCode(8217), "g"),\n\t\t"strReplace" : "\'"\n\t},\n\t{\n\t\t"regFind" : new RegExp(String.fromCharCode(34), "g"),\n\t\t"strReplace" : "&quot;"\n\t},\n\t{\n\t\t"regFind" : new RegExp(String.fromCharCode(11), "g"),\n\t\t"strReplace" : " "\n\t}\n];\n\n\n// JC: Depcriated but leave for now\n//var REG_INITIAL_PATTERN = "[^\\\\w";\n//var REG_TAIL_PATTERN = "\\\\ \\\\f\\\\n\\\\r\\\\t]{1}";\n//var STR_ADDITIONAL_WHITELIST_CHARACTERS = "\\!\\"\\\\$\\%\\^\\&\\*\\(\\)\\-\\_\\+\\=\\[\\]\\;\\\'\\.\\,\\\\\\/\\{\\}\\:\\@\\>\\?\\<\\#\\~\\|\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" // "\'\n'},function(n,e,t){t(0)(t(127))},function(n,e){n.exports="/* globals global CORE, ACTIONS_INTERACTIONS, EM, O_EXTENDER, FileOpener, OBJ_REF, OUTPUT_MODE_CHECKER,\n_, BOO_DYMANIC_CONTINUOUS_SCROLLING, TOPIC_MANAGER, DYNAMIC_CONTENT_SCREEN_MANAGER, BOO_ANIMATE_SCREENS, PREVIEW_DATA */\n/**\n * @title Actions Extention - Subscreens\n * @description To be described.\n *\n *\n * @author James Hough\n * @version 2.0 10/01/14\n * REFACTOR NOTE: This file should be split apart and held within the individual actions. If there\n * is required to be a \"central\" navigation then that should be loaded via dependancies.\n */\n\nvar ACTIONS_EXTENTION_NAVIGATION = {\n  _booNavigationWarningMessageShown: false,\n\n  _process_navigation: function(_objActionData, _objOptionalExtraData) {\n    var objAction = {};\n    var checkScreenBounce = false;\n    var bypassScreenCheck = false;\n    // This shouldn't be hard coded like this, it should follow the test for method pattern.\n    if (_objActionData.strType == 'internal_link') {\n      objAction = this._navigation_internal_link(\n        _objActionData,\n        _objOptionalExtraData,\n        checkScreenBounce,\n        bypassScreenCheck\n      );\n    } else if (_objActionData.strType == 'external_link') {\n      objAction = this._navigation_external_link(_objActionData, _objOptionalExtraData);\n    } else if (_objActionData.strType == 'resource_link') {\n      objAction = this._navigation_resource_link(_objActionData, _objOptionalExtraData);\n    } else if (_objActionData.strType == 'metaTopic_link') {\n      objAction = this._navigation_metaTopic_link(_objActionData, _objOptionalExtraData);\n    } else if (_objActionData.strType == 'mailto_link') {\n      objAction = this._navigation_mailto_link(_objActionData, _objOptionalExtraData);\n    } else if (\n      _objActionData.strType == 'goto_previous_screen' ||\n      _objActionData.strType == 'goto_next_screen' ||\n      _objActionData.strType == 'show_menu_screen'\n    ) {\n      checkScreenBounce = true;\n      bypassScreenCheck = true;\n      if (_objActionData.strType == 'goto_previous_screen') {\n        _objActionData.objParameters.target_id = '-1';\n        _objOptionalExtraData.booForceNumericModifier = true;\n      } else if (_objActionData.strType == 'goto_next_screen') {\n        _objActionData.objParameters.target_id = '1';\n        _objOptionalExtraData.booForceNumericModifier = true;\n      } else if (_objActionData.strType == 'show_menu_screen') {\n        var _strTargetId = '';\n        if (\n          CORE.objMenuLoader.strScreenID != '' &&\n          typeof CORE.objMenuLoader.strScreenID != 'undefined'\n        ) {\n          _strTargetId = CORE.objMenuLoader.strScreenID;\n        } else if (\n          CORE.objMenuLoader.strTopicID != '' &&\n          typeof CORE.objMenuLoader.strTopicID != 'undefined'\n        ) {\n          _strTargetId = CORE.objMenuLoader.strTopicID;\n        } else {\n          if (!this._booNavigationWarningMessageShown) {\n            alert(\n              'WARNING: A Topic hasn\\'t been set as a Menu so using Root Topic. ' +\n                'ACTIONS_EXTENTION_NAVIGATION._process_navigation()'\n            );\n            this._booNavigationWarningMessageShown = true;\n          }\n          _strTargetId = CORE.objCourseData.objCourseLaunchers.primaryTopic.strScreenID;\n        }\n        _objActionData.objParameters.target_id = _strTargetId;\n      }\n      objAction = this._navigation_internal_link(\n        _objActionData,\n        _objOptionalExtraData,\n        checkScreenBounce,\n        bypassScreenCheck\n      );\n    } else {\n      alert(\n        'Unrecognised Navigation type of \\'' +\n          _objActionData.strType +\n          '\\'. ACTIONS_EXTENTION_NAVIGATION._process_navigation()'\n      );\n    }\n\n    return objAction;\n  },\n\n  _navigation_internal_link: function(\n    _objActionData,\n    _objOptionalExtraData,\n    checkScreenBounce,\n    bypassScreenCheck\n  ) {\n    var objAction = {};\n    objAction.funActionJob = function(_objActionData, _objOptionalExtraData) {\n      /*\n      * Remove hidden screen alerts if they are currently showing\n      * We're doing this here as sometime the screen is already in view\n      * so showScreen() is never triggered\n      */\n      gomo.alertManager.closeAlert('hiddenscreen');\n      // Check if the screen is available for navigation\n      var processNavigationAction = true;\n      var warningMessageDisplayed = false;\n      // Check for a screen redirect\n      var redirectData = DYNAMIC_CONTENT_SCREEN_MANAGER.getRedirectScreenId(\n        _objActionData.objParameters.target_id\n      );\n      if (redirectData) {\n        console.log('Actions_navigation: redirecting from screen '\n        + _objActionData.objParameters.target_id + ' to screen ' + redirectData.redirect);\n      }\n      if (!bypassScreenCheck) {\n        if (\n          typeof _objActionData.objParameters !== 'undefined' &&\n          typeof _objActionData.objParameters.target_id !== 'undefined' &&\n          _objActionData.objParameters.target_id !== null &&\n          (ACTIONS_INTERACTIONS._navigation_target_is_unlocked_screen(_objActionData) ||\n            ACTIONS_INTERACTIONS._navigation_target_is_topic_with_an_unlocked_screen(\n              _objActionData\n            ) ||\n            ACTIONS_INTERACTIONS._navigation_target_type(_objActionData) === 'course')\n        ) {\n          // If the action hasn't been modified to numeric values then modify now\n          if (\n            _objActionData.objParameters.target_id == 'previousScreen' ||\n            _objActionData.objParameters.target_id == 'nextScreen'\n          ) {\n            _objOptionalExtraData.booForceNumericModifier = true;\n\n            if (_objActionData.objParameters.target_id == 'previousScreen') {\n              _objActionData.objParameters.target_id = '-1';\n              _objActionData.objParameters.forceNumericSetting = true;\n            } else if (_objActionData.objParameters.target_id == 'nextScreen') {\n              _objActionData.objParameters.target_id = '1';\n              _objActionData.objParameters.forceNumericSetting = true;\n            }\n          } else if (_objActionData.objParameters.forceNumericSetting) {\n            // If the forceNumericModifier is needed, then set it\n            _objOptionalExtraData.booForceNumericModifier = true;\n          }\n        } else if (\n          typeof _objActionData.objParameters !== 'undefined' &&\n          typeof _objActionData.objParameters.target_id !== 'undefined' &&\n          _objActionData.objParameters.target_id !== null &&\n          (ACTIONS_INTERACTIONS._navigation_target_type(_objActionData) === 'screen' ||\n            ACTIONS_INTERACTIONS._navigation_target_type(_objActionData) === 'topic') &&\n          _objOptionalExtraData.origin !== 'scrolling_manager'\n        ) {\n          // Warn users when linking to locked topic or normal topic screen\n          if (ACTIONS_INTERACTIONS._navigation_target_is_not_current_screen(_objActionData)) {\n            gomo.alertManager.create(\n              'warning',\n              false,\n              gomo.localiser.get('NAVIGATION_HIDDEN_SCREEN_WARNING'),\n              [{label: gomo.localiser.get('NAVIGATION_ERROR_CLOSE'), type: 'secondary', action: null}],\n              'hiddenscreen'\n            );\n          }\n          // Link failed to work so ending action\n          processNavigationAction = false;\n          warningMessageDisplayed = true;\n          ACTIONS_INTERACTIONS._navigation_complete_action(_objOptionalExtraData);\n        } else {\n          // Link failed to work so ending action\n          processNavigationAction = false;\n          ACTIONS_INTERACTIONS._navigation_complete_action(_objOptionalExtraData);\n        }\n      }\n\n      // Navigate to screen\n      if (processNavigationAction) {\n        ACTIONS_INTERACTIONS.actionCompletedCallBack(_objOptionalExtraData);\n\n        var _objActionRequestData = {};\n\n        if (_objOptionalExtraData) {\n          _objActionRequestData = _objOptionalExtraData;\n        }\n        _objActionRequestData.funCallBack = function() {\n          ACTIONS_INTERACTIONS.actionCompletedCallBack(_objActionRequestData);\n        };\n\n        // If we have a redirect then point to that\n        if (redirectData) {\n          _objActionRequestData.strWhatModifier = redirectData.redirect;\n          _objActionRequestData.redirectParentTopicId = redirectData.topic;\n        } else {\n          _objActionRequestData.strWhatModifier = _objActionData.objParameters.target_id;\n        }\n        _objActionRequestData.booTriggeredByActionsObj = true;\n\n        // If the next screen is locked bounce the next page in horiz scroll topics to show there\n        // is a page there that needs unlocking.\n        if (\n          checkScreenBounce &&\n          ACTIONS_INTERACTIONS._navigation_bounce_screen(_objActionData, _objOptionalExtraData)\n        ) {\n          if (gomo.outputChecker.animationEnabled && BOO_ANIMATE_SCREENS) {\n            EM.trigger('bouncePage', _objActionRequestData);\n          }\n        } else {\n          EM.trigger('preNavigate', _objActionRequestData);\n          EM.trigger('goToPage', _objActionRequestData);\n        }\n      } else {\n        // don't fire on continuous scroll or topics with all\n        // locked screens and we aren't in editor mode\n        if (\n          !warningMessageDisplayed &&\n          _objOptionalExtraData.origin !== 'scrolling_manager' &&\n          !PREVIEW_DATA.editorMode\n        ) {\n          alert('No target set for internal Screen Link.');\n        }\n        ACTIONS_INTERACTIONS.actionCompletedCallBack(_objOptionalExtraData);\n      }\n    };\n\n    objAction.objActionData = _objActionData;\n    objAction.objOptionalExtraData = _objOptionalExtraData;\n\n    return objAction;\n  },\n\n  _navigation_external_link: function(_objActionData, _objOptionalExtraData) {\n    var objAction = {};\n    objAction.funActionJob = function(_objActionData, _objOptionalExtraData) {\n      var _strTargetID = unescape(_objActionData.objParameters.target_id);\n      var targetLocation = '_blank';\n      if (typeof _objActionData.objParameters.target_location !== 'undefined') {\n        targetLocation = _objActionData.objParameters.target_location;\n      }\n\n      if (typeof _strTargetID != 'undefined') {\n        if (_strTargetID.indexOf('http://') == -1 && _strTargetID.indexOf('https://') == -1) {\n          _strTargetID = 'http://' + _strTargetID;\n        }\n        window.open(_strTargetID, targetLocation);\n        ACTIONS_INTERACTIONS.actionCompletedCallBack(_objOptionalExtraData);\n      } else {\n        alert('No target set for external Screen Link.');\n        ACTIONS_INTERACTIONS.actionCompletedCallBack(_objOptionalExtraData);\n      }\n    };\n\n    objAction.objActionData = _objActionData;\n    objAction.objOptionalExtraData = _objOptionalExtraData;\n\n    return objAction;\n  },\n\n  _navigation_mailto_link: function(_objActionData, _objOptionalExtraData) {\n    var objAction = {};\n    objAction.funActionJob = function(_objActionData, _objOptionalExtraData) {\n      // decode special characters\n      var target = document.createElement('span');\n      target.innerHTML = _objActionData.objParameters.target_id;\n\n      var _strTargetID = encodeURIComponent(target.textContent || target.innerText);\n      if (typeof _strTargetID != 'undefined') {\n        if (_strTargetID.indexOf('mailto:') == -1) {\n          _strTargetID = 'mailto:' + _strTargetID;\n        }\n        if (OUTPUT_MODE_CHECKER.booIsSafari()) {\n          window.location.href = _strTargetID;\n        } else {\n          window.open(_strTargetID, '_blank');\n        }\n        ACTIONS_INTERACTIONS.actionCompletedCallBack(_objOptionalExtraData);\n      } else {\n        alert('No Email added for emailto function.');\n        ACTIONS_INTERACTIONS.actionCompletedCallBack(_objOptionalExtraData);\n      }\n    };\n\n    objAction.objActionData = _objActionData;\n    objAction.objOptionalExtraData = _objOptionalExtraData;\n\n    return objAction;\n  },\n\n  _navigation_resource_link: function(_objActionData, _objOptionalExtraData) {\n    var objAction = {};\n    objAction.funActionJob = function(_objActionData, _objOptionalExtraData) {\n      var _strTargetID = decodeURIComponent(_objActionData.objParameters.strResourcePath);\n      if (typeof _strTargetID != 'undefined') {\n        var _strResourceURL = 'resources/' + _strTargetID;\n        var isAndroid =\n          window.device && window.device.platform\n            ? window.device.platform.toLowerCase() === 'android'\n            : false;\n        if (isAndroid && FileOpener) {\n          FileOpener.open(_strResourceURL);\n        } else {\n          window.open(_strResourceURL, '_blank');\n        }\n        ACTIONS_INTERACTIONS.actionCompletedCallBack(_objOptionalExtraData);\n      } else {\n        alert('No target set for resource link.');\n        ACTIONS_INTERACTIONS.actionCompletedCallBack(_objOptionalExtraData);\n      }\n    };\n\n    objAction.objActionData = _objActionData;\n    objAction.objOptionalExtraData = _objOptionalExtraData;\n\n    return objAction;\n  },\n\n  _navigation_metaTopic_link: function(_objActionData, _objOptionalExtraData) {\n    var objAction = {};\n    objAction.funActionJob = function(_objActionData, _objOptionalExtraData) {\n      if (typeof _objActionData.objParameters.target_id != 'undefined') {\n        var _objActionRequestData = {};\n\n        if (_objOptionalExtraData) {\n          _objActionRequestData = _objOptionalExtraData;\n        }\n\n        _objActionRequestData.funCallBack = function() {\n          ACTIONS_INTERACTIONS.actionCompletedCallBack(_objActionRequestData);\n        };\n        _objActionRequestData.strWhatMetaTopicId = _objActionData.objParameters.target_id;\n        _objActionRequestData.booTriggeredByActionsObj = true;\n\n        EM.trigger('loadMetaTopic', _objActionRequestData);\n      } else {\n        alert('No target set for internal Screen Link.');\n        ACTIONS_INTERACTIONS.actionCompletedCallBack(_objOptionalExtraData);\n      }\n    };\n\n    objAction.objActionData = _objActionData;\n    objAction.objOptionalExtraData = _objOptionalExtraData;\n\n    return objAction;\n  },\n\n  _navigation_target_is_unlocked_screen: function(_objActionData) {\n    var targetID = _objActionData.objParameters.target_id;\n    if (ACTIONS_INTERACTIONS._is_linear_navigation(targetID)) {\n      var screenIndex = TOPIC_MANAGER.getNextOrPreviousUnlockedScreenIndex(targetID);\n      return (screenIndex > -1);\n    }\n    var topicId = targetID.split('s')[0];\n    if (!OBJ_REF.testForID(targetID)) {\n      TOPIC_MANAGER.silentlyLoadTopicObject({'strTopicID': topicId});\n    }\n\n    if (OBJ_REF.testForID(targetID)) {\n      var ref = OBJ_REF.get(targetID);\n      if (ref.strObjType === 'screen' && ref.booIsDisplayed) {\n        return true;\n      }\n    } else {\n      /*\n      * If the screen is Dynamic screen then allow\n      * as the topic isn't built yet to check for the screen\n      */\n      if (!targetID || targetID.indexOf('s') === -1) {\n        return false;\n      }\n      var rawTopicData = OBJ_REF.get(topicId).objRawTopicData;\n      if (rawTopicData && rawTopicData.arrScreens && rawTopicData.arrScreens.length) {\n        var screenCount;\n        for (screenCount = 0; screenCount < rawTopicData.arrScreens.length; screenCount++) {\n          var screenData = rawTopicData.arrScreens[screenCount];\n          if (screenData.strID\n            && screenData.strID === targetID\n            && screenData.strType === 'dynamicContentScreen') {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  },\n\n  _navigation_target_is_topic_with_an_unlocked_screen: function(_objActionData) {\n    var targetID = _objActionData.objParameters.target_id;\n    if (this._is_linear_navigation(targetID)) return false;\n    // element ref exists\n    if (OBJ_REF.testForID(targetID)) {\n      var ref = OBJ_REF.get(targetID);\n      // not a topic\n      if (ref.strObjType && ref.strObjType !== 'topic') return false;\n      // load topic\n      TOPIC_MANAGER.silentlyLoadTopicObject({strTopicID: targetID});\n      // refresh ref after topic load\n      ref = OBJ_REF.get(targetID);\n      // has an unlocked screen\n      var unlockedScreen = _.findWhere(ref.arrScreens, {booIsDisplayed: true});\n      // has an unlocked screen\n      return typeof unlockedScreen !== 'undefined';\n    }\n  },\n\n  _navigation_target_is_standard_topic: function(_objActionData) {\n    var targetID = _objActionData.objParameters.target_id;\n\n    if (OBJ_REF.testForID(targetID)) {\n      var ref = OBJ_REF.get(targetID);\n      if (ref.strObjType && ref.strObjType === 'topic'\n        && typeof BOO_DYMANIC_CONTINUOUS_SCROLLING !== 'undefined' &&\n        BOO_DYMANIC_CONTINUOUS_SCROLLING === false\n      ) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  _navigation_target_type: function(_objActionData) {\n    var targetID = _objActionData.objParameters.target_id;\n\n    if (typeof targetID !== 'undefined') {\n      // target of linear nav will always be screen\n      if (this._is_linear_navigation(targetID)) return 'screen';\n      if (OBJ_REF.testForID(targetID)) {\n        var ref = OBJ_REF.get(targetID);\n        if (ref.strObjType) return ref.strObjType;\n      }\n    }\n    return false;\n  },\n\n  _navigation_target_is_not_current_screen: function(_objActionData) {\n    var targetID = _objActionData.objParameters.target_id;\n    var currentNavIndex = TOPIC_MANAGER._objCurrCourseObject.intNavigationIndex;\n    var targetNavIndex;\n    if (ACTIONS_INTERACTIONS._is_linear_navigation(targetID)) {\n      // is first or last screen\n      if (currentNavIndex === 0 && (targetID == 'previousScreen' || targetID === '-1')\n      || currentNavIndex === TOPIC_MANAGER._objCurrCourseObject.arrScreens.length - 1\n      && (targetID == 'nextScreen' || targetID === '1')) {\n        return false;\n      } else {\n        targetNavIndex = TOPIC_MANAGER.getNextOrPreviousUnlockedScreenIndex(targetID);\n        if (targetNavIndex === currentNavIndex) return false;\n      }\n    }\n    return true;\n  },\n\n  _is_linear_navigation: function(targetID) {\n    return (targetID === 'previousScreen' ||\n      targetID === 'nextScreen' ||\n      targetID === '1' ||\n      targetID === '-1'\n    );\n  },\n\n  _navigation_bounce_screen: function(_objActionData, _objOptionalExtraData) {\n    var bounceIt = false;\n    var currentObject = CORE.objCurrCourseObject;\n    var nextUnlockedScreen = -1;\n    var remainingScreens;\n    var targetID = _objActionData.objParameters.target_id;\n\n    if (typeof targetID !== 'undefined') {\n      if (targetID === '1' || targetID === '-1') {\n        if (targetID === '1') {\n          remainingScreens = _.rest(currentObject.arrScreens, currentObject.intNavigationIndex + 1);\n        } else if (targetID === '-1') {\n          remainingScreens = currentObject.arrScreens.slice(0, currentObject.intNavigationIndex);\n        }\n        if (remainingScreens.length) {\n          if (targetID === '1') {\n            nextUnlockedScreen = _.findIndex(remainingScreens, {booIsDisplayed: true});\n          } else if (targetID === '-1') {\n            nextUnlockedScreen = _.findLastIndex(remainingScreens, {booIsDisplayed: true});\n          }\n        }\n        if (nextUnlockedScreen < 0) {\n          bounceIt = true;\n        }\n      }\n    }\n    return bounceIt;\n  },\n\n  _navigation_complete_action: function(_objOptionalExtraData) {\n    var _objActionRequestData = {};\n    if (_objOptionalExtraData) {\n      _objActionRequestData = _objOptionalExtraData;\n    }\n    ACTIONS_INTERACTIONS.actionCompletedCallBack(_objActionRequestData);\n  }\n};\n\nO_EXTENDER.extend(ACTIONS_INTERACTIONS, ACTIONS_EXTENTION_NAVIGATION);\n"},function(n,e,t){t(0)(t(129))},function(n,e){n.exports='/**\n* @title Actions Extention - Subscreens\n* @description To be described.\n*\n*\n* @author James Hough\n* @version 2.0 10/01/14\n*/\n\nvar ACTIONS_EXTENTION_SUBSCREEN =\n{\n\t_process_subscreen : function(_objActionData, _objOptionalExtraData)\n\t{\n\t\tvar objAction = {};\n\n\t\tif (_objActionData.strType == "showSubScreen" || _objActionData.strActionType == "showSubScreen")\n\t\t{\n\t\t\tobjAction = this._show_subscreen(_objActionData, _objOptionalExtraData);\n\t\t}\n\t\telse if (_objActionData.strType == "hide_all_subscreens" || _objActionData.strActionType == "hide_all_subscreens")\n\t\t{\n\t\t\tobjAction = this._hide_all_subscreens(_objActionData, _objOptionalExtraData);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar undefinedObject = _objActionData.strType;\n\t\t\tif (typeof _objActionData.strType == "undefined")\n\t\t\t{\n\t\t\t\tundefinedObject = _objActionData.strActionType\n\t\t\t}\n\t\t\talert("Unrecognised subscreen type of \'" + undefinedObject + "\'. ACTIONS_EXTENTION_NAVIGATION._process_subscreen()");\n\t\t}\n\n\t\treturn objAction;\n\t},\n\n\t_show_subscreen : function (_objActionData, _objOptionalExtraData)\n\t{\n\t\tvar objAction = {};\n\t\tobjAction.funActionJob = function(_objActionData, _objOptionalExtraData)\n\t\t{\n\t\t\tif ((_objActionData.objParameters.strSubScreenID) && (_objActionData.objParameters.strSubScreenID != "null"))\n\t\t\t{\n\t\t\t\tvar _objActionRequestData = {};\n\n\t\t\t\tif (_objOptionalExtraData)\n\t\t\t\t{\n\t\t\t\t\t_objActionRequestData = _objOptionalExtraData;\n\t\t\t\t}\n\n\t\t\t\t_objActionRequestData.funCallBack = function(){ACTIONS_INTERACTIONS.actionCompletedCallBack(_objActionRequestData)};\n\t\t\t\t_objActionRequestData.strTargetSubScreenID = _objActionData.objParameters.strSubScreenID;\n\t\t\t\t_objActionRequestData.booTriggeredByActionsObj = true;\n\t\t\t\t_objActionRequestData.domLink = _objOptionalExtraData.domLink;\n\n\t\t\t\tEM.trigger("showSubScreen", _objActionRequestData);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\n\t\t\t\talert("ERROR: Please set a sub screen for this item.");\n\t\t\t\t//LOCALISER.l_alert("ERROR: Please set a subscreen ID for this item.");\n\t\t\t}\n\t\t};\n\n\t\tobjAction.objActionData = _objActionData;\n\t\tobjAction.objOptionalExtraData = _objOptionalExtraData;\n\n\t\treturn objAction;\n\t},\n\n\t_hide_all_subscreens : function(_objActionData, _objOptionalExtraData) {\n\t\tvar objAction = {};\n\t\tobjAction.funActionJob = function(_objActionData, _objOptionalExtraData)\n\t\t{\n\t\t\tSUB_SCREEN_INTERACTIONS.hideSubScreens(true);\n\t\t\tACTIONS_INTERACTIONS.actionCompletedCallBack(_objOptionalExtraData);\n\t\t};\n\n\t\tobjAction.objActionData = _objActionData;\n\t\tobjAction.objOptionalExtraData = _objOptionalExtraData;\n\t\treturn objAction;\n\t}\n};\n\nO_EXTENDER.extend(ACTIONS_INTERACTIONS, ACTIONS_EXTENTION_SUBSCREEN);\n'},function(n,e,t){t(0)(t(131))},function(n,e){n.exports='/**\n* @title Actions Extention - Variables\n* @description To be described.\n*\n*\n* @author James Hough\n* @version 2.0 17/01/14\n*/\n\nvar ACTIONS_EXTENTION_VARIABLES =\n{\n\t_process_variables : function (_objActionData, _objOptionalExtraData)\n\t{\n\t\tvar objAction = {};\n\n\t\tif (_objActionData.strType == "setAccessibilityState")\n\t\t{\n\t\t\tobjAction = this._set_variables_accessibility_state(_objActionData, _objOptionalExtraData);\n\t\t}\n\t\telse if (_objActionData.strType == "setVariable")\n\t\t{\n\t\t\tobjAction = this._set_variables_state_general(_objActionData, _objOptionalExtraData);\n\t\t}\n\t\telse\n\t\t{\n\t\t\talert("Unrecognised Variables action type of \'" + _objActionData.strType + "\'. ACTIONS_EXTENTION_VARIABLES._process_variables(), actions_variables.js");\n\t\t}\n\n\t\treturn objAction;\n\t},\n\n\t_set_variables_accessibility_state : function (_objActionData, _objOptionalExtraData)\n\t{\n\t\tvar objAction = {};\n\t\tobjAction.funActionJob = function(_objActionData, _objOptionalExtraData)\n\t\t{\n\t\t\tif (typeof _objActionData.objParameters.strStateToSetTo != "undefined"\n\t\t\t    && ACTIONS_INTERACTIONS._booCanChangeState())\n\t\t\t{\n\t\t\t\tvar _strStateToSetTo = ACTIONS_INTERACTIONS._setStateToSanitiser(_objActionData.objParameters.strStateToSetTo);\n\n\t\t\t\tvar _objActionRequestData = {};\n\n\t\t\t\tif (_objOptionalExtraData)\n\t\t\t\t{\n\t\t\t\t\t_objActionRequestData = _objOptionalExtraData;\n\t\t\t\t}\n\n\t\t\t\t_objActionRequestData.funCallBack = function(){ACTIONS_INTERACTIONS.actionCompletedCallBack(_objActionRequestData)};\n\t\t\t\t_objActionRequestData.strWhatModifier = _objActionData.objParameters.target_id;\n\t\t\t\t_objActionRequestData.booTriggeredByActionsObj = true;\n\t\t\t\t_objActionRequestData.objActionTriggerParams = {\'strWhatVersionChoice\':_strStateToSetTo, \'booSurpressReRender\':false};\n\n\t\t\t\tEM.trigger("userVersionChoice", _objActionRequestData);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\talert("No set to data or device not supported.");\n\t\t\t\tACTIONS_INTERACTIONS.actionCompletedCallBack();\n\t\t\t}\n\t\t};\n\n\t\tobjAction.objActionData = _objActionData;\n\t\tobjAction.objOptionalExtraData = _objOptionalExtraData;\n\n\t\treturn objAction;\n\t},\n\n\t_set_variables_state_general : function (_objActionData, _objOptionalExtraData)\n\t{\n\t\tvar _objAction = {};\n\t\t_objAction.funActionJob = function(_objActionData, _objOptionalExtraData)\n\t\t{\n\t\t\tvar _objParameters = _objActionData.objParameters;\n\n\t\t\t//We may have many variable updates so we only want to action post processes (mainly on the render output) once\n\t\t\tvar deferPostUpdateActions = true;\n\t\t\tvar _objEventData =\n\t\t\t{\n\t\t\t\t"strVariableName" : _objParameters["strVariableID"],\n\t\t\t\t"strVariableValue" : _objParameters["strValueToSetToo"],\n\t\t\t\t"deferPostUpdateActions" : deferPostUpdateActions\n\t\t\t}\n\n\t\t\tEM.trigger("updateVariableValue", _objEventData);\n\n\t\t\tif (_objOptionalExtraData)\n\t\t\t{\n\t\t\t\t_objActionRequestData = _objOptionalExtraData;\n\t\t\t}\n\n\t\t\tACTIONS_INTERACTIONS.actionCompletedCallBack(_objActionRequestData);\n\t\t}\n\n\t\t//Set a defered task to run once at the end of all the actions\n\t\tvar taskObject = {\n\t\t\t"taskName" : "postGroupAssetDisplayStatesUpdated",\n\t\t\t"taskFun" : ASSET_INTERACTIONS.postGroupAssetDisplayStatesUpdated\n\t\t};\n\t\tthis._setDeferedTask(taskObject);\n\n\t\t_objAction.objActionData = _objActionData;\n\t\t_objAction.objOptionalExtraData = _objOptionalExtraData;\n\n\t\treturn _objAction;\n\t},\n\n\t_setStateToSanitiser : function (_strRawSetStateTo)\n\t{\n\t\tvar _strStateToSetTo = _strRawSetStateTo;\n\n\t\tif (_strRawSetStateTo == "toggle")\n\t\t{\n\t\t\tif (OUTPUT_MODE_CHECKER.strCurrentMode == "graphicalC")\n\t\t\t{\n\t\t\t\t_strStateToSetTo = "accessible";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t_strStateToSetTo = "graphical";\n\t\t\t}\n\t\t}\n\t\telse if (_strStateToSetTo == "graphicalC")\n\t\t{\n\t\t\t_strStateToSetTo = "graphical";\n\t\t}\n\t\telse if (_strStateToSetTo == "accessibleC")\n\t\t{\n\t\t\t_strStateToSetTo = "accessible";\n\t\t}\n\n\t\treturn _strStateToSetTo;\n\t},\n\n\t_booCanChangeState : function ()\n\t{\n\t\tif (OUTPUT_MODE_CHECKER.strCurrentMode == "smartphoneC"\n\t\t\t|| OUTPUT_MODE_CHECKER.strCurrentMode == "tabletC" )\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n};\n\nO_EXTENDER.extend(ACTIONS_INTERACTIONS, ACTIONS_EXTENTION_VARIABLES);\n'},function(n,e,t){t(0)(t(133))},function(n,e){n.exports="/* globals CORE, OBJ_REF, ASSET_RENDERER, ACTIONS_INTERACTIONS, O_EXTENDER */\n/**\n * @title Actions Extention - Asset setters\n * @description This collection of actions will be responsible for setting Asset states from OUTSIDE of the assets own layer of interactivity.\n *\n *\n * @author Johnathan Castle\n * @version 2.0 14/05/14\n */\n\nvar ACTIONS_EXTENTION_ASSET_SETTERS = {\n  _process_asset_setter: function(_objActionData, _objOptionalExtraData) {\n    var objAction = {};\n\n    if (_objActionData.strType == 'setImageAction') {\n      objAction = this._setImageStateAction(\n        _objActionData,\n        _objOptionalExtraData\n      );\n    } else {\n      alert(\n        'Unrecognised asset setter action type of \\'' +\n          _objActionData.strType +\n          '\\'. ACTIONS_EXTENTION_ASSET_SETTERS._process_asset_setter()'\n      );\n    }\n\n    return objAction;\n  },\n\n  _setImageStateAction: function(_objActionData, _objOptionalExtraData) {\n    var _objAction = {};\n\n    _objAction.funActionJob = function(_objActionData, _objOptionalExtraData) {\n      var _objParameters = _objActionData.objParameters;\n      var _strImageAssetClass = 'imageAssetC';\n\n      var _strTargetAssetID = _objParameters.strImageAssetID;\n      var _strNewPathToSwitchToo = _objParameters.strResourcePath;\n      var _strNewAltTextToSwitchToo = _objParameters.strAltText;\n\n      if (!_strTargetAssetID || _strTargetAssetID === '') {\n        alert('Please specify an image to update.');\n        return;\n      }\n\n      if (!OBJ_REF.testForID(_strTargetAssetID)) {\n        alert('Unable to find the specified image to update.');\n        return;\n      }\n\n      var _objTargetAssetData = OBJ_REF.get(_strTargetAssetID);\n      var _domAssetWrapper = ASSET_RENDERER.getAssetDOMElement(\n        _objTargetAssetData.objRawData\n      );\n      var _domImage = CORE.getElementsByClassName(\n        _domAssetWrapper,\n        _strImageAssetClass\n      )[0];\n\n      _domImage.src =\n        gomo.utility.getSrcPath(_strNewPathToSwitchToo) +\n        decodeURIComponent(_strNewPathToSwitchToo);\n      _domImage.alt = _strNewAltTextToSwitchToo;\n      _domImage.title = _strNewAltTextToSwitchToo;\n\n      var _objActionRequestData = {};\n      if (_objOptionalExtraData) {\n        _objActionRequestData = _objOptionalExtraData;\n      }\n\n      ACTIONS_INTERACTIONS.actionCompletedCallBack(_objActionRequestData);\n    };\n\n    _objAction.objActionData = _objActionData;\n    _objAction.objOptionalExtraData = _objOptionalExtraData;\n\n    return _objAction;\n  },\n\n  booTerminal: true\n};\n\nO_EXTENDER.extend(ACTIONS_INTERACTIONS, ACTIONS_EXTENTION_ASSET_SETTERS);\n"},function(n,e,t){t(0)(t(135))},function(n,e){n.exports='/**\n* @title Actions Extention - Course setters\n* @description This collection of actions will be responsible for setting Course states from OUTSIDE of the internal mechanisms of the core player code.\n*\n*\n* @author Johnathan Castle\n* @version 2.0 14/05/14\n*/\n\nvar ACTIONS_EXTENTION_COURSE_SETTERS =\n{\n\t_process_course_setter : function (_objActionData, _objOptionalExtraData)\n\t{\n\t\tvar objAction = {};\n\n\t\tif (_objActionData.strType == "setCourseOverallScore")\n\t\t{\n\t\t\tobjAction = this._setCourseOverallScoreAction(_objActionData, _objOptionalExtraData);\n\t\t}\n\t\telse if (_objActionData.strType == "setCourseCompletion")\n\t\t{\n\t\t\tobjAction = this._setCourseCompletionAction(_objActionData, _objOptionalExtraData);\n\t\t}\n\t\telse\n\t\t{\n\t\t\talert("Unrecognised course setter action type of \'" + _objActionData.strType + "\'. ACTIONS_EXTENTION_COURSE_SETTERS._process_course_setter()");\n\t\t}\n\n\t\treturn objAction;\n\t},\n\n\t_setCourseOverallScoreAction : function (_objActionData, _objOptionalExtraData)\n\t{\n\t\tvar _objAction = {};\n\n\t\t_objAction.funActionJob = function(_objActionData, _objOptionalExtraData)\n\t\t{\n\t\t\tvar _objParameters = _objActionData.objParameters;\n\t\t\tvar score = _objParameters.strStateToSetTo;\n\t\t\tif(!isNaN(+score)){\n\t\t\t\tscore = +score;\n\t\t\t\tCORE.setCourseScore(score);\n\t\t\t}\n\t\t\t\n\t\t\t//EM.trigger("updateCourseScore", _objParameters.strStateToSetTo);\n\n\n\t\t\tif (_objOptionalExtraData)\n\t\t\t{\n\t\t\t\t_objActionRequestData = _objOptionalExtraData;\n\t\t\t}\n\n\t\t\tACTIONS_INTERACTIONS.actionCompletedCallBack(_objActionRequestData);\n\t\t}\n\n\t\t_objAction.objActionData = _objActionData;\n\t\t_objAction.objOptionalExtraData = _objOptionalExtraData;\n\n\t\treturn _objAction;\n\t},\n\n\t_setCourseCompletionAction : function (_objActionData, _objOptionalExtraData)\n\t{\n\t\tvar _objAction = {};\n\n\t\t_objAction.funActionJob = function(_objActionData, _objOptionalExtraData)\n\t\t{\n\t\t\tvar _objParameters = _objActionData.objParameters;\n\n\n\n\t\t\tswitch (_objParameters.strStateToSetTo)\n\t\t\t{\n\t\t\t\tcase "not attempted":\n\t\t\t\t\tEM.trigger("resetCourseCompletion");\n\t\t\t\tbreak;\n\t\t\t\tcase "incomplete":\n\t\t\t\t\tEM.trigger("courseStarted");\n\t\t\t\tbreak;\n\t\t\t\tcase "completed":\n\t\t\t\t\t//EM.trigger("courseCompleted");\n\t\t\t\t\tCORE.setCourseCompleted();\n\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (_objOptionalExtraData)\n\t\t\t{\n\t\t\t\t_objActionRequestData = _objOptionalExtraData;\n\t\t\t}\n\n\t\t\tACTIONS_INTERACTIONS.actionCompletedCallBack(_objActionRequestData);\n\t\t}\n\n\t\t_objAction.objActionData = _objActionData;\n\t\t_objAction.objOptionalExtraData = _objOptionalExtraData;\n\n\t\treturn _objAction;\n\t},\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(ACTIONS_INTERACTIONS, ACTIONS_EXTENTION_COURSE_SETTERS);'},function(n,e,t){t(0)(t(137))},function(n,e){n.exports='/**\n* @title Actions Extention - Pre-process events\n* @description These are checked for upon asset instantsaition.\n*\n*\n* @author Johnathan Castle\n* @version 1.0 11/11/14\n*/\n\nvar ACTIONS_EXTENTION_PREPROCESS =\n{\n\t_process_preprocess : function (_objActionData, _objOptionalExtraData)\n\t{\n\t\tvar objAction = {};\n\n\t\tif (_objActionData.strActionType == "createSubScreenFromText")\n\t\t{\n\t\t\tthis._createSubScreenFromText(_objActionData, _objOptionalExtraData);\n\t\t}\n\t\telse\n\t\t{\n\t\t\talert("Unrecognised PreProcess action type of \'" + _objActionData.strType + "\'. ACTIONS_EXTENTION_PREPROCESS._process_preprocess()");\n\t\t}\n\n\t\treturn objAction;\n\t},\n\n\t_createSubScreenFromText : function (_objActionData, _objOptionalExtraData)\n\t{\n\t\tvar _objNewSubscreenFromText = TOPIC_STRUCTURE_PARSER.transferTextPropertyIntoSubScreen(_objOptionalExtraData.objParentAssetDataHolder, _objActionData.objParameters.strTextToCreateSubScreenID);\n\t\tvar _objParentScreen = _objOptionalExtraData.objParentAssetDataHolder.objParent;\n\t\tif (_objParentScreen.strObjType == "subscreen")\n\t\t{\n\t\t\t_objParentScreen = _objParentScreen.objParent;\n\t\t}\n\t\t_objParentScreen.objRawData.arrSubscreens.push(_objNewSubscreenFromText);\n\n\t\tvar tempBooAssetOwned = _objActionData.objParameters.booAssetOwnedSubscreen || false;\n\t\t\n\t\t//This is needed for SUBSCREEN_RENDERER.rerenderSubScreen();\n\t\t_objNewSubscreenFromText.booAssetOwnedSubscreen = tempBooAssetOwned;\n\n\t\tvar subscreenUUID = _objActionData.subscreenUuid || null;\n\t\t// Delete all the previous properties but keep the object reference\n\t\tfor (var _strCurrProperty in _objActionData)\n\t\t{\n\t\t\tdelete _objActionData[_strCurrProperty];\n\t\t}\n\n\t\t// Inject the new properties\n\t\t_objActionData.strActionType = "showSubScreen";\n\t\t_objActionData.strActionGroup = "subscreen";\n\t\t_objActionData.objParameters =\n\t\t{\n\t\t\tstrSubScreenID : _objNewSubscreenFromText.strID,\n\t\t\tstrSubScreenUUID : subscreenUUID,\n\t\t\tbooAssetOwnedSubscreen : tempBooAssetOwned\n\t\t};\n\t\t_objActionData.strObjectType = "action";\n\t},\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(ACTIONS_INTERACTIONS, ACTIONS_EXTENTION_PREPROCESS);\n'},function(n,e,t){t(0)(t(139))},function(n,e){n.exports="/* globals PREVIEW_DATA, ACTIONS_INTERACTIONS, ASSET_INTERACTIONS, O_EXTENDER */\n/**\n * @title Actions Extention - Subscreens\n * @description To be described.\n *\n *\n * @author James Hough\n * @version 2.0 10/01/14\n * REFACTOR NOTE: This file should be split apart and held within the individual actions.\n * If there is required to be a \"central\" navigation then that should be loaded via dependancies.\n */\n\nvar ACTIONS_EXTENTION_INTERACTIONS = {\n  _process_interaction: function(_objActionData, _objOptionalExtraData) {\n    var objAction = {};\n\n    // This shouldn't be hard coded like this, it should follow the test for method pattern.\n    if (_objActionData.strType == 'playAudioAsset') {\n      objAction = this._interaction_play_audio(_objActionData, _objOptionalExtraData);\n    } else if (_objActionData.strType == 'setLanguage') {\n      if (PREVIEW_DATA.editorMode) {\n        var alertType = 'warning';\n        var title = 'Action disabled';\n        var message = 'Language switching is disabled in this view.';\n        var buttons = [\n          {\n            label: 'Ok',\n            type: 'primary',\n            action: function() {}\n          }\n        ];\n        gomo.alertManager.create(alertType, title, message, buttons);\n        return false;\n      }\n      objAction = this._interaction_set_language(_objActionData, _objOptionalExtraData);\n    } else {\n      alert(\n        'Unrecognised Interaction type of ' +\n          _objActionData.strType +\n          '. ACTIONS_EXTENTION_NAVIGATION._process_navigation()'\n      );\n    }\n\n    return objAction;\n  },\n\n  _interaction_play_audio: function(_objActionData, _objOptionalExtraData) {\n    var objAction = {};\n    objAction.funActionJob = function(_objActionData, _objOptionalExtraData) {\n      if (typeof _objActionData.objParameters.strAudioAssetID != 'undefined') {\n        var _objActionRequestData = {};\n\n        if (_objOptionalExtraData) {\n          _objActionRequestData.optional = _objOptionalExtraData;\n        } else {\n          _objActionRequestData.optional = null;\n        }\n\n        _objActionRequestData.assetId = _objActionData.objParameters.strAudioAssetID;\n        _objActionRequestData.actionType = _objActionData.objParameters.strAudioAction || 'play';\n        _objActionRequestData.funCallBack = function() {\n          ACTIONS_INTERACTIONS.actionCompletedCallBack(_objActionRequestData.optional);\n        };\n        _objActionRequestData.booTriggeredByActionsObj = true;\n\n        if (ASSET_INTERACTIONS.playAudioAsset) {\n          ASSET_INTERACTIONS.playAudioAsset(_objActionRequestData);\n        }\n      } else {\n        alert('No target set for internal Screen Link.');\n      }\n    };\n\n    objAction.objActionData = _objActionData;\n    objAction.objOptionalExtraData = _objOptionalExtraData;\n\n    return objAction;\n  },\n\n  _interaction_set_language: function(_objActionData, _objOptionalExtraData) {\n    var objAction = {};\n    objAction.funActionJob = function(_objActionData, _objOptionalExtraData) {\n      if (typeof _objActionData.objParameters.languageId != 'undefined') {\n        var _objActionRequestData = {};\n\n        if (_objOptionalExtraData) {\n          _objActionRequestData.optional = _objOptionalExtraData;\n        } else {\n          _objActionRequestData.optional = null;\n        }\n\n        _objActionRequestData.langCode = _objActionData.objParameters.languageId;\n        _objActionRequestData.funCallBack = function() {\n          ACTIONS_INTERACTIONS.actionCompletedCallBack(_objActionRequestData.optional);\n        };\n        _objActionRequestData.booTriggeredByActionsObj = true;\n\n        if (gomo.translationManager && gomo.translationManager.setTranslationAction) {\n          gomo.translationManager.setTranslationAction(_objActionRequestData);\n        }\n      } else {\n        alert('No target language set.');\n      }\n    };\n\n    objAction.objActionData = _objActionData;\n    objAction.objOptionalExtraData = _objOptionalExtraData;\n\n    return objAction;\n  }\n};\n\nO_EXTENDER.extend(ACTIONS_INTERACTIONS, ACTIONS_EXTENTION_INTERACTIONS);\n"},function(n,e,t){t(0)(t(141))},function(n,e){n.exports="/* global VARIABLES_HOLDER, O_EXTENDER, DISPLAY_CONDITIONS_INTERACTIONS */\n/**\n * @title Display condition extension - accessibility state\n * @description To be described.\n *\n * @author JC\n * @version 1.0 12-6-14\n */\n\nvar DISPLAY_CONDITION_ACCESSIBILITY_STATE = {\n  strObjID: 'Display condition - accessibility state',\n\n  _checkCondition_accessibilityStateDisplayCondition: function(_objCurrCondition) {\n    var _strVariableToTestAgainst = _objCurrCondition.objParameters.strVariableToCheck;\n    var _strValueToTestAgainst = _objCurrCondition.objParameters.strValueToTestAgainst;\n    var _strComparisonType = _objCurrCondition.objParameters.strConditionTest;\n\n    var _strCurrVariableValue = VARIABLES_HOLDER.getVariableValue(_strVariableToTestAgainst);\n\n    var _booComparisonResult = this._performStandardValueComparison(\n      _strComparisonType,\n      _strValueToTestAgainst,\n      _strCurrVariableValue\n    );\n\n    // PhantomJS override. Accessible mode onload can break the player if set to a screen display condition\n    if (window.callPhantom && _strVariableToTestAgainst === 'gomo_accessibility_state') {\n      _booComparisonResult = true;\n    }\n\n    return _booComparisonResult;\n  },\n\n  booTerminal: true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_ACCESSIBILITY_STATE);\n"},function(n,e,t){t(0)(t(143))},function(n,e){n.exports='/**\n* @title Display condition extension - Asset correctness\n* @description To be described.\n*\n* @author JC\n* @version 1.0 28-10-14\n*/\n\nvar DISPLAY_CONDITION_ASSET_CORRECTNESS =\n{\n\tstrObjID : "Display condition - Asset correctness",\n\n\t_checkCondition_assetCorrectDisplayCondition : function (_objCurrCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objCurrCondition.objParameters.strVariableToCheck + "." + _objCurrCondition.objParameters.strAssetToTestAgainst;\n\t\tvar _strValueToTestAgainst = _objCurrCondition.objParameters.strValueToTestAgainst;\n\t\tvar _strComparisonType = _objCurrCondition.objParameters.strConditionTest;\n\n\t\tvar _strCurrVariableValue = VARIABLES_HOLDER.getVariableValue(_strVariableToTestAgainst);\n\n\t\tvar _booComparisonResult = this._performStandardValueComparison(_strComparisonType, _strValueToTestAgainst, _strCurrVariableValue);\n\t\treturn _booComparisonResult;\n\t},\n\n\t_preProcessDisplayConditionVariableName_gomo_asset_correct : function (_objWhatCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objWhatCondition.objParameters.strVariableToCheck + "." + _objWhatCondition.objParameters.strAssetToTestAgainst;\n\t\treturn _strVariableToTestAgainst;\n\t},\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_ASSET_CORRECTNESS);'},function(n,e,t){t(0)(t(145))},function(n,e){n.exports='/**\n* @title Display condition extension - Asset interacted\n* @description To be described.\n*\n* @author JC\n* @version 1.0 28-10-14\n*/\n\nvar DISPLAY_CONDITION_ASSET_INTERACTED =\n{\n\tstrObjID : "Display condition - Asset interacted",\n\n\t_checkCondition_assetInteractedDisplayCondition : function (_objCurrCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objCurrCondition.objParameters.strVariableToCheck + "." + _objCurrCondition.objParameters.strAssetToTestAgainst;\n\t\tvar _strValueToTestAgainst = _objCurrCondition.objParameters.strValueToTestAgainst;\n\t\tvar _strComparisonType = _objCurrCondition.objParameters.strConditionTest;\n\n\t\tvar _strCurrVariableValue = VARIABLES_HOLDER.getVariableValue(_strVariableToTestAgainst);\n\n\t\tvar _booComparisonResult = this._performStandardValueComparison(_strComparisonType, _strValueToTestAgainst, _strCurrVariableValue);\n\t\treturn _booComparisonResult;\n\t},\n\n\t_preProcessDisplayConditionVariableName_gomo_asset_interacted : function (_objWhatCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objWhatCondition.objParameters.strVariableToCheck + "." + _objWhatCondition.objParameters.strAssetToTestAgainst;\n\t\treturn _strVariableToTestAgainst;\n\t},\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_ASSET_INTERACTED);'},function(n,e,t){t(0)(t(147))},function(n,e){n.exports='/**\n* @title Display condition extension - Asset interacted\n* @description To be described.\n*\n* @author JC\n* @version 1.0 28-10-14\n*/\n\nvar DISPLAY_CONDITION_ASSET_COMPELETED =\n{\n\tstrObjID : "Display condition - Asset Completed",\n\n\t_checkCondition_assetCompletedDisplayCondition : function (_objCurrCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objCurrCondition.objParameters.strVariableToCheck + "." + _objCurrCondition.objParameters.strAssetToTestAgainst;\n\t\tvar _strValueToTestAgainst = _objCurrCondition.objParameters.strValueToTestAgainst;\n\t\tvar _strComparisonType = _objCurrCondition.objParameters.strConditionTest;\n\n\t\tvar _strCurrVariableValue = VARIABLES_HOLDER.getVariableValue(_strVariableToTestAgainst);\n\n\t\tvar _booComparisonResult = this._performStandardValueComparison(_strComparisonType, _strValueToTestAgainst, _strCurrVariableValue);\n\t\treturn _booComparisonResult;\n\t},\n\n\t_preProcessDisplayConditionVariableName_gomo_asset_completed : function (_objWhatCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objWhatCondition.objParameters.strVariableToCheck + "." + _objWhatCondition.objParameters.strAssetToTestAgainst;\n\t\treturn _strVariableToTestAgainst;\n\t},\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_ASSET_COMPELETED);'},function(n,e,t){t(0)(t(149))},function(n,e){n.exports='/**\n* @title Display condition extension - Course completion percentage\n* @description To be described.\n*\n* @author JC\n* @version 1.0 28-10-14\n*/\n\nvar DISPLAY_CONDITION_COURSE_COMPLETION_PERCENTAGE =\n{\n\tstrObjID : "Display condition - course completion percentage",\n\n\t_checkCondition_completionPercentageDisplayCondition : function (_objCurrCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objCurrCondition.objParameters.strVariableToCheck;\n\t\tvar _strValueToTestAgainst = _objCurrCondition.objParameters.strValueToTestAgainst;\n\t\tvar _strComparisonType = _objCurrCondition.objParameters.strConditionTest;\n\n\t\tvar _strCurrVariableValue = VARIABLES_HOLDER.getVariableValue(_strVariableToTestAgainst);\n\n\t\tvar _booComparisonResult = this._performStandardValueComparison(_strComparisonType, _strValueToTestAgainst, _strCurrVariableValue);\n\t\treturn _booComparisonResult;\n\t},\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_COURSE_COMPLETION_PERCENTAGE);'},function(n,e,t){t(0)(t(151))},function(n,e){n.exports='/**\n* @title Display condition extension - Course completion status\n* @description To be described.\n*\n* @author JC\n* @version 1.0 28-10-14\n*/\n\nvar DISPLAY_CONDITION_COURSE_COMPLETION_STATUS =\n{\n\tstrObjID : "Display condition - Course completion status",\n\n\t_checkCondition_courseCompletionDisplayCondition : function (_objCurrCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objCurrCondition.objParameters.strVariableToCheck;\n\t\tvar _strValueToTestAgainst = _objCurrCondition.objParameters.strValueToTestAgainst;\n\t\tvar _strComparisonType = _objCurrCondition.objParameters.strConditionTest;\n\n\t\tvar _strCurrVariableValue = VARIABLES_HOLDER.getVariableValue(_strVariableToTestAgainst);\n\n\t\tvar _booComparisonResult = this._performStandardValueComparison(_strComparisonType, _strValueToTestAgainst, _strCurrVariableValue);\n\t\treturn _booComparisonResult;\n\t},\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_COURSE_COMPLETION_STATUS);'},function(n,e,t){t(0)(t(153))},function(n,e){n.exports='/**\n* @title Display condition extension - Course score\n* @description To be described.\n*\n* @author JC\n* @version 1.0 28-10-14\n*/\n\nvar DISPLAY_CONDITION_COURSE_SCORE =\n{\n\tstrObjID : "Display condition - Course score",\n\n\t_checkCondition_courseScoreDisplayCondition : function (_objCurrCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objCurrCondition.objParameters.strVariableToCheck;\n\t\tvar _strValueToTestAgainst = _objCurrCondition.objParameters.strValueToTestAgainst;\n\t\tvar _strComparisonType = _objCurrCondition.objParameters.strConditionTest;\n\n\t\tvar _strCurrVariableValue = VARIABLES_HOLDER.getVariableValue(_strVariableToTestAgainst);\n\n\t\tvar _booComparisonResult = this._performStandardValueComparison(_strComparisonType, _strValueToTestAgainst, _strCurrVariableValue);\n\t\treturn _booComparisonResult;\n\t},\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_COURSE_SCORE);'},function(n,e,t){t(0)(t(155))},function(n,e){n.exports='/**\n* @title Display condition extension - device type\n* @description To be described.\n*\n* @author JC\n* @version 1.0 12-6-14\n*/\n\nvar DISPLAY_CONDITION_DEVICE_TYPE =\n{\n\tstrObjID : "Display condition - device type",\n\n\t_checkCondition_deviceTypeDisplayCondition : function (_objCurrCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objCurrCondition.objParameters.strVariableToCheck;\n\t\tvar _strValueToTestAgainst = _objCurrCondition.objParameters.strValueToTestAgainst;\n\t\tvar _strComparisonType = _objCurrCondition.objParameters.strConditionTest;\n\n\t\tvar _strCurrVariableValue = VARIABLES_HOLDER.getVariableValue(_strVariableToTestAgainst);\n\n\t\tvar _booComparisonResult = this._performStandardValueComparison(_strComparisonType, _strValueToTestAgainst, _strCurrVariableValue);\n\t\treturn _booComparisonResult;\n\t},\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_DEVICE_TYPE);'},function(n,e,t){t(0)(t(157))},function(n,e){n.exports='/**\n* @title Display condition extension - Topic incorrect questions\n* @description To be described.\n*\n* @author JC\n* @version 1.0 28-10-14\n*/\n\nvar DISPLAY_CONDITION_TOPIC_INCORRECT_QUESTIONS =\n{\n\tstrObjID : "Display condition - Topic incorrect questions",\n\n\t_checkCondition_topicIncorrectQuestionsDisplayCondition : function (_objCurrCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objCurrCondition.objParameters.strVariableToCheck + "." + _objCurrCondition.objParameters.strTopicToTestAgainst;\n\t\tvar _strValueToTestAgainst = _objCurrCondition.objParameters.strValueToTestAgainst;\n\t\tvar _strComparisonType = _objCurrCondition.objParameters.strConditionTest;\n\n\t\tvar _strCurrVariableValue = VARIABLES_HOLDER.getVariableValue(_strVariableToTestAgainst);\n\n\t\tvar _booComparisonResult = this._performStandardValueComparison(_strComparisonType, _strValueToTestAgainst, _strCurrVariableValue);\n\t\treturn _booComparisonResult;\n\t},\n\n\t_preProcessDisplayConditionVariableName_gomo_topic_incorrect_questions : function (_objWhatCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objWhatCondition.objParameters.strVariableToCheck + "." + _objWhatCondition.objParameters.strTopicToTestAgainst;\n\t\treturn _strVariableToTestAgainst;\n\t},\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_TOPIC_INCORRECT_QUESTIONS);'},function(n,e,t){t(0)(t(159))},function(n,e){n.exports='/**\n* @title Display condition extension - Topic score\n* @description To be described.\n*\n* @author JC\n* @version 1.0 28-10-14\n*/\n\nvar DISPLAY_CONDITION_TOPIC_SCORE_AS_PERCENT =\n{\n\tstrObjID : "Display condition - Topic score",\n\n\t_checkCondition_topicScoreDisplayCondition : function (_objCurrCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objCurrCondition.objParameters.strVariableToCheck + "." + _objCurrCondition.objParameters.strTopicToTestAgainst;\n\t\tvar _strValueToTestAgainst = _objCurrCondition.objParameters.strValueToTestAgainst;\n\t\tvar _strComparisonType = _objCurrCondition.objParameters.strConditionTest;\n\n\t\tvar _strCurrVariableValue = VARIABLES_HOLDER.getVariableValue(_strVariableToTestAgainst);\n\n\t\tvar _booComparisonResult = this._performStandardValueComparison(_strComparisonType, _strValueToTestAgainst, _strCurrVariableValue);\n\t\treturn _booComparisonResult;\n\t},\n\n\t_preProcessDisplayConditionVariableName_gomo_topic_score_as_percent : function (_objWhatCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objWhatCondition.objParameters.strVariableToCheck + "." + _objWhatCondition.objParameters.strTopicToTestAgainst;\n\t\treturn _strVariableToTestAgainst;\n\t},\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_TOPIC_SCORE_AS_PERCENT);'},function(n,e,t){t(0)(t(161))},function(n,e){n.exports='/**\n* @title Display condition extension - Topic score as percent\n* @description To be described.\n*\n* @author JC\n* @version 1.0 28-10-14\n*/\n\nvar DISPLAY_CONDITION_TOPIC_SCORE_AS_PERCENT =\n{\n\tstrObjID : "Display condition - Topic score as percent",\n\n\t_checkCondition_topicScoreAsPercentDisplayCondition : function (_objCurrCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objCurrCondition.objParameters.strVariableToCheck + "." + _objCurrCondition.objParameters.strTopicToTestAgainst;\n\t\tvar _strValueToTestAgainst = _objCurrCondition.objParameters.strValueToTestAgainst;\n\t\tvar _strComparisonType = _objCurrCondition.objParameters.strConditionTest;\n\n\t\tvar _strCurrVariableValue = VARIABLES_HOLDER.getVariableValue(_strVariableToTestAgainst);\n\n\t\tvar _booComparisonResult = this._performStandardValueComparison(_strComparisonType, _strValueToTestAgainst, _strCurrVariableValue);\n\t\treturn _booComparisonResult;\n\t},\n\n\t_preProcessDisplayConditionVariableName_gomo_topic_score : function (_objWhatCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objWhatCondition.objParameters.strVariableToCheck + "." + _objWhatCondition.objParameters.strTopicToTestAgainst;\n\t\treturn _strVariableToTestAgainst;\n\t},\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_TOPIC_SCORE_AS_PERCENT);'},function(n,e,t){t(0)(t(163))},function(n,e){n.exports='/**\n* @title Display condition extension - Topic completion status\n* @description To be described.\n*\n* @author JC\n* @version 1.0 28-10-14\n*/\n\nvar DISPLAY_CONDITION_TOPIC_COMPLETION_STATUS =\n{\n\tstrObjID : "Display condition - Topic completion status",\n\n\t_checkCondition_topicCompletionDisplayCondition : function (_objCurrCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objCurrCondition.objParameters.strVariableToCheck + "." + _objCurrCondition.objParameters.strTopicToTestAgainst;\n\t\tvar _strValueToTestAgainst = _objCurrCondition.objParameters.strValueToTestAgainst;\n\t\tvar _strComparisonType = _objCurrCondition.objParameters.strConditionTest;\n\n\t\tvar _strCurrVariableValue = VARIABLES_HOLDER.getVariableValue(_strVariableToTestAgainst);\n\n\t\tvar _booComparisonResult = this._performStandardValueComparison(_strComparisonType, _strValueToTestAgainst, _strCurrVariableValue);\n\t\treturn _booComparisonResult;\n\t},\n\n\t_preProcessDisplayConditionVariableName_gomo_topic_completion : function (_objWhatCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objWhatCondition.objParameters.strVariableToCheck + "." + _objWhatCondition.objParameters.strTopicToTestAgainst;\n\t\treturn _strVariableToTestAgainst;\n\t},\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_TOPIC_COMPLETION_STATUS);'},function(n,e,t){t(0)(t(165))},function(n,e){n.exports='/**\n* @title Display condition extension - Topic completion status\n* @description To be described.\n*\n* @author JC\n* @version 1.0 28-10-14\n*/\n\nvar DISPLAY_CONDITION_SCREEN_STATUS =\n{\n\tstrObjID : "Display condition - Screen status",\n\n\t_checkCondition_screenStatusDisplayCondition : function (_objCurrCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objCurrCondition.objParameters.strVariableToCheck + "." + _objCurrCondition.objParameters.strScreenToTestAgainst;\n\t\tvar _strValueToTestAgainst = _objCurrCondition.objParameters.strValueToTestAgainst;\n\t\tvar _strComparisonType = _objCurrCondition.objParameters.strConditionTest;\n\n\t\tvar _strCurrVariableValue = VARIABLES_HOLDER.getVariableValue(_strVariableToTestAgainst);\n\n\t\tvar _booComparisonResult = this._performStandardValueComparison(_strComparisonType, _strValueToTestAgainst, _strCurrVariableValue);\n\t\treturn _booComparisonResult;\n\t},\n\n\t_preProcessDisplayConditionVariableName_gomo_screen_status : function (_objWhatCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objWhatCondition.objParameters.strVariableToCheck + "." + _objWhatCondition.objParameters.strScreenToTestAgainst;\n\t\treturn _strVariableToTestAgainst;\n\t},\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_SCREEN_STATUS);'},function(n,e,t){t(0)(t(167))},function(n,e){n.exports='/**\n* @title Display condition extension - user variables\n* @description To be described.\n*\n* @author JC\n* @version 1.0 12-6-14\n*/\n\nvar DISPLAY_CONDITION_USER_VARIABLES =\n{\n\tstrObjID : "Display condition - user variables",\n\n\t_checkCondition_userVariableDisplayCondition : function (_objCurrCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objCurrCondition.objParameters.strVariableToCheck;\n\t\tvar _strValueToTestAgainst = _objCurrCondition.objParameters.strValueToTestAgainst;\n\t\tvar _strComparisonType = _objCurrCondition.objParameters.strConditionTest;\n\n\t\tvar _strCurrVariableValue = VARIABLES_HOLDER.getVariableValue(_strVariableToTestAgainst);\n\n\t\tvar _booComparisonResult = this._performStandardValueComparison(_strComparisonType, _strValueToTestAgainst, _strCurrVariableValue);\n\t\treturn _booComparisonResult;\n\t},\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_USER_VARIABLES);'},function(n,e,t){t(0)(t(169))},function(n,e){n.exports="/**\n* @title Display condition extension - custom variables\n* @description To be described.\n*\n* @author JC\n* @version 1.0 12-6-14\n*/\n\nvar DISPLAY_CONDITION_CUSTOM_VARIABLES =\n{\n\tstrObjID : \"Display condition - custom variables\",\n\n\t_checkCondition_customVariableDisplayCondition : function (_objCurrCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objCurrCondition.objParameters.strVariableToCheck + '.' + _objCurrCondition.objParameters.strBindedAsset;\n\t\tvar _strValueToTestAgainst = _objCurrCondition.objParameters.strValueToTestAgainst;\n\t\tvar _strComparisonType = _objCurrCondition.objParameters.strConditionTest;\n\n\t\tvar _strCurrVariableValue = VARIABLES_HOLDER.getVariableValue(_strVariableToTestAgainst);\n\n\t\tvar _booComparisonResult = false;\n\t\tif(_strCurrVariableValue){\n\t\t\t_booComparisonResult = this._performStandardValueComparison(_strComparisonType, _strValueToTestAgainst, _strCurrVariableValue);\n\t\t}\n\t\t\n\t\treturn _booComparisonResult;\n\t},\n\n\t_preProcessDisplayConditionVariableName_asset_variable : function (_objCurrCondition)\n\t{\n\t\treturn _objCurrCondition.objParameters.strVariableToCheck + '.' + _objCurrCondition.objParameters.strBindedAsset;\n\t},\n\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_CUSTOM_VARIABLES);"},function(n,e,t){t(0)(t(171))},function(n,e){n.exports='/**\n* @title Display condition extension - custom variables\n* @description To be described.\n*\n* @author JC\n* @version 1.0 12-6-14\n*/\n\nvar DISPLAY_CONDITION_ACTIVE_LANGUAGE =\n{\n\tstrObjID : "Display condition - Active Language",\n\n\t_checkCondition_activeLanguageDisplayCondition : function (_objCurrCondition)\n\t{\n\t\tvar _strVariableToTestAgainst = _objCurrCondition.objParameters.strVariableToCheck;\n\t\tvar _strValueToTestAgainst = _objCurrCondition.objParameters.strValueToTestAgainst;\n\t\tvar _strComparisonType = _objCurrCondition.objParameters.strConditionTest;\n\n\t\tvar _strCurrVariableValue = VARIABLES_HOLDER.getVariableValue(_strVariableToTestAgainst);\n\n\t\tif(_strCurrVariableValue == "default"){\n\t\t\t_strCurrVariableValue = gomo.translationManager.getDefaultCode();\n\t\t}\n\n\t\tvar _booComparisonResult = false;\n\t\tif(_strCurrVariableValue){\n\t\t\t_booComparisonResult = this._performStandardValueComparison(_strComparisonType, _strValueToTestAgainst, _strCurrVariableValue);\n\t\t}\n\t\t\n\t\treturn _booComparisonResult;\n\t},\n\n\t_preProcessDisplayConditionVariableName_active_language : function (_objCurrCondition)\n\t{\n\t\treturn _objCurrCondition.objParameters.strVariableToCheck + \'.\' + _objCurrCondition.objParameters.strBindedAsset;\n\t},\n\n\n\tbooTerminal : true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_ACTIVE_LANGUAGE);'},function(n,e,t){t(0)(t(173))},function(n,e){n.exports="/* global O_EXTENDER, DISPLAY_CONDITIONS_INTERACTIONS */\n/**\n * @title Display condition extension - Learning Objectives\n * @description Filters assets based on a learning objective score.\n *\n * @author Manos Tzoumas\n * @version 1.0 04-06-19\n */\n\nvar DISPLAY_CONDITION_LEARNING_OBJECTIVES =\n{\n  strObjID: 'Display condition - learning objectives',\n\n  _checkCondition_learningObjectiveDisplayCondition: function(data) {\n    var result = false;\n    var loScore = '';\n    var learningObjective = gomo.learningObjectivesManager.getLearningObjective(\n      data.objParameters.strLearningObjectiveToCheck\n    );\n\n    if (learningObjective && learningObjective.hasResults()) {\n      var scores = learningObjective.getScores();\n      loScore = scores.raw;\n      result = this._performStandardValueComparison(\n        data.objParameters.strConditionTest,\n        data.objParameters.strValueToTestAgainst,\n        loScore\n      );\n    }\n\n    return result;\n  },\n\n  booTerminal: true\n};\n\nO_EXTENDER.extend(DISPLAY_CONDITIONS_INTERACTIONS, DISPLAY_CONDITION_LEARNING_OBJECTIVES);\n"},function(n,e,t){t(0)(t(175))},function(n,e){n.exports="/* globals OBJ_ASSET_BOUNDARIES, OBJ_NAV_BUTTONS, EM */\n\n/**\n * @title Loader\n * @description Modules files are now bundled on authoring with webpack. \n * This class now grabs assets config from the bundle of manifest.js files\n */\n\nvar MANIFEST_MANAGER = {\n  strObjID: 'The loading manager',\n\n  objManifests: {},\n\n  // No trailing '/' required\n  _strManifestFilesSubFolder: 'files_player',\n  _strDeclarationBlock: 'objPlayerDeclarations',\n  trackingPreferences: null,\n\n  _booDebugMessages: false,\n\n  _booUseMasterCssFiles: true,\n\n  handleEvent_gomoManifestsLoaded: function() {\n    // Clear out the manifests load list ready for adding any fresh ones.\n    this._parseManifests();\n  },\n\n  reportManifestLoaded: function(_strWhatManifestKey, _objWhatManifestJSON) {\n    if (!this.objManifests[_strWhatManifestKey]) {\n      this.objManifests[_strWhatManifestKey] = _objWhatManifestJSON;\n    } else {\n      this._debug(\n        'ERROR: Duplciate manifest key of  \\'' +\n          _strWhatManifestKey +\n          '\\'. .reportManifestLoaded(), manifest_manager.js'\n      );\n    }\n  },\n\n  getLoadedAssetManifests: function() {\n    return this.objManifests;\n  },\n\n  getAssetManifest: function(_strAssetManifestType) {\n    for (var _strCurrManifestId in this.objManifests) {\n      if (Object.prototype.hasOwnProperty.call(this.objManifests, _strCurrManifestId)) {\n        var _objCurrManifest = this.objManifests[_strCurrManifestId];\n        if (_objCurrManifest['objDataTemplate']['strType'] == _strAssetManifestType) {\n          return _objCurrManifest;\n        }\n      }\n    }\n    return false;\n  },\n\n  _parseManifests: function() {\n    for (var _strCurrKey in this.objManifests) {\n      if (Object.prototype.hasOwnProperty.call(this.objManifests, _strCurrKey)) {\n        var _objCurrManifest = this.objManifests[_strCurrKey];\n\n        if (!_objCurrManifest['booManifestParsed']) {\n          this._storeManifestNavButtons(_objCurrManifest);\n          this._storeManifestAssetSizeBoundaries(_objCurrManifest, _strCurrKey);\n          this._parseManifestForPlayerPreferences(_objCurrManifest, _strCurrKey);\n          _objCurrManifest['booManifestParsed'] = true;\n        }\n      }\n    }\n  },\n\n  _storeManifestNavButtons: function(_objWhatManifest) {\n    if (_objWhatManifest.objPlayerDeclarations.objNavButton) {\n      OBJ_NAV_BUTTONS[_objWhatManifest.strID] = _objWhatManifest.objPlayerDeclarations.objNavButton;\n      OBJ_NAV_BUTTONS[_objWhatManifest.strID].strExtrasId = _objWhatManifest.strID;\n    }\n  },\n\n  _storeManifestAssetSizeBoundaries: function(_objWhatManifest, _strCurrKey) {\n    if (\n      _objWhatManifest.objPlayerDeclarations.arrRenderMethods &&\n      _objWhatManifest.objPlayerDeclarations.arrRenderMethods.length > 0\n    ) {\n      OBJ_ASSET_BOUNDARIES[_objWhatManifest.objDataTemplate.strType] = {};\n\n      if (_objWhatManifest.objPlayerDeclarations.arrRenderMethods[0].intMinValue) {\n        OBJ_ASSET_BOUNDARIES[_objWhatManifest.objDataTemplate.strType].intSmallest =\n          _objWhatManifest.objPlayerDeclarations.arrRenderMethods[0].intMinValue;\n      }\n      if (_objWhatManifest.objPlayerDeclarations.arrRenderMethods[2].intMaxValue) {\n        OBJ_ASSET_BOUNDARIES[_objWhatManifest.objDataTemplate.strType].intLargest =\n          _objWhatManifest.objPlayerDeclarations.arrRenderMethods[2].intMaxValue;\n      }\n    }\n  },\n\n  _parseManifestForPlayerPreferences: function(_objWhatManifest, _strCurrKey) {\n    if (_objWhatManifest) {\n      if (_objWhatManifest.objPlayerDeclarations) {\n        if (_objWhatManifest.objPlayerDeclarations.tracking) {\n          this.trackingPreferences = _objWhatManifest.objPlayerDeclarations.tracking;\n        }\n      }\n    }\n  },\n\n  _debug: function(_strWhatMessage) {\n    if (this._booDebugMessages && window['console'] && window['console']['log']) {\n      console.log(_strWhatMessage);\n    }\n  },\n\n  booTerminal: true\n};\n\nEM.register(MANIFEST_MANAGER);\n"}]);