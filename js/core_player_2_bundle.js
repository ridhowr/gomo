!function(t){var n={};function e(a){if(n[a])return n[a].exports;var r=n[a]={i:a,l:!1,exports:{}};return t[a].call(r.exports,r,r.exports,e),r.l=!0,r.exports}e.m=t,e.c=n,e.d=function(t,n,a){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:a})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var a=Object.create(null);if(e.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var r in t)e.d(a,r,function(n){return t[n]}.bind(null,r));return a},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=181)}([function(t,n){t.exports=function(t){function n(t){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",t)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(t):"undefined"!=typeof eval?eval.call(null,t):n("EvalError: No eval function available")}catch(t){n(t)}}},,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,function(t,n,e){"use strict";e.r(n);e(182),e(184),e(186),e(188),e(190),e(192),e(194),e(196),e(198),e(200),e(202),e(204),e(206),e(208),e(210),e(212),e(214),e(216),e(218),e(220),e(222),e(224),e(226),e(228),e(230),e(232),e(234),e(236),e(238),e(240),e(242)},function(t,n,e){e(0)(e(183))},function(t,n){t.exports="/* global CORE, MASTER_RENDERER, $, COURSE_TITLE */\n\n/**\n * gomo - The gomo API entry point\n */\nvar global = this;\n\nglobal.gomo = {\n  // v2.2 supported methods\n\n  /**\n   * @function getElementsByClassName\n   * @param {Object} element\n   * @param {string} className\n   * @param {string} tag\n   * @return {*}\n   */\n  getElementsByClassName: function(element, className, tag) {\n    return CORE.getElementsByClassName.apply(CORE, [element, className, tag]);\n  },\n\n  /**\n   * @function getVideoProperties\n   * @param {string} filename\n   * @return {*}\n   */\n  getVideoProperties: function(filename) {\n    return MASTER_RENDERER.getVideoProperties.apply(MASTER_RENDERER, [filename]);\n  },\n\n  /**\n   * @function getImageProperties\n   * @param {string} filename\n   * @return {*}\n   */\n  getImageProperties: function(filename) {\n    return MASTER_RENDERER.getImageProperties.apply(MASTER_RENDERER, [filename]);\n  },\n\n  /**\n  * @function getCourseTitle\n  * @return {string}\n  */\n  getCourseTitle: function() {\n    return COURSE_TITLE;\n  },\n\n  // v2.2 supported objects\n  decontaminater: global.DECONTAMINATER || null,\n  objectManager: global.OBJ_REF || null,\n\n  loadDataFile: function(filename, callback) {\n    callback = callback || function() {};\n    // For data files...\n    var filepath = 'data/';\n    var file = filepath + filename;\n    $.ajax(file, {dataType: 'json'}).done(function(data, status) {\n      if (status === 'success') {\n        callback(data);\n      }\n    });\n  }\n};\n"},function(t,n,e){e(0)(e(185))},function(t,n){t.exports="gomo.manifestManager = (function(){\n\n\t/**\n\t * ManifestManager - acts as an entry point for all\n\t * file operations, this will intreface with native filesystem if necessary.\n\t */\n\tvar me = this;\n\t\n\t// Public methods\n\n\t/**\n\t * @public\n\t * @function add - Adds manifest to the manifest collection\n\t * @param {Object} manifestData - The manifest data to be added\n\t */\n\tvar add = function(manifestData){\n\t\tvar id = manifestData.manifestId || manifestData.uuid;\n\t\tvar oldManifest = convertToOldManifest(manifestData);\n\t\tMANIFEST_MANAGER.reportManifestLoaded(id, oldManifest);\n\t};\n\n\t/**\n\t * @public\n\t * @function getAssetManifest\n\t * @param {string} id - The id of the asset for which you would like the manifest\n\t * @returns {Object}\n\t */\n\tvar getAssetManifest = function(id){\n\t\tvar manifest = MANIFEST_MANAGER.getAssetManifest(id);\n\t\treturn manifest.v3Manifest;\n\t};\n\n\t// Private methods\n\t/**\n\t * @private\n\t * @function convertToOldManifest\n\t * @param manifestData\n\t * @returns {Object} - Old manifest structure\n\t */\n\tvar convertToOldManifest = function(manifestData){\n\t\tvar oldManifest = {};\n\t\toldManifest.strID = manifestData.id;\n\t\toldManifest.strName = manifestData.name || '';\n\t\toldManifest.strDescription = manifestData.description || '';\n\t\toldManifest.strVersion = manifestData.version || '1.0';\n\t\toldManifest.strManifestType = manifestData.type || '';\n\t\toldManifest.objActionSets = {};\n\t\toldManifest.booManifestParsed = false;\n\t\toldManifest.v3Manifest = manifestData;\n\t\toldManifest.legacyId = manifestData.manifestId || '';\n\n\t\t// Data template\n\t\toldManifest.objDataTemplate = {\n\t\t\tstrGroup: manifestData.group || '',\n\t\t\tstrType: oldManifest.strID\n\t\t}\n\n\t\t// Player declarations\n\t\toldManifest.objPlayerDeclarations = {\n\t\t\tobjNavButton: {},\n\t\t\tobjFiles: {},\n\t\t\tobjDependancies: {},\n\t\t\tarrRenderMethods: new Array(3)\n\t\t};\n\n\t\t// Copy any custom settings...\n\t\tif(manifestData.settings){\n\t\t\tfor(var i in manifestData.settings){\n\t\t\t\toldManifest.objPlayerDeclarations[i] = manifestData.settings[i];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Add boundaries\n\t\tif(manifestData.boundaries){\n\t\t\tfor(i in manifestData.boundaries){\n\t\t\t\tvar index = 0;\n\t\t\t\tswitch(i){\n\t\t\t\t\tcase 'small':\n\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'medium':\n\t\t\t\t\t\tindex = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'large':\n\t\t\t\t\t\tindex = 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// Add render methods - old boundaries...\n\t\t\t\toldManifest.objPlayerDeclarations.arrRenderMethods[index] = {\n\t\t\t\t\tintMinValue: manifestData.boundaries[i].min || -1,\n\t\t\t\t\tintMaxValue: manifestData.boundaries[i].min || -1,\n\t\t\t\t\tstrMethodName: ''\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add asset files...\n\t\tif(manifestData.files){\n\t\t\tfor(i in manifestData.files){\n\t\t\t\tvar file = manifestData.files[i];\n\t\t\t\tif(file && file.file){\n\t\t\t\t\toldManifest.objPlayerDeclarations.objFiles[file.file] = file.context || 'base';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add asset dependencies in player...\n\t\tif(manifestData.dependencies){\n\t\t\tfor(i in manifestData.dependencies){\n\t\t\t\tvar file = manifestData.dependencies[i];\n\t\t\t\tif(file && file.file){\n\t\t\t\t\toldManifest.objPlayerDeclarations.objDependancies[file.file] = file.context || 'dependant-api';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn oldManifest;\n\t}\n\n\treturn {\n\t\tadd: add,\n\t\tgetAssetManifest: getAssetManifest\n\t}\n\n})();"},function(t,n,e){e(0)(e(187))},function(t,n){t.exports="/* global _, ASSET_RENDERER */\ngomo.assetManager = (function() {\n  var assetRegistry = {};\n  var assetInstances = {};\n  var domRef = null;\n\n  /**\n * AssetManager - registers and controls all assets\n */\n  var AssetManager = function() {};\n\n  AssetManager.prototype = {\n    /**\n     * @public\n     * Register a new asset type...\n     * @param {string} assetType\n     * @param {string} assetClass\n     * @param {object} options\n     */\n    register: function(assetType, assetClass, options) {\n      var me = this;\n      options = options || {};\n      // Add default support data...\n      if (!options.supportData) {\n        options.supportData = {\n          'graphicalC': true,\n          'accessibleC': true,\n          'tabletC': true,\n          'smartphoneC': true\n        };\n      }\n      if (me.isRegistered(assetType)) {\n        // Throw some error to inform duplicate assetRegistry...\n      } else {\n        assetRegistry[assetType] = assetClass;\n        // Add the support data for this asset class...\n        ASSET_RENDERER.addAssetSupportData(assetType, options.supportData);\n      }\n    },\n\n    /**\n     * Checks if the asset type is registered\n     * @public\n     * @function isRegistered\n     * @param {string} assetType\n     * @return {boolean}\n     */\n    isRegistered: function(assetType) {\n      if (assetRegistry[assetType]) {\n        return true;\n      }\n      return false;\n    },\n\n    /**\n     * @public\n     * @function setDOM\n     * @param {Object} dom\n     */\n    setDOM: function(dom) {\n      domRef = dom;\n    },\n\n    /**\n     * @public\n     * @function setCommonAssetTemplates\n     */\n    setCommonAssetTemplates: function() {\n      var partials = {\n        'confirmButton': '.confirmButtonPartial',\n        'resetButton': '.resetButtonPartial'\n      };\n\n      gomo.templateManager.setPartials(partials);\n    },\n\n    /**\n     * @public\n     * Add a new istance of an asset.\n     * @param {string} assetType\n     * @param {object} data\n     * @return {object}\n     */\n    add: function(assetType, data) {\n      var me = this;\n      var AssetClass = assetRegistry[assetType] || null;\n      if (AssetClass) {\n        var asset = new AssetClass({data: data});\n        me.remove(asset.id);\n        assetInstances[asset.id] = asset;\n        asset.registerEvents();\n        return asset;\n      }\n\n      return null;\n    },\n\n    /**\n     * @public\n     * Remove instance of an asset.\n     * @param {string} instanceId\n     * @return {boolean}\n     */\n    remove: function(instanceId) {\n      if (assetInstances[instanceId]) {\n        assetInstances[instanceId].remove();\n        assetInstances[instanceId] = null;\n        delete assetInstances[instanceId];\n        return true;\n      }\n\n      return false;\n    },\n\n    /**\n     * @public\n     * @function findInstance\n     * @param {string} instanceId\n     * @return {object}\n     */\n    findInstance: function(instanceId) {\n      if (assetInstances[instanceId]) {\n        return assetInstances[instanceId];\n      }\n      return null;\n    },\n\n    raiseEvents: function(eventName, eventArgs, options) {\n      _.each(assetInstances, function(value, key) {\n        assetInstances[key].raiseEvent(eventName, eventArgs, options);\n      });\n    },\n\n    /**\n     * @public\n     * @function getElementFromAssetData\n     * @param {object} assetData The asset data\n     * @return {object}\n     */\n    getElementFromAssetData: function(assetData) {\n      var me = this;\n      var el = me.getElementFromAssetId(assetData.strObjID);\n      if (el) {\n        return el;\n      }\n\n      gomo.localiser.localisedAlert(\n        'ASSET_RENDERER_UNABLE_TO_FIND_ASSET_DOM_ELEMENT',\n        [assetData.strObjID, me.getAssetDomID(assetData.strObjID)]\n      );\n      return false;\n    },\n\n    getElementFromAssetId: function(assetId) {\n      var id = this.getAssetDomID(assetId);\n      return domRef.getElementById(id);\n    },\n\n    /**\n     * Get the asset's dom ID\n     * @param {string} assetId The asset id\n     * @return {string}\n     */\n    getAssetDomID: function(assetId) {\n      return 'assetWrapperFor_YY' + assetId + 'YY_L';\n    }\n  };\n\n  return new AssetManager();\n})();\n"},function(t,n,e){e(0)(e(189))},function(t,n){t.exports="/* globals EM*/\ngomo.eventManager = (function() {\n  /**\n   * EventManager - registers and controls all assets\n   */\n  var EventManager = function() {};\n\n  EventManager.prototype = {\n    raise: function(eventName, eventArgs, options) {\n      gomo.assetManager.raiseEvents(eventName, eventArgs, options);\n    },\n    legacy: function(eventName, eventArgs) {\n      EM.trigger(eventName, eventArgs);\n    },\n    registerLegacyEvent: function(eventName, method) {\n      if (EM && EM.register) {\n        var obj = {};\n        obj['handleEvent_' + eventName] = method;\n        EM.register(obj);\n      }\n    }\n  };\n\n  return new EventManager();\n})();\n"},function(t,n,e){e(0)(e(191))},function(t,n){t.exports="gomo.dataBinding = (function(){\n\n\t/**\n\t * DataBinding - registers and controls all assets\n\t */\n\tvar DataBinding = function(){\n\t\tvar me = this;\n\t};\n\n\tDataBinding.prototype = {\n\n\t\tbindings: [],\n\n\t\t/**\n\t\t * Register a new binding...\n\t\t */\n\t\tregister: function(uuid, data, scope, groupId){\n\t\t\tvar me = this;\n\t\t\tif (!scope) {\n\t\t\t\t// If there is no scope then we should exit!\n\t\t\t\t// Otherwise this could cause unexpected results.\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(uuid && me.bindings){\n\t\t\t\tvar found = _.findWhere(me.bindings, {uuid: uuid});\n\t\t\t\tif(!found){\n\t\t\t\t\t// Create observables...\n\t\t\t\t\tvar model = ko.mapping.fromJS(data);\n\t\t\t\t\t// Save and apply binding...\n\t\t\t\t\tme.bindings.push({\n\t\t\t\t\t\tuuid: uuid,\n\t\t\t\t\t\tmodel: model,\n\t\t\t\t\t\tgroup: groupId || ''\n\t\t\t\t\t});\n\t\t\t\t\ttry {\n\t\t\t\t\t\tko.applyBindings(model, scope);\n\t\t\t\t\t} catch(e){\n\t\t\t\t\t\ttypeof ErrorHandler != 'undefined' && ErrorHandler['catch'] && ErrorHandler['catch'](e);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Binding already exists, update it.\n\t\t\t\t\tme.update(uuid, data);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Unregister a binding\n\t\t */\n\t\tunregister: function(ids){\n\t\t\tvar me = this;\n\t\t\tif(!_.isArray(ids)){\n\t\t\t\tids = [ids];\n\t\t\t}\n\t\t\tvar newBindings = _.reject(me.bindings, function(binding){ \n\t\t\t\treturn ~ids.indexOf(binding.uuid); \n\t\t\t});\n\t\t\t// Empty current bindings and reset.\n\t\t\tme.bindings = null;\n\t\t\tme.bindings = newBindings;\n\t\t},\n\n\t\t/**\n\t\t * Unregister all bindings belonging to the group\n\t\t */\n\t\tunregisterGroup: function(groupId){\n\t\t\tvar me = this;\n\t\t\tif(groupId){\n\t\t\t\tvar matches = _.where(me.bindings, {group: groupId});\n\t\t\t\tif(matches.length){\n\t\t\t\t\tme.unregister(_.pluck(matches, 'uuid'));\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * re-Register a binding which may have had child elements change\n\t\t */\n\t\treregister: function(uuid, data, scope, groupId){\n\t\t\tvar me = this;\n\t\t\tif(uuid && me.bindings){\n\t\t\t\tvar found = _.findWhere(me.bindings, {uuid: uuid});\n\t\t\t\tif(found){\n\t\t\t\t\tfound.model.dispose();\n\t\t\t\t\tfound.model = ko.mapping.fromJS(data);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tko.applyBindings(found.model, scope);\n\t\t\t\t\t} catch(e){\n\t\t\t\t\t\tconsole.log('Binding issue on reregister');\n\t\t\t\t\t\tconsole.log(e);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Binding wasn't found.\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Updates the matching binding!\n\t\t */\n\t\tupdate: function(uuid, data){\n\t\t\tvar me = this;\n\t\t\tif(uuid && me.bindings.length){\n\t\t\t\tvar found = _.findWhere(me.bindings, {uuid: uuid});\n\t\t\t\tif(found){\n\t\t\t\t\tfound.model = ko.mapping.fromJS(data, found.model);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Creates custom handlers for binding\n\t\t */\n\t\tregisterHandlers: function(handlers){\n\t\t\tvar me = this;\n\t\t\tfor(var handlerId in handlers){\n\t\t\t\t// Check if the handler exists...\n\t\t\t\tif(ko.bindingHandlers && !ko.bindingHandlers[handlerId]){\n\t\t\t\t\t// \n\t\t\t\t\tko.bindingHandlers[handlerId] = {\n\t\t\t\t\t\tinit: function(element, valueAccessor, allBindings, viewModel, bindingContext){\n\t\t\t\t\t\t\t// When applied\n\t\t\t\t\t\t},\n\t\t\t\t\t\tupdate: function(element, valueAccessor, allBindings, viewModel, bindingContext){\n\t\t\t\t\t\t\t// When updated...\n\t\t\t\t\t\t\tvar updateMethod = handlers[handlerId];\n\t\t\t\t\t\t\tvar value = valueAccessor();\n\t\t\t\t\t        var valueUnwrapped = ko.unwrap(value);\n\t\t\t\t\t        updateMethod(element, valueUnwrapped);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t};\n\n\treturn new DataBinding();\n\n})();"},function(t,n,e){e(0)(e(193))},function(t,n){t.exports="/* global _, MASTER_RENDERER, PREVIEW_DATA */\n\ngomo.utility = (function() {\n  /**\n   * Utility - Useful functions available to all classes in gomo\n   */\n  var Utility = function() {};\n\n  Utility.prototype = {\n    // v2.2 supported methods\n\n    /**\n     * Clean up a string with browsers html decoding.\n     * Grabbed from stackoverflow\n     * @see {@link http://stackoverflow.com/questions/7394748}\n     * @param {string} html The html to decode.\n     * @return {string}\n     */\n    decodeHtml: function(html) {\n      var txt = document.createElement('textarea');\n      txt.innerHTML = html;\n      return txt.value;\n    },\n\n    /**\n     * Convert a number holding a char code into a character.\n     * @param {number} value A unicode number.\n     * @param {boolean} any Convert into any character, default convert to a lowercase letter (a-z).\n     * @return {string}\n     */\n    convertNumberToCharacter: function(value, any) {\n      var charCodeZero = 48;\n      var charCodeLowercaseA = 97;\n      if (value < 0 || (!!any && value < charCodeZero)) {\n        return null;\n      }\n      var valueToConvert = parseInt(value);\n      if (_.isNaN(valueToConvert)) {\n        return null;\n      }\n      if (!any) {\n        valueToConvert += charCodeLowercaseA;\n      }\n      return String.fromCharCode(valueToConvert);\n    },\n\n    /**\n     * Format text\n     * @param {string} text\n     * @param {string} resourcePath\n     * @return {string}\n     */\n    formatHTML: function(text, resourcePath) {\n      if (gomo.variablesHolder) {\n        text = gomo.variablesHolder.parseHTMLForVariableMarkup(text);\n      }\n\n      if (text) {\n        // Clean up required characters for string replace\n        text = text.replace(/&#x0027;/g, '\\'');\n        text = text.replace(/&#x0022;/g, '\"');\n\n        // Dollar\n        text = text.replace(/\\$/g, '&#36;');\n\n        // quotes\n        text = text.replace(/\\[ldquo\\]/g, '&ldquo;');\n        text = text.replace(/\\[rdquo\\]/g, '&rdquo;');\n\n        // bold format\n        text = text.replace(/\\[b\\]/g, '<b>');\n        text = text.replace(/\\[\\/b\\]/g, '</b>');\n\n        // italic format\n        text = text.replace(/\\[i\\]/g, '<i>');\n        text = text.replace(/\\[\\/i\\]/g, '</i>');\n\n        // bold and italic\n        text = text.replace(/\\[bi\\]/g, '<b><i>');\n        text = text.replace(/\\[\\/bi\\]/g, '</i></b>');\n\n        // underline format\n        text = text.replace(/\\[u\\]/g, '<u>');\n        text = text.replace(/\\[\\/u\\]/g, '</u>');\n\n        // list format\n        text = text.replace(/\\[ul\\]/g, '<ul>');\n        text = text.replace(/\\[\\/ul\\]/g, '</ul>');\n        text = text.replace(/\\[ol\\]/g, '<ol>');\n        text = text.replace(/\\[\\/ol\\]/g, '</ol>');\n        text = text.replace(/\\[li\\]/g, '<li>');\n        text = text.replace(/\\[\\/li\\]/g, '</li>');\n\n        text = text.replace(/\\[hrule\\]/g, '<hr/>');\n\n        text = text.replace(/\\[sub\\]/g, '<sub>');\n        text = text.replace(/\\[\\/sub\\]/g, '</sub>');\n        text = text.replace(/\\[sup\\]/g, '<sup>');\n        text = text.replace(/\\[\\/sup\\]/g, '</sup>');\n\n        // br format\n        text = text.replace(/\\n/g, '<br/>');\n        text = text.replace(/\\r/g, '<br/>');\n\n        // BB Markup lists\n        text = text.replace(/\\[list=1\\]((.|\\n)*?)\\[\\/list\\](<br[/]?>)?/gi, '<ol>$1</li></ol>');\n        text = text.replace(/\\[list\\]((.|\\n)*?)\\[\\/list\\](<br[/]?>)?/gi, '<ul>$1</li></ul>');\n        text = text.replace(/\\[\\*\\]/gi, '</li><li>');\n        text = text.replace(/<ul>\\s<\\/li>/gi, '<ul>');\n        text = text.replace(/<ol>\\s<\\/li>/gi, '<ol>');\n        text = text.replace(/<ul><br[/]?>/gi, '<ul>');\n        text = text.replace(/<ol><br[/]?>/gi, '<ol>');\n\n        // Multi action link format\n        text = text.replace(\n          /\\[link type=[\"']([^\"]+?)[\"'] name=[\"']([^\"]+?)[\"']\\]/g,\n          '<a class=\\'contentLinkC\\' onclick=\\'EM.trigger(\"assetLinkClicked\", '+\n          '{\"src\":this, \"type\":\"$1\", \"params\":\"$2\"})\\' title=\\'Type: $1, Params: $2\\'>'\n        );\n        text = text.replace(\n          /\\[link type=&quot;([^\"]+?)&quot; name=&quot;([^\"]+?)&quot;\\]/g,\n          '<a class=\\'contentLinkC\\' onclick=\\'EM.trigger(\"assetLinkClicked\", '+\n          '{\"src\":this, \"type\":\"$1\", \"params\":\"$2\"})\\' title=\\'Type: $1, Params: $2\\'>'\n        );\n        text = text.replace(/\\[\\/link\\]/g, '</a>');\n\n        var asRegex = /\\[actionset=([^\\]]+)\\]/g;\n        var asReplacement = text.replace(asRegex, function(match, groupOne) {\n          var assetId = '';\n          var actionId = '';\n          if (typeof groupOne !== 'undefined') {\n            var breakUp = groupOne.split('.');\n            var assetData = gomo.assetManager.findInstance(breakUp[0]);\n            var actionState = 'enabledAction';\n            if (assetData\n              && assetData.checkEnabledState\n              && assetData.checkEnabledState(groupOne) == false) {\n              actionState = 'disabledAction';\n            }\n            if (breakUp.length >= 2) {\n              assetId = breakUp[0];\n              actionId = breakUp[1];\n            }\n          }\n          return '<span role=\\'button\\' id=\\'actionSetLink_' +\n            actionId +\n            '_L\\' data-linkid=\\'' + assetId + '_' + actionId + '\\'' +\n            'onclick=\\'EM.trigger(\"processInlineActionSet\", {strAssetID: \"' +\n            assetId +\n            '\", strActionSetID : \"' +\n            actionId +\n            '\", domLink : this});\\'' +\n            'onkeydown=\\'var code = event.which || event.keyCode; if (code == 32 || code == 13) {' +\n            'EM.trigger(\"processInlineActionSet\", {strAssetID: \"' +\n            assetId +\n            '\", strActionSetID : \"' +\n            actionId +\n            '\", domLink : this});}\\'' +\n            'class=\\'actionSetWrapperC ' +\n            actionState +\n            '\\'>';\n        });\n        text = asReplacement;\n\n        text = text.replace(/\\[\\/actionset\\]/g, '</span>');\n        text = text.replace(/\\[\\/link\\]/g, '</a>');\n        text = text.replace(/\\[Step \\d+\\]/gi, '');\n\n        // red format\n        text = text.replace(/\\[red\\]/g, '<span style=\\'color:red;\\'>');\n        text = text.replace(/\\[\\/red\\]/g, '</span>');\n\n        text = text.replace(/\\[redb\\]/g, '<span style=\\'color:red; font-weight: bold;\\'>');\n        text = text.replace(/\\[\\/redb\\]/g, '</span>');\n\n        text = text.replace(/\\[redi\\]/g, '<span style=\\'color:red; font-style: italic;\\'>');\n        text = text.replace(/\\[\\/redi\\]/g, '</span>');\n\n        text = text.replace(\n          /\\[redbi\\]/g,\n          '<span style=\\'color:red; font-weight: bold; font-style: italic;\\'>'\n        );\n        text = text.replace(/\\[\\/redbi\\]/g, '</span>');\n\n        // \" Used for whitespace handling in editor\n        text = text.replace(/\\[font type=[\"']([^\"]+?)[\"']\\]/g, '<span class=\\'$1ImportedC\\'>');\n        text = text.replace(/\\[\\/font\\]/g, '</span>');\n\n        text = text.replace(/\\[img\\]([^[]+)\\[\\/img\\]/g, '<img src=\\'' + resourcePath + '$1\\'/>');\n      }\n      return text;\n    },\n\n    /**\n     * Remove markup from text\n     * @param {string} text\n     * @return {string}\n     */\n    removeMarkup: function(text) {\n      if (text) {\n        // Clean up required characters for string replace\n        text = text.replace(/&#x0027;/g, '');\n        text = text.replace(/&#x0022;/g, '');\n\n        // Dollar\n        text = text.replace(/\\$/g, '');\n\n        // bold format\n        text = text.replace(/\\[b\\]/g, '');\n        text = text.replace(/\\[\\/b\\]/g, '');\n\n        // italic format\n        text = text.replace(/\\[i\\]/g, '');\n        text = text.replace(/\\[\\/i\\]/g, '');\n\n        // bold and italic\n        text = text.replace(/\\[bi\\]/g, '');\n        text = text.replace(/\\[\\/bi\\]/g, '');\n\n        // underline format\n        text = text.replace(/\\[u\\]/g, '');\n        text = text.replace(/\\[\\/u\\]/g, '');\n\n        // list format\n        text = text.replace(/\\[ul\\]/g, '');\n        text = text.replace(/\\[\\/ul\\]/g, '');\n        text = text.replace(/\\[ol\\]/g, '');\n        text = text.replace(/\\[\\/ol\\]/g, '');\n        text = text.replace(/\\[li\\]/g, '');\n        text = text.replace(/\\[\\/li\\]/g, '');\n\n        text = text.replace(/\\[hrule\\]/g, '');\n\n        text = text.replace(/\\[sub\\]/g, '');\n        text = text.replace(/\\[\\/sub\\]/g, '');\n        text = text.replace(/\\[sup\\]/g, '');\n        text = text.replace(/\\[\\/sup\\]/g, '');\n\n        // br format\n        text = text.replace(/\\n/g, '');\n        text = text.replace(/\\r/g, '');\n\n        // BB Markup lists\n        text = text.replace(/\\[list=1\\]((.|\\n)*?)\\[\\/list\\](<br[/]?>)?/gi, '');\n        text = text.replace(/\\[list\\]((.|\\n)*?)\\[\\/list\\](<br[/]?>)?/gi, '');\n        text = text.replace(/\\[\\*\\]/gi, '');\n        text = text.replace(/<ul>\\s<\\/li>/gi, '');\n        text = text.replace(/<ol>\\s<\\/li>/gi, '');\n        text = text.replace(/<ul><br[/]?>/gi, '');\n        text = text.replace(/<ol><br[/]?>/gi, '');\n\n        // Multi action link format\n        text = text.replace(/\\[link type=[\"']([^\"]+?)[\"'] name=[\"']([^\"]+?)[\"']\\]/g, '');\n        text = text.replace(/\\[link type=&quot;([^\"]+?)&quot; name=&quot;([^\"]+?)&quot;\\]/g, '');\n        text = text.replace(/\\[\\/link\\]/g, '');\n\n        var asRegex = /\\[actionset=([^\\]]+)\\]/g;\n        var asReplacement = text.replace(asRegex, function(match, groupOne) {\n          return '';\n        });\n        text = asReplacement;\n\n        text = text.replace(/\\[\\/actionset\\]/g, '');\n        text = text.replace(/\\[\\/link\\]/g, '');\n        text = text.replace(/\\[Step \\d+\\]/gi, '');\n\n        // red format\n        text = text.replace(/\\[red\\]/g, '');\n        text = text.replace(/\\[\\/red\\]/g, '');\n\n        text = text.replace(/\\[redb\\]/g, '');\n        text = text.replace(/\\[\\/redb\\]/g, '');\n\n        text = text.replace(/\\[redi\\]/g, '');\n        text = text.replace(/\\[\\/redi\\]/g, '');\n\n        text = text.replace(/\\[redbi\\]/g, '');\n        text = text.replace(/\\[\\/redbi\\]/g, '');\n\n        // \" Used for whitespace handling in editor\n        text = text.replace(/\\[font type=[\"']([^\"]+?)[\"']\\]/g, '');\n        text = text.replace(/\\[\\/font\\]/g, '</span>');\n\n        text = text.replace(/\\[img\\]([^[]+)\\[\\/img\\]/g, '');\n      }\n      return text;\n    },\n\n    /**\n     * Format text and decode it to remove any markup and html.\n     * @param {string} text\n     * @return {string}\n     */\n    cleanupText: function(text) {\n      text = this.decodeHtml(text);\n      text = this.removeMarkup(text);\n      return text;\n    },\n\n    /**\n     * Checks for subscreen actions\n     * @param {array} actions A list of actions\n     * @return {boolean}\n     */\n    checkForShowSubscreenAction: function(actions) {\n      return _.filter(actions, function(action) {\n        return action.strType === 'showSubScreen' || action.strActionType === 'showSubScreen';\n      }).length > 0;\n    },\n\n    /**\n     * Base64 convertion stuff!\n     */\n    Base64: {\n      _keyStr: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n\n      encode: function(e) {\n        var t = '';\n        var n;\n        var r;\n        var i;\n        var s;\n        var o;\n        var u;\n        var a;\n        var f = 0;\n        e = gomo.utility.Base64._utf8_encode(e);\n        while (f < e.length) {\n          n = e.charCodeAt(f++);\n          r = e.charCodeAt(f++);\n          i = e.charCodeAt(f++);\n          s = n >> 2;\n          o = (n & 3) << 4 | r >> 4;\n          u = (r & 15) << 2 | i >> 6;\n          a = i & 63;\n          if (isNaN(r)) {\n            u = a = 64;\n          } else if (isNaN(i)) {\n            a = 64;\n          }\n          t = t + gomo.utility.Base64._keyStr.charAt(s) +\n            gomo.utility.Base64._keyStr.charAt(o) +\n            gomo.utility.Base64._keyStr.charAt(u) +\n            gomo.utility.Base64._keyStr.charAt(a);\n        }\n        return t;\n      },\n\n      decode: function(e) {\n        var t = '';\n        var n;\n        var r;\n        var i;\n        var s;\n        var o;\n        var u;\n        var a;\n        var f = 0;\n        e = e.replace(/[^A-Za-z0-9+/=]/g, '');\n        while (f < e.length) {\n          s = gomo.utility.Base64._keyStr.indexOf(e.charAt(f++));\n          o = gomo.utility.Base64._keyStr.indexOf(e.charAt(f++));\n          u = gomo.utility.Base64._keyStr.indexOf(e.charAt(f++));\n          a = gomo.utility.Base64._keyStr.indexOf(e.charAt(f++));\n          n = s << 2 | o >> 4;\n          r = (o & 15) << 4 | u >> 2;\n          i = (u & 3) << 6 | a;\n          t = t + String.fromCharCode(n);\n          if (u != 64) {\n            t = t + String.fromCharCode(r);\n          }\n          if (a != 64) {\n            t = t + String.fromCharCode(i);\n          }\n        }\n        t = gomo.utility.Base64._utf8_decode(t);\n        return t;\n      },\n\n      _utf8_encode: function(e) {\n        e = e.replace(/\\r\\n/g, 'n');\n        var t = '';\n        for (var n = 0; n < e.length; n++) {\n          var r = e.charCodeAt(n);\n          if (r < 128) {\n            t += String.fromCharCode(r);\n          } else if (r > 127 && r < 2048) {\n            t += String.fromCharCode(r >> 6 | 192);\n            t += String.fromCharCode(r & 63 | 128);\n          } else {\n            t += String.fromCharCode(r >> 12 | 224);\n            t += String.fromCharCode(r >> 6 & 63 | 128);\n            t += String.fromCharCode(r & 63 | 128);\n          }\n        }\n        return t;\n      },\n\n      _utf8_decode: function(e) {\n        var t = '';\n        var n = 0;\n        var r = 0;\n        var c2 = 0;\n        var c3 = 0;\n        while (n < e.length) {\n          r = e.charCodeAt(n);\n          if (r < 128) {\n            t += String.fromCharCode(r);\n            n++;\n          } else if (r > 191 && r < 224) {\n            c2 = e.charCodeAt(n + 1);\n            t += String.fromCharCode((r & 31) << 6 | c2 & 63);\n            n += 2;\n          } else {\n            c2 = e.charCodeAt(n + 1);\n            c3 = e.charCodeAt(n + 2);\n            t += String.fromCharCode((r & 15) << 12 | (c2 & 63) << 6 | c3 & 63);\n            n += 3;\n          }\n        }\n        return t;\n      },\n\n      /**\n       * Stringifies and base64 encodes an object!\n       * @param {object} obj\n       * @return {string}\n       */\n      encodeObject: function(obj) {\n        // Save all json base64 encoded.\n        return gomo.utility.Base64.encode(JSON.stringify(obj));\n      },\n\n      /**\n       * Safely decodes and objectifies encoded JSON\n       * @param {string} data\n       * @return {object}\n       */\n      decodeObject: function(data) {\n        // If we already have an object return it...\n        if (typeof data == 'object') {\n          return data;\n        }\n        // Try and parse object...\n        var result = {};\n        if (data) {\n          try {\n            // Parse the data\n            result = JSON.parse(data);\n          } catch (e) {\n            try {\n              // Is it Base64 encoded?\n              var tmp = gomo.utility.Base64.decode(data);\n              result = JSON.parse(tmp);\n            } catch (e) {\n              // Unable to parse!\n            }\n          }\n        }\n        return result;\n      }\n    },\n\n    /**\n     * sanitiseBoolean\n     * This routine is used to sanitise gomo data where a boolen value is\n     * expected. It is explicit about the values it considers to be boolean\n     * and if these values are not met an exception is thrown.\n     * @param {*} dirtyData Any type of data requiring sanitisation\n     * @throws Will throw an error if the argument is not recognised.\n     * @return {Boolean}\n     */\n    sanitiseBoolean: function(dirtyData) {\n      switch (String(dirtyData)) {\n        case '1':\n        case 'true':\n          return true;\n        case '0':\n        case 'false':\n          return false;\n        default:\n          throw new Error('SanitiseBoolean: true/false value couldn\\'t be identified');\n      }\n    },\n\n    /**\n     * Get query params.\n     * @param {String} variable\n     * @return {boolean}\n     */\n    getQueryParam: function(variable) {\n      var query = window.location.search.substring(1);\n      var vars = query.split('&');\n      for (var i=0; i<vars.length; i++) {\n        var val = vars[i].split('=');\n        if (val[0] === variable) {\n          return val[1];\n        }\n      }\n      return (false);\n    },\n\n    /**\n     * Convert an object to a URL query string\n     * @param {Object} obj\n     * @return {string}\n     */\n    objectToQueryString: function(obj) {\n      var queryString = '';\n      for (var item in obj) {\n        if ({}.hasOwnProperty.call(obj, item)) {\n          queryString += '&' + item + '=' + obj[item];\n        }\n      }\n      return queryString.substring(1);\n    },\n\n    /**\n     * Get the source path to a resource for any given env\n     * @param {string} srcPath\n     * @return {string}\n     */\n    getSrcPath: function(srcPath) {\n      return MASTER_RENDERER.getResourcesPath(srcPath);\n    },\n\n    /**\n     * Switch alerts to console logs for certain scenarios\n     * @param {string} alertString\n     */\n    alert: function(alertString) {\n      if (PREVIEW_DATA && PREVIEW_DATA.editorMode) {\n        console.log(alertString);\n      } else {\n        alert(alertString);\n      }\n    }\n  };\n\n  return new Utility();\n})();\n"},function(t,n,e){e(0)(e(195))},function(t,n){t.exports="var global = this;\n\ngomo.dataStorage = (function(){\n\n\t\tvar storage = {};\n\t\tvar storageId = '';\n\t\tvar storageConfig = {\n\t\t\tuser: 'all'\n\t\t};\n\n\t\t/**\n\t\t * Do we have local storage?\n\t\t */\n\t\tvar hasLocalStorage = function() {\n\t\t\treturn typeof window['localStorage'] !== 'undefined';\n\t\t}\n\n\t\t/**\n\t\t * Create a unique storage id...\n\t\t */\n\t\tvar createStorageId = function() {\n\t\t\tvar id = 'gomo-cstore-';\n\t\t\tif (typeof window['CORE'] !== 'undefined' && CORE.objCourseData && CORE.objCourseData.strObjID) {\n\t\t\t\tid += CORE.objCourseData.strObjID;\n\t\t\t} else {\n\t\t\t\tid += Math.floor((Math.random()*9000)+1000);\n\t\t\t}\n\t\t\t/// Do we have additional arguments?\n\t\t\tif (typeof arguments !== 'undefined') {\n\t\t\t\t_.each(arguments, function(arg) {\n\t\t\t\t\tif (typeof arg !== 'undefined') {\n\t\t\t\t\t\tid += '-' + String(arg);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn id;\n\t\t}\n\n\t\t/**\n\t\t * Update the model in storage...\n\t\t */\n\t\tvar updateStoredModel = function() {\n\t\t\tif (hasLocalStorage() && storage) {\n\t\t\t\tvar model = global.gomo.utility.Base64.encodeObject(storage);\n\t\t\t\twindow.localStorage.setItem(storageId, model);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Get the model from storage!\n\t\t */\n\t\tvar pullStoredModel = function() {\n\t\t\tvar model = null;\n\t\t\tif (hasLocalStorage()) {\n\t\t\t\tmodel = window.localStorage.getItem(storageId);\n\t\t\t\tmodel = global.gomo.utility.Base64.decodeObject(model);\n\t\t\t}\n\t\t\t// Update the the storage variable accordingly...\n\t\t\tstorage = model && typeof model == 'object' ? model : {};\n\t\t}\n\n\t\t/**\n\t\t * Create the DataStorage!!\n\t\t */\n\t\tvar DataStorage = function() {\n\t\t\tvar me = this;\n\t\t\t// Create the storage id and pull the relevant model!\n\t\t\tstorageId = createStorageId(storageConfig.user);\n\t\t\tpullStoredModel();\n\t\t}\n\n\t\t// DataStorage\n\t\tDataStorage.prototype = {\n\n\t\t\t/**\n\t\t\t * Update the configuration\n\t\t\t * i.e if this data is user specific and any other types of config\n\t\t\t */\n\t\t\tconfig: function(options) {\n\t\t\t\t// Save the current model!\n\t\t\t\tupdateStoredModel();\n\t\t\t\t// Update the configuration!\n\t\t\t\tif (typeof options !== 'undefined') {\n\t\t\t\t\tif (options['user']) {\n\t\t\t\t\t\tstorageConfig.user = String(options.user);\n\t\t\t\t\t\tstorageId = createStorageId(storageConfig.user);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Pull latest model!\n\t\t\t\tpullStoredModel();\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Get the data from storage...\n\t\t\t */\n\t\t\tget: function(id) {\n\t\t\t\tvar me = this;\n\t\t\t\t// Check we have the requested id!\n\t\t\t\tif (typeof storage[id] !== 'undefined') {\n\t\t\t\t\treturn storage[id];\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Set the data in storage.\n\t\t\t */\n\t\t\tset: function(id, value) {\n\t\t\t\tvar me = this;\n\t\t\t\t// Check we have a valid id\n\t\t\t\tif (String(id)) {\n\t\t\t\t\tstorage[String(id)] = value;\n\t\t\t\t\tupdateStoredModel();\n\t\t\t\t}\n\t\t\t}\n\n\t\t};\n\n\t\t// Return and instance...\n\t\treturn new DataStorage();\n})();\n"},function(t,n,e){e(0)(e(197))},function(t,n){t.exports="/* globals NavigationManager, EMPTY_CONTROL_WHITESPACE, CORE, BOO_DYNAMIC_CONTINUOUS_SCROLLING,\n$, TEMPLATE_MANANGER, LOCALISER, SCREEN_INTERACTIONS, Mustache, TOPIC_INTERACTIONS,\nCONTINUOUS_SCROLLING_TRANSITION_TYPE, STR_DYNAMIC_TRANSITION_TYPE, _ */\n\ngomo.drawerMenu = (function() {\n  /**\n   * DrawerMenu - provides a drawer style menu for course controls and table of contents.\n   */\n  var DrawerMenu = function() {};\n\n  DrawerMenu.prototype = {\n    /**\n     * Get the header and footer controls.\n     * @return {object} controlsData\n     */\n    getControls: function() {\n      var me = this;\n      var controlsData = {\n        topControls: false,\n        bottomControls: false,\n        tocAvailable: false,\n        pageCountAvailable: false,\n        emptyHeader: false\n      };\n\n      var topControls = NavigationManager.getNavigationGroupById('top');\n      var bottomControls = NavigationManager.getNavigationGroupById('bottom');\n\n      // Search control groups for toc page count controls.\n      controlsData.tocAvailable =\n        me.searchForControl([topControls, bottomControls], 'extra-table-of-contents');\n      controlsData.pageCountAvailable =\n        me.searchForControl([topControls, bottomControls], 'extra-progress_bar');\n\n      // If no toc and no page count then all that is in the header is the close button which\n      // needs an extra classname for layout which is added on build.\n      controlsData.emptyHeader = !controlsData.topControls ? true : false;\n\n      // Render all of the controls\n      if (topControls && topControls.controls && topControls.controls.length) {\n        controlsData.topControls = this.renderControls(topControls);\n      }\n\n      if (bottomControls && bottomControls.controls && bottomControls.controls.length) {\n        controlsData.bottomControls = this.renderControls(bottomControls);\n      }\n\n      return controlsData;\n    },\n\n    /**\n     * Checks if a control exists in the supplied control group(s).\n     * @param {Array} groups\n     * @param {String} controlId\n     * @return {Boolean}\n     */\n    searchForControl: function(groups, controlId) {\n      var controlAvailable = false;\n      _.each(groups, function(group) {\n        if (group && group.controls && group.controls.length && !controlAvailable) {\n          controlAvailable =\n            _.contains(_.pluck(group.controls, 'id'), controlId);\n        }\n      });\n      return controlAvailable;\n    },\n\n    /**\n     * Renders the controls in the supplied control group.\n     * @param {object} controlGroup\n     * @return {object} controlsData\n     */\n    renderControls: function(controlGroup) {\n      // Render each controls html.\n      var controlsData = {controls: []};\n      if (controlGroup && controlGroup.getControls) {\n        var index = 0;\n        var controls = controlGroup.getControls();\n        while (controlsData.controls.length < 5) {\n          var html = '';\n          var controlId = '';\n          for (var i in controls) {\n            if (Object.prototype.hasOwnProperty.call(controls, i)) {\n              var control = controls[i];\n              if (\n                (control.position == 0 && !control.processed) ||\n                control.position == controlsData.controls.length + 1\n              ) {\n                control.processed = true;\n                html = control.render();\n                controlId = control.id;\n                break;\n              }\n            }\n          }\n          var whitespace = EMPTY_CONTROL_WHITESPACE ? '' : '&nbsp';\n          controlsData.controls.push({\n            index: ++index,\n            prefix: 'top',\n            id: controlId,\n            html: html || whitespace\n          });\n        }\n      }\n\n      // Remove any empty controls, the accessible and the toc control. Also remove the page count\n      // control because it will be rendered next to the open menu button.\n      var filteredControls = _.reject(controlsData.controls, function(control) {\n        if (\n          control.id == '' ||\n          control.id == 'extra-table-of-contents' ||\n          control.id == 'extra-accessible' ||\n          control.id === 'extra-progress_bar'\n        ) {\n          return control;\n        }\n      });\n\n      controlsData.controls = filteredControls;\n      return controlsData;\n    },\n\n    /**\n     * Get all course topics, set the correct label and mark the current topic.\n     * @return {object} topics\n     */\n    getTopics: function() {\n      var topics = CORE.objCourseData.objRawData.arrQuickLaunchTopics || false;\n      var currentTopicId =\n        CORE.getCurrentCourseObject().strObjType === 'topic'\n          ? CORE.getCurrentCourseObject().strObjID\n          : false;\n\n      // Mark the current topic.\n      for (var x = 0; x < topics.length; x++) {\n        var topicType = 'available';\n        if (topics[x].strTopicID === currentTopicId) {\n          topicType = 'current';\n        }\n        topics[x].topicType = topicType;\n        // Set the correct language.\n        if (topics[x].titles) {\n          topics[x].title =\n            topics[x].titles[gomo.translationManager.langCode] || topics[x].titles['default'];\n        }\n      }\n\n      return topics;\n    },\n\n    /**\n     * Get the screen navigation html including next and back buttons and set thier classes.\n     * @return {object} screenNavHtml\n     */\n    getScreenNav: function() {\n      var screenNavHtml = '';\n      var screenNav = NavigationManager.getNavigationGroupById('screen');\n\n      if (screenNav && screenNav.renderControls) {\n        screenNavHtml = screenNav.renderControlsByType('screen_navigation');\n      }\n\n      if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n        screenNavHtml = screenNavHtml.replace(\n          /XX_TRANSITION_TYPE_CLASS_XX/g,\n          CONTINUOUS_SCROLLING_TRANSITION_TYPE + 'TransitionC'\n        );\n      } else {\n        screenNavHtml = screenNavHtml.replace(\n          /XX_TRANSITION_TYPE_CLASS_XX/g,\n          STR_DYNAMIC_TRANSITION_TYPE + 'TransitionC'\n        );\n      }\n\n      return screenNavHtml;\n    },\n\n    /**\n     * Gets the page count HTML for rendering if enabled.\n     * @return {String | Boolean} HTML for the page counter, otherwise false.\n     */\n    getPageCountElement: function() {\n      var pageCountControl = NavigationManager.getRegisteredControlById('extra-progress_bar');\n      return pageCountControl ? pageCountControl.render() : false;\n    },\n\n    /**\n     * Build the drawer menu.\n     */\n    buildMenu: function() {\n      var me = this;\n      var drawerMenuData = {\n        headerControls: false,\n        footerControls: false,\n        topicsList: false,\n        screenNavHtml: '',\n        tileView: false,\n        headerPageCountControl: false\n      };\n      var menuHtml = '';\n\n      // Trigger nav proxy to rebuild the current nav so translations can be used.\n      if (SCREEN_INTERACTIONS.getCurrentScreenData()) {\n        gomo.eventManager.legacy('rebuildNavMenu', SCREEN_INTERACTIONS.getCurrentScreenData());\n      }\n\n      // Get all the controls.\n      var controls = this.getControls();\n\n      // Get the page count html.\n      if (controls.pageCountAvailable) {\n        drawerMenuData.headerPageCountControl = me.getPageCountElement();\n      }\n\n      // If we have no extras specified in authoring then don't render the drawer menu.\n      if (\n        controls.tocAvailable ||\n        controls.topControls && controls.topControls.controls.length ||\n        controls.bottomControls && controls.bottomControls.controls.length\n      ) {\n        drawerMenuData.headerControls = controls.topControls.controls;\n        drawerMenuData.footerControls = controls.bottomControls.controls;\n        // Get all the topics if toc extra is enabled.\n        drawerMenuData.topicsList = controls.tocAvailable ? this.getTopics() : false;\n        // If no toc is enabled show the tile view for nav items.\n        drawerMenuData.tileView = !controls.tocAvailable;\n        // Get the drawer menu template and render it.\n        var drawerTemplate = TEMPLATE_MANANGER.getTemplate('drawerMenu').htmData;\n        menuHtml = Mustache.render(drawerTemplate, drawerMenuData);\n        // Localise the html.\n        menuHtml = LOCALISER.parseForLocalisableMarkup(menuHtml);\n        // Remove exisintg drawer menu and add to the dom.\n        me.removeMenuFromDom();\n        $('#screenHolderL').prepend(menuHtml);\n        // Add open/close click event.\n        $('.drawer-menu__open-button, .drawer-menu__close-button').on('click', function() {\n          $('.drawer-menu').toggleClass('drawer-menu--hidden');\n        });\n        // Add click events for topics\n        $('.drawer-menu__topic-button').click(me.gotoTopic);\n        //  Add class for an empty header to position the close button correctly.\n        if (controls.emptyHeader) {\n          $('.drawer-menu').addClass('drawer-menu--empty-header');\n        }\n      }\n\n      this.buildScreenNav();\n      this.updatePlayerData();\n    },\n\n    /**\n     * Build the screen navigation. This is required here because the bottom/top strap renderer\n     * normally does this.\n     */\n    buildScreenNav: function() {\n      var screenNavHtml = '';\n      var screenNavData = {\n        screenNavHtml: ''\n      };\n\n      // Get screen navigation html.\n      screenNavData.screenNavHtml = this.getScreenNav();\n      // Get the screen navigation template.\n      var screenNavTemplate = TEMPLATE_MANANGER.getTemplate('screenNav').htmData;\n      // Render template.\n      screenNavHtml = Mustache.render(screenNavTemplate, screenNavData);\n      // Localise the html.\n      screenNavHtml = LOCALISER.parseForLocalisableMarkup(screenNavHtml);\n      // Add the menu to the dom.\n      if ($('#roleNavigationButtonWrapperL').length) {\n        $('#roleNavigationButtonWrapperL').replaceWith(screenNavHtml);\n      } else {\n        $('#screenHolderL').append(screenNavHtml);\n      }\n    },\n\n    /**\n     * Updates any required player data such as navigation models, page counts and button states.\n     */\n    updatePlayerData: function() {\n      // Update progress count.\n      if (typeof SCREEN_INTERACTIONS.getCurrentScreenData() !== 'undefined') {\n        gomo.eventManager.legacy(\n          'rebuiltNavMenu',\n          SCREEN_INTERACTIONS.getCurrentScreenData().objParent\n        );\n      }\n\n      // Update topic navigation data.\n      var currentScreenCount = CORE.objCurrCourseObject.intNavigationIndex + 1;\n      var currentScreenId = CORE.objCurrCourseObject.arrScreens[currentScreenCount - 1].strObjID;\n      TOPIC_INTERACTIONS.updateNavigation(\n        currentScreenCount,\n        CORE.objCurrCourseObject.arrScreens.length,\n        currentScreenId\n      );\n\n      // Update the accessible button state.\n      gomo.eventManager.legacy('navigationRendered');\n    },\n\n    /**\n     * Toc action to open the selected topic.\n     * @param {Object} event\n     */\n    gotoTopic: function(event) {\n      var topicId = $(event.currentTarget).data('topicid');\n      var actionOptions = {};\n      actionOptions.objActions = [\n        {\n          objParameters: {target_id: topicId},\n          strActionGroup: 'navigation',\n          strObjectType: 'action',\n          strType: 'internal_link'\n        }\n      ];\n      actionOptions.objOptionalExtraData = {};\n      actionOptions.objOptionalExtraData.domLink = event.currentTarget;\n      actionOptions.objOptionalExtraData.funTriggerCallBack = function() {\n        $('.drawer-menu').toggleClass('drawer-menu--hidden');\n      };\n      gomo.eventManager.legacy('processActions', actionOptions);\n    },\n\n    /**\n     * Removes the menu from the dom.\n     */\n    removeMenuFromDom: function() {\n      if ($('.drawer-menu').length) {\n        $('.drawer-menu__bar').remove();\n        $('.drawer-menu').remove();\n      }\n    }\n  };\n\n  return new DrawerMenu();\n})();\n"},function(t,n,e){e(0)(e(199))},function(t,n){t.exports="/* eslint-disable no-global-assign */\n/* globals global, _, $, CORE, ErrorHandler, OBJ_REF, BOO_ENABLE_RTL, MOBILE_DRAWER_MENU,\n  CURRENT_LOCALISED_DATA, LOCALISED_DATA, VARIABLES_HOLDER, DYNAMIC_CONTENT_SCREEN_MANAGER,\n  TOPIC_MANAGER, META_TOPIC_MANAGER, ASSET_INTERACTIONS, ASSET_RENDERER,\n  SUB_SCREEN_INTERACTIONS, SCREEN_INTERACTIONS, TOP_STRAP_RENDERER, BOTTOM_STRAP_RENDERER,\n  LogManager, CONTENT_TRACKING, PREVIEW_DATA, LOADER */\ngomo.translationManager = (function() {\n  /**\n   * TranslationManager - registers and controls all assets\n   */\n  var TranslationManager = function() {\n    // eslint-disable-next-line no-unused-vars\n    var me = this;\n  };\n\n  TranslationManager.prototype = {\n    // default\n    langCode: 'default',\n\n    ASSETGROUP: 'topic',\n    EXTRAGROUP: 'global',\n\n    courseData: {},\n    topicsData: [],\n\n    screenElements: {},\n    topicElements: {},\n\n    localisationElements: null,\n    registeredLocalisationGroups: [],\n\n    isRtlLanguage: false,\n    loadedDataLang: false,\n\n    // Translations data doesn't know if the Obj should have loaded yet so suppress errors\n    suppressDataErrors: true,\n\n    /*\n     * Set the localisation object\n     */\n    setLocalisation: function(optionLang) {\n      var me = this;\n      var langCode = (!optionLang || optionLang === 'default') ? me.getDefaultCode() : optionLang;\n\n      // If using a theme without rtl support set to false\n      if (typeof BOO_ENABLE_RTL == 'undefined') {\n        BOO_ENABLE_RTL = false;\n      }\n\n      // Set language direction if rtl is enabled\n      if (BOO_ENABLE_RTL) {\n        me.setLanguageDirection(me.isRTLLanguage(langCode));\n      }\n\n      // Set language code in html\n      $('html').attr('lang', langCode.replace('_', '-'));\n\n      // Set the whole localisation data object to support legacy data without subObjects\n      if (LOCALISED_DATA.globalCoreLocalisation || LOCALISED_DATA.globalCustomLocalisation) {\n        var coreLocal = LOCALISED_DATA.globalCoreLocalisation || {};\n        var customLocal = LOCALISED_DATA.globalCustomLocalisation || {};\n        CURRENT_LOCALISED_DATA = _.extend(coreLocal, customLocal);\n      } else {\n        CURRENT_LOCALISED_DATA = LOCALISED_DATA;\n      }\n\n      // Apply default language translations if they exist\n      if (typeof LOCALISED_DATA[langCode] !== 'undefined') {\n        for (var key in LOCALISED_DATA[langCode]) {\n          if (Object.prototype.hasOwnProperty.call(LOCALISED_DATA[langCode], key)) {\n            CURRENT_LOCALISED_DATA[key] = LOCALISED_DATA[langCode][key];\n          }\n        }\n      }\n    },\n\n    /*\n     * Set the current translation...\n     */\n    setTranslation: function(langCode, force, callback, langData, selfCalled) {\n      var me = this;\n      selfCalled = selfCalled || false;\n      // Set localisation data\n      me.setLocalisation(langCode);\n\n      // If the current render is a translation we need to refresh default for fallback purposes\n      if (\n        me.langCode !== 'default' &&\n        me.langCode !== me.getDefaultCode() &&\n        langCode !== me.getDefaultCode()\n      ) {\n        me.setTranslation(me.getDefaultCode(), true, function() {\n          // On completion of default, we now need to rerun the original request\n          me.setTranslation(langCode, force, callback, langData, true);\n        }, langData);\n        return;\n      }\n\n      if (langCode && (langCode !== me.langCode || force)) {\n        // Set the language code\n        me.langCode = langCode;\n        // Set Variable\n        if (VARIABLES_HOLDER) {\n          VARIABLES_HOLDER.setActiveLanguage(langCode);\n        }\n        if (langData && PREVIEW_DATA.editorMode && LOADER.booLoadSequenceComplete) {\n          me.updatePreviewTopicData(langData, callback, selfCalled);\n          return;\n        }\n        // Load data....\n        me.loadCourseData(function() {\n          me.loadTopicData(function() {\n            me.loadedDataLang = me.langCode;\n            me.updateBoundFields();\n            me.updateBoundLocalisations();\n            me.translateScreenElements();\n            callback();\n          });\n        });\n        return;\n      }\n      callback();\n    },\n\n    updatePreviewTopicData: function(langData, callback, selfCalled) {\n      var me = this;\n      var langCode = me.langCode === me.getDefaultCode() ? 'default' : me.langCode;\n      var topicData = _.find(langData.languages, {language: langCode});\n      /* If the translation is self called then we know\n      * we don't need to unregister any bindings\n      */\n      if (!selfCalled) {\n        me.resetTopicData();\n        me.unbindCurrentTopicFields();\n      }\n      me.topicsData = [];\n      me.topicsData.push(topicData);\n      me.translateCurrentData();\n      me.loadedDataLang = me.langCode;\n      me.updateBoundFields();\n      me.updateBoundLocalisations();\n      me.translateScreenElements();\n      callback();\n    },\n\n    /*\n     * For gomo actions definition!\n     */\n    setTranslationAction: function(actionData) {\n      var me = this;\n      var lang = actionData.langCode || 'default';\n      var callback = actionData.funCallBack || function() {};\n      me.setTranslation(lang, true, callback);\n    },\n\n    updateContentTracking: function() {\n      var me = this;\n      var defaultTopic = CORE.objCurrCourseObject;\n      var currentScreen = SCREEN_INTERACTIONS.getCurrentScreenData();\n      var screenDetails = TOPIC_MANAGER.screenDetails;\n\n      screenDetails.topicTitle = me.getTopicTitle() || currentScreen.objParent.strTitle,\n      screenDetails.pageTitle = currentScreen.strTitle;\n      if (defaultTopic.strObjTopicModel == 'linear') {\n        CONTENT_TRACKING.visit({\n          topicId: screenDetails.topicId,\n          pageId: screenDetails.pageId,\n          pageTitle: screenDetails.pageTitle,\n          topicTitle: screenDetails.topicTitle,\n          progress: VARIABLES_HOLDER.getVariableValue('gomo_course_completion_percentage'),\n          referrer: {\n            id: screenDetails.referrerId,\n            type: screenDetails.referrerType,\n            title: screenDetails.referrerTitle\n          }\n        });\n      }\n    },\n\n    setLanguageDirection: function(isRtl) {\n      if (isRtl) {\n        $('html').addClass('rtlLanguage');\n        $('html').attr('dir', 'rtl');\n      } else {\n        $('html').removeClass('rtlLanguage');\n        $('html').attr('dir', 'ltr');\n      }\n    },\n    /**\n     * Topic changed - update the relevant data\n     * and thus update certain fields...\n     */\n    changeTopic: function() {\n      var me = this;\n      if (me.langCode !== 'default') {\n        me.loadTopicData(function() {\n          // We don't need to unbind as resetTopicData() takes care of this\n          // me.unbindCurrentTopicFields();\n          me.updateBoundFields();\n          me.updateBoundLocalisations();\n          me.translateScreenElements();\n          me.updateContentTracking();\n        });\n      }\n    },\n\n    /*\n     * Meta topic has been opened\n     */\n    loadMetaTopic: function(callback) {\n      var me = this;\n      if (me.langCode !== 'default') {\n        me.loadMetaTopicData(function() {\n          me.updateMetaTopicData();\n          me.loadMetaTopicData(function() {\n            me.updateMetaTopicData();\n            if (callback) {\n              callback();\n            }\n          }, me.langCode);\n        }, me.getDefaultCode());\n      } else {\n        if (callback) {\n          callback();\n        }\n      }\n    },\n\n    updateMetaTopicData: function() {\n      var me = this;\n      me.unbindCurrentTopicFields();\n      me.updateBoundFields();\n      me.translateScreenData(me.metaTopicData);\n      me.translateAssetData(me.metaTopicData);\n    },\n\n    /*\n     * Load the global data\n     */\n    loadCourseData: function(callback) {\n      var me = this;\n      callback = callback || function() {};\n\n      var courseId = CORE.objCourseData.strObjID;\n      var filename = courseId + '_' + me.langCode + '_data.json';\n      gomo.loadDataFile(filename, function(data) {\n        if (data) {\n          me.courseData = data;\n        } else {\n          me.courseData = {};\n        }\n        callback();\n      });\n    },\n\n    /*\n     * Load the topic data\n     */\n    loadTopicData: function(callback) {\n      var me = this;\n      callback = callback || function() {};\n      var currentTopicIds = me.getCurrentTopicIds();\n\n      // Reset the topic data when loading a new topic\n      me.topicsData = [];\n\n      var topicFilenames = [];\n      var count = 0;\n      while (count < currentTopicIds.length) {\n        topicFilenames.push(\n          currentTopicIds[count] + '_' + me.langCode + '_data' + '.json'\n        );\n        count++;\n      }\n\n      var loadData = function(topicFilenames, fileCount, callback) {\n        gomo.loadDataFile(topicFilenames[fileCount], function(data) {\n          if (data) {\n            me.topicsData.push(data);\n          }\n          // Call again if more files to download\n          var newPosition = fileCount + 1;\n          if (newPosition < topicFilenames.length) {\n            loadData(topicFilenames, newPosition, callback);\n          } else {\n            me.ASSETGROUP = 'topic';\n            me.translateCurrentData();\n            callback();\n          }\n        });\n      };\n\n      loadData(topicFilenames, 0, callback);\n    },\n\n    getCurrentTopicIds: function() {\n      var topicIds = [];\n\n      topicIds.push(TOPIC_MANAGER._objCurrCourseObject.strTopicDataFilename);\n\n      var dynamicTopics = DYNAMIC_CONTENT_SCREEN_MANAGER.getReferencedMetaTopics();\n      var count = 0;\n      while (count < dynamicTopics.length) {\n        topicIds.push(dynamicTopics[count].strTopicDataFilename);\n        count++;\n      }\n\n      return topicIds;\n    },\n\n    /*\n     * Load the Meta topic data\n     */\n    loadMetaTopicData: function(callback, langCode) {\n      var me = this;\n      callback = callback || function() {};\n      var topicId = META_TOPIC_MANAGER._objCurrMetaObject.strTopicDataFilename;\n      var filename = topicId + '_' + langCode + '_data' + '.json';\n\n      gomo.loadDataFile(filename, function(data) {\n        if (data) {\n          me.metaTopicData = data;\n          me.ASSETGROUP = 'metaTopic';\n        } else {\n          me.metaTopicData = {};\n        }\n        callback();\n      });\n    },\n\n    /*\n     * Update all the bound fields...\n     */\n    updateBoundFields: function(dataType) {\n      var me = this;\n      var assets = [];\n      var topicsData = [];\n\n      if (me.ASSETGROUP == 'metaTopic') {\n        topicsData[0] = me.metaTopicData;\n      } else if (me.ASSETGROUP == 'topic') {\n        topicsData = me.topicsData;\n      }\n\n      // Test all topics to see if data has been set\n      var translationsSet = false;\n      var countTopics = 0;\n      while (countTopics < topicsData.length) {\n        if (\n          topicsData &&\n          typeof topicsData[countTopics] != 'undefined' &&\n          topicsData[countTopics].topic &&\n          topicsData[countTopics].topic.screens.length\n        ) {\n          translationsSet = true;\n        }\n        countTopics++;\n      }\n\n      // Test that the main topic has been set before continuing\n      if (translationsSet) {\n        // Find all assets\n        assets = [];\n        countTopics = 0;\n        while (countTopics < topicsData.length) {\n          var currentTopicData = topicsData[countTopics];\n          var newAssets = me.findAllAssets(currentTopicData.topic.screens);\n          assets.push.apply(assets, newAssets);\n          countTopics++;\n        }\n\n        // Add the list of clones to assets which are copied\n        assets = me.findAssetClones(assets);\n\n        // Loop all the assets...\n        for (var x = 0; x < assets.length; x++) {\n          var asset = assets[x];\n          var assetCoreData = null;\n          if (asset.id) {\n            assetCoreData = gomo.assetManager.findInstance(asset.id);\n            if (assetCoreData) {\n              /**\n               * New asset type:\n               * Grab custom handlers and register the asset with data binding lib\n               */\n              me.translateNewAssetType(assetCoreData, asset);\n            } else {\n              /**\n               * Find original asset type...\n               */\n              var screens = TOPIC_MANAGER._objCurrCourseObject.arrScreens;\n              assetCoreData = me.findLegacyAssetData(asset.id, screens);\n              // Not all data will be in the OBJ_REF yet. The meta data might not have been loaded.\n              if (!assetCoreData) {\n                continue;\n              }\n              me.translateLegacyAssetType(assetCoreData, asset);\n            }\n          }\n        }\n      }\n    },\n\n    translateNewAssetType: function(assetCoreData, assetTranslationData) {\n      var me = this;\n      // Check the data JSON file is loaded.\n      if (me.loadedDataLang !== me.langCode) {\n        return;\n      }\n\n      if (assetCoreData.data.booIsDisplayed != false) {\n        // Only preprocess if it's displayed.\n        assetCoreData.translationPreprocess();\n        me.bindAnyDynamicallyCreatedTextAssets(assetTranslationData);\n\n        var handlers = assetCoreData.bindingHandlers || {};\n        gomo.dataBinding.registerHandlers(handlers);\n\n        var assetIds = me.findAllInstancesOfAsset(assetTranslationData);\n\n        var count = 0;\n        while (count < assetIds.length) {\n          var assetId = assetIds[count];\n          var element = gomo.assetManager.getElementFromAssetId(assetId);\n\n          // Register the binding!\n          gomo.dataBinding.register(\n            assetId,\n            assetTranslationData,\n            element,\n            me.ASSETGROUP\n          );\n\n          count++;\n        }\n\n        assetCoreData.translationPostprocess();\n      } else {\n        assetCoreData.translationProcessOnHidden();\n      }\n    },\n\n    translateLegacyAssetType: function(assetCoreData, assetTranslationData) {\n      var me = this;\n\n      // Check the data JSON file is loaded. Check the asset hasn't already translated.\n      if (me.loadedDataLang !== me.langCode) {\n        return;\n      }\n\n      if (assetCoreData && assetCoreData.booIsDisplayed != false) {\n        ASSET_INTERACTIONS.translationPreprocess(assetTranslationData.id);\n\n        var handlers = ASSET_INTERACTIONS.bindingHandlers || {};\n        gomo.dataBinding.registerHandlers(handlers);\n\n        me.bindAnyDynamicallyCreatedTextAssets(assetTranslationData);\n\n        var assetIds = me.findAllInstancesOfAsset(assetTranslationData);\n\n        var count = 0;\n        while (count < assetIds.length) {\n          var legacyAsset = {};\n          legacyAsset.strType = assetCoreData.objRawData.strType;\n          legacyAsset.strID = assetIds[count];\n          var element = ASSET_RENDERER.getAssetDOMElement(legacyAsset);\n\n          gomo.dataBinding.register(\n            legacyAsset.strID,\n            assetTranslationData,\n            element,\n            me.ASSETGROUP\n          );\n\n          count++;\n        }\n\n        ASSET_INTERACTIONS.translationPostprocess(assetTranslationData.id);\n      } else {\n        ASSET_INTERACTIONS.translationProcessOnHidden(assetTranslationData.id);\n      }\n    },\n\n    /*\n     * Update all the bound Localisations...\n     */\n    updateBoundLocalisations: function(optionalData) {\n      var me = this;\n      var element;\n      var topicData = optionalData || TOPIC_MANAGER.getCurrentTopic();\n      // Create options for localistation\n      var assetOpts = {group: 'topic', searchClass: 'localisationWrapper'};\n      var subscreenOpts = {\n        group: 'subscreen',\n        searchClass: 'subscreenLocalisationWrapper',\n        depthSuppressor: true\n      };\n\n      if (topicData && topicData.arrScreens && topicData.arrScreens.length) {\n        var screenCount = 0;\n        while (screenCount < topicData.arrScreens.length) {\n          var currentScreen = topicData.arrScreens[screenCount];\n          // is screen hidden by display conditions\n          if (currentScreen.booIsDisplayed) {\n            // Translate screen level assets\n            var screenAssetCount = 0;\n            while (screenAssetCount < currentScreen.arrAssets.length) {\n              var currentScreenAsset = currentScreen.arrAssets[screenAssetCount];\n              element = me.getAssetDomElement(currentScreenAsset);\n              me.translateLocalisations(\n                element,\n                currentScreenAsset.strObjID,\n                assetOpts\n              );\n\n              screenAssetCount++;\n            }\n\n            // Apply subscreen translation and subscreen asset translations (as assets are nested in subscreens, the )\n            var subscreenCount = 0;\n            while (subscreenCount < currentScreen.arrSubScreens.length) {\n              var currentSubScreen = currentScreen.arrSubScreens[subscreenCount];\n\n              // Only translate subscreens that aren't owned by subscreens\n              if (\n                currentSubScreen &&\n                currentSubScreen.objRawData &&\n                currentSubScreen.objRawData.booAssetOwnedSubscreen !== true &&\n                !currentSubScreen.objRawData.strInstigatingAssetID\n              ) {\n                element = SUB_SCREEN_INTERACTIONS.getSubScreenDOMElement(\n                  currentSubScreen.strObjID\n                );\n                me.translateLocalisations(\n                  element,\n                  currentSubScreen.strObjID,\n                  subscreenOpts\n                );\n\n                // Translate screen level assets\n                var subscreenAssetCount = 0;\n                while (subscreenAssetCount < currentSubScreen.arrAssets.length) {\n                  var currentSubscreenAsset =\n                    currentSubScreen.arrAssets[subscreenAssetCount];\n\n                  element = me.getAssetDomElement(currentSubscreenAsset);\n                  me.translateLocalisations(\n                    element,\n                    currentSubscreenAsset.strObjID,\n                    assetOpts\n                  );\n\n                  subscreenAssetCount++;\n                }\n              }\n\n              subscreenCount++;\n            }\n          }\n          screenCount++;\n        }\n      }\n    },\n\n    /*\n     * Get the asset DOM element no matter which type of asset\n     */\n    getAssetDomElement: function(assetData) {\n      // Get asset DOM Element\n      var assetCoreData = gomo.assetManager.findInstance(assetData.strObjID);\n      if (assetCoreData) {\n        return gomo.assetManager.getElementFromAssetId(assetData.strObjID);\n      } else {\n        return ASSET_RENDERER.getAssetDOMElement(assetData.objRawData);\n      }\n    },\n\n    /*\n     * If an element has been destroyed and rebuilt, we'll need to setup a new data binding for that element\n     */\n    rebindDataToElement: function(uniqueId, assetId, elementId) {\n      var me = this;\n      // Check the element has been translated\n      if (gomo.dataBinding.bindings && gomo.dataBinding.bindings.length) {\n        var countBindings = 0;\n        while (countBindings < gomo.dataBinding.bindings.length) {\n          if (gomo.dataBinding.bindings[countBindings].uuid == uniqueId) {\n            // Find all assets\n            var assets = [];\n            var countTopics = 0;\n            while (countTopics < me.topicsData.length) {\n              var currentTopicData = me.topicsData[countTopics];\n              var newAssets = me.findAllAssets(currentTopicData.topic.screens);\n              assets.push.apply(assets, newAssets);\n              countTopics++;\n            }\n\n            var found = _.findWhere(assets, {id: assetId});\n            if (found) {\n              // Add preprocess data\n              ASSET_INTERACTIONS.translationPreprocess(assetId);\n\n              // Bind and dynamically created assets based off of this asset\n              me.unbindAnyDynamicallyCreatedTextAssets(found);\n              me.bindAnyDynamicallyCreatedTextAssets(found);\n\n              // Rebind linked subscreens\n              me.unbindLinkedSubscreens(found);\n              me.bindLinkedSubscreens(found);\n\n              // unregister current binding\n              gomo.dataBinding.unregister(uniqueId);\n\n              // Register the newbinding\n              var handlers = ASSET_INTERACTIONS.bindingHandlers || {};\n              gomo.dataBinding.registerHandlers(handlers);\n\n              gomo.dataBinding.register(\n                uniqueId,\n                found,\n                $('#' + elementId)[0],\n                me.ASSETGROUP\n              );\n            }\n\n            break;\n          }\n          countBindings++;\n        }\n      }\n    },\n\n    /**\n     * Topic reset functions\n     */\n    resetTopicData: function() {\n      var me = this;\n      me.localisationElements = {};\n      me.screenElements = {};\n      me.topicElements = {};\n      me.registeredLocalisationGroups = [];\n      gomo.dataBinding.unregisterGroup('topic');\n      gomo.dataBinding.unregisterGroup('subscreen');\n    },\n\n    /*\n     * Set localisation translations\n     */\n    translateLocalisations: function(elementToParse, uuid, opts) {\n      var me = this;\n\n      uuid = uuid + '_local';\n      var group = (opts && opts.group) || me.ASSETGROUP;\n      var classSearchTerm = (opts && opts.searchClass) || 'localisationWrapper';\n      /* Suppress searching within 'disableFurtherBinding'.\n       * An example of this use is localisation on subscreens, which might include assets with their own subscreens (which will duplicate binding)\n       */\n      var depthSuppressor = (opts && opts.depthSuppressor) || false;\n\n      // Add the elements to the group object so we can update just the required group later\n      if (elementToParse) {\n        if (typeof me.localisationElements[group] == 'undefined') {\n          me.localisationElements[group] = {};\n        }\n\n        if (depthSuppressor) {\n          me.localisationElements[group][uuid] = $(elementToParse)\n            .find('.' + classSearchTerm)\n            .not('.disableFurtherBinding .' + classSearchTerm);\n        } else {\n          me.localisationElements[group][uuid] = CORE.getElementsByClassName(\n            elementToParse,\n            classSearchTerm\n          );\n        }\n      }\n\n      if (\n        me.localisationElements &&\n        me.localisationElements[group] &&\n        me.localisationElements[group][uuid] &&\n        me.localisationElements[group][uuid].length\n      ) {\n        if ($.inArray(group, me.registeredLocalisationGroups) == -1) {\n          me.registeredLocalisationGroups.push(group);\n        }\n        var count = 0;\n        var handlers = ASSET_INTERACTIONS.bindingHandlers || {};\n        gomo.dataBinding.registerHandlers(handlers);\n\n        while (count < me.localisationElements[group][uuid].length) {\n          gomo.dataBinding.register(\n            uuid + '_' + count,\n            CURRENT_LOCALISED_DATA,\n            me.localisationElements[group][uuid][count],\n            group\n          );\n          count++;\n        }\n      }\n    },\n\n    /*\n     * Set localisation translations\n     */\n    unregisterLocalisation: function(group, uuid) {\n      var me = this;\n      uuid = uuid + '_local';\n\n      if (\n        me.localisationElements &&\n        me.localisationElements[group] &&\n        me.localisationElements[group][uuid] &&\n        me.localisationElements[group][uuid].length\n      ) {\n        var count = 0;\n        while (count < me.localisationElements[group][uuid].length) {\n          gomo.dataBinding.unregister(uuid + '_' + count);\n          count++;\n        }\n        // Remove the dom objects so they can't be passed in for rebinding later\n        me.localisationElements[group][uuid] = [];\n      }\n    },\n\n    /*\n     * Find the default Code\n     */\n    getDefaultCode: function() {\n      var langCode = null;\n\n      if (\n        CORE &&\n        CORE.objCourseData &&\n        CORE.objCourseData.objRawData &&\n        CORE.objCourseData.objRawData.arrLangs &&\n        CORE.objCourseData.objRawData.arrLangs['default']\n      ) {\n        langCode = CORE.objCourseData.objRawData.arrLangs['default'];\n      }\n\n      return langCode;\n    },\n\n    isRTLLanguage: function(langCode) {\n      var me = this;\n      var count = 0;\n      var isRtl = false;\n      me.isRtlLanguage = false;\n\n      langCode = (langCode === 'default') ? me.getDefaultCode() : langCode;\n\n      if (\n        CORE &&\n        CORE.objCourseData &&\n        CORE.objCourseData.objRawData &&\n        CORE.objCourseData.objRawData.arrLangs &&\n        CORE.objCourseData.objRawData.arrLangs.langs\n      ) {\n        while (count < CORE.objCourseData.objRawData.arrLangs.langs.length) {\n          if (\n            langCode == CORE.objCourseData.objRawData.arrLangs.langs[count].id\n          ) {\n            if (\n              CORE.objCourseData.objRawData.arrLangs.langs[count].is_rtl == 1\n            ) {\n              isRtl = true;\n              me.isRtlLanguage = true;\n            }\n            break;\n          }\n          count++;\n        }\n      }\n\n      return isRtl;\n    },\n\n    /**\n     * Return the current language Code and Readable title\n     * @return {Object} - \"id\" and \"Title\"\n     */\n    getCurrentLangCodeAndTitle: function() {\n      var me = this;\n      var currentLangCode = me.langCode;\n      // CurrentLangCode will be the current code OR default\n      if (currentLangCode == 'default') {\n        currentLangCode = me.getDefaultCode();\n      }\n\n      if (\n        CORE &&\n        CORE.objCourseData &&\n        CORE.objCourseData.objRawData &&\n        CORE.objCourseData.objRawData.arrLangs &&\n        CORE.objCourseData.objRawData.arrLangs.langs &&\n        CORE.objCourseData.objRawData.arrLangs.langs.length > 0\n      ) {\n        var count = 0;\n        var langs = CORE.objCourseData.objRawData.arrLangs.langs;\n        while (count < langs.length) {\n          // return the object when we find the langCode in the langs array\n          if (langs[count] && langs[count].id == currentLangCode) {\n            return langs[count];\n          }\n          count++;\n        }\n        return CORE.objCourseData.objRawData.arrLangs[me.langCode];\n      } else {\n        if (global.LogManager) {\n          global.LogManager.add(\n            'TEXT',\n            'Warning : Translation Manager failed to find ' +\n              me.langCode +\n              ' language code.'\n          );\n        }\n        return false;\n      }\n    },\n\n    /**\n     * Return the current language Code and Readable title\n     * @return {array} - Objects - \"id\" and \"Title\"\n     */\n    getAllLangCodesAndTitles: function() {\n      if (\n        CORE &&\n        CORE.objCourseData &&\n        CORE.objCourseData.objRawData &&\n        CORE.objCourseData.objRawData.arrLangs &&\n        CORE.objCourseData.objRawData.arrLangs.langs &&\n        CORE.objCourseData.objRawData.arrLangs.langs.length > 0\n      ) {\n        return CORE.objCourseData.objRawData.arrLangs.langs;\n      } else {\n        return [];\n      }\n    },\n\n    /*\n     * Find all assets in subscreens etc.\n     */\n    findAllAssets: function(screens) {\n      var me = this;\n      var assets = [];\n      // Loop all screens...\n      for (var i = 0; i < screens.length; i++) {\n        var screen = screens[i];\n        // Don't attempt to interact with Content Bank placeholders\n        if (screen &&\n          screen.id &&\n          DYNAMIC_CONTENT_SCREEN_MANAGER.isDynamicScreenPlaceholder(screen.id)) {\n          continue;\n        }\n        // Grab all assets in screen\n        if (\n          screen &&\n          screen.id &&\n          OBJ_REF.get(screen.id, me.suppressDataErrors) &&\n          OBJ_REF.get(screen.id, me.suppressDataErrors).booIsDisplayed ||\n          OBJ_REF.get(screen.id, me.suppressDataErrors).strObjType === 'subscreen' &&\n          screen.assets && screen.assets.length\n        ) {\n          for (var x = 0; x < screen.assets.length; x++) {\n            var asset = screen.assets[x];\n            assets.push(asset);\n          }\n        }\n        // Check for subscreens\n        if (screen.subscreens && screen.subscreens.length) {\n          assets = assets.concat(me.findAllAssets(screen.subscreens));\n        }\n      }\n      return assets;\n    },\n\n    /*\n     * Find all clones of assets\n     */\n    findAssetClones: function(assets) {\n      // eslint-disable-next-line no-unused-vars\n      var me = this;\n\n      // Check to see if the asset is used in a cloned subscreen\n      var clonedSubscreens = SUB_SCREEN_INTERACTIONS.getAllClonedSubscreenList();\n\n      var countAssets = 0;\n      while (countAssets < assets.length) {\n        var asset = assets[countAssets];\n\n        var countSubscreens = 0;\n        while (countSubscreens < clonedSubscreens.length) {\n          var subscreenId = clonedSubscreens[countSubscreens];\n          if (asset.id.indexOf(subscreenId) !== -1) {\n            var clones = SUB_SCREEN_INTERACTIONS.getRegisterSubscreenClonesById(\n              subscreenId\n            );\n            asset.clones = [];\n            var countClones = 0;\n            while (countClones < clones.length) {\n              var cloneSubscreenId = clones[countClones];\n              var assetCloneId = asset.id.replace(\n                subscreenId,\n                cloneSubscreenId\n              );\n              asset.clones.push(assetCloneId);\n              countClones++;\n            }\n            break;\n          }\n          countSubscreens++;\n        }\n\n        countAssets++;\n      }\n\n      return assets;\n    },\n\n    /*\n     * Construct list of elements the asset needs binding to\n     * from the asset data.\n     */\n    findAllInstancesOfAsset: function(asset) {\n      var assetIds = [];\n\n      assetIds.push(asset.id);\n      if (asset.clones) {\n        var count = 0;\n        while (count < asset.clones.length) {\n          assetIds.push(asset.clones[count]);\n          count++;\n        }\n      }\n      return assetIds;\n    },\n\n    /*\n     * Look for legacy asset data in the current\n     * topic data.\n     */\n    findLegacyAssetData: function(id, screens) {\n      var me = this;\n      // Loop all screens...\n      if (screens && screens.length) {\n        for (var i = 0; i < screens.length; i++) {\n          var screen = screens[i];\n          // Don't attempt to interact with Content Bank placeholders\n          if (screen &&\n            screen.id &&\n            DYNAMIC_CONTENT_SCREEN_MANAGER.isDynamicScreenPlaceholder(screen.strObjID)) {\n            continue;\n          }\n          // Loop all assets in screen...\n          if (\n            screen &&\n            screen.strObjID &&\n            OBJ_REF.get(screen.strObjID, me.suppressDataErrors) &&\n            OBJ_REF.get(screen.strObjID, me.suppressDataErrors).booIsDisplayed ||\n            OBJ_REF.get(screen.strObjID, me.suppressDataErrors).strObjType === 'subscreen' &&\n            screen.arrAssets && screen.arrAssets.length\n          ) {\n            for (var x = 0; x < screen.arrAssets.length; x++) {\n              var asset = screen.arrAssets[x];\n              if (asset.strObjID == id) {\n                return asset;\n              }\n            }\n          }\n          if (screen.arrSubScreens && screen.arrSubScreens.length) {\n            var found = me.findLegacyAssetData(id, screen.arrSubScreens);\n            if (found) {\n              return found;\n            }\n          }\n        }\n      }\n    },\n\n    /*\n     * Find and bind data for gomo linked subscreens to asset\n     */\n    bindLinkedSubscreens: function(assetTranslationData) {\n      var me = this;\n\n      var assetActions = me.getArrayOfItemsFromObjectAtKey(\n        assetTranslationData,\n        'strActionType',\n        'showSubScreen'\n      );\n      // Test if the asset has any action groups\n      if (assetActions.length > 0) {\n        var countActions = 0;\n        while (countActions < assetActions.length) {\n          var action = assetActions[countActions];\n          if (action.objParameters && action.objParameters.strSubScreenID) {\n            var linkedSubscreenId = action.objParameters.strSubScreenID;\n\n            var countTopics = 0;\n            while (countTopics < me.topicsData.length) {\n              var currentTopicData = me.topicsData[countTopics];\n\n              // Remove all asset binding from subscreen\n              var countScreens = 0;\n              while (countScreens < currentTopicData.topic.screens.length) {\n                var currentScreen =\n                  currentTopicData.topic.screens[countScreens];\n                if (currentScreen.subscreens) {\n                  var subscreen = _.findWhere(currentScreen.subscreens, {\n                    id: linkedSubscreenId\n                  });\n                  if (subscreen && subscreen.assets) {\n                    var assets = subscreen.assets;\n                    var countAssets = 0;\n                    var assetCoreData;\n                    while (countAssets < assets.length) {\n                      assetCoreData = gomo.assetManager.findInstance(\n                        assets[countAssets].id\n                      );\n                      if (assetCoreData) {\n                        // New asset type\n                        me.translateNewAssetType(\n                          assetCoreData,\n                          assets[countAssets]\n                        );\n                      } else {\n                        // Legacy asset type\n                        var screens =\n                          TOPIC_MANAGER._objCurrCourseObject.arrScreens;\n                        assetCoreData = me.findLegacyAssetData(\n                          assets[countAssets].id,\n                          screens\n                        );\n\n                        me.translateNewAssetType(\n                          assetCoreData,\n                          assets[countAssets]\n                        );\n                      }\n                      countAssets++;\n                    }\n                  }\n                }\n                countScreens++;\n              }\n\n              countTopics++;\n            }\n          }\n          countActions++;\n        }\n      }\n    },\n\n    /*\n     * Find and UNbind data for gomo linked subscreens to asset\n     */\n    unbindLinkedSubscreens: function(assetTranslationData) {\n      var me = this;\n\n      var assetActions = me.getArrayOfItemsFromObjectAtKey(\n        assetTranslationData,\n        'strActionType',\n        'showSubScreen'\n      );\n      // Test if the asset has any action groups\n      if (assetActions.length > 0) {\n        var countActions = 0;\n        while (countActions < assetActions.length) {\n          var action = assetActions[countActions];\n          if (action.objParameters && action.objParameters.strSubScreenID) {\n            var linkedSubscreenId = action.objParameters.strSubScreenID;\n\n            var countTopics = 0;\n            while (countTopics < me.topicsData.length) {\n              var currentTopicData = me.topicsData[countTopics];\n\n              // Remove all asset binding from subscreen\n              var countScreens = 0;\n              while (countScreens < currentTopicData.topic.screens.length) {\n                var currentScreen =\n                  currentTopicData.topic.screens[countScreens];\n                if (currentScreen.subscreens) {\n                  var subscreen = _.findWhere(currentScreen.subscreens, {\n                    id: linkedSubscreenId\n                  });\n                  if (subscreen && subscreen.assets) {\n                    var assets = subscreen.assets;\n                    var countAssets = 0;\n                    while (countAssets < assets.length) {\n                      var assetIds = me.findAllInstancesOfAsset(\n                        assets[countAssets]\n                      );\n                      var countAllAssets = 0;\n                      while (countAllAssets < assetIds.length) {\n                        gomo.dataBinding.unregister(assetIds[countAllAssets]);\n                        countAllAssets++;\n                      }\n                      countAssets++;\n                    }\n                  }\n                }\n                countScreens++;\n              }\n\n              countTopics++;\n            }\n          }\n          countActions++;\n        }\n      }\n    },\n\n    /*\n     * Find gomo dynmically created asset data and bind required translation data to the dynamic element\n     */\n    bindAnyDynamicallyCreatedTextAssets: function(assetTranslationData) {\n      var me = this;\n\n      var assetActions = me.getArrayOfItemsFromObjectAtKey(\n        assetTranslationData,\n        'strObjectType',\n        'action'\n      );\n      // Test if the asset has any action groups\n      if (assetActions.length > 0) {\n        var countActions = 0;\n        while (countActions < assetActions.length) {\n          var action = assetActions[countActions];\n          if (\n            action.subscreenUuid &&\n            action.objParameters &&\n            action.objParameters.strTextToCreateSubScreenID\n          ) {\n            var clones = SUB_SCREEN_INTERACTIONS.getRegisterSubscreenClonesById(\n              action.subscreenUuid\n            );\n            var assetContent = action.objParameters.strTextToCreateSubScreenID;\n            if (clones) {\n              var countClones = 0;\n              while (countClones < clones.length) {\n                var cloneSubscreenId = clones[countClones];\n                var assetFakeData = {strContent: assetContent};\n                var domElement = SUB_SCREEN_INTERACTIONS.getSubScreenContentDOMElement(\n                  cloneSubscreenId\n                );\n                /* The text asset should be the only one in the subscreen.\n                 * This step is required because the LOCALISATION function uses the subscreen ID element,\n                 * so it can't be shared with asset data\n                 */\n                var assetElement = $(domElement).find(\n                  '.genericAssetWrapperC'\n                )[0];\n\n                gomo.dataBinding.register(\n                  cloneSubscreenId,\n                  assetFakeData,\n                  assetElement,\n                  me.ASSETGROUP\n                );\n                countClones++;\n              }\n            }\n          }\n          countActions++;\n        }\n      }\n    },\n\n    /*\n     * Find gomo dynmically created asset data and UNbind required translation data to the dynamic element\n     */\n    unbindAnyDynamicallyCreatedTextAssets: function(assetTranslationData) {\n      var me = this;\n\n      var assetActions = me.getArrayOfItemsFromObjectAtKey(\n        assetTranslationData,\n        'strObjectType',\n        'action'\n      );\n      // Test if the asset has any action groups\n      if (assetActions.length > 0) {\n        var countActions = 0;\n        while (countActions < assetActions.length) {\n          var action = assetActions[countActions];\n          if (\n            action.subscreenUuid &&\n            action.objParameters &&\n            action.objParameters.strTextToCreateSubScreenID\n          ) {\n            var clones = SUB_SCREEN_INTERACTIONS.getRegisterSubscreenClonesById(\n              action.subscreenUuid\n            );\n            // eslint-disable-next-line no-unused-vars\n            var assetContent = action.objParameters.strTextToCreateSubScreenID;\n            if (clones) {\n              var countClones = 0;\n              while (countClones < clones.length) {\n                var cloneSubscreenId = clones[countClones];\n                // Check the element has been translated\n                if (\n                  gomo.dataBinding.bindings &&\n                  gomo.dataBinding.bindings.length\n                ) {\n                  var countBindings = 0;\n                  while (countBindings < gomo.dataBinding.bindings.length) {\n                    if (\n                      gomo.dataBinding.bindings[countBindings].uuid ==\n                      cloneSubscreenId\n                    ) {\n                      // unregister current binding\n                      gomo.dataBinding.unregister(cloneSubscreenId);\n                    }\n                    countBindings++;\n                  }\n                }\n                countClones++;\n              }\n            }\n          }\n          countActions++;\n        }\n      }\n    },\n\n    /*\n     * Search through an object for every instance of a key and return the level the key was found\n     */\n    getArrayOfItemsFromObjectAtKey: function(\n      objectToSearch,\n      keyToMatch,\n      valueToMatch\n    ) {\n      var returnItems = [];\n\n      var searchItem = function(searchNode) {\n        if (searchNode) {\n          if (searchNode.constructor === Object) {\n            for (var key in searchNode) {\n              if (key == keyToMatch && searchNode[key] == valueToMatch) {\n                returnItems.push(searchNode);\n              } else {\n                searchItem(searchNode[key]);\n              }\n            }\n          } else if (searchNode.constructor === Array) {\n            var count = 0;\n            while (count < searchNode.length) {\n              searchItem(searchNode[count]);\n              count++;\n            }\n          }\n        }\n      };\n\n      searchItem(objectToSearch);\n      return returnItems;\n    },\n\n    /**\n     * Remove binding for previous topic...\n     */\n    unbindCurrentTopicFields: function() {\n      var me = this;\n      gomo.dataBinding.unregisterGroup(me.ASSETGROUP);\n    },\n\n    /**\n     * Translate the current core data object for various player requirements (not\n     * the intial screen render update which is handled in data binding)\n     */\n    translateCurrentData: function() {\n      var me = this;\n      var currentCoreTopicData = TOPIC_MANAGER.getCurrentTopic();\n\n      var countTopics = 0;\n      while (countTopics < me.topicsData.length) {\n        var topicData = me.topicsData[countTopics];\n        if (topicData && topicData.topic && topicData.topic.screens) {\n          // me.translateTopicData(currentCoreToipcData);\n          me.translateScreenData(topicData);\n          me.translateAssetData(topicData);\n          me.translateNavLabels(currentCoreTopicData);\n        }\n        countTopics++;\n      }\n    },\n\n    /*\n     * Translate screen data in current topic\n     */\n    translateScreenData: function(translationData) {\n      // eslint-disable-next-line no-unused-vars\n      var me = this;\n\n      var countScreens = 0;\n      while (countScreens < translationData.topic.screens.length) {\n        var currentScreenTranslationData =\n          translationData.topic.screens[countScreens];\n\n        if (\n          currentScreenTranslationData &&\n          currentScreenTranslationData.id &&\n          OBJ_REF\n        ) {\n          // If the Object doesn't exist then it's not required for this topic.\n          // Also check Content Banks cache as the object will have been removed from OBJ_REF\n          if (!DYNAMIC_CONTENT_SCREEN_MANAGER.isDynamicScreenPlaceholder(\n            currentScreenTranslationData.id\n          )\n          && OBJ_REF.get(currentScreenTranslationData.id, me.suppressDataErrors)) {\n            // Translate Screen CORE data\n            var currentCoreScreenDataRaw = OBJ_REF.get(\n              currentScreenTranslationData.id, me.suppressDataErrors\n            ).objRawData;\n            var currentCoreScreenData = OBJ_REF.get(\n              currentScreenTranslationData.id, me.suppressDataErrors\n            );\n            var translatableFields =\n              currentCoreScreenDataRaw.arrTranslatableFields;\n            if (typeof translatableFields === 'undefined' || translatableFields === '') {\n              // Set a minimum default to translate the screen title if nothing has been set in the data\n              translatableFields = ['strTitle'];\n            }\n            currentCoreScreenData = gomo.translationManagerHelper.portTranslatedData(\n              currentScreenTranslationData,\n              currentCoreScreenData,\n              translatableFields\n            );\n            // The title is stored in two locations which need updating\n            currentCoreScreenDataRaw = gomo.translationManagerHelper.portTranslatedData(\n              currentScreenTranslationData,\n              currentCoreScreenDataRaw,\n              translatableFields\n            );\n          }\n        }\n        countScreens++;\n      }\n    },\n\n    /*\n     * Translate all assets within the current topic\n     */\n    translateAssetData: function(translationData) {\n      var me = this;\n\n      var translateDynamicallyCreatedAssets = function(\n        parentId,\n        assetToTranslate\n      ) {\n        // Pass off to UUID dynamic version function\n        var assetActions = me.getArrayOfItemsFromObjectAtKey(\n          assetToTranslate,\n          'strObjectType',\n          'action'\n        );\n        // Test if the asset has any action groups\n        if (assetActions.length > 0) {\n          var countActions = 0;\n          while (countActions < assetActions.length) {\n            var action = assetActions[countActions];\n            if (action.subscreenUuid) {\n              var clones = SUB_SCREEN_INTERACTIONS.getRegisterSubscreenClonesById(\n                action.subscreenUuid\n              );\n              // Clones can return as null if the screen isn't displayed\n              if (clones) {\n                var assetFakeData = {\n                  strContent: action.objParameters.strTextToCreateSubScreenID\n                };\n                var cloneCount = 0;\n                while (cloneCount < clones.length) {\n                  // Assume the asset to translate is the first asset in the subscreen as it's the only one built\n                  var assetId = parentId + 'a01';\n                  translateClonedSubscreenAsset(\n                    parentId,\n                    clones[cloneCount],\n                    assetId,\n                    assetFakeData\n                  );\n                  cloneCount++;\n                }\n              }\n            }\n            countActions++;\n          }\n        }\n      };\n\n      var translateClonedSubscreenAsset = function(\n        originalParentId,\n        cloneParentId,\n        assetIdToTranslate,\n        assetToTranslate\n      ) {\n        var translatableFields = null;\n        // update the id to point at the cloned version\n        var tempNewCurrentAssetTranslationId = assetIdToTranslate.replace(\n          originalParentId,\n          cloneParentId\n        );\n        // Legacy asset support\n        if (tempNewCurrentAssetTranslationId && OBJ_REF) {\n          // Translate Asset CORE data\n          var currentCoreAssetData = OBJ_REF.get(\n            tempNewCurrentAssetTranslationId, me.suppressDataErrors\n          ).objRawData;\n          if (\n            currentCoreAssetData &&\n            currentCoreAssetData.arrTranslatableFields\n          ) {\n            translatableFields = currentCoreAssetData.arrTranslatableFields;\n            currentCoreAssetData = gomo.translationManagerHelper.portTranslatedData(\n              assetToTranslate,\n              currentCoreAssetData,\n              translatableFields\n            );\n          }\n        }\n      };\n\n      var countScreens = 0;\n      var countAssets = 0;\n      var currentAssetTranslation = null;\n      var currentCoreAssetData = null;\n      while (countScreens < translationData.topic.screens.length) {\n        var currentScreenTranslationData =\n          translationData.topic.screens[countScreens];\n\n        // Translate Screen assets\n        if (currentScreenTranslationData.assets) {\n          countAssets = 0;\n          while (countAssets < currentScreenTranslationData.assets.length) {\n            currentAssetTranslation =\n              currentScreenTranslationData.assets[countAssets];\n            // Legacy asset support\n            if (\n              currentAssetTranslation &&\n              currentAssetTranslation.id &&\n              OBJ_REF\n            ) {\n              // Translate dynmically created clones of asset\n              translateDynamicallyCreatedAssets(\n                currentScreenTranslationData.id,\n                currentAssetTranslation\n              );\n\n              // Translate Asset CORE data\n              currentCoreAssetData = OBJ_REF.get(currentAssetTranslation.id, me.suppressDataErrors)\n                .objRawData;\n              if (\n                currentCoreAssetData &&\n                currentCoreAssetData.arrTranslatableFields\n              ) {\n                var translatableFields =\n                  currentCoreAssetData.arrTranslatableFields;\n                currentCoreAssetData = gomo.translationManagerHelper.portTranslatedData(\n                  currentAssetTranslation,\n                  currentCoreAssetData,\n                  translatableFields\n                );\n              }\n            }\n            countAssets++;\n          }\n        }\n\n        // Translate subscreen assets\n        if (currentScreenTranslationData.subscreens) {\n          var countSubscreens = 0;\n          while (\n            countSubscreens < currentScreenTranslationData.subscreens.length\n          ) {\n            var currentSubscreenTranslationData =\n              currentScreenTranslationData.subscreens[countSubscreens];\n            // Translate subscreen with the same data\n            if (currentSubscreenTranslationData.assets) {\n              countAssets = 0;\n              while (\n                countAssets < currentSubscreenTranslationData.assets.length\n              ) {\n                currentAssetTranslation =\n                  currentSubscreenTranslationData.assets[countAssets];\n                // Legacy asset support\n                if (\n                  currentAssetTranslation &&\n                  currentAssetTranslation.id &&\n                  OBJ_REF\n                ) {\n                  // Translate Asset CORE data\n                  currentCoreAssetData = OBJ_REF.get(\n                    currentAssetTranslation.id, me.suppressDataErrors\n                  ).objRawData;\n                  if (\n                    currentCoreAssetData &&\n                    currentCoreAssetData.arrTranslatableFields\n                  ) {\n                    translatableFields =\n                      currentCoreAssetData.arrTranslatableFields;\n                    currentCoreAssetData = gomo.translationManagerHelper.portTranslatedData(\n                      currentAssetTranslation,\n                      currentCoreAssetData,\n                      translatableFields\n                    );\n                  }\n                }\n                countAssets++;\n              }\n            }\n\n            // Translate cloned subscreens\n            var clones = SUB_SCREEN_INTERACTIONS.getRegisterSubscreenClonesById(\n              currentSubscreenTranslationData.id\n            );\n            if (clones && clones.length && clones.length > 0) {\n              var countClones = 0;\n              while (countClones < clones.length) {\n                var cloneSubscreenId = clones[countClones];\n                if (currentSubscreenTranslationData.assets) {\n                  countAssets = 0;\n                  while (\n                    countAssets < currentSubscreenTranslationData.assets.length\n                  ) {\n                    currentAssetTranslation =\n                      currentSubscreenTranslationData.assets[countAssets];\n\n                    translateClonedSubscreenAsset(\n                      currentSubscreenTranslationData.id,\n                      cloneSubscreenId,\n                      currentAssetTranslation.id,\n                      currentAssetTranslation\n                    );\n\n                    countAssets++;\n                  }\n                }\n                countClones++;\n              }\n            }\n            countSubscreens++;\n          }\n        }\n        countScreens++;\n      }\n    },\n\n    /*\n     * Translate navigation items\n     */\n    translateNavLabels: function(currentCoreTopicData) {\n      var me = this;\n\n      var countScreens = 0;\n      while (countScreens < currentCoreTopicData.arrScreens.length) {\n        var currentScreenCountData =\n          currentCoreTopicData.arrScreens[countScreens].objRawData;\n\n        if (me.courseData.extras && me.courseData.extras.objNavigationConfiguration) {\n          // Check if the data is valid\n          for (var navigationItem in me.courseData.extras\n            .objNavigationConfiguration) {\n            if (\n              typeof me.courseData.extras.objNavigationConfiguration[\n                navigationItem\n              ] !== 'object'\n            ) {\n              // If it's not valid, log an error\n              var errorMessage =\n                'Error : Navigation data malformed for ' + navigationItem;\n              if (typeof LogManager !== 'undefined') {\n                LogManager.add('TEXT', errorMessage);\n              } else {\n                console.log(errorMessage);\n              }\n\n              // Clean up the data\n              delete me.courseData.extras.objNavigationConfiguration[\n                navigationItem\n              ];\n            }\n          }\n          // Convert global extras\n          $.extend(\n            true,\n            currentScreenCountData.objNavigationConfiguration,\n            me.courseData.extras.objNavigationConfiguration\n          );\n        }\n\n        // Translate screen level if applicable\n        var countTranslationTopics = 0;\n        while (countTranslationTopics < me.topicsData.length) {\n          var countTranslationScreens = 0;\n          var thisTopicData = me.topicsData[countTranslationTopics];\n          while (countTranslationScreens < thisTopicData.topic.screens.length) {\n            var currentScreenTranslation =\n              thisTopicData.topic.screens[countTranslationScreens];\n            if (currentScreenTranslation.id == currentScreenCountData.strID) {\n              $.extend(\n                true,\n                currentScreenCountData.objNavigationConfiguration,\n                currentScreenTranslation.extras.objNavigationConfiguration\n              );\n              break;\n            }\n            countTranslationScreens++;\n          }\n          countTranslationTopics++;\n        }\n\n        countScreens++;\n      }\n\n      var currentScreenData = SCREEN_INTERACTIONS.getCurrentScreenData();\n\n      if (MOBILE_DRAWER_MENU && gomo.outputChecker.isSmartPhone()) {\n        gomo.drawerMenu.buildMenu(currentScreenData.objParent);\n      } else {\n        TOP_STRAP_RENDERER.rerenderNav(currentScreenData.objParent);\n        BOTTOM_STRAP_RENDERER.rerenderNav(currentScreenData.objParent);\n      }\n    },\n\n    /**\n     * Translate Screen specific translations\n     */\n    translateScreenElements: function() {\n      var me = this;\n\n      me.updateScreenElements();\n\n      for (var screenElementId in me.screenElements) {\n        if (screenElementId !== null) {\n          if (\n            typeof me.screenElements[screenElementId].element == 'undefined'\n          ) {\n            me.screenElements[\n              screenElementId\n            ].element = document.getElementById(screenElementId);\n          }\n          gomo.dataBinding.register(\n            screenElementId,\n            me.screenElements[screenElementId].data,\n            me.screenElements[screenElementId].element,\n            me.ASSETGROUP\n          );\n        }\n      }\n\n      for (var topicElementId in me.topicElements) {\n        if (topicElementId !== null) {\n          if (typeof me.topicElements[topicElementId].element == 'undefined') {\n            me.topicElements[topicElementId].element = document.getElementById(\n              topicElementId\n            );\n          }\n          gomo.dataBinding.register(\n            topicElementId,\n            me.topicElements[topicElementId].data,\n            me.topicElements[topicElementId].element,\n            me.ASSETGROUP\n          );\n        }\n      }\n      SCREEN_INTERACTIONS.setScreenTitle();\n    },\n\n    /*\n     * Set Screen specific translations\n     */\n    setScreenElement: function(elementId, gomoId, elementData, dataType) {\n      var me = this;\n\n      if (dataType == 'screen') {\n        me.screenElements[elementId] = {id: gomoId, data: elementData};\n      } else if (dataType == 'topic') {\n        me.topicElements[elementId] = {id: gomoId, data: elementData};\n      }\n    },\n\n    /**\n     * Update Screen specific translations\n     */\n    updateScreenElements: function() {\n      var me = this;\n\n      for (var screenElementId in me.screenElements) {\n        if (screenElementId !== null) {\n          var countTopics = 0;\n          while (countTopics < me.topicsData.length) {\n            var currentTopicData = me.topicsData[countTopics];\n\n            var count = 0;\n            while (count < currentTopicData.topic.screens.length) {\n              if (\n                me.screenElements[screenElementId].id ==\n                currentTopicData.topic.screens[count].id\n              ) {\n                me.screenElements[screenElementId].data =\n                  currentTopicData.topic.screens[count];\n                break;\n              }\n              count++;\n            }\n            countTopics++;\n          }\n        }\n      }\n\n      for (var topicElementId in me.topicElements) {\n        if (typeof me.topicElements[topicElementId] !== 'undefined') {\n          // TODO: I need to see how this works and if the below assumption of [0] is acceptable\n          me.topicElements[topicElementId].data = me.topicsData[0].topic;\n        }\n      }\n    },\n\n    /*\n     * Set the image to render based on specific assets logic\n     */\n    setImage: function(assetId, pathToImage, options) {\n      var me = this;\n      var countTopics = 0;\n      while (countTopics < me.topicsData.length) {\n        var currentTopicData = me.topicsData[countTopics];\n\n        if (\n          currentTopicData &&\n          currentTopicData.topic &&\n          currentTopicData.topic.screens\n        ) {\n          var imgOptions = options || {};\n          var assets = me.findAllAssets(currentTopicData.topic.screens);\n          var translatedAsset = _.findWhere(assets, {id: assetId});\n          var currentCoreAssetData = OBJ_REF.get(assetId).objRawData;\n          var newPath = imgOptions.newPath || 'renderImage';\n\n          if (translatedAsset) {\n            translatedAsset[newPath] = {};\n\n            // Some translations may not have translated the entire asset. Fall back to blank or default\n            var imageSource = '';\n            // Set default if available\n            if (\n              currentCoreAssetData[pathToImage] &&\n              currentCoreAssetData[pathToImage].strSrc\n            ) {\n              imageSource = currentCoreAssetData[pathToImage].strSrc;\n            }\n            // Set translation if available\n            if (\n              translatedAsset[pathToImage] &&\n              translatedAsset[pathToImage].strSrc\n            ) {\n              imageSource = translatedAsset[pathToImage].strSrc;\n            }\n\n            // Some translations may not have translated the entire asset. Fall back to blank or default\n            var imageAltText = '';\n            // Set default if available\n            if (\n              currentCoreAssetData[pathToImage] &&\n              currentCoreAssetData[pathToImage].strAltText\n            ) {\n              imageAltText = currentCoreAssetData[pathToImage].strAltText;\n            }\n            // Set translation if available\n            if (\n              translatedAsset[pathToImage] &&\n              translatedAsset[pathToImage].strAltText\n            ) {\n              imageAltText = translatedAsset[pathToImage].strAltText;\n            }\n\n            translatedAsset[newPath].strSrc =\n              imageSource === ''\n                ? imageSource\n                : gomo.utility.getSrcPath(imageSource) + decodeURIComponent(imageSource);\n\n            if (imageAltText !== '') {\n              translatedAsset[newPath].strAltText = gomo.utility.decodeHtml(\n                imageAltText\n              );\n            }\n          }\n\n          if (translatedAsset) {\n            var assetIds = me.findAllInstancesOfAsset(translatedAsset);\n            var count = 0;\n            while (count < assetIds.length) {\n              // eslint-disable-next-line no-unused-vars\n              var currentAssetId = assetIds[count];\n              // gomo.dataBinding.update(currentAssetId, translatedAsset);\n              count++;\n            }\n          }\n        }\n        countTopics++;\n      }\n    },\n\n    /*\n     * Set an array of images to render based on specific assets logic\n     */\n    setArrayOfImages: function(assetId, pathToArray, pathToImage, options) {\n      var me = this;\n\n      var count = 0;\n      var countTopics = 0;\n      while (countTopics < me.topicsData.length) {\n        var currentTopicData = me.topicsData[countTopics];\n        if (\n          currentTopicData &&\n          currentTopicData.topic &&\n          currentTopicData.topic.screens\n        ) {\n          var imgOptions = options || {};\n          var assets = me.findAllAssets(currentTopicData.topic.screens);\n          var translatedAsset = _.findWhere(assets, {id: assetId});\n          var currentCoreAssetData = OBJ_REF.get(assetId).objRawData;\n          var newPath = imgOptions.newPath || 'renderImages';\n\n          if (translatedAsset && translatedAsset[pathToArray]) {\n            var translatedImages = translatedAsset[pathToArray];\n            var currentImages = currentCoreAssetData[pathToArray];\n            translatedAsset[newPath] = [];\n\n            count = 0;\n            while (count < currentImages.length) {\n              translatedAsset[newPath][count] = {};\n\n              // Some translations may not have translated the entire asset. Fall back to blank or default\n              var imageSource = '';\n              var imagePath = '';\n              // Set default if available\n              if (\n                currentImages[count] &&\n                currentImages[count][pathToImage] &&\n                currentImages[count][pathToImage].strSrc\n              ) {\n                imagePath = gomo.utility.getSrcPath(currentImages[count][pathToImage].strSrc);\n                imageSource = imagePath + currentImages[count][pathToImage].strSrc;\n              }\n              // Set translation if available\n              if (\n                translatedImages[count] &&\n                translatedImages[count][pathToImage] &&\n                translatedImages[count][pathToImage].strSrc\n              ) {\n                imagePath = gomo.utility.getSrcPath(translatedImages[count][pathToImage].strSrc);\n                imageSource = imagePath + translatedImages[count][pathToImage].strSrc;\n              }\n\n              translatedAsset[newPath][count].strSrc = decodeURIComponent(imageSource);\n\n              var imageAltText = '';\n              // Set default if available\n              if (\n                currentImages[count] &&\n                currentImages[count][pathToImage] &&\n                currentImages[count][pathToImage].strAltText\n              ) {\n                imageAltText = currentImages[count][pathToImage].strAltText;\n              }\n              // Set translation if available\n              if (\n                translatedImages[count] &&\n                translatedImages[count][pathToImage] &&\n                translatedImages[count][pathToImage].strAltText\n              ) {\n                imageAltText = translatedImages[count][pathToImage].strAltText;\n              }\n              translatedAsset[newPath][\n                count\n              ].strAltText = gomo.utility.decodeHtml(imageAltText);\n\n              count++;\n            }\n          }\n\n          if (translatedAsset) {\n            var assetIds = me.findAllInstancesOfAsset(translatedAsset);\n            count = 0;\n            while (count < assetIds.length) {\n              var currentAssetId = assetIds[count];\n              gomo.dataBinding.update(currentAssetId, translatedAsset);\n              count++;\n            }\n          }\n        }\n        countTopics++;\n      }\n    },\n\n    setDynamicTranslationsItem: function(assetId, name, value) {\n      var me = this;\n\n      var countTopics = 0;\n      while (countTopics < me.topicsData.length) {\n        var currentTopicData = me.topicsData[countTopics];\n        if (\n          currentTopicData &&\n          currentTopicData.topic &&\n          currentTopicData.topic.screens\n        ) {\n          var assets = me.findAllAssets(currentTopicData.topic.screens);\n          var translatedAsset = _.findWhere(assets, {id: assetId});\n          if (translatedAsset) {\n            translatedAsset[name] = value;\n          }\n        }\n        countTopics++;\n      }\n    },\n\n    /*\n     * Clean an array of values of special characters from a translation object\n     * Asset ID - the id of the asset to clean\n     * Array to clean - the list of translation fields to pass through the decoder\n     */\n    htmlDecodeAssetTranslations: function(assetId, arrayToClean) {\n      var me = this;\n      var assets = [];\n      var countTopics = 0;\n      while (countTopics < me.topicsData.length) {\n        var currentTopicData = me.topicsData[countTopics];\n        var newAssets = me.findAllAssets(currentTopicData.topic.screens);\n        assets.push.apply(assets, newAssets);\n        countTopics++;\n      }\n      var translatedAsset = _.findWhere(assets, {id: assetId});\n\n      if (translatedAsset) {\n        var count = 0;\n        while (count < arrayToClean.length) {\n          var fieldToClean = arrayToClean[count];\n          if (translatedAsset[fieldToClean]) {\n            translatedAsset[fieldToClean] = gomo.utility.decodeHtml(\n              translatedAsset[fieldToClean]\n            );\n          } else {\n            // Convert the translation value over to the new clean value\n            try {\n              eval(\n                'translatedAsset.' +\n                  fieldToClean +\n                  '=gomo.utility.decodeHtml(translatedAsset.' +\n                  fieldToClean +\n                  ')'\n              );\n            } catch (err) {\n              typeof ErrorHandler != 'undefined' &&\n                ErrorHandler['catch'] &&\n                ErrorHandler['catch'](err);\n              console.log(\n                'Tranlsation manager was unable to convert ' +\n                  fieldToClean +\n                  ' to htmlDecodeAssetTranslations() ERROR:' +\n                  err\n              );\n            }\n          }\n\n          count++;\n        }\n      }\n    },\n\n    /*\n     * Get the translated asset data for a particular asset.\n     */\n    findDataByAssetId: function(assetId) {\n      var countTopic = 0;\n\n      if (gomo.translationManager.topicsData) {\n        // Check each topic\n        while (countTopic < gomo.translationManager.topicsData.length) {\n          if (\n            gomo.translationManager.topicsData[countTopic].topic &&\n            gomo.translationManager.topicsData[countTopic].topic.screens\n          ) {\n            var assets = gomo.translationManager.findAllAssets(\n              gomo.translationManager.topicsData[countTopic].topic.screens\n            );\n            var found = _.findWhere(assets, {id: assetId});\n\n            if (found) {\n              return found;\n            }\n          }\n          countTopic++;\n        }\n        return false;\n      }\n    },\n    /*\n     * Get the translated topic title tracking and display in the bookmark popup.\n     */\n    getTopicTitle: function() {\n      var me = this;\n      var topicTitle = '';\n      var translatedTopic = {};\n      if (me.topicsData.length) {\n        translatedTopic = _.find(me.topicsData, {'language': me.getCurrentLangCodeAndTitle().id});\n        if (translatedTopic && translatedTopic.topic && translatedTopic.topic.strTitle) {\n          topicTitle = translatedTopic.topic.strTitle;\n        }\n      }\n      return topicTitle;\n    }\n  };\n\n  return new TranslationManager();\n})();\n"},function(t,n,e){e(0)(e(201))},function(t,n){t.exports="gomo.translationManagerHelper = (function(){\n\n\t/**\n\t * TranslationManager - registers and controls all assets\n\t */\n\tvar TranslationManagerHelper = function(){\n\t\tvar me = this;\n\t};\n\n\tTranslationManagerHelper.prototype = {\n\n\t\tsetSubobjectValue : function (assetFieldName, portFrom, portTo)\n\t\t{\n\t\t\tvar me = this;\n\n\t\t\tfunction changeSubValue(assetFieldName, portFrom, portTo)\n\t\t\t{\n\t\t\t\tif(assetFieldName.indexOf('#') != -1 || assetFieldName.indexOf('.') != -1 )\n\t\t\t\t{\n\t\t\t\t\tif(assetFieldName.indexOf('.') != -1 \n\t\t\t\t\t&& (assetFieldName.indexOf('.') < assetFieldName.indexOf('#')) || (assetFieldName.indexOf('#') == -1) )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar arrObjPath = assetFieldName.split('.');\n\t\t\t\t\t\tvar firstPath = arrObjPath[0];\n\t\t\t\t\t\tvar newFieldName = assetFieldName.replace(firstPath+'.','');\n\t\t\t\t\t\tvar newRawObj = portFrom[firstPath] || null;\n\n\t\t\t\t\t\tif(portTo == null){\n\t\t\t\t\t\t\tportTo = {};\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(typeof portTo[firstPath] == \"undefined\"){\n\t\t\t\t\t\t\tportTo[firstPath] = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(newRawObj){\n\t\t\t\t\t\t\tportTo[firstPath] = changeSubValue(newFieldName, newRawObj, portTo[firstPath]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t// I am not sure why we'd return a null object. Maybe required for edtior but not play. If it's null we'll use the default data.\n\t\t\t\t\t\t\t//return newRawObj;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn portTo;\n\t\t\t\t\t}\n\t\t\t\t\tif(assetFieldName.indexOf('#') != -1 \n\t\t\t\t\t&& (assetFieldName.indexOf('#') < assetFieldName.indexOf('.')) || (assetFieldName.indexOf('.') == -1) )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar arrObjPath = assetFieldName.split('#');\n\t\t\t\t\t\tvar firstPath = arrObjPath[0];\n\t\t\t\t\t\tvar newFieldName = assetFieldName.replace(firstPath+'#.','');\t\n\n\t\t\t\t\t\tvar arrCount = 0;\n\t\t\t\t\t\tif(portTo == null || portTo.length < 0){\n\t\t\t\t\t\t\tportTo = [null];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\twhile (arrCount < portFrom.length)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tportTo[arrCount] = changeSubValue(newFieldName, portFrom[arrCount], portTo[arrCount]);\n\t\t\t\t\t\t\tarrCount++;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn portTo;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(assetFieldName == \"SUBSCREEN\")\n\t\t\t\t\t{\n\t\t\t\t\t\t//Subscreen assets are translated individually and we don't want to translate actions attached to subscreens\t\t\t\t\t\n\t\t\t\t\t\treturn portTo;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif(typeof portTo == \"object\" && portTo != null){\n\t\t\t\t\t\t\tif(typeof portFrom[assetFieldName] !== 'undefined'){\n\t\t\t\t\t\t\t\tportTo[assetFieldName] = portFrom[assetFieldName];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tportTo = {};\n\t\t\t\t\t\t\tif(typeof portFrom[assetFieldName] !== 'undefined'){\n\t\t\t\t\t\t\t\tportTo[assetFieldName] = portFrom[assetFieldName];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn portTo;\n\t\t\t\t\t}\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar returnObj = changeSubValue(assetFieldName, portFrom, portTo);\n\n\t\t\treturn returnObj;\n\t\t},\t\n\n\t\tportTranslatedData : function(portFrom, portTo, translatableFields){\n\t\t\tvar me = this;\n\n\t\t\tvar countTranslations = 0;\n\t\t\twhile(countTranslations < translatableFields.length)\n\t\t\t{\n\t\t\t\tvar translatableField = translatableFields[countTranslations];\n\n\t\t\t\tif(translatableField.indexOf('.') != -1)\n\t\t\t\t{\n\t\t\t\t\tconsole.log(translatableField+' contains an object');\n\t\t\t\t\tvar translatableField = me.setSubobjectValue(translatableField, portFrom, portTo);\n\t\t\t\t}\n\t\t\t\telse if(translatableField.indexOf('#') != -1)\n\t\t\t\t{\n\t\t\t\t\tconsole.log(translatableField+' contains an array');\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//If the translation term exists, then port it.\n\t\t\t\tif(jQuery.inArray(translatableField, translatableFields) !== -1){\n\t\t\t\t\t\t//check there is a translation to port\n\t\t\t\t\t\tif(typeof portFrom[translatableField] != \"undefined\"){\n\t\t\t\t\t\t\tportTo[translatableField] = portFrom[translatableField];\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcountTranslations++;\n\t\t\t}\n\n\t\t\treturn portTo;\n\t\t},\n\n\t\t//Not used yet so currently untested!!\n\t\treturnSubValue : function(assetFieldName, objectToSearch)\n\t\t{\n\t\t\tif(assetFieldName.indexOf('#') != -1 || assetFieldName.indexOf('.') != -1 )\n\t\t\t{\n\t\t\t\tif(assetFieldName.indexOf('.') != -1 \n\t\t\t\t&& (assetFieldName.indexOf('.') < assetFieldName.indexOf('#')) || (assetFieldName.indexOf('#') == -1) )\n\t\t\t\t{\n\t\t\t\t\tvar arrObjPath = assetFieldName.split('.');\n\t\t\t\t\tvar firstPath = arrObjPath[0];\n\t\t\t\t\tvar newFieldName = assetFieldName.replace(firstPath+'.','');\n\t\t\t\t\tvar newRawObj = objectToSearch[firstPath] || null;\n\t\t\t\t\t\n\t\t\t\t\tif(newRawObj){\n\t\t\t\t\t\treturn changeSubValue(newFieldName, newRawObj);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tconsole.log('TranslationManagerHelper.returnSubValue() couldn\\'t find '+newFieldName);\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(assetFieldName.indexOf('#') != -1 \n\t\t\t\t&& (assetFieldName.indexOf('#') < assetFieldName.indexOf('.')) || (assetFieldName.indexOf('.') == -1) )\n\t\t\t\t{\n\t\t\t\t\tvar arrObjPath = assetFieldName.split('#');\n\t\t\t\t\tvar firstPath = arrObjPath[0];\n\t\t\t\t\tvar newFieldName = assetFieldName.replace(firstPath+'#.','');\t\n\n\t\t\t\t\tvar arrCount = 0;\n\t\t\t\t\tvar arrayOfValues = [];\n\t\t\t\t\twhile (arrCount < objectToSearch.length)\n\t\t\t\t\t{\n\t\t\t\t\t\tarrayOfValues.push(changeSubValue(newFieldName, objectToSearch[arrCount]));\n\t\t\t\t\t\tarrCount++;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn arrayOfValues;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(assetFieldName == \"SUBSCREEN\")\n\t\t\t\t{\n\t\t\t\t\tconsole.log('TranslationManagerHelper.returnSubValue() found a subscreen');\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif(typeof objectToSearch[assetFieldName] !== 'undefined'){\n\t\t\t\t\t\treturn objectToSearch[assetFieldName];\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\treturn objectToSearch[assetFieldName];;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t};\n\n\treturn new TranslationManagerHelper();\n\n})();"},function(t,n,e){e(0)(e(203))},function(t,n){t.exports="var global  = this;\n\n/**\n * Geo Location\n */\ngomo.geoLocation = (function(global){\n\n\t/**\n\t * Constructor\n\t */\n\tvar GeoLocation = function() {\n\t\tvar me = this;\n\t\tme.supported = !!navigator.geolocation;\n\t\tme.currentLocation = null;\n\t}\n\n\tvar validateOptions = function(options) {\n\t\tvar template = {\n\t\t\tsuccess: function(){},\n\t\t\terror: function(){},\n\t\t};\n\n\t\toptions = options || template;\n\t\toptions.success = options.success || template.success;\n\t\toptions.error = options.error || template.error;\n\n\t\treturn options;\n\t}\n\n\t/**\n\t *\n\t */\n\tGeoLocation.prototype = {\n\n\t\t/**\n\t\t * Initialise, set get the location and set it....\n\t\t */\n\t\tinit: function(options) {\n\t\t\tvar me = this;\n\t\t\tvar deferred = $.Deferred();\n\n\t\t\toptions = validateOptions(options);\n\n\t\t\tif(me.supported) {\n\t\t\t\t// Get the location...\n\t\t\t\tme.locate()\n\t\t\t\t\t// Success, finding the location\n\t\t\t\t\t.then(function(pos) {\n\t\t\t\t\t\t// Save the position once we have it.\n\t\t\t\t\t\tme.setPosition(pos)\n\t\t\t\t\t\t\t// Success\n\t\t\t\t\t\t\t.then(function(loc) {\n\t\t\t\t\t\t\t\tdeferred.resolve(loc);\n\t\t\t\t\t\t\t\toptions.success(loc);\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t// Error\n\t\t\t\t\t\t\t.fail(function(err) {\n\t\t\t\t\t\t\t\tdeferred.reject(err);\n\t\t\t\t\t\t\t\toptions.error(err)\n\t\t\t\t\t\t\t})\n\t\t\t\t\t})\n\t\t\t\t\t// Error finding the location...\n\t\t\t\t\t.fail(function(err) {\n\t\t\t\t\t\tconsole.log('Failed to locate...');\n\t\t\t\t\t\tconsole.log(err ? err.message : '');\n\n\t\t\t\t\t\tdeferred.reject(err);\n\t\t\t\t\t\toptions.error(err);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn deferred.promise();\n\t\t},\n\n\t\t/**\n\t\t * Automatically determine location\n\t\t * Returns a promise with success returning the position object\n\t\t */\n\t\tlocate: function(locationOptions, options) {\n\t\t\tvar me = this;\n\t\t\tvar deferred = $.Deferred();\n\t\t\toptions = validateOptions(options);\n\n\t\t\tif(me.supported) {\n\t\t\t\t/////////\n\t\t\t\t// Get the current location\n\t\t\t\t////////\n\t\t\t\tnavigator.geolocation.getCurrentPosition(\n\t\t\t\t\t// Success\n\t\t\t\t\tfunction(result) {\n\t\t\t\t\t\toptions.success(result);\n\t\t\t\t\t\tdeferred.resolve(result);\n\t\t\t\t\t},\n\t\t\t\t\t// Error\n\t\t\t\t\tfunction(err) {\n\t\t\t\t\t\toptions.error(err);\n\t\t\t\t\t\tdeferred.reject(err);\n\t\t\t\t\t},\n\t\t\t\t\t// Options\n\t\t\t\t\tlocationOptions);\n\t\t\t} else {\n\t\t\t\tvar err = 'Not supported.';\n\t\t\t\toptions.error(err);\n\t\t\t\tdeferred.reject({\n\t\t\t\t\tcode: 1,\n\t\t\t\t\tmessage: err\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn deferred.promise();\n\t\t},\n\n\t\t/**\n\t\t * Set the position\n\t\t * Attempts to get human-readable adddrss for location\n\t\t * then saves it in memory and sends to CONTENT_TRACKING if available...\n\t\t */\n\t\tsetPosition: function(location) {\n\t\t\tvar me = this;\n\t\t\tvar deferred = $.Deferred();\n\n\t\t\tif(location) {\n\t\t\t\tme.getAddress(location)\n\t\t\t\t\t// success, set the address...\n\t\t\t\t\t.then(function(address) {\n\t\t\t\t\t\tlocation.address = address;\n\t\t\t\t\t\tme.currentLocation = location;\n\t\t\t\t\t\tdeferred.resolve(me.currentLocation);\n\t\t\t\t\t})\n\t\t\t\t\t// failed to get the address, but if we still have the location reoslve it.\n\t\t\t\t\t.fail(function(err) {\n\t\t\t\t\t\tif(location && location.coords) {\n\t\t\t\t\t\t\tme.currentLocation = location;\n\t\t\t\t\t\t\tdeferred.resolve(me.currentLocation);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdeferred.reject(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t}\n\t\t\treturn deferred.promise();\n\t\t},\n\n\t\t/**\n\t\t * Convert location in to actual address...\n\t\t * this will call upon google APIs\n\t\t */\n\t\tgetAddress: function(location, options) {\n\t\t\tvar deferred = $.Deferred();\n\t\t\toptions = validateOptions(options);\n\n\t\t\t// Validate the location\n\t\t\tlocation = location || {};\n\t\t\tlocation.coords = location.coords || {};\n\t\t\tvar latitude = location.coords.latitude || 0;\n\t\t\tvar longitude = location.coords.longitude || 0;\n\t\t\t// Ensure we have a location...\n\t\t\tif(latitude && longitude) {\n\t\t\t\t$.ajax({\n\t\t\t\t\turl: '//maps.googleapis.com/maps/api/geocode/json?key=AIzaSyAQLo3pU1sEeVkXhJKbwUC9raRnSvxVJAY&latlng=' + latitude + ',' + longitude,\n\t\t\t\t\tdataType: 'json',\n\t\t\t\t\ttimeout: 600\n\t\t\t\t})\n\t\t\t\t.always(function(jqXHR, textStatus, error) {\n\n\t\t\t\t\tif(jqXHR && jqXHR.status == 'OK') {\n\t\t\t\t\t\tif(jqXHR.results) {\n\t\t\t\t\t\t\tvar postalTown = '';\n\t\t\t\t\t\t\tvar cityAndCounty = '';\n\n\t\t\t\t\t\t\t_.each(jqXHR.results, function(point) {\n\t\t\t\t\t\t\t\tif(point.types && point.types.length) {\n\t\t\t\t\t\t\t\t\t// Find the city and county...\n\t\t\t\t\t\t\t\t\tif(~point.types.indexOf('political') && ~point.types.indexOf('locality')) {\n\t\t\t\t\t\t\t\t\t\tcityAndCounty = point.formatted_address;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// Find the postal town (UK mainly)\n\t\t\t\t\t\t\t\t\tif(~point.types.indexOf('postal_town')) {\n\t\t\t\t\t\t\t\t\t\tpostalTown = point.formatted_address;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\tvar result = postalTown || cityAndCounty;\n\t\t\t\t\t\t\tconsole.log('Result: ' + result);\n\t\t\t\t\t\t\tdeferred.resolve(result);\n\t\t\t\t\t\t\toptions.success(result);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\toptions.error();\n\t\t\t\t\t\tdeferred.reject();\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// Reject the promise...\n\t\t\t\toptions.error();\n\t\t\t\tdeferred.reject();\n\t\t\t}\n\n\t\t\treturn deferred.promise();\n\t\t},\n\n\t\t/**\n\t\t *\n\t\t */\n\t\tgetGeoJSON: function(location) {\n\n\t\t\t// Emtpty GeoJSON object\n\t\t\tvar result = {\n\t\t\t\ttype: 'Feature',\n\t\t\t\tgeometry: {\n\t\t\t\t\ttype: 'Point',\n\t\t\t\t\tcoordinates: []\n\t\t\t\t},\n\t\t\t\tproperties: {\n\t\t\t\t\tname: ''\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tif(location) {\n\t\t\t\tvar coords = location.coords || {};\n\t\t\t\t// Set the co-ordinates\n\t\t\t\tresult.geometry.coordinates = [\n\t\t\t\t\tcoords.longitude || 0,\n\t\t\t\t\tcoords.latitude || 0\n\t\t\t\t];\n\t\t\t\t// Set the name of the location...\n\t\t\t\tresult.properties.name = location.address || '';\n\t\t\t}\n\n\t\t\t// Return the JSON...\n\t\t\treturn JSON.stringify(result);\n\t\t},\n\n\t\t/**\n\t\t *\n\t\t */\n\t\tgeoJSON: function() {\n\t\t\tvar me = this;\n\t\t\treturn me.getGeoJSON(me.currentLocation);\n\t\t}\n\t}\n\n\treturn new GeoLocation();\n\n\n})(global)\n"},function(t,n,e){e(0)(e(205))},function(t,n){t.exports="var global  = this;\n/**\n * Inactivity Monitor\n */\ngomo.inactivityMonitor = (function(global, _){\n\n\tvar defaultDuration = 180000; // 3 mins\n\tvar duration = 0;\n\tvar lastActivity = null;\n\n\tvar onActivity = [];\n\tvar onInactivity = [];\n\n\tvar activityInterval = null;\n\tvar eventNamespace = '.gomoactivity';\n\tvar inactivityEventName = 'courseInactive';\n\n\t/**\n\t * Constructor\n\t */\n\tvar InactivityMonitor = function() {\n\t\tvar me = this;\n\t}\n\n\t/**\n\t * Validate the options\n\t */\n\tvar validateOptions = function(options) {\n\n\t\tvar template = {\n\t\t\tduration: null,\n\t\t\tonActivity: [],\n\t\t\tonInactivity: [],\n\t\t};\n\n\t\toptions = options || template;\n\n\t\t// Validate the duration...\n\t\toptions.duration = _.isNumber(options.duration) && !isNaN(options.duration) ? options.duration : null;\n\n\t\t// Validate the method...\n\t\toptions.onActivity = !_.isArray(options.onActivity) && !_.isFunction(options.onActivity) ? function() { } : options.onActivity;\n\t\toptions.onInactivity = !_.isArray(options.onInactivity) && !_.isFunction(options.onInactivity) ? function() { } : options.onInactivity;\n\t\t// Finally ensure its an array...\n\t\toptions.onActivity = _.isArray(options.onActivity) ? options.onActivity : [options.onActivity];\n\t\toptions.onInactivity = _.isArray(options.onInactivity) ? options.onInactivity : [options.onInactivity];\n\n\t\treturn options;\n\t}\n\n\t/**\n\t * Set an interval based on the on the duration of inactivity\n\t * to be monitored...\n\t */\n\tvar startIntervalChecks = function() {\n\t\t// Set last activity now!\n\t\tregisterActivity();\n\t\t// Start checking...\n\t\tactivityInterval = setInterval(checkActivity, duration/2);\n\t}\n\n\t/**\n\t * Clears the interval checking for activity...\n\t */\n\tvar stopIntervalChecks = function() {\n\t\tif (activityInterval) {\n\t\t\ttry {\n\t\t\t\tclearInterval(activityInterval);\n\t\t\t} catch (e) {\n\t\t\t\t// Do nothing...\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Registers activity has ocurred!\n\t */\n\tvar registerActivity = function() {\n\t\tlastActivity = Date.now();\n\t\t// Now fire any custom methods\n\t\tif (_.isArray(onActivity)) {\n\t\t\t_.each(onActivity, function(method) {\n\t\t\t\tif (_.isFunction(method)) {\n\t\t\t\t\tmethod();\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t}\n\n\t/**\n\t * Check if activity has ocurred..\n\t */\n\tvar checkActivity = function() {\n\t\t// Have we been inactive for longer than requested?\n\t\tif (lastActivity && (Date.now()-lastActivity) >= duration) {\n\t\t\t// Yes - so fire the events!\n\t\t\tgomo.eventManager.raise(inactivityEventName);\n\t\t\tgomo.eventManager.legacy(inactivityEventName);\n\t\t\t// Now fire any custom methods\n\t\t\tif (_.isArray(onInactivity)) {\n\t\t\t\t_.each(onInactivity, function(method) {\n\t\t\t\t\tif (_.isFunction(method)) {\n\t\t\t\t\t\tmethod();\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t}\n\t\t\t// Reset activity...\n\t\t\tlastActivity = Date.now();\n\t\t}\n\t}\n\n\t/**\n\t *\n\t */\n\tvar registerActivityEvents = function() {\n\t\tvar eventList = [\n\t\t\t'click',\n\t\t\t'touchstart',\n\t\t\t'keyup',\n\t\t\t'scroll'\n\t\t].join(eventNamespace + ' ');\n\t\t$(document).off(eventNamespace);\n\t\t$(document).on(eventList, registerActivity);\n\t}\n\n\tvar unregisterActivityEvents = function() {\n\t\t$(document).off(eventNamespace);\n\t}\n\n\t/**\n\t *\n\t */\n\tInactivityMonitor.prototype = {\n\n\t\t/**\n\t\t * Starts the inactivity monitor...\n\t\t */\n\t\tstart: function(config) {\n\t\t\tvar cfg = validateOptions(config);\n\t\t\t// Add the methods to be called on activity...\n\t\t\tif (cfg.onActivity && cfg.onActivity.length) {\n\t\t\t\tonActivity = _.union(cfg.onActivity);\n\t\t\t}\n\t\t\t// Add the methods to be called on inactivity....\n\t\t\tif (cfg.onInactivity && cfg.onInactivity.length) {\n\t\t\t\tonInactivity = _.union(cfg.onInactivity);\n\t\t\t}\n\t\t\t// Set the duration...\n\t\t\tif (cfg.duration) {\n\t\t\t\tduration = cfg.duration;\n\t\t\t}\n\n\t\t\tduration = duration || defaultDuration;\n\n\t\t\tregisterActivityEvents();\n\t\t\tstopIntervalChecks();\n\t\t\tstartIntervalChecks();\n\t\t},\n\n\t\t/**\n\t\t * Pauses the inactivity monitor\n\t\t * Checking for inactivity will pause but it will retain the methods\n\t\t * it needs to fire when is resumes...\n\t\t */\n\t\tpause: function() {\n\t\t\tstopIntervalChecks();\n\t\t},\n\n\t\t/**\n\t\t * Stops the inactivity monitor\n\t\t * Checking for inactivity will stop and all custom settings will be reset.\n\t\t */\n\t\tstop: function() {\n\t\t\tstopIntervalChecks();\n\t\t\tunregisterActivityEvents();\n\t\t\t// Reset custom attributes...\n\t\t\tduration = defaultDuration;\n\t\t\tonActivity.length = 0;\n\t\t\tonInactivity.length = 0;\n\t\t},\n\n        lastActivity: function() {\n            return lastActivity;\n        }\n\t}\n\n\treturn new InactivityMonitor();\n\n})(global, _)\n"},function(t,n,e){e(0)(e(207))},function(t,n){t.exports="gomo.templateManager = (function(){\n\n\t/**\n\t * TemplateManager - centralises all common template related tasks\n\t */\n\tvar TemplateManager = function(){\n\t\tvar me = this;\n\t};\n\n\tTemplateManager.prototype = {\n\t\t// v2.2 supported methods\n\t\tcachedTemplates: {},\n\n\t\t/**\n\t\t * @function setPartials - Set Handlebars partials\n\t\t * @param {object} partials name - partial dom element ID and/or class\n\t\t */\n\t\tsetPartials: function(partials){\n\t\t\tfor(partialName in partials){\n\t\t\t\ttry{\n\t\t\t\t\tvar htmlFragment = $(partials[partialName]).html();\n\t\t\t\t\tHandlebars.registerPartial(partialName, htmlFragment);\n\t\t\t\t}\n\t\t\t\tcatch(err){\n\t\t\t\t\tif(global.LogManager){\n\t\t\t\t\t\tglobal.LogManager.add('ERROR', err);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * @function setTemplate - Gets the html for template\n\t\t * @param {Object} document - Script element for Handlebars\n\t\t * @param {string} fragmentId - ID of script element\n\t\t */\n\t\tsetTemplate: function(fragmentDoc, fragmentId){\n\t\t\tvar me = this;\n\t\t\tvar template = fragmentDoc.find('#' + fragmentId).html();\n\n\t\t\t/*\n\t\t\t* If we don't have one cached, find it, compile and cache!\n\t\t\t* We don't need version '~className' of the templates as there is only one\n\t\t\t* template and the subparts handed by if/else handlebars controllers\n\t\t\t*/\n\t\t\tif(me.cachedTemplates[fragmentId] == undefined){\n\t\t\t\tme.complieAndCache(fragmentId, template);\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * @function getTemplate - Gets the html for template\n\t\t * @param {string} templateName - Name of the template\n\t\t * @param {string} templateClass - Optional class\n\t\t */\n\t\tgetTemplate: function(templateName, templateClass){\n\t\t\treturn TEMPLATE_MANANGER.getTemplate.apply(TEMPLATE_MANANGER, arguments);\n\t\t},\n\n\t\t/**\n\t\t * @function getCompiledTemplate - Gets the html for template via two potential methods\n\t\t * @param {Object} options \n\t\t * - itemType string - Name of the item which the template ID will match\n\t\t * - legacyMethod Object - templateName string and templateClass string, which together make the cached name of the template\n\t\t */\n\t\tgetCompiledTemplate: function(options){\n\t\t\tvar me = this;\n\t\t\t\n\t\t\t//Set the legacy template and class names\n\t\t\tvar templateName = \"\";\n\t\t\tif(typeof options.legacyMethod !== \"undefined\" && typeof options.legacyMethod.templateName !== \"undefined\"){\n\t\t\t\ttemplateName = options.legacyMethod.templateName;\n\t\t\t}\n\t\t\tvar templateClass = \"\";\n\t\t\tif(typeof options.legacyMethod !== \"undefined\" && typeof options.legacyMethod.templateClass !== \"undefined\"){\n\t\t\t\ttemplateClass = options.legacyMethod.templateClass;\n\t\t\t}\n\n\t\t\tvar cacheName = options.itemType;\n\t\t\tvar cacheNameLegacy = templateName + '~' + (templateClass || '');\n\t\t\t\n\t\t\t//If the cacheName exists, return it\n\t\t\tif(me.cachedTemplates[cacheName] !== undefined){\n\t\t\t\treturn me.cachedTemplates[cacheName];\n\t\t\t}\n\n\t\t\t/* If we don't have either cached then it must be the first call of a legacy item.\n\t\t\t* We need to find it, compile and cache!\n\t\t\t*/\n\t\t\telse if(me.cachedTemplates[cacheNameLegacy] == undefined){\n\t\t\t\t// Get the template...\n\t\t\t\tvar template = me.getTemplate(templateName, templateClass);\n\t\t\t\ttemplate = template.htmData;\n\n\t\t\t\tme.complieAndCache(cacheNameLegacy, template);\n\t\t\t}\n\t\t\treturn me.cachedTemplates[cacheNameLegacy];\n\t\t\t\n\t\t},\n\n\t\tcomplieAndCache: function (cacheName, template){\n\t\t\tvar me = this;\n\n\t\t\t// Hack: replace ID's in IE8, will not be necessary with new tempate loading...\n\t\t\tvar idRegEx = new RegExp('id=\"(.*?)\"(\\{\\{.*?L)', 'g');\n\t\t\tif(idRegEx.test(template)){\n\t\t\t\ttemplate = template.replace(idRegEx, 'id=\"$1$2\"');\n\t\t\t}\n\t\t\t\n\t\t\t// Compile and cache!\n\t\t\tme.cachedTemplates[cacheName] = Handlebars.compile(template);\n\t\t}\n\t};\n\n\treturn new TemplateManager();\n\n})();"},function(t,n,e){e(0)(e(209))},function(t,n){t.exports="/* global _, gomo, global, CONTENT_TRACKING,  LearningObjective */\n\ngomo.learningObjectivesManager = (function() {\n  var dataFileName = 'learning_objectives.json';\n\n  /**\n   * LearningObjectivesManager - centralises all common learning objectives tasks\n   * @return {object}\n   */\n  var LearningObjectivesManager = function() {\n    /**\n     * List of learning objective instances\n     */\n    var learningObjectives = {};\n\n    /**\n     * Initialise learning objectives manager\n     */\n    function init() {\n      loadData();\n    }\n\n    /**\n     * Responsible for loading definition JSON\n     */\n    function loadData() {\n      gomo.loadDataFile(dataFileName, function(data) {\n        if (data) {\n          initialiseLearningObjectives(data.learningObjectives);\n        }\n      });\n    }\n\n    /**\n     * Initialise learning objectives\n     * @param {array} los A list of learning objectives\n     */\n    function initialiseLearningObjectives(los) {\n      if (los && los.length) {\n        _.each(los, function(loData) {\n          var stateData = loadStateData(loData.id);\n          learningObjectives[loData.id] = new LearningObjective(loData, stateData);\n          if (stateData && stateData.complete) {\n            var activeActions = learningObjectives[loData.id].getActiveActions();\n            performActions(activeActions);\n          }\n        });\n      }\n    }\n\n    /**\n     * Loads state data from XAPI, SCORM, localstorage etc.\n     * @param {string} loId The learning objective identifier\n     * @return {object}\n     */\n    function loadStateData(loId) {\n      return CONTENT_TRACKING.state.get(loId);\n    }\n\n    /**\n     * Get learning objective by id\n     * @param {string} loId The id of the learning objective to return\n     * @return {object} Return the learning objective instance\n     */\n    function getLearningObjective(loId) {\n      var learningObjective = null;\n      if (loId && _.has(learningObjectives, loId)) {\n        learningObjective = learningObjectives[loId];\n      }\n      return learningObjective;\n    }\n\n    /**\n     * Looks up LO based on id, saves the result value\n     * @param {string} loId Learning objective identifier\n     * @param {string} resultId identifier i.e. questions asset id\n     * @param {object|number} result\n     */\n    function addResult(loId, resultId, result) {\n      var learningObjective = getLearningObjective(loId);\n\n      if (learningObjective) {\n        learningObjective.addResult(resultId, result);\n        gomo.eventManager.legacy('learningObjectiveUpdated', {\n          learningObjectiveId: loId,\n          deferPostUpdateActions: true\n        });\n      }\n    }\n\n    /**\n     * Looks up LO based on id, completes the LO, gets summary of all scores,\n     * sends the tracking data (XAPI, scorm)\n     * @param {string|array} filter The LO identifier or a list of LO identifiers\n     */\n    function complete(filter) {\n      var loIDs = filter == undefined ? [] : filter;\n      loIDs = _.isArray(filter) ? filter : [filter];\n\n      _.each(loIDs, function(loId) {\n        var learningObjective = getLearningObjective(loId);\n\n        if (learningObjective) {\n          learningObjective.complete(loId);\n          var activeActions = learningObjective.getActiveActions();\n          saveStateData(loId);\n          sendTrackingSummary(loId);\n          performActions(activeActions);\n        }\n      });\n    }\n\n    /**\n     * Saves state data to XAPI, SCORM, localstorage etc.\n     * @param {string} loId The learning objective identifier\n     */\n    function saveStateData(loId) {\n      var learningObjective = getLearningObjective(loId);\n\n      if (learningObjective) {\n        var state = learningObjective.getState();\n        CONTENT_TRACKING.state.add(loId, state);\n        CONTENT_TRACKING.saveState();\n      }\n    }\n\n    /**\n     * Send the summary statement to the content tracking\n     * @param {string} loId The learning objective identifier\n     */\n    function sendTrackingSummary(loId) {\n      var learningObjective = getLearningObjective(loId);\n\n      if (learningObjective) {\n        var scores = learningObjective.getScores();\n        var loData = learningObjective.getData();\n        var interactionData = {\n          type: 'scored',\n          activity: {\n            id: loData.id,\n            title: gomo.utility.decodeHtml(loData.title) || '',\n            type: 'objective'\n          },\n          result: {\n            score: {\n              raw: scores.raw,\n              min: scores.min,\n              max: scores.max\n            }\n          }\n        };\n\n        // The scaled scored must be between -1 and 1\n        if (!(scores.zscore < -1 || scores.zscore > 1)) {\n          interactionData.result.score.scaled = scores.zscore;\n        }\n\n        CONTENT_TRACKING.interaction(interactionData);\n      }\n    }\n\n    /**\n     * Perform LO actions\n     * @param {array} actions\n     */\n    function performActions(actions) {\n      _.each(actions, function(action) {\n        if (action.type === 'recommend') {\n          gomo.topicManager.recommendTopic(action.topicId, true);\n        } else if (global.LogManager) {\n          global.LogManager.add(\n            'TEXT',\n            'Unsupported action type: ' + action.type\n          );\n        }\n      });\n    }\n\n    return {\n      init: function() {\n        init();\n      },\n      getLearningObjective: function(loId) {\n        return getLearningObjective(loId);\n      },\n      /**\n       * Get learning objectives\n       * @return {object}\n       */\n      getLearningObjectives: function() {\n        return learningObjectives;\n      },\n      addResult: function(loId, resultId, resultScore) {\n        addResult(loId, resultId, resultScore);\n      },\n      complete: function(loId) {\n        complete(loId);\n      },\n      saveStateData: function(loId) {\n        saveStateData(loId);\n      }\n    };\n  };\n\n  return new LearningObjectivesManager();\n})();\n"},function(t,n,e){e(0)(e(211))},function(t,n){t.exports="/* global _ */\n\nvar LearningObjective = function(data, stateData) { // eslint-disable-line no-unused-vars\n  /**\n   * Definition data from JSON\n   */\n  var definition = data;\n\n  /**\n   * Current state object\n   */\n  var state = {\n    complete: false,\n    results: []\n  };\n\n  /**\n   * Calculate scores (raw, zscore and sten)\n   * @return {object}\n   */\n  function calculateScores() {\n    var scores = {\n      raw: 0,\n      min: 0,\n      max: 0,\n      zscore: 0,\n      sten: 0\n    };\n\n    _.each(state.results, function(result) {\n      scores.raw += result.score;\n      scores.min += result.min;\n      scores.max += result.max;\n    });\n    scores.zscore = (scores.raw - definition.mean) / definition.standardDeviation;\n    scores.zscore = +scores.zscore.toFixed(2);\n    scores.sten = Math.ceil((scores.zscore * 2) + 5.5);\n\n    return scores;\n  }\n\n  /**\n   * Saves result to state\n   * @param {string} resultId Identifier i.e. questions asset id\n   * @param {object} resultScore The result score, min and max\n   */\n  function addResult(resultId, resultScore) {\n    var found = _.find(state.results, {id: resultId});\n    var result = resultScore;\n\n    if (_.isNumber(resultScore)) {\n      result = {\n        score: resultScore,\n        min: 0,\n        max: 100\n      };\n    }\n\n    if (found) { // Update score\n      found.score = result.score;\n    } else { // Add new result\n      state.results.push({\n        id: resultId,\n        score: result.score,\n        min: result.min,\n        max: result.max\n      });\n    }\n  }\n\n  /**\n   * Updates the state data\n   * @param {object} loadedStateData\n   */\n  function updateStateData(loadedStateData) {\n    if (loadedStateData) {\n      state.complete = loadedStateData.complete;\n      state.results = _.map(loadedStateData.results, _.clone);\n    }\n  }\n\n  /**\n   * Loops all actions in LearningObjective and checks if there are any matches\n   * if action criteria is met then returns array of actions which are active\n   * @return {array}\n   */\n  function getActiveActions() {\n    var actions = [];\n    if (definition.actions && definition.actions.length) {\n      var scores = calculateScores();\n      _.each(definition.actions, function(action) {\n        if (validateAction(action, scores)) {\n          actions.push(action);\n        }\n      });\n    }\n    return actions;\n  }\n\n  /**\n   * Validate learning objective action\n   * @param {object} action\n   * @param {object} scores\n   * @return {boolean}\n   */\n  function validateAction(action, scores) {\n    var valid = false;\n\n    if (_.isNumber(action.value) && action.attribute) {\n      if (action.operator === 'eq') {\n        valid = scores[action.attribute] === action.value;\n      } else if (action.operator === 'ne') {\n        valid = scores[action.attribute] !== action.value;\n      } else if (action.operator === 'lt') {\n        valid = scores[action.attribute] < action.value;\n      } else if (action.operator === 'le') {\n        valid = scores[action.attribute] <= action.value;\n      } else if (action.operator === 'gt') {\n        valid = scores[action.attribute] > action.value;\n      } else { // action.operator === 'ge'\n        valid = scores[action.attribute] >= action.value;\n      }\n    }\n\n    return valid;\n  }\n\n  /**\n   * Completes the LO, saves the state data and sends the tracking summary\n   */\n  function complete() {\n    state.complete = true;\n  }\n\n  updateStateData(stateData);\n\n  return {\n    getData: function() {\n      return _.extend(definition);\n    },\n    getState: function() {\n      return {\n        complete: state.complete,\n        results: _.map(state.results, _.clone)\n      };\n    },\n    addResult: function(resultId, result) {\n      addResult(resultId, result);\n    },\n    hasResults: function() {\n      return state.results.length > 0;\n    },\n    getScores: function() {\n      return calculateScores();\n    },\n    getActiveActions: function() {\n      return getActiveActions();\n    },\n    complete: function() {\n      complete();\n    }\n  };\n};\n"},function(t,n,e){e(0)(e(213))},function(t,n){t.exports="/* global Mustache, $ */\n\ngomo.alertManager = (function() {\n  /**\n   * AlertManager - handles alerts in the Player\n   */\n  var AlertManager = function() {};\n\n  AlertManager.prototype = {\n    /**\n     * Create an alert\n     * @param {string} alertType - success, info, warning or danger\n     * @param {string} title - title for alert conent\n     * @param {string} message - alert conent\n     * @param {Object[]} buttons - buttons to assign to alert\n     * @param {string} buttons[].label - label on button\n     * @param {*} buttons[].action - function call to action on button click OR false\n     * @param {string} gomoReference - a generic or specific reference for gomo to find the notification\n     */\n    create: function(alertType, title, message, buttons, gomoReference) {\n      var me = this;\n\n      // Get the template\n      var alertEl = gomo.templateManager.getTemplate('alertWrapperC').htmData;\n\n      /* Set a random ID for the element to support multiple concurrent alerts\n       * in the future, all with their own functions attached\n       */\n      var elId = me.generateRandomElementId();\n\n      gomoReference = gomoReference || '';\n      var renderData = {\n        elId: elId,\n        alertType: alertType,\n        title: title,\n        message: message,\n        buttons: buttons,\n        gomoReference: gomoReference\n      };\n\n      // Render the template.\n      alertEl = Mustache.render(alertEl, renderData);\n      $('#pageWrapperL').prepend(alertEl);\n\n      var count = 0;\n      $('#' + elId + ' .btn').each(function() {\n        $(this).on('click', function() {\n          $('#' + elId).remove();\n        });\n        if (\n          typeof renderData.buttons[count].action !== 'undefined' &&\n          renderData.buttons[count].action\n        ) {\n          $(this).on('click', renderData.buttons[count].action);\n        }\n        count++;\n      });\n    },\n\n    /**\n     * Close alert(s) with a given reference if they're open\n     * @param {string} gomoReference\n     */\n    closeAlert: function(gomoReference) {\n      $('.alert-box[data-reference='+gomoReference+']').remove();\n    },\n\n    /**\n     * Create a unique random element\n     * @return {String}\n     */\n    generateRandomElementId: function() {\n      var randomNumber = function() {\n        return Math.floor(Math.random() * 999);\n      };\n\n      var elId = 'alert-' + randomNumber();\n      while ($('#' + elId).length > 0) {\n        elId = 'alert-' + randomNumber();\n      }\n\n      return elId;\n    }\n  };\n\n  return new AlertManager();\n})();\n"},function(t,n,e){e(0)(e(215))},function(t,n){t.exports="/* global $, _, EM */\n\n/**\n * Parallax manager responsible for applying and controlling parallax scrolling within continuous\n * scroll topics.\n *\n * @author J.Gowen\n */\n\ngomo.parallaxManager = (function() {\n  return {\n    /**\n     * Initialise the parallax effect on screens within the current topic.\n     */\n    init: function() {\n      var me = this;\n\n      // Only use parallax on desktop in newer browsers\n      if (gomo.outputChecker.isIE8() || gomo.outputChecker.currentMode === 'accessibleC') return;\n\n      me.preLoadInit();\n    },\n\n    /**\n     * Initialise the parallax effect on screens within the current topic.\n     */\n    preLoadInit: function() {\n      var me = this;\n      // Init all screens within the topic\n      var topicScreensData = gomo.topicManager.getCurrentTopic().arrScreens;\n\n      // Count bg images loaded\n      var screenCount = 0;\n      var bgLoadedCount = 0;\n      var blankingToggleSet = false;\n\n      // Init every screen that has parallax enabled\n      _.each(topicScreensData, function(screenData) {\n        var parallaxSettings = screenData.objRawData.objParallaxSettings;\n        var imgSrc = screenData.objRawData.objNormalBackgroundSrc.strSrc;\n        if (typeof parallaxSettings === 'undefined' || !parallaxSettings.enabled || imgSrc === '') {\n          return;\n        }\n        screenData.parallaxData = {};\n        screenData.parallaxData.screenDom = $('#screenWrapper_' + screenData.strObjID + 'L');\n\n        // Add parallax css class\n        if (blankingToggleSet === false && gomo.outputChecker.currentMode !== 'accessibleC') {\n          EM.trigger('toggleBlanking', {strState: 'ON', objWhatDOM: false});\n          blankingToggleSet = true;\n        }\n        screenCount++;\n\n        $('<img/>')\n          .attr('src', 'resources/' + imgSrc)\n          .on('load error', function() {\n            $(this).remove(); // prevent memory leaks\n            $(screenData.parallaxData.screenDom).css(\n              'background-image',\n              'resources/' + imgSrc\n            );\n            bgLoadedCount++;\n            if (bgLoadedCount === screenCount) {\n              EM.trigger('toggleBlanking', {strState: 'OFF', objWhatDOM: false});\n              me.postLoadInit();\n            }\n          });\n      });\n    },\n\n    /**\n     * Initialise the parallax effect on screens within the current topic.\n     */\n    postLoadInit: function() {\n      var me = this;\n\n      // Init all screens within the topic\n      var topicScreensData = gomo.topicManager.getCurrentTopic().arrScreens;\n\n      // The screens in the topic that have parallax enabled\n      var parallaxScreens = [];\n\n      var contentWrapperHeight = $('#contentWrapperL').height();\n      var contentTop = $('#contentWrapperL').offset().top;\n\n      // Init every screen that has parallax enabled\n      _.each(topicScreensData, function(screenData) {\n        var parallaxSettings = screenData.objRawData.objParallaxSettings;\n        // If the parallaxSettings data doesn't exist or is disabled for this screen, skip this\n        // iteration\n        if (typeof parallaxSettings === 'undefined' || !parallaxSettings.enabled) {\n          return;\n        }\n        screenData.parallaxData = {};\n        screenData.parallaxData.screenDom = $('#screenWrapper_' + screenData.strObjID + 'L');\n        screenData.parallaxData.screenHeight = $(screenData.parallaxData.screenDom).height();\n        screenData.parallaxData.contentTop = contentTop;\n        screenData.parallaxData.contentWrapperHeight = contentWrapperHeight;\n\n        // Add parallax css class\n        me.addCss(screenData.strObjID, 'parallax');\n\n        // If screen is full height then add fullHeight parallax class\n        if (parallaxSettings.fullHeight) {\n          me.addCss(screenData.strObjID, 'parallax-full-height');\n          // Re-check height as we've modified the CSS\n          screenData.parallaxData.screenHeight = $(screenData.parallaxData.screenDom).height();\n        }\n\n        // Caluate and set the background aspect ratio\n        parallaxSettings.bgAspectRatio = me.getBackgroundAspectRatio(\n          screenData.objRawData.objNormalBackgroundSrc.strSrc\n        );\n        // If the screen has parallax enabled add it to the array of enabled screens\n        parallaxScreens.push(screenData);\n\n        // Set image start position for images moving slower than screen scrolling\n        parallaxSettings.startPosition = 0;\n        parallaxSettings.floatSpeed = parseFloat(parallaxSettings.speed);\n\n        // If the screen is static and desktop, then leave CSS set to fixed\n        if (parallaxSettings.floatSpeed > 0 || !gomo.outputChecker.isDesktop()) {\n          me.addCss(screenData.strObjID, 'moves');\n        }\n\n        var overflow = contentWrapperHeight;\n        overflow += screenData.parallaxData.screenHeight;\n\n        if (parallaxSettings.floatSpeed < 1 && parallaxSettings.floatSpeed !== 0) {\n          parallaxSettings.startPosition = parallaxSettings.floatSpeed * overflow;\n        }\n        me.scaleBackgroundImage(screenData);\n      });\n\n      if (gomo.outputChecker.isDesktop()) {\n        // Add a scroll event that will trigger parallax on screens that have parallax enabled\n        $('#contentWrapperL').on('scroll DOMMouseScroll', function(e) {\n          me.applyParallax(parallaxScreens, contentWrapperHeight);\n        });\n      } else {\n        // mobile scrolling event\n        $('#contentWrapperInnerL').on('iscroll', function(e) {\n          me.applyParallax(parallaxScreens, contentWrapperHeight);\n        });\n      }\n\n      // Run the apply straight away to reposition screens inview\n      me.applyParallax(parallaxScreens, contentWrapperHeight);\n    },\n\n    /**\n     * Add the css classes that are required for parallax scrolling\n     * @param {string} screenId\n     * @param {string} className\n     */\n    addCss: function(screenId, className) {\n      // Add parallax css to screens that need it\n      $('#screenWrapper_' + screenId + 'L').addClass(className);\n    },\n\n    /**\n     * Scale the screen background image to allow for parallax movement\n     * @param {object} screenData\n     */\n    scaleBackgroundImage: function(screenData) {\n      var me = this;\n      // All screens assume the background size of the largest screen\n      var parallaxSettings = screenData.objRawData.objParallaxSettings;\n      var parallaxData = screenData.parallaxData;\n\n      var requiredBackgroundWidth = $(window).width();\n      var imageProperties = me.getBackgroundProperties(\n        screenData.objRawData.objNormalBackgroundSrc.strSrc\n      );\n\n      // If we don't know the image properties then leave them as 'auto'\n      if (imageProperties === false) {\n        return;\n      }\n\n      var widthIncreased = false;\n      // If we've made the width bigger than we need to increase the height too\n      if (imageProperties.width < requiredBackgroundWidth) {\n        widthIncreased = true;\n        imageProperties.width = requiredBackgroundWidth;\n        imageProperties.height = imageProperties.width * parallaxSettings.bgAspectRatio;\n      }\n\n      // Now the height is set we need to see how much height plus movement we need\n      var distanceToMove = parallaxData.screenHeight + parallaxData.contentWrapperHeight;\n      var moveSpeed = parallaxSettings.floatSpeed;\n      var remainingContentView = parallaxData.screenHeight;\n      var requiredBackgroundHeight = distanceToMove * moveSpeed + remainingContentView;\n\n      var currentScreenElement = $('#screenWrapper_' + screenData.strObjID + 'L');\n      if (imageProperties.height && imageProperties.height < requiredBackgroundHeight) {\n        parallaxData.centralStartPos = 0;\n        // If parallax is enabled and the speed isn't set to static (cover the screen)\n        if (parallaxSettings.enabled && parallaxSettings.floatSpeed !== 0) {\n          // Resize the background\n          $(currentScreenElement).css(\n            'background-size',\n            'auto ' + parseInt(requiredBackgroundHeight) + 'px'\n          );\n        }\n      } else {\n        var extraImageHeight = imageProperties.height - requiredBackgroundHeight;\n        var startPos = parallaxData.centralStartPos = extraImageHeight / 2;\n        startPos = startPos * -1;\n        // Move the background image\n        $(currentScreenElement).css('background-position-y', startPos + 'px');\n        if (widthIncreased) {\n          // Resize the background\n          $(currentScreenElement).css(\n            'background-size',\n            parseInt(imageProperties.width) + 'px ' + parseInt(imageProperties.height) + 'px'\n          );\n        }\n      }\n    },\n\n    /**\n     * Apply the parallax movement to each parallax enabled screen\n     * @param {array} parallaxScreens\n     * @param {number} contentWrapperHeight\n     */\n    applyParallax: function(parallaxScreens, contentWrapperHeight) {\n      // Apply parallax to each screen\n      _.each(parallaxScreens, function(screen, index) {\n        var parallaxSettings = screen.objRawData.objParallaxSettings || {};\n        // If the parallaxSettings data doesn't exist or is disabled for this screen, skip this\n        // iteration\n        if (typeof parallaxSettings === 'undefined' || !parallaxSettings.enabled) {\n          return;\n        }\n        var speed = parallaxSettings.speed || 0;\n        var screenDom = screen.parallaxData.screenDom;\n        var actualScreenTop = screenDom.offset().top - screen.parallaxData.contentTop;\n        var actualScreenBottom = actualScreenTop + screen.parallaxData.screenHeight;\n        var moveAmount = 0;\n\n        // Check if the screen is visible and animate if it is\n        if (\n          actualScreenTop < contentWrapperHeight &&\n          actualScreenBottom > 0 &&\n          parallaxSettings.floatSpeed !== 0\n        ) {\n          moveAmount = contentWrapperHeight - actualScreenTop;\n\n          // Apply speed\n          moveAmount *= speed;\n          var moveDirection = 1;\n          if (moveAmount > 0) {\n            moveDirection = -1;\n          }\n\n          var orginalPosition = parallaxSettings.startPosition || 0;\n          orginalPosition += screen.parallaxData.centralStartPos || 0;\n\n          // Fast moving screens need to reverse their position value\n          if (parallaxSettings.floatSpeed > 1) {\n            moveAmount = orginalPosition + moveAmount;\n          } else {\n            moveAmount = orginalPosition - moveAmount;\n          }\n\n          // Move positive moveAmounts up and negative moveAmounts down\n          moveAmount = moveAmount * moveDirection;\n\n          // Move the background image\n          $(screenDom).css('background-position-y', moveAmount + 'px');\n        } else if (actualScreenTop < contentWrapperHeight &&\n          actualScreenBottom > 0 &&\n          parallaxSettings.floatSpeed === 0 &&\n          !gomo.outputChecker.isDesktop()) {\n          // Apply the mobile static position via JS as mobile doesn't support fixed background pos\n          var direction = -1;\n\n          var mobileStatic = actualScreenTop + screen.parallaxData.centralStartPos || 0;\n          mobileStatic = mobileStatic * direction;\n\n          // Move the background image\n          $(screenDom).css('background-position-y', mobileStatic + 'px');\n        }\n      });\n    },\n\n    /**\n     * Calculates the screen top position within the content wrapper\n     * @param {string} currentScreenId\n     * @return {number}\n     */\n    calculateScreenTop: function(currentScreenId) {\n      var currentScreenTop = 0;\n      var screenIndex = 0;\n      var screensData = gomo.topicManager.getCurrentTopic().arrScreens;\n\n      // Find our current screen and note the index.\n      _.each(screensData, function(screen, index) {\n        if (screen.strObjID === currentScreenId) {\n          screenIndex = index;\n        }\n      });\n\n      // Loop through all screens before that index and find thier heights\n      var count = 0;\n      while (count < screenIndex) {\n        var screenData = screensData[count];\n        // Measure and store screen height\n        currentScreenTop += screenData.parallaxData.screenHeight;\n        count++;\n      }\n\n      return currentScreenTop;\n    },\n\n    /**\n     * Calculates the background image aspect ratio which is used for re-sizing the image.\n     * @param {string} src\n     * @return {number}\n     */\n    getBackgroundAspectRatio: function(src) {\n      // Return the aspect ratio of the background image\n      var aspectRatio = 1;\n      if (gomo && gomo.fileManager && gomo.fileManager.getImageProperties) {\n        var backgroundDimensions = gomo.fileManager.getImageProperties(decodeURIComponent(src));\n        if (\n          backgroundDimensions &&\n          backgroundDimensions.strWidth &&\n          backgroundDimensions.strHeight\n        ) {\n          aspectRatio =\n            parseInt(backgroundDimensions.strHeight) / parseInt(backgroundDimensions.strWidth);\n        }\n      }\n      return aspectRatio;\n    },\n\n    /**\n     * Calculates the background image aspect ratio which is used for re-sizing the image.\n     * @param {string} src\n     * @return {number}\n     */\n    getBackgroundProperties: function(src) {\n      // Return the aspect ratio of the background image\n      var response = {};\n      if (gomo && gomo.fileManager && gomo.fileManager.getImageProperties) {\n        var backgroundDimensions = gomo.fileManager.getImageProperties(decodeURIComponent(src));\n        if (backgroundDimensions && backgroundDimensions.strHeight) {\n          response.height = parseInt(backgroundDimensions.strHeight);\n          response.width = parseInt(backgroundDimensions.strWidth);\n        } else {\n          // force parallax to use auto sizes\n          response = false;\n        }\n      }\n      return response;\n    },\n\n    /**\n     * Re-initialise the parallax when content changes on screen to allow for height changes.\n     */\n    refreshParallax: function() {\n      var me = this;\n      if (gomo.topicManager && gomo.topicManager.getCurrentTopic()) {\n        me.postLoadInit();\n      }\n    },\n\n    /**\n     * Triggered when the screen resizes so parallax can re-initialise.\n     */\n    screenResized: function() {\n      gomo.parallaxManager.refreshParallax();\n    }\n  };\n})();\ngomo.eventManager.registerLegacyEvent('screenResize', gomo.parallaxManager.screenResized);\n"},function(t,n,e){e(0)(e(217))},function(t,n){t.exports="/* globals Backbone, $, ko, BOO_ANIMATE_ASSETS_EVERY_VISIT, ASSET_RENDERER, OUTPUT_MODE_CHECKER, MASTER_RENDERER,\nCORE, DEBUG, EM, _, OBJ_REF, TOPIC_MANAGER, DISPLAY_CONDITIONS_INTERACTIONS, ACTIONS_INTERACTIONS, BOO_DYNAMIC_CONTINUOUS_SCROLLING, BOO_TURN_OFF_CONTINUOUS_SCROLL_ASSET_RESET */\ngomo.Asset = (function() {\n  var Asset = Backbone.View.extend({\n    type: '',\n    data: {},\n    gomoEvents: [],\n    resourcePath: '',\n    previewMode: false,\n    importedStyleSuffix: 'ImportedC',\n    bindingHandlers: {},\n    screenId: '',\n    handleOwnEnabledState: false,\n\n    /**\n     * Asset Constructor\n     * @constructor\n     * @param {object} options\n     */\n    initialize: function(options) {\n      var me = this;\n      me.resourcePath = MASTER_RENDERER.getResourcesPath();\n      options = options || {};\n      me.addData(options.data);\n      me.gomoEvents = [];\n      // Trigger asset extensions init function for instances variables etc.\n      me.init();\n\n      // Add default text handler...\n      me.bindingHandlers.gomotext = function(el, value) {\n        $(el).html(me.formatHTML(value || ''));\n      };\n      // Disable certain nested elements from binding\n      ko.bindingHandlers.disableBindings = {\n        init: function() {\n          return {controlsDescendantBindings: true};\n        }\n      };\n    },\n\n    /**\n     * Set instance variables for asset object\n     */\n    init: function() {},\n\n    /**\n     * @private\n     * @function addData\n     * @param {Object} data\n     */\n    addData: function(data) {\n      var me = this;\n      // private/generic sanitisation\n      var d = me._sanitiseData(data);\n      // Add the data...\n      me.data = d.data;\n      me.resourcePath = d.resourcePath;\n      me.previewMode = d.previewMode;\n      me.screenId = d.screenId;\n      me.id = d.id;\n\n      this.setVariablesToGlobal(me);\n\n      // Once it's added start asset specific processing...\n      me.processData(me.data);\n    },\n\n    /**\n     * @private\n     * @function _sanitiseData\n     * @param {object} data\n     * @return {object} result\n     */\n    _sanitiseData: function(data) {\n      var me = this;\n      var result = {};\n      data = data || {};\n      result.resourcePath = data.strWhatResourcePath || me.resourcePath;\n      result.previewMode = data.booPreviewMode || me.previewMode;\n      result.screenId = data.strScreenId || me.screenId;\n      result.data = data.objWhatAssetCourseObject || {};\n\n      if (result.data.objRawData.objDisplayAnimation) {\n        result.data.objRawData.objDisplayAnimation.booAnimated = false;\n      }\n\n      result.data.objRawData = result.data.objRawData || {};\n      if (result.data.objRawData.strID) {\n        result.id = result.data.objRawData.strID;\n        // Create the domId...\n        result.data.objRawData.domId = 'YY' + result.id + 'YY';\n        if (result.previewMode) {\n          result.data.objRawData.domId += 'Preview';\n        }\n      }\n\n      me.type = result.data.strAssetType;\n      me.id = result.id;\n      return result;\n    },\n\n    /**\n     * @private\n     * Fired before the asset is shown and just before the plugins own beforeShown()\n     */\n    beforeShownSystemProcesses: function() {\n      var me = this;\n      var rawData = me.data.objRawData;\n      var el;\n\n      // Animate the asset if required\n      if (\n        rawData.objDisplayAnimation &&\n          gomo.outputChecker.currentMode != 'accessibleC' &&\n          rawData.objDisplayAnimation.strAnimationType != 'null' &&\n          rawData.objDisplayAnimation.strAnimationType != 'none' &&\n          rawData.objDisplayAnimation.strAnimationType != ''\n      ) {\n        if (\n          BOO_ANIMATE_ASSETS_EVERY_VISIT ||\n          rawData.objDisplayAnimation.booAnimateOnEveryVisit ||\n          rawData.objDisplayAnimation.booAnimated == false\n        ) {\n          rawData.objDisplayAnimation.booAnimated = true;\n          var animationType = rawData.objDisplayAnimation.strAnimationType;\n\n          var objAnimationOptions = {\n            delay: rawData.objDisplayAnimation.intAnimationDelay,\n            duration: rawData.objDisplayAnimation.intAnimationDuration\n          };\n\n          el = gomo.assetManager.getElementFromAssetData(me.data);\n          me.setElement(el);\n          var animateData = {\n            animationType: animationType,\n            objAnimationOptions: objAnimationOptions,\n            el: el,\n            preHideElement: true\n          };\n          gomo.animator.animate(animateData);\n        }\n      }\n\n      // Set the element so we can interact with it, like bind events\n      el = gomo.assetManager.getElementFromAssetData(me.data);\n      if (typeof el !== 'undefined') {\n        me.setElement(el);\n      }\n    },\n\n    /**\n     * @public\n     * @function processData\n     * @param {Object} data The data to be processed.\n     */\n    processData: function(data) {},\n\n    /**\n     * @public\n     * Fired before the asset is rendered\n     */\n    beforeRender: function() {},\n\n    /**\n     * @public\n     * Fired when translation data is triggered by user\n     */\n    translationPreprocess: function() {},\n\n    /**\n     * @public\n     * Fired when translation data is triggered by user but the asset is hidden\n     */\n    translationProcessOnHidden: function() {},\n\n    /**\n     * @public\n     * Fired when translation have rendered on screen\n     */\n    translationPostprocess: function() {},\n\n    /**\n     * @public\n     * Render the asset and returns the html\n     * @return {string}\n     */\n    render: function() {\n      var me = this;\n\n      // Run prerender function\n      me.beforeRender();\n\n      if (!me.isSupportedInCurrentOutputMode()) {\n        return '';\n      }\n\n      // Run any data formatting required before rendering...\n      // me.formatData();\n\n      // Grab the generic asset wrapper!\n      var wrapperTemplate = me.getWrapper();\n\n      // Grab the assetTemplate and render it...\n      var assetTemplate = me.getTemplate();\n      if (!assetTemplate) {\n        me.debug(gomo.localiser.get('TEXT_DEBUG_TEMPLATE_ERROR', [me.data.strAssetType]));\n        return gomo.localiser.get('TEXT_RETURN_TEMPLATE_ERROR', [me.data.strObjID]);\n      }\n\n      // We have the compiled templates (Handlebars) - so just pass data to them to\n      // get the final output (string)\n      var asset = assetTemplate(me.data.objRawData);\n      var wrapperData = {};\n      wrapperData.asset = asset;\n      wrapperData.objRawData = me.data.objRawData;\n      wrapperData.booIsDisplayed = me.data.booIsDisplayed;\n      wrapperData.assetPositionClass = me.getAssetPositionClass(me.data);\n      wrapperData.developerClass = me.getDeveloperClass(me.data);\n      wrapperData.displayConditionClass = me.getDisplayConditionClass(me.data);\n      wrapperData.forceOutputModeClass = me.getForceOutputModeClass(me.data);\n\n      me.afterRender();\n\n      // Output the wrapper with, asset is injected in wrapper (wrapperData.asset)...\n      return wrapperTemplate(wrapperData);\n    },\n\n    /**\n     * @public\n     * Fired when the topic is preloaded.\n     */\n    preloadTopic: function() {},\n\n    /**\n     * @public\n     * Fired before the asset it shown\n     */\n    beforeShown: function() {},\n\n    /**\n     * @public\n     * Fired after render has triggered, not noecessarily visible at this point!\n     */\n    afterRender: function() {},\n\n    /**\n     * @public\n     * Fired after render has triggered and about to show asset\n     */\n    afterRenderShown: function() {},\n\n    /**\n     * @public\n     * @method afterRenderHidden\n     */\n    afterRenderHidden: function() {},\n\n    /**\n     * @public\n     * Fired just before display conditions removes the asset from the render\n     * @method displayConditionsHide\n     */\n    displayConditionsHide: function() {},\n\n    /**\n     * @public\n     * @method obscureForPopup\n     */\n    obscureForPopup: function() {},\n\n    /**\n     * @public\n     * @method restoreFromPopup\n     */\n    restoreFromPopup: function() {},\n\n    /**\n     * @public\n     * @method returnFocusToSelf\n     */\n    returnFocusToSelf: function() {},\n\n    /**\n     * @public\n     * Fired when asset is reset\n     * @param {boolean} force\n     * @return {boolean}\n     */\n    reset: function(force) {\n      return false;\n    },\n    /**\n     * @public\n     * Check to see if asset has been interacted with in continuous scrolling mode\n     * @param {boolean} force\n     * @return {boolean}\n     */\n    shouldAssetReset: function() {\n      var me = this;\n      if (BOO_DYNAMIC_CONTINUOUS_SCROLLING && BOO_TURN_OFF_CONTINUOUS_SCROLL_ASSET_RESET) {\n        return !me.data.initialised;\n      }\n      return true;\n    },\n\n    /**\n     * Check for & perform any actions\n     * @param {Array} arrActions\n     */\n    processAssetActions: function(arrActions) {\n      var me = this;\n      var data = me.data;\n      var rawData = data.objRawData;\n      var actionOptions = {};\n      // Check optional array param\n      actionOptions.objActions =\n        typeof arrActions === 'undefined' ? rawData.arrActions : arrActions;\n      actionOptions.objOptionalExtraData = data;\n      actionOptions.objOptionalExtraData.strAssetID = data.strObjID;\n\n      // Execute all actions\n      gomo.eventManager.legacy('processActions', actionOptions);\n    },\n\n    /**\n     * @public\n     * @return {boolean}\n     */\n    isCompletable: function() {\n      return false;\n    },\n\n    /**\n     * @public\n     * @return {boolean}\n     */\n    isComplete: function() {\n      return false;\n    },\n\n    /**\n     * @public\n     * @param {string} outputMode\n     * @return {boolean}\n     */\n    isSupportedInOutputMode: function(outputMode) {\n      var me = this;\n      if (me.type) {\n        var supportData = ASSET_RENDERER.objAssetSupportByType[me.type];\n        if (supportData) {\n          return supportData[outputMode] == true;\n        }\n      }\n      return true;\n    },\n\n    isSupportedInCurrentOutputMode: function() {\n      var me = this;\n      return me.isSupportedInOutputMode(ASSET_RENDERER._strCurrOutputModeClass);\n    },\n\n    /**\n     * @public\n     * @param {string} text\n     * @return {string} text\n     */\n    formatHTML: function(text) {\n      var me = this;\n      if (gomo.variablesHolder) {\n        text = gomo.variablesHolder.parseHTMLForVariableMarkup(text);\n      }\n\n      if (text) {\n        text = gomo.utility.formatHTML(text, me.resourcePath);\n      }\n      return text;\n    },\n\n    /**\n    * Converts and tidies up string quote type.\n    * @param {String} stringToConvert\n    * @return {String}\n    */\n    convertStringQuote: function(stringToConvert) {\n      if (!stringToConvert || !stringToConvert.replace) {\n        return stringToConvert;\n      }\n      stringToConvert = stringToConvert.replace(/&#x0027;/g, '\\'');\n      stringToConvert = stringToConvert.replace(/&quot;/g, '\"');\n      return stringToConvert;\n    },\n\n    getAssetPositionClass: function(data) {\n      var result = '';\n      var firstClass = 'firstAssetC';\n      var middleClass = 'middleAssetC';\n      var lastClass = 'lastAssetC';\n\n      if (data.booIsDisplayed) {\n        switch (true) {\n          case data.booIsFirstAssetInColumn && data.booIsLastAssetInColumn:\n            result = firstClass + ' ' + lastClass;\n            break;\n          case data.booIsFirstAssetInColumn:\n            result = firstClass;\n            break;\n          case data.booIsLastAssetInColumn:\n            result = lastClass;\n            break;\n          default:\n            result = middleClass;\n        }\n      }\n\n      return result;\n    },\n\n    classPrefixAssetPosition: function() {\n      var me = this;\n      var data = me.data;\n\n      var result = '';\n      if (data.intColumnAffinity) {\n        switch (data.objParent.intColumns) {\n          case 1:\n            result = 'mid';\n            break;\n          case 2:\n            switch (data.intColumnAffinity) {\n              case 0:\n                result = 'left';\n                break;\n              case 1:\n                result = 'right';\n                break;\n              default:\n                result = '';\n                break;\n            }\n            break;\n          default:\n            result = '';\n            break;\n        }\n      }\n      return result;\n    },\n\n    /**\n     * @public\n     * @function getDeveloperClass\n     * @param {object} data\n     * @return {string}\n     */\n    getDeveloperClass: function(data) {\n      if (\n        data.objRawData.objDeveloperOptions &&\n        data.objRawData.objDeveloperOptions.objAdvancedStyling &&\n        data.objRawData.objDeveloperOptions.objAdvancedStyling.strCustomCSSClasses\n      ) {\n        return data.objRawData.objDeveloperOptions.objAdvancedStyling.strCustomCSSClasses;\n      }\n      return '';\n    },\n\n    /**\n     * @public\n     * @function getDisplayConditionClass\n     * @param {object} data\n     * @return {string}\n     */\n    getDisplayConditionClass: function(data) {\n      return data.booIsDisplayed ? 'displayedAssetMarkerC' : 'hiddenAssetMarkerC';\n    },\n\n    /**\n     * @public\n     * @function getForceOutputModeClass\n     * @param {object} data\n     * @return {string}\n     */\n    getForceOutputModeClass: function(data) {\n      if (data && data.strOutputMode) {\n        return 'force' + data.strOutputMode + 'C';\n      }\n      return '';\n    },\n\n    /**\n     * @public\n     * @function getInlineStyle\n     * @param {object} data\n     * @return {string}\n     */\n    getInlineStyle: function(data) {\n      if (\n        data &&\n        data.objRawData.strScreenBackgroundColor &&\n        data.objRawData.strBackgroundOpacity\n      ) {\n        var opacity = data.objRawData.strBackgroundOpacity;\n        var bgColor = data.objRawData.strScreenBackgroundColor;\n        var strColour = CORE.hexToRgb(bgColor);\n        var strStyle = '';\n        if (\n          OUTPUT_MODE_CHECKER.strWhatBrowserTypeClass == 'ie8C' ||\n          OUTPUT_MODE_CHECKER.strWhatBrowserTypeClass == 'ie8CompatibilityModeC'\n        ) {\n          var _strComponentColour = CORE.hexToRgb(bgColor);\n          var _arrColourSplit = _strComponentColour.split(',');\n          var _intComponentRangedOpacity = Math.round(255 * opacity);\n          var _strRGBAasHex = CORE.rgbToHex(\n            _arrColourSplit[0],\n            _arrColourSplit[1],\n            _arrColourSplit[2],\n            _intComponentRangedOpacity\n          );\n          strStyle +=\n            '-ms-filter: \\'progid:DXImageTransform.Microsoft.gradient(startColorstr=' +\n            _strRGBAasHex +\n            ', endColorstr=' +\n            _strRGBAasHex +\n            ')\\';';\n\n          // Remove the default bg color. We do this because if it's an opacity of 1 then LESS will\n          // convert it to a value which IE8 will render along with the ms-filter.\n          strStyle += 'background-color:transparent;';\n        } else if (data.objRawData.wrapContent) {\n          // Updated to generate custom stylng require for PWC\n          var padding = data.objRawData.padding;\n          strStyle += 'background-color:rgba(' + strColour + ', ' + opacity + ');' +\n          'box-shadow: rgba(' + strColour + ', ' + opacity + ') '+\n          padding.horizontal + 'px '+ padding.vertical +'px 0px, ' +\n          'rgba(' + strColour + ', ' + opacity + ') '+\n          (padding.horizontal * -1) +'px '+ padding.vertical +'px 0px;';\n        } else {\n          strStyle += 'background-color:rgba(' + strColour + ', ' + opacity + ');';\n        }\n\n        return strStyle;\n      }\n      return '';\n    },\n\n    /**\n     * @public\n     * Retrieves the template asscoiated with the asset.\n     * @return {string}\n     */\n    getTemplate: function() {\n      var me = this;\n      var options = {};\n      options.legacyMethod = {\n        templateName: me.data.strAssetType + 'TemplateWrapperC',\n        templateClass: ''\n      };\n      // Templates will work for more than just assets going forward, so in the future types could\n      // be screen, layout etc..\n      options.itemType = me.type;\n      return gomo.templateManager.getCompiledTemplate(options);\n    },\n\n    getWrapper: function() {\n      return gomo.templateManager.getCompiledTemplate({\n        legacyMethod: {templateName: 'newAssetContentWrapperC'}\n      });\n    },\n\n    /**\n     * @public\n     * @function setVariablesToGlobal\n     * @param {Object} asset\n     */\n    setVariablesToGlobal: function(asset) {\n      var data = asset.data;\n      if (data.objRawData.variableFields) {\n        var count = 0;\n        var variables = {};\n        var variableFields = data.objRawData.variableFields;\n        var variablesStringify = '';\n        while (count < variableFields.length) {\n          var variableValue = this.getVariableFromAsset(data, variableFields[count]);\n          variables[variableFields[count]] = variableValue;\n          variablesStringify += variableValue;\n          count++;\n        }\n\n        var variableData = {\n          variablesStringify: variablesStringify,\n          assetId: data.objRawData.strID,\n          variables: variables,\n          initialise: true\n        };\n\n        if (gomo.variablesHolder) {\n          gomo.variablesHolder.setAssetVariable(variableData);\n        }\n      }\n    },\n\n    /**\n     * @public\n     * @function getVariableFromAsset\n     * @param {Object} objRawData\n     * @param {string} assetFieldName\n     * @return {string}\n     */\n    getVariableFromAsset: function(objRawData, assetFieldName) {\n      // When we can grab screens easily based of an id, we can enable the subscreen data option\n      return searchForValue(assetFieldName, objRawData);\n\n      /**\n       * Search for value in asset\n       * @param {string} assetFieldName\n       * @param {object} objRawData\n       * @return {string}\n       */\n      function searchForValue(assetFieldName, objRawData) {\n        var arrObjPath;\n        var firstPath;\n        var newFieldName;\n        if (assetFieldName.indexOf('#') != -1 || assetFieldName.indexOf('.') != -1) {\n          if (\n            (assetFieldName.indexOf('.') != -1 &&\n              assetFieldName.indexOf('.') < assetFieldName.indexOf('#')) ||\n            assetFieldName.indexOf('#') == -1\n          ) {\n            arrObjPath = assetFieldName.split('.');\n            firstPath = arrObjPath[0];\n            newFieldName = assetFieldName.replace(firstPath + '.', '');\n            var newRawObj = objRawData[firstPath];\n\n            return searchForValue(newFieldName, newRawObj);\n          }\n          if (\n            (assetFieldName.indexOf('#') != -1 &&\n              assetFieldName.indexOf('#') < assetFieldName.indexOf('.')) ||\n            assetFieldName.indexOf('.') == -1\n          ) {\n            arrObjPath = assetFieldName.split('#');\n            firstPath = arrObjPath[0];\n            newFieldName = assetFieldName.replace(firstPath + '#.', '');\n\n            var strContent = '';\n            var arrCount = 0;\n            while (arrCount < objRawData.length) {\n              strContent += searchForValue(newFieldName, objRawData[arrCount]) + ' ';\n              arrCount++;\n            }\n            return strContent;\n          }\n        } else {\n          if (assetFieldName == 'SUBSCREEN') {\n            return 'Subscreen data is not yet supported. asset.js getVariableFromAsset()';\n          } else {\n            if (typeof objRawData !== 'undefined') {\n              return (objRawData[assetFieldName]);\n            } else {\n              return '';\n            }\n          }\n        }\n      }\n    },\n\n    /**\n     * @public\n     * Outputs debug message\n     */\n    debug: function() {\n      if (DEBUG) {\n        DEBUG.lert.apply(DEBUG, arguments);\n      }\n    },\n\n    registerEvents: function() {},\n\n    /**\n     * @param {string} eventName\n     * @param {function} method\n     */\n    registerEvent: function(eventName, method) {\n      var me = this;\n      me.gomoEvents.push({\n        name: eventName,\n        method: method\n      });\n    },\n\n    registerLegacyEvent: function(eventName, method) {\n      if (EM && EM.register) {\n        var obj = {};\n        obj['handleEvent_' + eventName] = method;\n        EM.register(obj);\n      }\n    },\n\n    /**\n     * @param {string} eventName\n     */\n    unregisterEvent: function(eventName) {\n      var me = this;\n      if (eventName && me.gomoEvents && me.gomoEvents.length) {\n        var newEvents = _.filter(me.gomoEvents, function(evt) {\n          return evt.name !== eventName;\n        });\n        me.gomoEvents.length = 0;\n        me.gomoEvents = newEvents;\n      }\n    },\n\n    /**\n     * @param {string} eventName\n     * @param {object} eventArgs\n     * @param {object} options\n     */\n    raiseEvent: function(eventName, eventArgs, options) {\n      var me = this;\n      eventArgs = eventArgs == undefined ? [] : eventArgs;\n      eventArgs = _.isArray(eventArgs) ? eventArgs : [eventArgs];\n      for (var i = 0; i < me.gomoEvents.length; i++) {\n        if (me.gomoEvents[i].name == eventName) {\n          me.gomoEvents[i].method.apply(me, eventArgs);\n        }\n      }\n    },\n\n    /**\n     * @public\n     * Some assets will need to handle their own enabled states and checks\n     * @function checkAndHandleEnabledState\n     */\n    checkAndHandleEnabledState: function() {},\n\n    /**\n     * @public\n     * @function checkEnabledState\n     * @param {String} element\n     * @return {boolean}\n     */\n    checkEnabledState: function(element) {\n      var me = this;\n      var data = me.data;\n      var actions = me.data.objRawData.arrActions || [];\n      var actionSets = me.data.objRawData.objActionSets;\n      var subAsset = false;\n      // handle inline actions for text assets\n      if (typeof actionSets != 'undefined'\n      && Object.keys(actionSets).length !== 0) {\n        if (element) {\n          var actionSplit = element.split('.');\n          var actionIndex = actionSplit[actionSplit.length-1];\n          actions = data.objRawData.objActionSets[actionIndex];\n        } else {\n          for (var actionSet in data.objRawData.objActionSets) {\n            if (Object.prototype.hasOwnProperty.call(data.objRawData.objActionSets, actionSet)) {\n              actions = actions.concat(data.objRawData.objActionSets[actionSet]);\n            }\n          }\n        }\n      // pull asset actions\n      } else if (data.objRawData.arrActions && data.objRawData.arrActions.length) {\n        actions = data.objRawData.arrActions;\n      // pull actions from sub assets passed in with the element param\n      } else if (element.arrActions && element.arrActions.length) {\n        subAsset = true;\n        actions = element.arrActions;\n      } else {\n        console.log('Asset.checkEnabledState() - actions not found for ' + me.id);\n        return false;\n      }\n\n      // Match the data that asset_interactions.checkEnabledState() uses to simplify future function updates\n      var assetData = me.data.objRawData;\n\n      // Ensure the action has a valid format\n      var validateAction = function(action) {\n        if (typeof(action) !== 'undefined' && action['strType'] == 'internal_link') {\n          if (action['objParameters'] && action.objParameters['target_id']) {\n            return true;\n          }\n        }\n        return false;\n      };\n\n      /*\n      * Method to return a target or attempt to silently load\n      */\n      var getTarget = function(targetID) {\n        if (ACTIONS_INTERACTIONS._is_linear_navigation(targetID)) {\n          var sourceAssetScreenId = '';\n          if (assetData['strID']) {\n            sourceAssetScreenId = assetData.strID.split('a')[0];\n            sourceAssetScreenId = sourceAssetScreenId.split('sub')[0];\n            targetID = TOPIC_MANAGER.getNextOrPreviousScreenId(sourceAssetScreenId, targetID);\n          } else if (assetData['strObjID']) {\n            sourceAssetScreenId = assetData.strObjID.split('a')[0];\n            sourceAssetScreenId = sourceAssetScreenId.split('sub')[0];\n            targetID = TOPIC_MANAGER.getNextOrPreviousScreenId(sourceAssetScreenId, targetID);\n          }\n        }\n        var target = OBJ_REF.get(targetID);\n        if (target === false && targetID) {\n          var topicId = targetID.split('s')[0];\n          TOPIC_MANAGER.silentlyLoadTopicObject({'strTopicID': topicId});\n          target = OBJ_REF.get(targetID);\n        }\n        return target;\n      };\n\n      /*\n      * Method to return rawData of screens that aren't stored in OBJ_REF\n      */\n      var getRawScreenTarget = function(targetID) {\n        var target = OBJ_REF.get(targetID);\n        if (target || !targetID || targetID.indexOf('s') === -1) {\n          return false;\n        }\n\n        var topicId = targetID.split('s')[0];\n        var rawTopicData = OBJ_REF.get(topicId).objRawTopicData;\n        if (rawTopicData && rawTopicData.arrScreens && rawTopicData.arrScreens.length) {\n          var screenCount;\n          for (screenCount = 0; screenCount < rawTopicData.arrScreens.length; screenCount++) {\n            var screenData = rawTopicData.arrScreens[screenCount];\n            if (screenData.strID\n              && screenData.strID === targetID) {\n              target = screenData;\n              break;\n            }\n          }\n        }\n        return target;\n      };\n\n      /*\n      * Method to filter hidden links\n      */\n      var filterHiddenLinkActions = function(action) {\n        if (validateAction(action)) {\n          var target = getTarget(action.objParameters.target_id);\n\n          // Is the link a screen and is it hidden?\n          if (target && target.strObjType === 'screen') {\n            return !target.booIsDisplayed;\n          }\n        }\n        return false;\n      };\n\n      /*\n      * Method to filter actions\n      * this will only return actions which are internal_links\n      * and where the target doesn't exist\n      */\n      var filterInternalBrokenLinkActions = function(action) {\n        if (validateAction(action)) {\n          var target = getTarget(action.objParameters.target_id);\n\n          // Can the target not be found?\n          if (!target) {\n            // Only search for the raw screen if we can't find the target directly\n            var rawScreenTarget = getRawScreenTarget(action.objParameters.target_id);\n            // Assume dynamic screens exist as we haven't set them yet\n            if (rawScreenTarget && rawScreenTarget.strType === 'dynamicContentScreen') {\n              return false;\n            }\n            return true;\n          }\n        }\n        return false;\n      };\n\n      // Get the valid link actions\n      var linkActions = actions.filter(validateAction);\n      // Are there actions other than just internal links?\n      if (actions.length > linkActions.length) {\n        return true;\n      }\n      // Get links to hidden screens\n      var linksToHiddenScreens = linkActions.filter(filterHiddenLinkActions);\n      var brokenInternalLinks = linkActions.filter(filterInternalBrokenLinkActions);\n      // Are all the screens hidden or broken targets?\n      if (linkActions.length === linksToHiddenScreens.length\n        || linkActions.length === brokenInternalLinks.length) {\n        DISPLAY_CONDITIONS_INTERACTIONS.setObjectsLinkedDisplayedState(\n          (subAsset) ? element:assetData, false\n        );\n        return false;\n      }\n      DISPLAY_CONDITIONS_INTERACTIONS.setObjectsLinkedDisplayedState(\n        (subAsset) ? element:assetData, true\n      );\n      return true;\n    },\n\n    /**\n     * @public\n     * @function switchState\n     * @param {object} data\n     * @param {boolean} enabled\n\n     */\n    switchState: function(data, enabled) { },\n\n    clearEvents: function() {\n      var me = this;\n      me.gomoEvents = null;\n      me.gomoEvents = [];\n    },\n\n    getContent: function() {\n      return null;\n    },\n\n    getAccessibleElements: function() {\n      return [];\n    },\n    /**\n     * @public\n     * @method topicStatusChanged\n     */\n    topicStatusChange: function() {}\n  });\n\n  return Asset;\n})();\n"},function(t,n,e){e(0)(e(219))},function(t,n){t.exports="// @class QuestionAsset @extend Asset view\n/* globals BOO_SHOW_CORRECTNESS_ICONS_ON_CONFIRM_CLICK, global, $ */\n\ngomo.QuestionAsset = (function() {\n  var Question = gomo.Asset.extend({\n    selectedOptionClass: 'selectedOptionC',\n    unselectedOptionClass: 'unSelectedOptionC',\n\n    /**\n     * Sets all options to unselected and resets 'option marker image'.\n     */\n    resetOptions: function() {\n      var me = this;\n      var rawData = me.data.objRawData;\n      var optionElements = gomo.getElementsByClassName(me.el, me.optionClassName);\n\n      var count = 0;\n      while (count < optionElements.length) {\n        rawData.optionStates[count] = false;\n        var currOptionElement = optionElements[count];\n\n        currOptionElement.className = currOptionElement.className.replace(\n          me.selectedOptionClass,\n          me.unselectedOptionClass\n        );\n        currOptionElement.checked = false;\n        this.resetOptionMarkerImage(currOptionElement);\n        count++;\n      }\n      me.activateButtons(me.el);\n    },\n\n    /**\n     * Automatically called from resetOptions(), set option marker image to 'unset'.\n     * @param {Object} currOptionElement The DOM element for any given option.\n     */\n    resetOptionMarkerImage: function(currOptionElement) {\n      var me = this;\n\n      var markerImage = gomo.getElementsByClassName(\n        currOptionElement,\n        me.optionCorrectnessClass\n      )[0];\n      // The accessible marker is in a slightly different place, so check there too.\n      if (!markerImage) {\n        markerImage = gomo.getElementsByClassName(\n          currOptionElement.parentNode,\n          me.optionCorrectnessClass\n        )[0];\n      }\n      // The single correctness marker might be at the route level of the asset so check there last.\n      if (!markerImage) {\n        markerImage = gomo.getElementsByClassName(\n          currOptionElement.parentNode,\n          this._strOptionCorrectnessClass\n        )[0];\n      }\n\n      if (markerImage) {\n        // Reset the correctness images.\n        markerImage.className = markerImage.className.replace(\n          /incorrectAnswerC/g,\n          'unSetCorrectnessC'\n        );\n        markerImage.className = markerImage.className.replace(\n          /correctAnswerC/g,\n          'unSetCorrectnessC'\n        );\n        markerImage.alt = '';\n        // Get the generic asset wrapper that the asset sits in and remove all correctness classes.\n        $(currOptionElement)\n          .parents('.genericAssetWrapperC')\n          .find('.correct-option, .incorrect-option')\n          .removeClass('correct-option incorrect-option');\n      }\n    },\n\n    /**\n     * show tickets and crosses at the end of each option for an asset.\n     * @param {array} optionElements DOM elements for assets options.\n     */\n    showOptionCorrectness: function(optionElements) {\n      var me = this;\n\n      if (BOO_SHOW_CORRECTNESS_ICONS_ON_CONFIRM_CLICK) {\n        var count = 0;\n        var markerImages = [];\n        while (count < optionElements.length) {\n          var currOptionElement = optionElements[count];\n          var markerImage = gomo.getElementsByClassName(\n            currOptionElement,\n            me.optionCorrectnessClass\n          )[0];\n          var currOptionData = me.scoreInfo['objOptionData'][count];\n          // The accessible marker is in a slightly different place, so check there too.\n          if (!markerImage) {\n            markerImage = gomo.getElementsByClassName(\n              currOptionElement.parentNode,\n              me.optionCorrectnessClass\n            )[0];\n          }\n\n          markerImages[count] = markerImage;\n\n          if (currOptionData.booIsCorrect) {\n            $(currOptionElement).addClass('correct-option');\n            markerImage.className = markerImage.className.replace(\n              /unSetCorrectnessC/g,\n              'correctAnswerC'\n            );\n            markerImage.alt = gomo.localiser.get('ASSET_INTERACTIONS_OPTION_CORRECT_TEXT');\n            markerImage.title = gomo.localiser.get('ASSET_INTERACTIONS_OPTION_CORRECT_TEXT');\n          } else {\n            $(currOptionElement).addClass('incorrect-option');\n            markerImage.className = markerImage.className.replace(\n              /unSetCorrectnessC/g,\n              'incorrectAnswerC'\n            );\n            markerImage.alt = gomo.localiser.get('ASSET_INTERACTIONS_OPTION_INCORRECT_TEXT');\n            markerImage.title = gomo.localiser.get('ASSET_INTERACTIONS_OPTION_INCORRECT_TEXT');\n          }\n\n          count++;\n        }\n      }\n    },\n\n    /**\n     * Create an array of the selected options.\n     */\n    setSelectedOptions: function() {\n      var me = this;\n      var optionStates = me.data.objRawData.optionStates;\n\n      if (optionStates) {\n        var selectedOptionFound = false;\n        var stateInfo = {};\n        var count = 0;\n        while (count < optionStates.length) {\n          if (optionStates[count]) {\n            selectedOptionFound = true;\n            stateInfo[count] = true;\n          }\n          count++;\n        }\n        if (selectedOptionFound) {\n          me.data.selectedOptions = stateInfo;\n        }\n      }\n    },\n\n    /**\n     * Set confirm visiblity to on and reset button to off.\n     */\n    showConfirmButton: function() {\n      var me = this;\n      var confirmButton = gomo.getElementsByClassName(me.el, me.confirmButtonClass)[0];\n      var resetButton = gomo.getElementsByClassName(me.el, me.resetButtonClass)[0];\n      resetButton.className = resetButton.className.replace('visibleButtonC', 'hiddenButtonC');\n      confirmButton.className = confirmButton.className.replace('hiddenButtonC', 'visibleButtonC');\n      me.activateButtons(me.el);\n    },\n\n    /**\n     * Set reset visiblity to on and confirm button to off.\n     */\n    showResetButton: function() {\n      var me = this;\n      var confirmButton = gomo.getElementsByClassName(me.el, me.confirmButtonClass)[0];\n      var resetButton = gomo.getElementsByClassName(me.el, me.resetButtonClass)[0];\n      confirmButton.className = confirmButton.className.replace('visibleButtonC', 'hiddenButtonC');\n      resetButton.className = resetButton.className.replace('hiddenButtonC', 'visibleButtonC');\n    },\n\n    /**\n     * Return visibility to confirm or reset button depending on which is visible\n     */\n    returnFocusToSelf: function() {\n      var me = this;\n\n      var confirmButton = gomo.getElementsByClassName(me.el, me.confirmButtonClass)[0];\n      // IE throws a script error if you attempt to focus something that hidden.\n      try {\n        confirmButton.focus();\n      } catch (err) {\n        if (global.LogManager) {\n          global.LogManager.add('ERROR', err);\n        }\n      }\n      var resetButton = gomo.getElementsByClassName(me.el, me.resetButtonClass)[0];\n      try {\n        resetButton.focus();\n      } catch (err) {\n        if (global.LogManager) {\n          global.LogManager.add('ERROR', err);\n        }\n      }\n    },\n\n    deactivateButtons: function() {\n      var me = this;\n      $(me.el)\n        .find('.confirmButtonC, .resetButtonC')\n        .addClass('inactiveOptionButtonC')\n        .removeClass('activeOptionButtonC')\n        .attr('aria-disabled', 'true');\n    },\n\n    activateButtons: function() {\n      var me = this;\n      $(me.el)\n        .find('.confirmButtonC, .resetButtonC')\n        .addClass('activeOptionButtonC')\n        .removeClass('inactiveOptionButtonC')\n        .removeAttr('aria-disabled');\n    }\n  });\n\n  return Question;\n})();\n"},function(t,n,e){e(0)(e(221))},function(t,n){t.exports="/* globals Backbone */\n\nvar global = this;\ngomo.config = (function(global) {\n  var Config = Backbone.Model.extend({\n    defaults: {\n      // v2.2 supported config options\n      ARR_POPUP_CONFIG: global.ARR_POPUP_CONFIG,\n      BASE_ROOT_PATH: global.BASE_ROOT_PATH,\n      BOO_ALLOW_AUTOPLAY_VIDEOS: global.BOO_ALLOW_AUTOPLAY_VIDEOS,\n      BOO_APP_VERSION: global.BOO_APP_VERSION,\n      BOO_CENTER_FILMSTRIP_IMAGES_HORIZONTALLY: global.BOO_CENTER_FILMSTRIP_IMAGES_HORIZONTALLY,\n      BOO_CENTER_FILMSTRIP_IMAGES_VERTICALLY: global.BOO_CENTER_FILMSTRIP_IMAGES_VERTICALLY,\n      BOO_FORCE_SHOW_SWIFFY: global.BOO_FORCE_SHOW_SWIFFY,\n      BOO_HIDE_NEXT_UNTIL_CONFIRM: global.BOO_HIDE_NEXT_UNTIL_CONFIRM,\n      BOO_HIGHLIGHT_CORRECT_ANSWER: global.BOO_HIGHLIGHT_CORRECT_ANSWER,\n      BOO_INCLUDE_FILMSTRIP_STEP_HEADINGS: global.BOO_INCLUDE_FILMSTRIP_STEP_HEADINGS,\n      BOO_PROGRESS_ON_CONFIRM_CLICK: global.BOO_PROGRESS_ON_CONFIRM_CLICK,\n      BOO_SINGLE_ATTEMPT_IN_ASSESSMENT: global.BOO_SINGLE_ATTEMPT_IN_ASSESSMENT,\n      BOO_SHOW_CORRECTNESS_ICONS_ON_CONFIRM_CLICK:\n        global.BOO_SHOW_CORRECTNESS_ICONS_ON_CONFIRM_CLICK,\n      BOO_SHOW_FILMSTRIP_STEP_NUMBERS: global.BOO_SHOW_FILMSTRIP_STEP_NUMBERS,\n      BOO_SHOW_HIDDEN_ELEMENTS: global.BOO_SHOW_HIDDEN_ELEMENTS,\n      BOO_SMART_FIT_FILMSTRIP: global.BOO_SMART_FIT_FILMSTRIP,\n      BOO_USE_LOCAL_RESOURCES: global.BOO_USE_LOCAL_RESOURCES,\n      BOO_USE_SPRITE_SHEET_HOTSPOTS: global.BOO_USE_SPRITE_SHEET_HOTSPOTS,\n      INT_TRANSITION_TIMER: global.INT_TRANSITION_TIMER,\n      ROOT_PATH: global.ROOT_PATH,\n      STR_LOCAL_RESOURCES_PATH: global.STR_LOCAL_RESOURCES_PATH,\n      OBJ_SWF_EMBED_BY_MODE: global.OBJ_SWF_EMBED_BY_MODE\n    },\n    autoSubtitles: {\n      enabled: false,\n      language: null\n    }\n  });\n\n  return new Config();\n})(global);\n"},function(t,n,e){e(0)(e(223))},function(t,n){t.exports="gomo.animator = (function(){\n\n\t/**\n\t * Animator\n\t */\n\tvar Animator = function(){\n\t\tvar me = this;\n\t};\n\n\tAnimator.prototype = {\n\t\t/**\n\t\t * Animate - animates an element\n\t\t * @public\n\t\t * @function animate\n\t\t * @param {Object} animateData.objAnimationOptions - The animation object\n\t\t * @param {String} animateData.animationType - The animation type\n\t\t * @param {Object} animateData.el - the element to animate\n\t\t * @param {boolean} animateData.preHideElement - hide the element before animating\n\t\t */\n\t\tanimate: function(animateData){\n\t\t\tif(typeof ANIMATOR_INTERFACE_2 !== undefined){\n\t\t\t\tvar objAnimationOptions = animateData.objAnimationOptions;\n\t\t\t\tvar el = animateData.el;\n\t\t\t\tvar animationType = animateData.animationType;\n\t\t\t\tvar preHideElement = animateData.preHideElement;\n\n\t\t\t\tif(objAnimationOptions.delay){\n\t\t\t\t\tvar $el = $(el);\n\t\t\t\t\t//stop any animations from a previous screen load and clear any animation queue on the el\n\t\t\t\t\t$el.velocity('stop', true);\n\t\t\t\t}\n\t\t\t\tif(preHideElement){\n\t\t\t\t\tANIMATOR_INTERFACE_2.applyOpacityToElement(el);\n\t\t\t\t}\n\t\t\t\tANIMATOR_INTERFACE_2.assignRegisteredAnimation(el, animationType, objAnimationOptions);\n\t\t\t}\n\t\t}\n\t};\n\n\treturn new Animator();\n})();"},function(t,n,e){e(0)(e(225))},function(t,n){t.exports="gomo.fileManager = (function(){\n\n\t/**\n\t * FileManager - acts as an entry point for all\n\t * file operations, this will intreface with native filesystem if necessary.\n\t */\n\tvar FileManager = function(){\n\t\tvar me = this;\n\t\t// v2.2 supported variables\n\t\tme.imageMetaDataHash = MASTER_RENDERER.objImageMetaDataHash;\n\t\tme.interfaceImagePath = MASTER_RENDERER.strInterfaceImagePath;\n\t\tme.resourceBasePath = MASTER_RENDERER.strResourceBasePath;\n\t\tme.appFilePrefix = OUTPUT_MODE_CHECKER.strAppFilePrefix;\n\t};\n\n\tFileManager.prototype = {\n\t\t// v2.2 supported methods\n\n\t\t/**\n\t\t * @function getImageProperties - Gets proprties for image specified by filename\n\t\t * @param {string} filename - Filename of the file you are requesting properties for\n\t\t */\n\t\tgetImageProperties: function(filename){\n\t\t\treturn MASTER_RENDERER.getImageProperties.apply(MASTER_RENDERER, [filename]);\n\t\t}, \n\n\t\t/**\n\t\t * @function getVideoProperties - Gets properties for the video specified by filename\n\t\t * @param {string} filename - Filename of the file you are requesting properties for\n\t\t */\n\t\tgetVideoProperties: function(filename){\n\t\t\treturn MASTER_RENDERER.getVideoProperties.apply(MASTER_RENDERER, [filename]);\n\t\t}\n\t};\n\n\treturn new FileManager();\n\n})();"},function(t,n,e){e(0)(e(227))},function(t,n){t.exports="gomo.localiser = (function(){\n\n\t/**\n\t * Localiser - centralises all common topic related tasks\n\t */\n\tvar Localiser = function(){\n\t\tvar me = this;\n\t};\n\n\tLocaliser.prototype = {\n\t\t// v2.2 supported methods\n\n\t\t/**\n\t\t * @function get - Get the localised string for the key\n\t\t * @param {string} key - The key of the string you would like\n\t\t * @param {string[]} variables - A list of variables to replaced tokens in new string\n\t\t */\n\t\tget: function(key, variables){\n\t\t\treturn LOCALISER.get.apply(LOCALISER, [key, variables]);\n\t\t},\n\n\t\t/**\n\t\t * @function localisedAlert - Displays an alert with the localised string\n\t\t * @param {string} key - The key of the string to use\n\t\t * @param {string[]} variables - A list of variables to replace tokens in new string\n\t\t */\n\t\t localisedAlert: function(key, variables){\n\t\t \treturn LOCALISER.l_alert.apply(LOCALISER, [key, variables]);\n\t\t }\n\t};\n\n\treturn new Localiser();\n\n})();"},function(t,n,e){e(0)(e(229))},function(t,n){t.exports="/* globals OUTPUT_MODE_CHECKER */\ngomo.outputChecker = (function() {\n  /**\n   * OutputChecker - detects the environment the player is running on\n   * and provides useful info such as screen dimensions, etc.\n   */\n  var OutputChecker = function() {\n    var me = this;\n\n    // This can be called at any point by legacy OUTPUT_MODE_CHECKER to sync variables\n    me.updateOutputVariables = function() {\n      // v2.2 supported variables\n      me.currentScreenSize = OUTPUT_MODE_CHECKER.strCurrentScreenSize;\n      me.browserTypeClass = OUTPUT_MODE_CHECKER.strWhatBrowserTypeClass;\n      me.screenSizeBoundaries = OUTPUT_MODE_CHECKER.objScreenSizeBoundaries;\n      me.currentMode = OUTPUT_MODE_CHECKER.strCurrentMode;\n      me.appDirFilePrefix = OUTPUT_MODE_CHECKER.strAppFilePrefix;\n      me.smallScreenMax = OUTPUT_MODE_CHECKER.intSmallScreenMax;\n      me.animationEnabled = OUTPUT_MODE_CHECKER.animationEnabled;\n    };\n\n    me.updateOutputVariables();\n  };\n\n  OutputChecker.prototype = {\n    // v2.2 supported methods\n    /**\n     * @function isIE8\n     * @return {boolean}\n     */\n    isIE8: function() {\n      return OUTPUT_MODE_CHECKER.booIsIE8.apply(OUTPUT_MODE_CHECKER);\n    },\n\n    /**\n     * @function isAnsroidDevice\n     * @return {boolean}\n     */\n    isAndroidDevice: function() {\n      return OUTPUT_MODE_CHECKER.isAndroidDevice.apply(OUTPUT_MODE_CHECKER);\n    },\n\n    /**\n     * @function isWindowsPhone\n     * @return {boolean}\n     */\n    isWindowsPhone: function() {\n      return OUTPUT_MODE_CHECKER.isWindowsPhone.apply(OUTPUT_MODE_CHECKER);\n    },\n\n    /**\n     * @function isDesktop\n     * @return {boolean}\n     */\n    isDesktop: function() {\n      return OUTPUT_MODE_CHECKER.isDesktop.apply(OUTPUT_MODE_CHECKER);\n    },\n\n    /**\n     * @function isIOSDevice\n     * @return {boolean}\n     */\n    isIOSDevice: function() {\n      return OUTPUT_MODE_CHECKER.isIOSDevice.apply(OUTPUT_MODE_CHECKER);\n    },\n\n    /**\n     * @function isTablet\n     * @return {boolean}\n     */\n    isTablet: function() {\n      return OUTPUT_MODE_CHECKER.isTablet.apply(OUTPUT_MODE_CHECKER);\n    },\n\n    /**\n     * @function isSmartPhone\n     * @return {boolean}\n     */\n    isSmartPhone: function() {\n      return OUTPUT_MODE_CHECKER.isSmartPhone.apply(OUTPUT_MODE_CHECKER);\n    },\n\n    /**\n     * @function isBlackberryPhone\n     * @return {boolean}\n     */\n    isBlackberryPhone: function() {\n      return OUTPUT_MODE_CHECKER.isBlackberryPhone.apply(OUTPUT_MODE_CHECKER);\n    },\n\n    /**\n     * @function isRunningFromFile\n     * @return {boolean}\n     */\n    isRunningFromFile: function() {\n      return OUTPUT_MODE_CHECKER.isRunningFromFile.apply(OUTPUT_MODE_CHECKER);\n    },\n\n    /**\n     * @function getScreenDimensions\n     * @return {object}\n     */\n    getScreenDimensions: function() {\n      return OUTPUT_MODE_CHECKER.getScreenDimensions.apply(OUTPUT_MODE_CHECKER);\n    },\n\n    /**\n     * @function setNewScreenSizeBoundary\n     * @param {object} screenSize\n     * @return {function}\n     */\n    setNewScreenSizeBoundary: function(screenSize) {\n      return OUTPUT_MODE_CHECKER.setNewScreenSizeBoundary.apply(OUTPUT_MODE_CHECKER, [screenSize]);\n    },\n\n    /**\n     * @function manualScreenSizeCheck\n     * @return {function}\n     */\n    manualScreenSizeCheck: function() {\n      return OUTPUT_MODE_CHECKER.manualScreenSizeCheck.apply(OUTPUT_MODE_CHECKER);\n    },\n\n    /**\n     * @function addScreenSizeChangeListener\n     * @param {function} listener\n     * @return {function}\n     */\n    addScreenSizeChangeListener: function(listener) {\n      return OUTPUT_MODE_CHECKER.setNewScreensizeChangeCallback.apply(OUTPUT_MODE_CHECKER, [\n        listener\n      ]);\n    },\n\n    /**\n     * @function getAndroidVersion\n     * @return {string}\n     */\n    getAndroidVersion: function() {\n      var androidVersion = '';\n      var userAgentResult = navigator.userAgent;\n      if (userAgentResult.indexOf('Android') >= 0) {\n        androidVersion = parseFloat(userAgentResult.slice(userAgentResult.indexOf('Android') + 8));\n        androidVersion = androidVersion + '';\n      }\n      return androidVersion;\n    },\n\n    /**\n     * @function applyScrolling\n     * @return {boolean}\n     */\n    applyScrolling: function() {\n      return OUTPUT_MODE_CHECKER.applyScrolling();\n    }\n  };\n\n  return new OutputChecker();\n})();\n"},function(t,n,e){e(0)(e(231))},function(t,n){t.exports="gomo.screenManager = (function(){\n\n\t/**\n\t * ScreenManager - centralises all common screen related tasks\n\t */\n\tvar ScreenManager = function(){\n\t\tvar me = this;\n\t};\n\n\tScreenManager.prototype = {\n\t\t// v2.2 supported methods\n\n\n\t\t/**\n\t\t * @public\n\t\t * @function getScreenData\n\t\t * @param {String} screenId Id of the screen we want data for\n\t\t */\n\t\tgetScreenData: function(screenId){\n\t\t\treturn SCREEN_INTERACTIONS._getScreenData(screenId);\n\t\t},\n\n\t\t/**\n\t\t * @function\n\t\t */\n\t\tgetCurrentScreenData: function(){\n\t\t\treturn SCREEN_INTERACTIONS.getCurrentScreenData.apply(SCREEN_INTERACTIONS, arguments);\n\t\t},\n\n\t\t/**\n\t\t * @function\n\t\t */\n\t\tgetLastScreenId: function(){\n\t\t\treturn SCREEN_INTERACTIONS.getLastScreenID.apply(SCREEN_INTERACTIONS, arguments);\n\t\t},\n\t\t\n\t\t/**\n\t\t * @function\n\t\t */\n\t\tgetScreenWrapper: function(){\n\t\t\treturn SCREEN_INTERACTIONS.getScreenWrapper.apply(SCREEN_INTERACTIONS, arguments);\n\t\t}, \n\t\t\n\t\t/**\n\t\t * @function\n\t\t */\n\t\trefreshCurrentScroller: function(){\n\t\t\treturn SCREEN_INTERACTIONS.refreshCurrentIScrollComponent.apply(SCREEN_INTERACTIONS, arguments);\n\t\t},\n\t\t\n\t\t/**\n\t\t * @function\n\t\t */\n\t\tgetSubScreenElement: function(){\n\t\t\treturn SUB_SCREEN_INTERACTIONS.getSubScreenDOMElement.apply(SUB_SCREEN_INTERACTIONS, arguments);\n\t\t},\n\t\t\n\t\t/**\n\t\t * @function\n\t\t */\n\t\trefreshSubScreenScroller: function(){\n\t\t\treturn SUB_SCREEN_INTERACTIONS.refreshCurrentIScrollComponent.apply(SUB_SCREEN_INTERACTIONS, arguments);\n\t\t},\n\n\t\t/**\n\t\t * @function\n\t\t */\n\t\trenderSubScreen: function(){\n\t\t\treturn SUB_SCREEN_RENDERER.renderSubScreen.apply(SUB_SCREEN_RENDERER, arguments);\n\t\t},\n\n\t\tgetFollowingSibling: function(assetData, screenData, ignoreColumns){\n\t\t\treturn TOPIC_STRUCTURE_PARSER._getFollowingSibling.apply(TOPIC_STRUCTURE_PARSER, [assetData, screenData, ignoreColumns]);\n\t\t},\n\n\t\t/**\n\t\t * @function\n\t\t */\n\t\tgetPrecedingSibling: function(assetData, screenData, ignoreColumns){\n\t\t\treturn TOPIC_STRUCTURE_PARSER._getPrecedingSibling.apply(TOPIC_STRUCTURE_PARSER, [assetData, screenData, ignoreColumns]);\n\t\t }\n\t};\n\n\treturn new ScreenManager();\n\n})();"},function(t,n,e){e(0)(e(233))},function(t,n){t.exports="gomo.scrollManager = (function(){\n\n\t/**\n\t * ScrollManager - handles interactions with the 3rd party iscroll and with internal SCROLLING_MANAGER\n\t * Javascript scroller for supported devices\n\t */\n\tvar ScrollManager = function(){\n\t\tvar me = this;\n\t};\n\n\tScrollManager.prototype = {\n\t\t\n\t\t// v2.2 supported methods\n\t\t\n\t\t/**\n\t\t * @function refreshScrollers\n\t\t */\n\t\trefreshScrollers: function(){\n\t\t\treturn ISCROLL_INTERFACE.refreshIScrolls.apply(ISCROLL_INTERFACE);\n\t\t},\n\n\t\t/**\n\t\t * @function parseChildElements\n\t\t * @param {Object} elementToParse - Element to check for scroll classes in\n\t\t * @param {boolean} isChildIScroll\n\t\t */\n\t\tparseChildElements: function(elementToParse, isChildIScroll){\n\t\t\treturn ISCROLL_INTERFACE.parseChildDOMElements.apply(ISCROLL_INTERFACE, [elementToParse, isChildIScroll]);\n\t\t},\n\n\t\t/**\n\t\t * @function recycleScroller\n\t\t * @param {Object} elementToParse - Element to recycle\n\t\t */\n\t\trecycleScroller: function(elementToParse){\n\t\t\treturn ISCROLL_INTERFACE.recycleScroller.apply(ISCROLL_INTERFACE, [elementToParse]);\n\t\t},\n\n\t\t/**\n\t\t * @function disableScreenSwitchFromScrolling\n\t\t */\n\t\tdisableScreenSwitchFromScrolling: function(){\n\t\t\treturn SCROLLING_MANAGER.disableScreenSwitchFromScrolling.apply(SCROLLING_MANAGER);\n\t\t},\n\n\t\t/**\n\t\t * @function enableScreenSwitchFromScrolling\n\t\t */\n\t\tenableScreenSwitchFromScrolling: function(){\n\t\t\treturn SCROLLING_MANAGER.enableScreenSwitchFromScrolling.apply(SCROLLING_MANAGER);\n\t\t},\n\n\t\t/**\n\t\t * @function restoreScrollPosition\n\t\t */\n\t\trestoreScrollPosition: function(elementToParse){\n\t\t\treturn SCROLLING_MANAGER.restoreScrollPosition.apply(SCROLLING_MANAGER);\n\t\t}\n\n\t};\n\n\treturn new ScrollManager();\n\n})();"},function(t,n,e){e(0)(e(235))},function(t,n){t.exports="/* global TOPIC_INTERACTIONS */\n\ngomo.topicInteractions = (function() {\n  /**\n   * TopicInteractions - centralises all common topic related tasks\n   */\n  var TopicInteractions = function() {\n    // empty\n  };\n\n  TopicInteractions.prototype = {\n    // v2.2 supported methods\n\n    /**\n     * @param {Object} assetData\n     * @param {Object} additionalTrackingData\n     */\n    addAnsweredQuestionToTopic: function(assetData, additionalTrackingData) {\n      TOPIC_INTERACTIONS.addAnsweredQuestionAssetToTopic.apply(\n        TOPIC_INTERACTIONS,\n        [assetData, additionalTrackingData]\n      );\n    },\n\n    /**\n     * @param {Object} assetData\n     */\n    addViewedQuestionToTopic: function(assetData) {\n      TOPIC_INTERACTIONS.addViewedQuestionAssetToTopic.apply(\n        TOPIC_INTERACTIONS,\n        [assetData]\n      );\n    },\n\n    /**\n     * @param {Object} assetData\n     */\n    removeAnsweredQuestionFromTopic: function(assetData) {\n      TOPIC_INTERACTIONS.removeAnsweredQuestionAssetToTopic.apply(\n        TOPIC_INTERACTIONS,\n        [assetData]\n      );\n    }\n  };\n\n  return new TopicInteractions();\n})();\n"},function(t,n,e){e(0)(e(237))},function(t,n){t.exports="gomo.layoutInteractions = (function() {\n  /**\n   * LayoutInteractions - centralises all common layout related tasks\n   */\n  var LayoutInteractions = function() {};\n\n  LayoutInteractions.prototype = {\n    // v2.2 supported methods\n\n    /**\n     * @function getEmptyColumnClass\n     * @return {string}\n     */\n    getEmptyColumnClass: function() {\n      return 'emptyLayoutC';\n    }\n  };\n\n  return new LayoutInteractions();\n})();\n"},function(t,n,e){e(0)(e(239))},function(t,n){t.exports="/* global TOPIC_MANAGER, CORE */\n\ngomo.topicManager = (function() {\n  /**\n   * TopicManager - centralises all common topic related tasks\n   */\n  var TopicManager = function() {};\n\n  TopicManager.prototype = {\n    // v2.2 supported methods\n\n    /**\n     * Get current topic\n     * @return {object} currentTopic\n     */\n    getCurrentTopic: function() {\n      return TOPIC_MANAGER.getCurrentTopic.apply(TOPIC_MANAGER, arguments);\n    },\n\n    /**\n     * Set the recommend flag on a topic\n     * @param {string} topicId\n     * @param {boolean} recommend\n     */\n    recommendTopic: function(topicId, recommend) {\n      if (topicId) {\n        var topic = CORE.getCourseItemById(topicId);\n        if (topic) {\n          topic.recommend = recommend;\n        }\n      }\n    },\n\n    /**\n     * Sends the screen changed statement\n     */\n    sendScreenChanged: function() {\n      TOPIC_MANAGER.sendScreenChanged.apply(TOPIC_MANAGER, arguments);\n    },\n\n    /**\n     * Sends the topic completed statement\n     */\n    sendTopicCompleted: function() {\n      TOPIC_MANAGER.sendTopicCompleted.apply(TOPIC_MANAGER, arguments);\n    },\n\n    /**\n     * Gets whether the current topic is continuous scrolling or not\n     * @return {boolean} continuousScrollEnabled\n     */\n    isContinuousScrollEnabled: function() {\n      return TOPIC_MANAGER.isContinuousScrollEnabled();\n    }\n  };\n\n  return new TopicManager();\n})();\n"},function(t,n,e){e(0)(e(241))},function(t,n){t.exports="/* global META_TOPIC_MANAGER */\ngomo.metaTopicManager = (function() {\n  /**\n   * MetaTopicManager - centralises all common meta topic related tasks\n   */\n  var MetaTopicManager = function() {};\n\n  MetaTopicManager.prototype = {\n    /**\n     * Get meta topic\n     * @return {Object} currentMetaTopic\n     */\n    getCurrentMetaTopic: function() {\n      return META_TOPIC_MANAGER.getCurrentMetaTopic.apply(META_TOPIC_MANAGER);\n    }\n  };\n\n  return new MetaTopicManager();\n})();\n"},function(t,n,e){e(0)(e(243))},function(t,n){t.exports="gomo.variablesHolder = (function(){\n\n\t/**\n\t * VariablesHolder - centralises all common topic related tasks\n\t */\n\tvar VariablesHolder = function(){\n\t\tvar me = this;\n\t};\n\n\tVariablesHolder.prototype = {\n\t\t// v2.2 supported methods\n\n\t\t/**\n\t\t * @function parseHTMLForVariableMarkup\n\t\t * @param htmlContent {string} The HTML to have variables replaced.\n\t\t * @param variableValueOnly {boolean} Should only return value of variable\n\t\t * @returns {string} The parsed html with variable holders replaced with variable values.\n\t\t */\n\t\tparseHTMLForVariableMarkup: function(htmlContent, variableValueOnly){\n\t\t\treturn VARIABLES_HOLDER.parseHTMLForVariableMarkup.apply(VARIABLES_HOLDER, arguments);\n\t\t},\n\n\t\tsetAssetVariable: function(variableData){\n\t\t\tVARIABLES_HOLDER.setAssetVariables(variableData);\t\t\t\n\t\t\tEM.trigger('systemVariablesChanged',{\"arrChangedSystemVariables\":['asset_variable.'+variableData.assetId]});\n\t\t\tVARIABLES_HOLDER.updateAssetDomValue(variableData.assetId);\n\t\t}\n\n\t};\n\n\treturn new VariablesHolder();\n\n})();"}]);