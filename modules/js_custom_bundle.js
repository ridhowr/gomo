!function(t){var n={};function e(a){if(n[a])return n[a].exports;var s=n[a]={i:a,l:!1,exports:{}};return t[a].call(s.exports,s,s.exports,e),s.l=!0,s.exports}e.m=t,e.c=n,e.d=function(t,n,a){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:a})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var a=Object.create(null);if(e.r(a),Object.defineProperty(a,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var s in t)e.d(a,s,function(n){return t[n]}.bind(null,s));return a},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=1)}([function(t,n){t.exports=function(t){function n(t){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",t)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(t):"undefined"!=typeof eval?eval.call(null,t):n("EvalError: No eval function available")}catch(t){n(t)}}},function(t,n,e){e(2),e(4),e(6),e(8),e(10),e(12),e(14),e(16),e(18),e(20),e(22),e(24),e(26),e(28),e(30),e(32),e(34),e(36),e(38),e(40),e(42),e(44),e(46),e(48),e(50),e(52),e(54),e(56),e(58),e(60),e(62),e(64),e(66),e(68),e(70),e(72),t.exports=e(74)},function(t,n,e){e(0)(e(3))},function(t,n){t.exports="\n/*!\n * move\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n\n;(function(exports){\n\n  /**\n   * Computed style.\n   */\n\n  var current = window.getComputedStyle || window.currentStyle;\n\n  /**\n   * Map of prop -> type for numeric values.\n   */\n\n  var map = {\n      'top': 'px'\n    , 'bottom': 'px'\n    , 'left': 'px'\n    , 'right': 'px'\n    , 'width': 'px'\n    , 'height': 'px'\n    , 'font-size': 'px'\n    , 'margin': 'px'\n    , 'margin-top': 'px'\n    , 'margin-bottom': 'px'\n    , 'margin-left': 'px'\n    , 'margin-right': 'px'\n    , 'padding': 'px'\n    , 'padding-top': 'px'\n    , 'padding-bottom': 'px'\n    , 'padding-left': 'px'\n    , 'padding-right': 'px'\n  };\n\n  /**\n   * Initialize a `Move` instance with the given `selector`.\n   *\n   * @param {String} selector\n   * @return {Move}\n   * @api public\n   */\n\n  exports.move = function(selector) {\n    return new Move(move.select(selector));\n  };\n\n  /**\n   * Library version.\n   */\n\n  exports.move.version = '0.0.3';\n\n  /**\n   * Defaults.\n   * \n   *   `duration` - default duration of 500ms\n   * \n   */\n\n  move.defaults = {\n    duration: 500\n  };\n\n  /**\n   * Easing functions.\n   */\n\n  move.ease = {\n      'in':                'ease-in'\n    , 'out':               'ease-out'\n    , 'in-out':            'ease-in-out'\n    , 'snap':              'cubic-bezier(0,1,.5,1)'\n    , 'linear':            'cubic-bezier(0.250, 0.250, 0.750, 0.750)'\n    , 'ease-in-quad':      'cubic-bezier(0.550, 0.085, 0.680, 0.530)'\n    , 'ease-in-cubic':     'cubic-bezier(0.550, 0.055, 0.675, 0.190)'\n    , 'ease-in-quart':     'cubic-bezier(0.895, 0.030, 0.685, 0.220)'\n    , 'ease-in-quint':     'cubic-bezier(0.755, 0.050, 0.855, 0.060)'\n    , 'ease-in-sine':      'cubic-bezier(0.470, 0.000, 0.745, 0.715)'\n    , 'ease-in-expo':      'cubic-bezier(0.950, 0.050, 0.795, 0.035)'\n    , 'ease-in-circ':      'cubic-bezier(0.600, 0.040, 0.980, 0.335)'\n    , 'ease-in-back':      'cubic-bezier(0.600, -0.280, 0.735, 0.045)'\n    , 'ease-out-quad':     'cubic-bezier(0.250, 0.460, 0.450, 0.940)'\n    , 'ease-out-cubic':    'cubic-bezier(0.215, 0.610, 0.355, 1.000)'\n    , 'ease-out-quart':    'cubic-bezier(0.165, 0.840, 0.440, 1.000)'\n    , 'ease-out-quint':    'cubic-bezier(0.230, 1.000, 0.320, 1.000)'\n    , 'ease-out-sine':     'cubic-bezier(0.390, 0.575, 0.565, 1.000)'\n    , 'ease-out-expo':     'cubic-bezier(0.190, 1.000, 0.220, 1.000)'\n    , 'ease-out-circ':     'cubic-bezier(0.075, 0.820, 0.165, 1.000)'\n    , 'ease-out-back':     'cubic-bezier(0.175, 0.885, 0.320, 1.275)'\n    , 'ease-out-quad':     'cubic-bezier(0.455, 0.030, 0.515, 0.955)'\n    , 'ease-out-cubic':    'cubic-bezier(0.645, 0.045, 0.355, 1.000)'\n    , 'ease-in-out-quart': 'cubic-bezier(0.770, 0.000, 0.175, 1.000)'\n    , 'ease-in-out-quint': 'cubic-bezier(0.860, 0.000, 0.070, 1.000)'\n    , 'ease-in-out-sine':  'cubic-bezier(0.445, 0.050, 0.550, 0.950)'\n    , 'ease-in-out-expo':  'cubic-bezier(1.000, 0.000, 0.000, 1.000)'\n    , 'ease-in-out-circ':  'cubic-bezier(0.785, 0.135, 0.150, 0.860)'\n    , 'ease-in-out-back':  'cubic-bezier(0.680, -0.550, 0.265, 1.550)'\n  };\n\n  /**\n   * Default element selection utilized by `move(selector)`.\n   *\n   * Override to implement your own selection, for example\n   * with jQuery one might write:\n   *\n   *     move.select = function(selector) {\n   *       return jQuery(selector).get(0);\n   *     };\n   *\n   * @param {Object|String} selector\n   * @return {Element}\n   * @api public\n   */\n\n  move.select = function(selector){\n    if ('string' != typeof selector) return selector;\n    return document.getElementById(selector)\n      || document.querySelectorAll(selector)[0];\n  };\n\n  /**\n   * EventEmitter.\n   */\n\n  function EventEmitter() {\n    this.callbacks = {};\n  }\n\n  /**\n   * Listen on the given `event` with `fn`.\n   *\n   * @param {String} event\n   * @param {Function} fn\n   */\n\n  EventEmitter.prototype.on = function(event, fn){\n    (this.callbacks[event] = this.callbacks[event] || [])\n      .push(fn);\n    return this;\n  };\n\n  /**\n   * Emit `event` with the given args.\n   *\n   * @param {String} event\n   * @param {Mixed} ...\n   */\n\n  EventEmitter.prototype.emit = function(event){\n    var args = Array.prototype.slice.call(arguments, 1)\n      , callbacks = this.callbacks[event]\n      , len;\n\n    if (callbacks) {\n      len = callbacks.length;\n      for (var i = 0; i < len; ++i) {\n        callbacks[i].apply(this, args)\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Initialize a new `Move` with the given `el`.\n   *\n   * @param {Element} el\n   * @api public\n   */\n\n  exports.Move = function Move(el) {\n    if (!(this instanceof Move)) return new Move(el);\n    EventEmitter.call(this);\n    this.el = el;\n    this._props = {};\n    this._rotate = 0;\n    this._transitionProps = [];\n    this._transforms = [];\n    this.duration(move.defaults.duration)\n  };\n\n  /**\n   * Inherit from `EventEmitter.prototype`.\n   */\n\n  Move.prototype = new EventEmitter;\n  Move.prototype.constructor = Move;\n\n  /**\n   * Buffer `transform`.\n   *\n   * @param {String} transform\n   * @return {Move} for chaining\n   * @api private\n   */\n\n  Move.prototype.transform = function(transform){\n    this._transforms.push(transform);\n    return this;\n  };\n\n  /**\n   * Skew `x` and `y`.\n   *\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.skew = function(x, y){\n    y = y || 0;\n    return this.transform('skew('\n      + x + 'deg, '\n      + y + 'deg)');\n  };\n\n  /**\n   * Skew x by `n`.\n   *\n   * @param {Number} n\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.skewX = function(n){\n    return this.transform('skewX(' + n + 'deg)');\n  };\n\n  /**\n   * Skew y by `n`.\n   *\n   * @param {Number} n\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.skewY = function(n){\n    return this.transform('skewY(' + n + 'deg)');\n  };\n\n  /**\n   * Translate `x` and `y` axis.\n   *\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.translate = \n  Move.prototype.to = function(x, y){\n    y = y || 0;\n    return this.transform('translate('\n      + x + 'px, '\n      + y + 'px)');\n  };\n\n  /**\n   * Translate on the x axis to `n`.\n   *\n   * @param {Number} n\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.translateX =\n  Move.prototype.x = function(n){\n    return this.transform('translate3d(' + n + 'px, 0px, 0px)');\n  };\n\n  /**\n   * Translate on the y axis to `n`.\n   *\n   * @param {Number} n\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.translateY =\n  Move.prototype.y = function(n){\n    return this.transform('translate3d(0px, ' + n + 'px, 0px)');\n  };\n\n  /**\n   * Scale the x and y axis by `x`, or \n   * individually scale `x` and `y`.\n   *\n   * @param {Number} x\n   * @param {Number} y\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.scale = function(x, y){\n    y = null == y ? x : y;\n    return this.transform('scale('\n      + x + ', '\n      + y + ')');\n  };\n\n  /**\n   * Scale x axis by `n`.\n   *\n   * @param {Number} n\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.scaleX = function(n){\n    return this.transform('scaleX(' + n + ')')\n  };\n\n  /**\n   * Scale y axis by `n`.\n   *\n   * @param {Number} n\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.scaleY = function(n){\n    return this.transform('scaleY(' + n + ')')\n  };\n\n  /**\n   * Rotate `n` degrees.\n   *\n   * @param {Number} n\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.rotate = function(n){\n    return this.transform('rotate(' + n + 'deg)');\n  };\n\n  /**\n   * Set transition easing function to to `fn` string.\n   *\n   * When:\n   *\n   *   - null \"ease\" is used\n   *   - \"in\" \"ease-in\" is used\n   *   - \"out\" \"ease-out\" is used\n   *   - \"in-out\" \"ease-in-out\" is used\n   *\n   * @param {String} fn\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.ease = function(fn){\n    fn = move.ease[fn] || fn || 'ease';\n    return this.setVendorProperty('transition-timing-function', fn);\n  };\n\n  /**\n   * Set animation properties\n   *\n   * @param {String} name\n   * @param {Object} props\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.animate = function(name, props){\n    for (var i in props){\n      if (props.hasOwnProperty(i)){\n        this.setVendorProperty('animation-' + i, props[i])\n      }\n    }\n    return this.setVendorProperty('animation-name', name);\n  }\n\n  /**\n   * Set duration to `n`.\n   *\n   * @param {Number|String} n\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.duration = function(n){\n    n = this._duration = 'string' == typeof n\n      ? parseFloat(n) * 1000\n      : n;\n    return this.setVendorProperty('transition-duration', n + 'ms');\n  };\n\n  /**\n   * Delay the animation by `n`.\n   *\n   * @param {Number|String} n\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.delay = function(n){\n    n = 'string' == typeof n\n      ? parseFloat(n) * 1000\n      : n;\n    return this.setVendorProperty('transition-delay', n + 'ms');\n  };\n\n  /**\n   * Set `prop` to `val`, deferred until `.end()` is invoked.\n   *\n   * @param {String} prop\n   * @param {String} val\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.setProperty = function(prop, val){\n    this._props[prop] = val;\n    return this;\n  };\n\n  /**\n   * Set a vendor prefixed `prop` with the given `val`.\n   *\n   * @param {String} prop\n   * @param {String} val\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.setVendorProperty = function(prop, val){\n    this.setProperty('-webkit-' + prop, val);\n    this.setProperty('-moz-' + prop, val);\n    this.setProperty('-ms-' + prop, val);\n    this.setProperty('-o-' + prop, val);\n    return this;\n  };\n\n  /**\n   * Set `prop` to `value`, deferred until `.end()` is invoked\n   * and adds the property to the list of transition props.\n   *\n   * @param {String} prop\n   * @param {String} val\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.set = function(prop, val){\n    this.transition(prop);\n    if ('number' == typeof val && map[prop]) val += map[prop]; \n    this._props[prop] = val;\n    return this;\n  };\n\n  /**\n   * Increment `prop` by `val`, deferred until `.end()` is invoked\n   * and adds the property to the list of transition props.\n   *\n   * @param {String} prop\n   * @param {Number} val\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.add = function(prop, val){\n    if (!current) return;\n    var self = this;\n    return this.on('start', function(){\n      var curr = parseInt(self.current(prop), 10);\n      self.set(prop, curr + val + 'px');\n    });\n  };\n\n  /**\n   * Decrement `prop` by `val`, deferred until `.end()` is invoked\n   * and adds the property to the list of transition props.\n   *\n   * @param {String} prop\n   * @param {Number} val\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.sub = function(prop, val){\n    if (!current) return;\n    var self = this;\n    return this.on('start', function(){\n      var curr = parseInt(self.current(prop), 10);\n      self.set(prop, curr - val + 'px');\n    });\n  };\n\n  /**\n   * Get computed or \"current\" value of `prop`.\n   *\n   * @param {String} prop\n   * @return {String}\n   * @api public\n   */\n\n  Move.prototype.current = function(prop){\n    return current(this.el).getPropertyValue(prop);\n  };\n\n  /**\n   * Add `prop` to the list of internal transition properties.\n   *\n   * @param {String} prop\n   * @return {Move} for chaining\n   * @api private\n   */\n\n  Move.prototype.transition = function(prop){\n    if (!this._transitionProps.indexOf(prop)) return this;\n    this._transitionProps.push(prop);\n    return this;\n  };\n\n  /**\n   * Commit style properties, aka apply them to `el.style`.\n   *\n   * @return {Move} for chaining\n   * @see Move#end()\n   * @api private\n   */\n\n  Move.prototype.applyProperties = function(){\n    var props = this._props\n      , el = this.el;\n\n    for (var prop in props) {\n      if (props.hasOwnProperty(prop)) {\n        el.style.setProperty(prop, props[prop], '');\n      }\n    }\n\n    return this;\n  };\n\n  /**\n   * Re-select element via `selector`, replacing\n   * the current element.\n   *\n   * @param {String} selector\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.move =\n  Move.prototype.select = function(selector){\n    this.el = move.select(selector);\n    return this;\n  };\n\n  /**\n   * Defer the given `fn` until the animation\n   * is complete. `fn` may be one of the following:\n   *\n   *   - a function to invoke\n   *   - an instanceof `Move` to call `.end()`\n   *   - nothing, to return a clone of this `Move` instance for chaining\n   *\n   * @param {Function|Move} fn\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.then = function(fn){\n    // invoke .end()\n    if (fn instanceof Move) {\n      this.on('end', function(){\n        fn.end();\n      });\n    // callback\n    } else if ('function' == typeof fn) {\n      this.on('end', fn);\n    // chain\n    } else {\n      var clone = new Move(this.el);\n      clone._transforms = this._transforms.slice(0);\n      this.then(clone);\n      clone.parent = this;\n      return clone;\n    }\n\n    return this;\n  };\n\n  /**\n   * Pop the move context.\n   *\n   * @return {Move} parent Move\n   * @api public\n   */\n\n  Move.prototype.pop = function(){\n    return this.parent;\n  };\n\n  /**\n   * Start animation, optionally calling `fn` when complete.\n   *\n   * @param {Function} fn\n   * @return {Move} for chaining\n   * @api public\n   */\n\n  Move.prototype.end = function(fn){\n    var self = this;\n\n    // emit \"start\" event\n    this.emit('start');\n\n    // transforms\n    if (this._transforms.length) {\n      this.setVendorProperty('transform', this._transforms.join(' '));\n    }\n\n    // transition properties\n    this.setVendorProperty('transition-properties', this._transitionProps.join(', '));\n    this.applyProperties();\n\n    // callback given\n    if (fn) this.then(fn);\n\n    // emit \"end\" when complete\n    setTimeout(function(){\n      self.emit('end');\n    }, this._duration);\n\n    return this;\n  };\n\n})(this);"},function(t,n,e){e(0)(e(5))},function(t,n){t.exports="/*\n\tAnimator.js 1.1.11\n\n\tThis library is released under the BSD license:\n\n\tCopyright (c) 2006, Bernard Sumption. All rights reserved.\n\n\tRedistribution and use in source and binary forms, with or without\n\tmodification, are permitted provided that the following conditions are met:\n\n\tRedistributions of source code must retain the above copyright notice, this\n\tlist of conditions and the following disclaimer. Redistributions in binary\n\tform must reproduce the above copyright notice, this list of conditions and\n\tthe following disclaimer in the documentation and/or other materials\n\tprovided with the distribution. Neither the name BernieCode nor\n\tthe names of its contributors may be used to endorse or promote products\n\tderived from this software without specific prior written permission.\n\n\tTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n\tAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\tIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n\tARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR\n\tANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n\tDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n\tSERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n\tCAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n\tLIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n\tOUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n\tDAMAGE.\n\n*/\n\n\n// Applies a sequence of numbers between 0 and 1 to a number of subjects\n// construct - see setOptions for parameters\nfunction Animator(options) {\n\tthis.setOptions(options);\n\tvar _this = this;\n\tthis.timerDelegate = function(){_this.onTimerEvent()};\n\tthis.subjects = [];\n\tthis.target = 0;\n\tthis.state = 0;\n\tthis.lastTime = null;\n};\nAnimator.prototype = {\n\t// apply defaults\n\tsetOptions: function(options) {\n\t\tthis.options = Animator.applyDefaults({\n\t\t\tinterval: 20,  // time between animation frames\n\t\t\tduration: 400, // length of animation\n\t\t\tonComplete: function(){},\n\t\t\tonStep: function(){},\n\t\t\ttransition: Animator.tx.easeInOut\n\t\t}, options);\n\t},\n\t// animate from the current state to provided value\n\tseekTo: function(to) {\n\t\tthis.seekFromTo(this.state, to);\n\t},\n\t// animate from the current state to provided value\n\tseekFromTo: function(from, to) {\n\t\tthis.target = Math.max(0, Math.min(1, to));\n\t\tthis.state = Math.max(0, Math.min(1, from));\n\t\tthis.lastTime = new Date().getTime();\n\t\tif (!this.intervalId) {\n\t\t\tthis.intervalId = window.setInterval(this.timerDelegate, this.options.interval);\n\t\t}\n\t},\n\t// animate from the current state to provided value\n\tjumpTo: function(to) {\n\t\tthis.target = this.state = Math.max(0, Math.min(1, to));\n\t\tthis.propagate();\n\t},\n\t// seek to the opposite of the current target\n\ttoggle: function() {\n\t\tthis.seekTo(1 - this.target);\n\t},\n\t// add a function or an object with a method setState(state) that will be called with a number\n\t// between 0 and 1 on each frame of the animation\n\taddSubject: function(subject) {\n\t\tthis.subjects[this.subjects.length] = subject;\n\t\treturn this;\n\t},\n\t// remove all subjects\n\tclearSubjects: function() {\n\t\tthis.subjects = [];\n\t},\n\t// forward the current state to the animation subjects\n\tpropagate: function() {\n\t\tvar value = this.options.transition(this.state);\n\t\tfor (var i=0; i<this.subjects.length; i++) {\n\t\t\tif (this.subjects[i].setState) {\n\t\t\t\tthis.subjects[i].setState(value);\n\t\t\t} else {\n\t\t\t\tthis.subjects[i](value);\n\t\t\t}\n\t\t}\n\t},\n\t// called once per frame to update the current state\n\tonTimerEvent: function() {\n\t\tvar now = new Date().getTime();\n\t\tvar timePassed = now - this.lastTime;\n\t\tthis.lastTime = now;\n\t\tvar movement = (timePassed / this.options.duration) * (this.state < this.target ? 1 : -1);\n\t\tif (Math.abs(movement) >= Math.abs(this.state - this.target)) {\n\t\t\tthis.state = this.target;\n\t\t} else {\n\t\t\tthis.state += movement;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tthis.propagate();\n\t\t}\n\t\tcatch (_objError)\n\t\t{\n\t\t\t// Empty catch to stop IE7 and lower failing.\n\t\t}\n\t\tfinally\n\t\t{\n\t\t\tthis.options.onStep.call(this);\n\t\t\tif (this.target == this.state) {\n\t\t\t\tthis.stop();\n\t\t\t}\n\t\t}\n\t},\n\tstop: function() {\n\t\tif (this.intervalId) {\n\t\t\twindow.clearInterval(this.intervalId);\n\t\t\tthis.intervalId = null;\n\t\t\tthis.options.onComplete.call(this);\n\t\t}\n\t},\n\t// shortcuts\n\tplay: function() {this.seekFromTo(0, 1)},\n\treverse: function() {this.seekFromTo(1, 0)},\n\t// return a string describing this Animator, for debugging\n\tinspect: function() {\n\t\tvar str = \"#<Animator:\\n\";\n\t\tfor (var i=0; i<this.subjects.length; i++) {\n\t\t\tstr += this.subjects[i].inspect();\n\t\t}\n\t\tstr += \">\";\n\t\treturn str;\n\t}\n}\n// merge the properties of two objects\nAnimator.applyDefaults = function(defaults, prefs) {\n\tprefs = prefs || {};\n\tvar prop, result = {};\n\tfor (prop in defaults) result[prop] = prefs[prop] !== undefined ? prefs[prop] : defaults[prop];\n\treturn result;\n}\n// make an array from any object\nAnimator.makeArrayOfElements = function(o) {\n\tif (o == null) return [];\n\tif (\"string\" == typeof o) {\n\t\treturn [document.getElementById(o)];\n\t}\n\tif (!o.length) return [o];\n\tvar result = [];\n\tfor (var i=0; i<o.length; i++) {\n\t\tif (\"string\" == typeof o[i]) {\n\t\t\tresult[i] = document.getElementById(o[i]);\n\t\t} else {\n\t\t\tresult[i] = o[i];\n\t\t}\n\t}\n\treturn result;\n}\n// convert a dash-delimited-property to a camelCaseProperty (c/o Prototype, thanks Sam!)\nAnimator.camelize = function(string) {\n\tvar oStringList = string.split('-');\n\tif (oStringList.length == 1) return oStringList[0];\n\n\tvar camelizedString = string.indexOf('-') == 0\n\t\t? oStringList[0].charAt(0).toUpperCase() + oStringList[0].substring(1)\n\t\t: oStringList[0];\n\n\tfor (var i = 1, len = oStringList.length; i < len; i++) {\n\t\tvar s = oStringList[i];\n\t\tcamelizedString += s.charAt(0).toUpperCase() + s.substring(1);\n\t}\n\treturn camelizedString;\n}\n// syntactic sugar for creating CSSStyleSubjects\nAnimator.apply = function(el, style, options) {\n\tif (style instanceof Array) {\n\t\treturn new Animator(options).addSubject(new CSSStyleSubject(el, style[0], style[1]));\n\t}\n\treturn new Animator(options).addSubject(new CSSStyleSubject(el, style));\n}\n// make a transition function that gradually accelerates. pass a=1 for smooth\n// gravitational acceleration, higher values for an exaggerated effect\nAnimator.makeEaseIn = function(a) {\n\treturn function(state) {\n\t\treturn Math.pow(state, a*2);\n\t}\n}\n// as makeEaseIn but for deceleration\nAnimator.makeEaseOut = function(a) {\n\treturn function(state) {\n\t\treturn 1 - Math.pow(1 - state, a*2);\n\t}\n}\n// make a transition function that, like an object with momentum being attracted to a point,\n// goes past the target then returns\nAnimator.makeElastic = function(bounces) {\n\treturn function(state) {\n\t\tstate = Animator.tx.easeInOut(state);\n\t\treturn ((1-Math.cos(state * Math.PI * bounces)) * (1 - state)) + state;\n\t}\n}\n// make an Attack Decay Sustain Release envelope that starts and finishes on the same level\n//\nAnimator.makeADSR = function(attackEnd, decayEnd, sustainEnd, sustainLevel) {\n\tif (sustainLevel == null) sustainLevel = 0.5;\n\treturn function(state) {\n\t\tif (state < attackEnd) {\n\t\t\treturn state / attackEnd;\n\t\t}\n\t\tif (state < decayEnd) {\n\t\t\treturn 1 - ((state - attackEnd) / (decayEnd - attackEnd) * (1 - sustainLevel));\n\t\t}\n\t\tif (state < sustainEnd) {\n\t\t\treturn sustainLevel;\n\t\t}\n\t\treturn sustainLevel * (1 - ((state - sustainEnd) / (1 - sustainEnd)));\n\t}\n}\n// make a transition function that, like a ball falling to floor, reaches the target and/\n// bounces back again\nAnimator.makeBounce = function(bounces) {\n\tvar fn = Animator.makeElastic(bounces);\n\treturn function(state) {\n\t\tstate = fn(state);\n\t\treturn state <= 1 ? state : 2-state;\n\t}\n}\n\n// pre-made transition functions to use with the 'transition' option\nAnimator.tx = {\n\teaseInOut: function(pos){\n\t\treturn ((-Math.cos(pos*Math.PI)/2) + 0.5);\n\t},\n\tlinear: function(x) {\n\t\treturn x;\n\t},\n\teaseIn: Animator.makeEaseIn(1.5),\n\teaseOut: Animator.makeEaseOut(1.5),\n\tstrongEaseIn: Animator.makeEaseIn(2.5),\n\tstrongEaseOut: Animator.makeEaseOut(2.5),\n\telastic: Animator.makeElastic(1),\n\tveryElastic: Animator.makeElastic(3),\n\tbouncy: Animator.makeBounce(1),\n\tveryBouncy: Animator.makeBounce(3)\n}\n\n// animates a pixel-based style property between two integer values\nfunction NumericalStyleSubject(els, property, from, to, units) {\n\tthis.els = Animator.makeArrayOfElements(els);\n\tif (property == 'opacity' && window.ActiveXObject) {\n\t\tthis.property = 'filter';\n\t} else {\n\t\tthis.property = Animator.camelize(property);\n\t}\n\tthis.from = parseFloat(from);\n\tthis.to = parseFloat(to);\n\tthis.units = units != null ? units : 'px';\n}\nNumericalStyleSubject.prototype = {\n\tsetState: function(state) {\n\t\tvar style = this.getStyle(state);\n\t\tvar visibility = (this.property == 'opacity' && state == 0) ? 'hidden' : '';\n\t\tvar j=0;\n\t\tfor (var i=0; i<this.els.length; i++) {\n\t\t\ttry {\n\t\t\t\tthis.els[i].style[this.property] = style;\n\t\t\t} catch (e) {\n\t\t\t\t// ignore fontWeight - intermediate numerical values cause exeptions in firefox\n\t\t\t\tif (this.property != 'fontWeight') throw e;\n\t\t\t}\n\t\t\tif (j++ > 20) return;\n\t\t}\n\t},\n\tgetStyle: function(state) {\n\t\tstate = this.from + ((this.to - this.from) * state);\n\t\tif (this.property == 'filter') return \"alpha(opacity=\" + Math.round(state*100) + \")\";\n\t\tif (this.property == 'opacity') return state;\n\t\treturn Math.round(state) + this.units;\n\t},\n\tinspect: function() {\n\t\treturn \"\\t\" + this.property + \"(\" + this.from + this.units + \" to \" + this.to + this.units + \")\\n\";\n\t}\n}\n\n// animates a colour based style property between two hex values\nfunction ColorStyleSubject(els, property, from, to) {\n\tthis.els = Animator.makeArrayOfElements(els);\n\tthis.property = Animator.camelize(property);\n\tthis.to = this.expandColor(to);\n\tthis.from = this.expandColor(from);\n\tthis.origFrom = from;\n\tthis.origTo = to;\n}\n\nColorStyleSubject.prototype = {\n\t// parse \"#FFFF00\" to [256, 256, 0]\n\texpandColor: function(color) {\n\t\tvar hexColor, red, green, blue;\n\t\thexColor = ColorStyleSubject.parseColor(color);\n\t\tif (hexColor) {\n\t\t\tred = parseInt(hexColor.slice(1, 3), 16);\n\t\t\tgreen = parseInt(hexColor.slice(3, 5), 16);\n\t\t\tblue = parseInt(hexColor.slice(5, 7), 16);\n\t\t\treturn [red,green,blue]\n\t\t}\n\t\tif (window.ANIMATOR_DEBUG) {\n\t\t\talert(\"Invalid colour: '\" + color + \"'\");\n\t\t}\n\t},\n\tgetValueForState: function(color, state) {\n\t\treturn Math.round(this.from[color] + ((this.to[color] - this.from[color]) * state));\n\t},\n\tsetState: function(state) {\n\t\tvar color = '#'\n\t\t\t\t+ ColorStyleSubject.toColorPart(this.getValueForState(0, state))\n\t\t\t\t+ ColorStyleSubject.toColorPart(this.getValueForState(1, state))\n\t\t\t\t+ ColorStyleSubject.toColorPart(this.getValueForState(2, state));\n\t\tfor (var i=0; i<this.els.length; i++) {\n\t\t\tthis.els[i].style[this.property] = color;\n\t\t}\n\t},\n\tinspect: function() {\n\t\treturn \"\\t\" + this.property + \"(\" + this.origFrom + \" to \" + this.origTo + \")\\n\";\n\t}\n}\n\n// return a properly formatted 6-digit hex colour spec, or false\nColorStyleSubject.parseColor = function(string) {\n\tvar color = '#', match;\n\tif(match = ColorStyleSubject.parseColor.rgbRe.exec(string)) {\n\t\tvar part;\n\t\tfor (var i=1; i<=3; i++) {\n\t\t\tpart = Math.max(0, Math.min(255, parseInt(match[i])));\n\t\t\tcolor += ColorStyleSubject.toColorPart(part);\n\t\t}\n\t\treturn color;\n\t}\n\tif (match = ColorStyleSubject.parseColor.hexRe.exec(string)) {\n\t\tif(match[1].length == 3) {\n\t\t\tfor (var i=0; i<3; i++) {\n\t\t\t\tcolor += match[1].charAt(i) + match[1].charAt(i);\n\t\t\t}\n\t\t\treturn color;\n\t\t}\n\t\treturn '#' + match[1];\n\t}\n\treturn false;\n}\n// convert a number to a 2 digit hex string\nColorStyleSubject.toColorPart = function(number) {\n\tif (number > 255) number = 255;\n\tvar digits = number.toString(16);\n\tif (number < 16) return '0' + digits;\n\treturn digits;\n}\nColorStyleSubject.parseColor.rgbRe = /^rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$/i;\nColorStyleSubject.parseColor.hexRe = /^\\#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/;\n\n// Animates discrete styles, i.e. ones that do not scale but have discrete values\n// that can't be interpolated\nfunction DiscreteStyleSubject(els, property, from, to, threshold) {\n\tthis.els = Animator.makeArrayOfElements(els);\n\tthis.property = Animator.camelize(property);\n\tthis.from = from;\n\tthis.to = to;\n\tthis.threshold = threshold || 0.5;\n}\n\nDiscreteStyleSubject.prototype = {\n\tsetState: function(state) {\n\t\tvar j=0;\n\t\tfor (var i=0; i<this.els.length; i++) {\n\t\t\tthis.els[i].style[this.property] = state <= this.threshold ? this.from : this.to;\n\t\t}\n\t},\n\tinspect: function() {\n\t\treturn \"\\t\" + this.property + \"(\" + this.from + \" to \" + this.to + \" @ \" + this.threshold + \")\\n\";\n\t}\n}\n\n// animates between two styles defined using CSS.\n// if style1 and style2 are present, animate between them, if only style1\n// is present, animate between the element's current style and style1\nfunction CSSStyleSubject(els, style1, style2) {\n\tels = Animator.makeArrayOfElements(els);\n\tthis.subjects = [];\n\tif (els.length == 0) return;\n\tvar prop, toStyle, fromStyle;\n\tif (style2) {\n\t\tfromStyle = this.parseStyle(style1, els[0]);\n\t\ttoStyle = this.parseStyle(style2, els[0]);\n\t} else {\n\t\ttoStyle = this.parseStyle(style1, els[0]);\n\t\tfromStyle = {};\n\t\tfor (prop in toStyle) {\n\t\t\tfromStyle[prop] = CSSStyleSubject.getStyle(els[0], prop);\n\t\t}\n\t}\n\t// remove unchanging properties\n\tvar prop;\n\tfor (prop in fromStyle) {\n\t\tif (fromStyle[prop] == toStyle[prop]) {\n\t\t\tdelete fromStyle[prop];\n\t\t\tdelete toStyle[prop];\n\t\t}\n\t}\n\t// discover the type (numerical or colour) of each style\n\tvar prop, units, match, type, from, to;\n\tfor (prop in fromStyle) {\n\t\tvar fromProp = String(fromStyle[prop]);\n\t\tvar toProp = String(toStyle[prop]);\n\t\tif (toStyle[prop] == null) {\n\t\t\tif (window.ANIMATOR_DEBUG) alert(\"No to style provided for '\" + prop + '\"');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (from = ColorStyleSubject.parseColor(fromProp)) {\n\t\t\tto = ColorStyleSubject.parseColor(toProp);\n\t\t\ttype = ColorStyleSubject;\n\t\t} else if (fromProp.match(CSSStyleSubject.numericalRe)\n\t\t\t\t&& toProp.match(CSSStyleSubject.numericalRe)) {\n\t\t\tfrom = parseFloat(fromProp);\n\t\t\tto = parseFloat(toProp);\n\t\t\ttype = NumericalStyleSubject;\n\t\t\tmatch = CSSStyleSubject.numericalRe.exec(fromProp);\n\t\t\tvar reResult = CSSStyleSubject.numericalRe.exec(toProp);\n\t\t\tif (match[1] != null) {\n\t\t\t\tunits = match[1];\n\t\t\t} else if (reResult[1] != null) {\n\t\t\t\tunits = reResult[1];\n\t\t\t} else {\n\t\t\t\tunits = reResult;\n\t\t\t}\n\t\t} else if (fromProp.match(CSSStyleSubject.discreteRe)\n\t\t\t\t&& toProp.match(CSSStyleSubject.discreteRe)) {\n\t\t\tfrom = fromProp;\n\t\t\tto = toProp;\n\t\t\ttype = DiscreteStyleSubject;\n\t\t\tunits = 0;   // hack - how to get an animator option down to here\n\t\t} else {\n\t\t\tif (window.ANIMATOR_DEBUG) {\n\t\t\t\talert(\"Unrecognised format for value of \"\n\t\t\t\t\t+ prop + \": '\" + fromStyle[prop] + \"'\");\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tthis.subjects[this.subjects.length] = new type(els, prop, from, to, units);\n\t}\n}\n\nCSSStyleSubject.prototype = {\n\t// parses \"width: 400px; color: #FFBB2E\" to {width: \"400px\", color: \"#FFBB2E\"}\n\tparseStyle: function(style, el) {\n\t\tvar rtn = {};\n\t\t// if style is a rule set\n\t\tif (style.indexOf(\":\") != -1) {\n\t\t\tvar styles = style.split(\";\");\n\t\t\tfor (var i=0; i<styles.length; i++) {\n\t\t\t\tvar parts = CSSStyleSubject.ruleRe.exec(styles[i]);\n\t\t\t\tif (parts) {\n\t\t\t\t\trtn[parts[1]] = parts[2];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// else assume style is a class name\n\t\telse {\n\t\t\tvar prop, value, oldClass;\n\t\t\toldClass = el.className;\n\t\t\tel.className = style;\n\t\t\tfor (var i=0; i<CSSStyleSubject.cssProperties.length; i++) {\n\t\t\t\tprop = CSSStyleSubject.cssProperties[i];\n\t\t\t\tvalue = CSSStyleSubject.getStyle(el, prop);\n\t\t\t\tif (value != null) {\n\t\t\t\t\trtn[prop] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tel.className = oldClass;\n\t\t}\n\t\treturn rtn;\n\n\t},\n\tsetState: function(state) {\n\t\tfor (var i=0; i<this.subjects.length; i++) {\n\t\t\tthis.subjects[i].setState(state);\n\t\t}\n\t},\n\tinspect: function() {\n\t\tvar str = \"\";\n\t\tfor (var i=0; i<this.subjects.length; i++) {\n\t\t\tstr += this.subjects[i].inspect();\n\t\t}\n\t\treturn str;\n\t}\n}\n// get the current value of a css property,\nCSSStyleSubject.getStyle = function(el, property){\n\tvar style;\n\tif(document.defaultView && document.defaultView.getComputedStyle){\n\t\tstyle = document.defaultView.getComputedStyle(el, \"\").getPropertyValue(property);\n\t\tif (style) {\n\t\t\treturn style;\n\t\t}\n\t}\n\tproperty = Animator.camelize(property);\n\tif(el.currentStyle){\n\t\tstyle = el.currentStyle[property];\n\t}\n\treturn style || el.style[property]\n}\n\n\nCSSStyleSubject.ruleRe = /^\\s*([a-zA-Z\\-]+)\\s*:\\s*(\\S(.+\\S)?)\\s*$/;\nCSSStyleSubject.numericalRe = /^-?\\d+(?:\\.\\d+)?(%|[a-zA-Z]{2})?$/;\nCSSStyleSubject.discreteRe = /^\\w+$/;\n\n// required because the style object of elements isn't enumerable in Safari\n/*\nCSSStyleSubject.cssProperties = ['background-color','border','border-color','border-spacing',\n'border-style','border-top','border-right','border-bottom','border-left','border-top-color',\n'border-right-color','border-bottom-color','border-left-color','border-top-width','border-right-width',\n'border-bottom-width','border-left-width','border-width','bottom','color','font-size','font-size-adjust',\n'font-stretch','font-style','height','left','letter-spacing','line-height','margin','margin-top',\n'margin-right','margin-bottom','margin-left','marker-offset','max-height','max-width','min-height',\n'min-width','orphans','outline','outline-color','outline-style','outline-width','overflow','padding',\n'padding-top','padding-right','padding-bottom','padding-left','quotes','right','size','text-indent',\n'top','width','word-spacing','z-index','opacity','outline-offset'];*/\n\n\nCSSStyleSubject.cssProperties = ['azimuth','background','background-attachment','background-color','background-image','background-position','background-repeat','border-collapse','border-color','border-spacing','border-style','border-top','border-top-color','border-right-color','border-bottom-color','border-left-color','border-top-style','border-right-style','border-bottom-style','border-left-style','border-top-width','border-right-width','border-bottom-width','border-left-width','border-width','bottom','clear','clip','color','content','cursor','direction','display','elevation','empty-cells','css-float','font','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','height','left','letter-spacing','line-height','list-style','list-style-image','list-style-position','list-style-type','margin','margin-top','margin-right','margin-bottom','margin-left','max-height','max-width','min-height','min-width','orphans','outline','outline-color','outline-style','outline-width','overflow','padding','padding-top','padding-right','padding-bottom','padding-left','pause','position','right','size','table-layout','text-align','text-decoration','text-indent','text-shadow','text-transform','top','vertical-align','visibility','white-space','width','word-spacing','z-index','opacity','outline-offset','overflow-x','overflow-y'];\n\n\n// chains several Animator objects together\nfunction AnimatorChain(animators, options) {\n\tthis.animators = animators;\n\tthis.setOptions(options);\n\tfor (var i=0; i<this.animators.length; i++) {\n\t\tthis.listenTo(this.animators[i]);\n\t}\n\tthis.forwards = false;\n\tthis.current = 0;\n}\n\nAnimatorChain.prototype = {\n\t// apply defaults\n\tsetOptions: function(options) {\n\t\tthis.options = Animator.applyDefaults({\n\t\t\t// by default, each call to AnimatorChain.play() calls jumpTo(0) of each animator\n\t\t\t// before playing, which can cause flickering if you have multiple animators all\n\t\t\t// targeting the same element. Set this to false to avoid this.\n\t\t\tresetOnPlay: true\n\t\t}, options);\n\t},\n\t// play each animator in turn\n\tplay: function() {\n\t\tthis.forwards = true;\n\t\tthis.current = -1;\n\t\tif (this.options.resetOnPlay) {\n\t\t\tfor (var i=0; i<this.animators.length; i++) {\n\t\t\t\tthis.animators[i].jumpTo(0);\n\t\t\t}\n\t\t}\n\t\tthis.advance();\n\t},\n\t// play all animators backwards\n\treverse: function() {\n\t\tthis.forwards = false;\n\t\tthis.current = this.animators.length;\n\t\tif (this.options.resetOnPlay) {\n\t\t\tfor (var i=0; i<this.animators.length; i++) {\n\t\t\t\tthis.animators[i].jumpTo(1);\n\t\t\t}\n\t\t}\n\t\tthis.advance();\n\t},\n\t// if we have just play()'d, then call reverse(), and vice versa\n\ttoggle: function() {\n\t\tif (this.forwards) {\n\t\t\tthis.seekTo(0);\n\t\t} else {\n\t\t\tthis.seekTo(1);\n\t\t}\n\t},\n\t// internal: install an event listener on an animator's onComplete option\n\t// to trigger the next animator\n\tlistenTo: function(animator) {\n\t\tvar oldOnComplete = animator.options.onComplete;\n\t\tvar _this = this;\n\t\tanimator.options.onComplete = function() {\n\t\t\tif (oldOnComplete) oldOnComplete.call(animator);\n\t\t\t_this.advance();\n\t\t}\n\t},\n\t// play the next animator\n\tadvance: function() {\n\t\tif (this.forwards) {\n\t\t\tif (this.animators[this.current + 1] == null) return;\n\t\t\tthis.current++;\n\t\t\tthis.animators[this.current].play();\n\t\t} else {\n\t\t\tif (this.animators[this.current - 1] == null) return;\n\t\t\tthis.current--;\n\t\t\tthis.animators[this.current].reverse();\n\t\t}\n\t},\n\t// this function is provided for drop-in compatibility with Animator objects,\n\t// but only accepts 0 and 1 as target values\n\tseekTo: function(target) {\n\t\tif (target <= 0) {\n\t\t\tthis.forwards = false;\n\t\t\tthis.animators[this.current].seekTo(0);\n\t\t} else {\n\t\t\tthis.forwards = true;\n\t\t\tthis.animators[this.current].seekTo(1);\n\t\t}\n\t}\n}"},function(t,n,e){e(0)(e(7))},function(t,n){t.exports='"function"!==typeof Object.create&&(Object.create=function(f){function g(){}g.prototype=f;return new g});\n(function(f,g,k){var l={init:function(a,b){this.$elem=f(b);this.options=f.extend({},f.fn.owlCarousel.options,this.$elem.data(),a);this.userOptions=a;this.loadContent()},loadContent:function(){function a(a){var d,e="";if("function"===typeof b.options.jsonSuccess)b.options.jsonSuccess.apply(this,[a]);else{for(d in a.owl)a.owl.hasOwnProperty(d)&&(e+=a.owl[d].item);b.$elem.html(e)}b.logIn()}var b=this,e;"function"===typeof b.options.beforeInit&&b.options.beforeInit.apply(this,[b.$elem]);"string"===typeof b.options.jsonPath?\n(e=b.options.jsonPath,f.getJSON(e,a)):b.logIn()},logIn:function(){this.$elem.data("owl-originalStyles",this.$elem.attr("style"));this.$elem.data("owl-originalClasses",this.$elem.attr("class"));this.$elem.css({opacity:0});this.orignalItems=this.options.items;this.checkBrowser();this.wrapperWidth=0;this.checkVisible=null;this.setVars()},setVars:function(){if(0===this.$elem.children().length)return!1;this.baseClass();this.eventTypes();this.$userItems=this.$elem.children();this.itemsAmount=this.$userItems.length;\nthis.wrapItems();this.$owlItems=this.$elem.find(".owl-item");this.$owlWrapper=this.$elem.find(".owl-wrapper");this.playDirection="next";this.prevItem=0;this.prevArr=[0];this.currentItem=0;this.customEvents();this.onStartup()},onStartup:function(){this.updateItems();this.calculateAll();this.buildControls();this.updateControls();this.response();this.moveEvents();this.stopOnHover();this.owlStatus();!1!==this.options.transitionStyle&&this.transitionTypes(this.options.transitionStyle);!0===this.options.autoPlay&&\n(this.options.autoPlay=5E3);this.play();this.$elem.find(".owl-wrapper").css("display","block");this.$elem.is(":visible")?this.$elem.css("opacity",1):this.watchVisibility();this.onstartup=!1;this.eachMoveUpdate();"function"===typeof this.options.afterInit&&this.options.afterInit.apply(this,[this.$elem])},eachMoveUpdate:function(){!0===this.options.lazyLoad&&this.lazyLoad();!0===this.options.autoHeight&&this.autoHeight();this.onVisibleItems();"function"===typeof this.options.afterAction&&this.options.afterAction.apply(this,\n[this.$elem])},updateVars:function(){"function"===typeof this.options.beforeUpdate&&this.options.beforeUpdate.apply(this,[this.$elem]);this.watchVisibility();this.updateItems();this.calculateAll();this.updatePosition();this.updateControls();this.eachMoveUpdate();"function"===typeof this.options.afterUpdate&&this.options.afterUpdate.apply(this,[this.$elem])},reload:function(){var a=this;g.setTimeout(function(){a.updateVars()},0)},watchVisibility:function(){var a=this;if(!1===a.$elem.is(":visible"))a.$elem.css({opacity:0}),\ng.clearInterval(a.autoPlayInterval),g.clearInterval(a.checkVisible);else return!1;a.checkVisible=g.setInterval(function(){a.$elem.is(":visible")&&(a.reload(),a.$elem.animate({opacity:1},200),g.clearInterval(a.checkVisible))},500)},wrapItems:function(){this.$userItems.wrapAll(\'<div class="owl-wrapper">\').wrap(\'<div class="owl-item"></div>\');this.$elem.find(".owl-wrapper").wrap(\'<div class="owl-wrapper-outer">\');this.wrapperOuter=this.$elem.find(".owl-wrapper-outer");this.$elem.css("display","block")},\nbaseClass:function(){var a=this.$elem.hasClass(this.options.baseClass),b=this.$elem.hasClass(this.options.theme);a||this.$elem.addClass(this.options.baseClass);b||this.$elem.addClass(this.options.theme)},updateItems:function(){var a,b;if(!1===this.options.responsive)return!1;if(!0===this.options.singleItem)return this.options.items=this.orignalItems=1,this.options.itemsCustom=!1,this.options.itemsDesktop=!1,this.options.itemsDesktopSmall=!1,this.options.itemsTablet=!1,this.options.itemsTabletSmall=\n!1,this.options.itemsMobile=!1;a=f(this.options.responsiveBaseWidth).width();a>(this.options.itemsDesktop[0]||this.orignalItems)&&(this.options.items=this.orignalItems);if(!1!==this.options.itemsCustom)for(this.options.itemsCustom.sort(function(a,b){return a[0]-b[0]}),b=0;b<this.options.itemsCustom.length;b+=1)this.options.itemsCustom[b][0]<=a&&(this.options.items=this.options.itemsCustom[b][1]);else a<=this.options.itemsDesktop[0]&&!1!==this.options.itemsDesktop&&(this.options.items=this.options.itemsDesktop[1]),\na<=this.options.itemsDesktopSmall[0]&&!1!==this.options.itemsDesktopSmall&&(this.options.items=this.options.itemsDesktopSmall[1]),a<=this.options.itemsTablet[0]&&!1!==this.options.itemsTablet&&(this.options.items=this.options.itemsTablet[1]),a<=this.options.itemsTabletSmall[0]&&!1!==this.options.itemsTabletSmall&&(this.options.items=this.options.itemsTabletSmall[1]),a<=this.options.itemsMobile[0]&&!1!==this.options.itemsMobile&&(this.options.items=this.options.itemsMobile[1]);this.options.items>this.itemsAmount&&\n!0===this.options.itemsScaleUp&&(this.options.items=this.itemsAmount)},response:function(){var a=this,b,e;if(!0!==a.options.responsive)return!1;e=f(g).width();a.resizer=function(){f(g).width()!==e&&(!1!==a.options.autoPlay&&g.clearInterval(a.autoPlayInterval),g.clearTimeout(b),b=g.setTimeout(function(){e=f(g).width();a.updateVars()},a.options.responsiveRefreshRate))};f(g).resize(a.resizer)},updatePosition:function(){this.jumpTo(this.currentItem);!1!==this.options.autoPlay&&this.checkAp()},appendItemsSizes:function(){var a=\nthis,b=0,e=a.itemsAmount-a.options.items;a.$owlItems.each(function(c){var d=f(this);d.css({width:a.itemWidth}).data("owl-item",Number(c));if(0===c%a.options.items||c===e)c>e||(b+=1);d.data("owl-roundPages",b)})},appendWrapperSizes:function(){this.$owlWrapper.css({width:this.$owlItems.length*this.itemWidth*2,left:0});this.appendItemsSizes()},calculateAll:function(){this.calculateWidth();this.appendWrapperSizes();this.loops();this.max()},calculateWidth:function(){this.itemWidth=Math.round(this.$elem.width()/\nthis.options.items)},max:function(){var a=-1*(this.itemsAmount*this.itemWidth-this.options.items*this.itemWidth);this.options.items>this.itemsAmount?this.maximumPixels=a=this.maximumItem=0:(this.maximumItem=this.itemsAmount-this.options.items,this.maximumPixels=a);return a},min:function(){return 0},loops:function(){var a=0,b=0,e,c;this.positionsInArray=[0];this.pagesInArray=[];for(e=0;e<this.itemsAmount;e+=1)b+=this.itemWidth,this.positionsInArray.push(-b),!0===this.options.scrollPerPage&&(c=f(this.$owlItems[e]),\nc=c.data("owl-roundPages"),c!==a&&(this.pagesInArray[a]=this.positionsInArray[e],a=c))},buildControls:function(){if(!0===this.options.navigation||!0===this.options.pagination)this.owlControls=f(\'<div class="owl-controls"/>\').toggleClass("clickable",!this.browser.isTouch).appendTo(this.$elem);!0===this.options.pagination&&this.buildPagination();!0===this.options.navigation&&this.buildButtons()},buildButtons:function(){var a=this,b=f(\'<div class="owl-buttons"/>\');a.owlControls.append(b);a.buttonPrev=\nf("<div/>",{"class":"owl-prev",html:a.options.navigationText[0]||""});a.buttonNext=f("<div/>",{"class":"owl-next",html:a.options.navigationText[1]||""});b.append(a.buttonPrev).append(a.buttonNext);b.on("touchstart.owlControls mousedown.owlControls",\'div[class^="owl"]\',function(a){a.preventDefault()});b.on("touchend.owlControls mouseup.owlControls",\'div[class^="owl"]\',function(b){b.preventDefault();f(this).hasClass("owl-next")?a.next():a.prev()})},buildPagination:function(){var a=this;a.paginationWrapper=\nf(\'<div class="owl-pagination"/>\');a.owlControls.append(a.paginationWrapper);a.paginationWrapper.on("touchend.owlControls mouseup.owlControls",".owl-page",function(b){b.preventDefault();Number(f(this).data("owl-page"))!==a.currentItem&&a.goTo(Number(f(this).data("owl-page")),!0)})},updatePagination:function(){var a,b,e,c,d,g;if(!1===this.options.pagination)return!1;this.paginationWrapper.html("");a=0;b=this.itemsAmount-this.itemsAmount%this.options.items;for(c=0;c<this.itemsAmount;c+=1)0===c%this.options.items&&\n(a+=1,b===c&&(e=this.itemsAmount-this.options.items),d=f("<div/>",{"class":"owl-page"}),g=f("<span></span>",{text:!0===this.options.paginationNumbers?a:"","class":!0===this.options.paginationNumbers?"owl-numbers":""}),d.append(g),d.data("owl-page",b===c?e:c),d.data("owl-roundPages",a),this.paginationWrapper.append(d));this.checkPagination()},checkPagination:function(){var a=this;if(!1===a.options.pagination)return!1;a.paginationWrapper.find(".owl-page").each(function(){f(this).data("owl-roundPages")===\nf(a.$owlItems[a.currentItem]).data("owl-roundPages")&&(a.paginationWrapper.find(".owl-page").removeClass("active"),f(this).addClass("active"))})},checkNavigation:function(){if(!1===this.options.navigation)return!1;!1===this.options.rewindNav&&(0===this.currentItem&&0===this.maximumItem?(this.buttonPrev.addClass("disabled"),this.buttonNext.addClass("disabled")):0===this.currentItem&&0!==this.maximumItem?(this.buttonPrev.addClass("disabled"),this.buttonNext.removeClass("disabled")):this.currentItem===\nthis.maximumItem?(this.buttonPrev.removeClass("disabled"),this.buttonNext.addClass("disabled")):0!==this.currentItem&&this.currentItem!==this.maximumItem&&(this.buttonPrev.removeClass("disabled"),this.buttonNext.removeClass("disabled")))},updateControls:function(){this.updatePagination();this.checkNavigation();this.owlControls&&(this.options.items>=this.itemsAmount?this.owlControls.hide():this.owlControls.show())},destroyControls:function(){this.owlControls&&this.owlControls.remove()},next:function(a){if(this.isTransition)return!1;\nthis.currentItem+=!0===this.options.scrollPerPage?this.options.items:1;if(this.currentItem>this.maximumItem+(!0===this.options.scrollPerPage?this.options.items-1:0))if(!0===this.options.rewindNav)this.currentItem=0,a="rewind";else return this.currentItem=this.maximumItem,!1;this.goTo(this.currentItem,a)},prev:function(a){if(this.isTransition)return!1;this.currentItem=!0===this.options.scrollPerPage&&0<this.currentItem&&this.currentItem<this.options.items?0:this.currentItem-(!0===this.options.scrollPerPage?\nthis.options.items:1);if(0>this.currentItem)if(!0===this.options.rewindNav)this.currentItem=this.maximumItem,a="rewind";else return this.currentItem=0,!1;this.goTo(this.currentItem,a)},goTo:function(a,b,e){var c=this;if(c.isTransition)return!1;"function"===typeof c.options.beforeMove&&c.options.beforeMove.apply(this,[c.$elem]);a>=c.maximumItem?a=c.maximumItem:0>=a&&(a=0);c.currentItem=c.owl.currentItem=a;if(!1!==c.options.transitionStyle&&"drag"!==e&&1===c.options.items&&!0===c.browser.support3d)return c.swapSpeed(0),\n!0===c.browser.support3d?c.transition3d(c.positionsInArray[a]):c.css2slide(c.positionsInArray[a],1),c.afterGo(),c.singleItemTransition(),!1;a=c.positionsInArray[a];!0===c.browser.support3d?(c.isCss3Finish=!1,!0===b?(c.swapSpeed("paginationSpeed"),g.setTimeout(function(){c.isCss3Finish=!0},c.options.paginationSpeed)):"rewind"===b?(c.swapSpeed(c.options.rewindSpeed),g.setTimeout(function(){c.isCss3Finish=!0},c.options.rewindSpeed)):(c.swapSpeed("slideSpeed"),g.setTimeout(function(){c.isCss3Finish=!0},\nc.options.slideSpeed)),c.transition3d(a)):!0===b?c.css2slide(a,c.options.paginationSpeed):"rewind"===b?c.css2slide(a,c.options.rewindSpeed):c.css2slide(a,c.options.slideSpeed);c.afterGo()},jumpTo:function(a){"function"===typeof this.options.beforeMove&&this.options.beforeMove.apply(this,[this.$elem]);a>=this.maximumItem||-1===a?a=this.maximumItem:0>=a&&(a=0);this.swapSpeed(0);!0===this.browser.support3d?this.transition3d(this.positionsInArray[a]):this.css2slide(this.positionsInArray[a],1);this.currentItem=\nthis.owl.currentItem=a;this.afterGo()},afterGo:function(){this.prevArr.push(this.currentItem);this.prevItem=this.owl.prevItem=this.prevArr[this.prevArr.length-2];this.prevArr.shift(0);this.prevItem!==this.currentItem&&(this.checkPagination(),this.checkNavigation(),this.eachMoveUpdate(),!1!==this.options.autoPlay&&this.checkAp());"function"===typeof this.options.afterMove&&this.prevItem!==this.currentItem&&this.options.afterMove.apply(this,[this.$elem])},stop:function(){this.apStatus="stop";g.clearInterval(this.autoPlayInterval)},\ncheckAp:function(){"stop"!==this.apStatus&&this.play()},play:function(){var a=this;a.apStatus="play";if(!1===a.options.autoPlay)return!1;g.clearInterval(a.autoPlayInterval);a.autoPlayInterval=g.setInterval(function(){a.next(!0)},a.options.autoPlay)},swapSpeed:function(a){"slideSpeed"===a?this.$owlWrapper.css(this.addCssSpeed(this.options.slideSpeed)):"paginationSpeed"===a?this.$owlWrapper.css(this.addCssSpeed(this.options.paginationSpeed)):"string"!==typeof a&&this.$owlWrapper.css(this.addCssSpeed(a))},\naddCssSpeed:function(a){return{"-webkit-transition":"all "+a+"ms ease","-moz-transition":"all "+a+"ms ease","-o-transition":"all "+a+"ms ease",transition:"all "+a+"ms ease"}},removeTransition:function(){return{"-webkit-transition":"","-moz-transition":"","-o-transition":"",transition:""}},doTranslate:function(a){return{"-webkit-transform":"translate3d("+a+"px, 0px, 0px)","-moz-transform":"translate3d("+a+"px, 0px, 0px)","-o-transform":"translate3d("+a+"px, 0px, 0px)","-ms-transform":"translate3d("+\na+"px, 0px, 0px)",transform:"translate3d("+a+"px, 0px,0px)"}},transition3d:function(a){this.$owlWrapper.css(this.doTranslate(a))},css2move:function(a){this.$owlWrapper.css({left:a})},css2slide:function(a,b){var e=this;e.isCssFinish=!1;e.$owlWrapper.stop(!0,!0).animate({left:a},{duration:b||e.options.slideSpeed,complete:function(){e.isCssFinish=!0}})},checkBrowser:function(){var a=k.createElement("div");a.style.cssText="  -moz-transform:translate3d(0px, 0px, 0px); -ms-transform:translate3d(0px, 0px, 0px); -o-transform:translate3d(0px, 0px, 0px); -webkit-transform:translate3d(0px, 0px, 0px); transform:translate3d(0px, 0px, 0px)";\na=a.style.cssText.match(/translate3d\\(0px, 0px, 0px\\)/g);this.browser={support3d:null!==a&&1===a.length,isTouch:"ontouchstart"in g||g.navigator.msMaxTouchPoints}},moveEvents:function(){if(!1!==this.options.mouseDrag||!1!==this.options.touchDrag)this.gestures(),this.disabledEvents()},eventTypes:function(){var a=["s","e","x"];this.ev_types={};!0===this.options.mouseDrag&&!0===this.options.touchDrag?a=["touchstart.owl mousedown.owl","touchmove.owl mousemove.owl","touchend.owl touchcancel.owl mouseup.owl"]:\n!1===this.options.mouseDrag&&!0===this.options.touchDrag?a=["touchstart.owl","touchmove.owl","touchend.owl touchcancel.owl"]:!0===this.options.mouseDrag&&!1===this.options.touchDrag&&(a=["mousedown.owl","mousemove.owl","mouseup.owl"]);this.ev_types.start=a[0];this.ev_types.move=a[1];this.ev_types.end=a[2]},disabledEvents:function(){this.$elem.on("dragstart.owl",function(a){a.preventDefault()});this.$elem.on("mousedown.disableTextSelect",function(a){return f(a.target).is("input, textarea, select, option")})},\ngestures:function(){function a(a){if(void 0!==a.touches)return{x:a.touches[0].pageX,y:a.touches[0].pageY};if(void 0===a.touches){if(void 0!==a.pageX)return{x:a.pageX,y:a.pageY};if(void 0===a.pageX)return{x:a.clientX,y:a.clientY}}}function b(a){"on"===a?(f(k).on(d.ev_types.move,e),f(k).on(d.ev_types.end,c)):"off"===a&&(f(k).off(d.ev_types.move),f(k).off(d.ev_types.end))}function e(b){b=b.originalEvent||b||g.event;d.newPosX=a(b).x-h.offsetX;d.newPosY=a(b).y-h.offsetY;d.newRelativeX=d.newPosX-h.relativePos;\n"function"===typeof d.options.startDragging&&!0!==h.dragging&&0!==d.newRelativeX&&(h.dragging=!0,d.options.startDragging.apply(d,[d.$elem]));(8<d.newRelativeX||-8>d.newRelativeX)&&!0===d.browser.isTouch&&(void 0!==b.preventDefault?b.preventDefault():b.returnValue=!1,h.sliding=!0);(10<d.newPosY||-10>d.newPosY)&&!1===h.sliding&&f(k).off("touchmove.owl");d.newPosX=Math.max(Math.min(d.newPosX,d.newRelativeX/5),d.maximumPixels+d.newRelativeX/5);!0===d.browser.support3d?d.transition3d(d.newPosX):d.css2move(d.newPosX)}\nfunction c(a){a=a.originalEvent||a||g.event;var c;a.target=a.target||a.srcElement;h.dragging=!1;!0!==d.browser.isTouch&&d.$owlWrapper.removeClass("grabbing");d.dragDirection=0>d.newRelativeX?d.owl.dragDirection="left":d.owl.dragDirection="right";0!==d.newRelativeX&&(c=d.getNewPosition(),d.goTo(c,!1,"drag"),h.targetElement===a.target&&!0!==d.browser.isTouch&&(f(a.target).on("click.disable",function(a){a.stopImmediatePropagation();a.stopPropagation();a.preventDefault();f(a.target).off("click.disable")}),\na=f._data(a.target,"events").click,c=a.pop(),a.splice(0,0,c)));b("off")}var d=this,h={offsetX:0,offsetY:0,baseElWidth:0,relativePos:0,position:null,minSwipe:null,maxSwipe:null,sliding:null,dargging:null,targetElement:null};d.isCssFinish=!0;d.$elem.on(d.ev_types.start,".owl-wrapper",function(c){c=c.originalEvent||c||g.event;var e;if(3===c.which)return!1;if(!(d.itemsAmount<=d.options.items)){if(!1===d.isCssFinish&&!d.options.dragBeforeAnimFinish||!1===d.isCss3Finish&&!d.options.dragBeforeAnimFinish)return!1;\n!1!==d.options.autoPlay&&g.clearInterval(d.autoPlayInterval);!0===d.browser.isTouch||d.$owlWrapper.hasClass("grabbing")||d.$owlWrapper.addClass("grabbing");d.newPosX=0;d.newRelativeX=0;f(this).css(d.removeTransition());e=f(this).position();h.relativePos=e.left;h.offsetX=a(c).x-e.left;h.offsetY=a(c).y-e.top;b("on");h.sliding=!1;h.targetElement=c.target||c.srcElement}})},getNewPosition:function(){var a=this.closestItem();a>this.maximumItem?a=this.currentItem=this.maximumItem:0<=this.newPosX&&(this.currentItem=\na=0);return a},closestItem:function(){var a=this,b=!0===a.options.scrollPerPage?a.pagesInArray:a.positionsInArray,e=a.newPosX,c=null;f.each(b,function(d,g){e-a.itemWidth/20>b[d+1]&&e-a.itemWidth/20<g&&"left"===a.moveDirection()?(c=g,a.currentItem=!0===a.options.scrollPerPage?f.inArray(c,a.positionsInArray):d):e+a.itemWidth/20<g&&e+a.itemWidth/20>(b[d+1]||b[d]-a.itemWidth)&&"right"===a.moveDirection()&&(!0===a.options.scrollPerPage?(c=b[d+1]||b[b.length-1],a.currentItem=f.inArray(c,a.positionsInArray)):\n(c=b[d+1],a.currentItem=d+1))});return a.currentItem},moveDirection:function(){var a;0>this.newRelativeX?(a="right",this.playDirection="next"):(a="left",this.playDirection="prev");return a},customEvents:function(){var a=this;a.$elem.on("owl.next",function(){a.next()});a.$elem.on("owl.prev",function(){a.prev()});a.$elem.on("owl.play",function(b,e){a.options.autoPlay=e;a.play();a.hoverStatus="play"});a.$elem.on("owl.stop",function(){a.stop();a.hoverStatus="stop"});a.$elem.on("owl.goTo",function(b,e){a.goTo(e)});\na.$elem.on("owl.jumpTo",function(b,e){a.jumpTo(e)})},stopOnHover:function(){var a=this;!0===a.options.stopOnHover&&!0!==a.browser.isTouch&&!1!==a.options.autoPlay&&(a.$elem.on("mouseover",function(){a.stop()}),a.$elem.on("mouseout",function(){"stop"!==a.hoverStatus&&a.play()}))},lazyLoad:function(){var a,b,e,c,d;if(!1===this.options.lazyLoad)return!1;for(a=0;a<this.itemsAmount;a+=1)b=f(this.$owlItems[a]),"loaded"!==b.data("owl-loaded")&&(e=b.data("owl-item"),c=b.find(".lazyOwl"),"string"!==typeof c.data("src")?\nb.data("owl-loaded","loaded"):(void 0===b.data("owl-loaded")&&(c.hide(),b.addClass("loading").data("owl-loaded","checked")),(d=!0===this.options.lazyFollow?e>=this.currentItem:!0)&&e<this.currentItem+this.options.items&&c.length&&this.lazyPreload(b,c)))},lazyPreload:function(a,b){function e(){a.data("owl-loaded","loaded").removeClass("loading");b.removeAttr("data-src");"fade"===d.options.lazyEffect?b.fadeIn(400):b.show();"function"===typeof d.options.afterLazyLoad&&d.options.afterLazyLoad.apply(this,\n[d.$elem])}function c(){f+=1;d.completeImg(b.get(0))||!0===k?e():100>=f?g.setTimeout(c,100):e()}var d=this,f=0,k;"DIV"===b.prop("tagName")?(b.css("background-image","url("+b.data("src")+")"),k=!0):b[0].src=b.data("src");c()},autoHeight:function(){function a(){var a=f(e.$owlItems[e.currentItem]).height();e.wrapperOuter.css("height",a+"px");e.wrapperOuter.hasClass("autoHeight")||g.setTimeout(function(){e.wrapperOuter.addClass("autoHeight")},0)}function b(){d+=1;e.completeImg(c.get(0))?a():100>=d?g.setTimeout(b,\n100):e.wrapperOuter.css("height","")}var e=this,c=f(e.$owlItems[e.currentItem]).find("img"),d;void 0!==c.get(0)?(d=0,b()):a()},completeImg:function(a){return!a.complete||"undefined"!==typeof a.naturalWidth&&0===a.naturalWidth?!1:!0},onVisibleItems:function(){var a;!0===this.options.addClassActive&&this.$owlItems.removeClass("active");this.visibleItems=[];for(a=this.currentItem;a<this.currentItem+this.options.items;a+=1)this.visibleItems.push(a),!0===this.options.addClassActive&&f(this.$owlItems[a]).addClass("active");\nthis.owl.visibleItems=this.visibleItems},transitionTypes:function(a){this.outClass="owl-"+a+"-out";this.inClass="owl-"+a+"-in"},singleItemTransition:function(){var a=this,b=a.outClass,e=a.inClass,c=a.$owlItems.eq(a.currentItem),d=a.$owlItems.eq(a.prevItem),f=Math.abs(a.positionsInArray[a.currentItem])+a.positionsInArray[a.prevItem],g=Math.abs(a.positionsInArray[a.currentItem])+a.itemWidth/2;a.isTransition=!0;a.$owlWrapper.addClass("owl-origin").css({"-webkit-transform-origin":g+"px","-moz-perspective-origin":g+\n"px","perspective-origin":g+"px"});d.css({position:"relative",left:f+"px"}).addClass(b).on("webkitAnimationEnd oAnimationEnd MSAnimationEnd animationend",function(){a.endPrev=!0;d.off("webkitAnimationEnd oAnimationEnd MSAnimationEnd animationend");a.clearTransStyle(d,b)});c.addClass(e).on("webkitAnimationEnd oAnimationEnd MSAnimationEnd animationend",function(){a.endCurrent=!0;c.off("webkitAnimationEnd oAnimationEnd MSAnimationEnd animationend");a.clearTransStyle(c,e)})},clearTransStyle:function(a,\nb){a.css({position:"",left:""}).removeClass(b);this.endPrev&&this.endCurrent&&(this.$owlWrapper.removeClass("owl-origin"),this.isTransition=this.endCurrent=this.endPrev=!1)},owlStatus:function(){this.owl={userOptions:this.userOptions,baseElement:this.$elem,userItems:this.$userItems,owlItems:this.$owlItems,currentItem:this.currentItem,prevItem:this.prevItem,visibleItems:this.visibleItems,isTouch:this.browser.isTouch,browser:this.browser,dragDirection:this.dragDirection}},clearEvents:function(){this.$elem.off(".owl owl mousedown.disableTextSelect");\nf(k).off(".owl owl");f(g).off("resize",this.resizer)},unWrap:function(){0!==this.$elem.children().length&&(this.$owlWrapper.unwrap(),this.$userItems.unwrap().unwrap(),this.owlControls&&this.owlControls.remove());this.clearEvents();this.$elem.attr("style",this.$elem.data("owl-originalStyles")||"").attr("class",this.$elem.data("owl-originalClasses"))},destroy:function(){this.stop();g.clearInterval(this.checkVisible);this.unWrap();this.$elem.removeData()},reinit:function(a){a=f.extend({},this.userOptions,\na);this.unWrap();this.init(a,this.$elem)},addItem:function(a,b){var e;if(!a)return!1;if(0===this.$elem.children().length)return this.$elem.append(a),this.setVars(),!1;this.unWrap();e=void 0===b||-1===b?-1:b;e>=this.$userItems.length||-1===e?this.$userItems.eq(-1).after(a):this.$userItems.eq(e).before(a);this.setVars()},removeItem:function(a){if(0===this.$elem.children().length)return!1;a=void 0===a||-1===a?-1:a;this.unWrap();this.$userItems.eq(a).remove();this.setVars()}};f.fn.owlCarousel=function(a){return this.each(function(){if(!0===\nf(this).data("owl-init"))return!1;f(this).data("owl-init",!0);var b=Object.create(l);b.init(a,this);f.data(this,"owlCarousel",b)})};f.fn.owlCarousel.options={items:5,itemsCustom:!1,itemsDesktop:[1199,4],itemsDesktopSmall:[979,3],itemsTablet:[768,2],itemsTabletSmall:!1,itemsMobile:[479,1],singleItem:!1,itemsScaleUp:!1,slideSpeed:200,paginationSpeed:800,rewindSpeed:1E3,autoPlay:!1,stopOnHover:!1,navigation:!1,navigationText:["prev","next"],rewindNav:!0,scrollPerPage:!1,pagination:!0,paginationNumbers:!1,\nresponsive:!0,responsiveRefreshRate:200,responsiveBaseWidth:g,baseClass:"owl-carousel",theme:"owl-theme",lazyLoad:!1,lazyFollow:!0,lazyEffect:"fade",autoHeight:!1,jsonPath:!1,jsonSuccess:!1,dragBeforeAnimFinish:!0,mouseDrag:!0,touchDrag:!0,addClassActive:!1,transitionStyle:!1,beforeUpdate:!1,afterUpdate:!1,beforeInit:!1,afterInit:!1,beforeMove:!1,afterMove:!1,afterAction:!1,startDragging:!1,afterLazyLoad:!1}})(jQuery,window,document);'},function(t,n,e){e(0)(e(9))},function(t,n,e){t.exports="// extracted by mini-css-extract-plugin"},function(t,n,e){e(0)(e(11))},function(t,n,e){t.exports="// extracted by mini-css-extract-plugin"},function(t,n,e){e(0)(e(13))},function(t,n,e){t.exports="// extracted by mini-css-extract-plugin"},function(t,n,e){e(0)(e(15))},function(t,n){t.exports="/**\n* @title Animator Interface\n* @description animator_interface is used to add a layer between animation calls and animation APIs\n*\tCurrently Animtor_interface uses animator.js or move.js depending on the devices CSS capabilities.\n*\n* @author JamesH\n* @version 1.0 10-12-12\n* @version 2.0 20-12-12 - James Hough - Refresh CSS 'if statement' added to _preprocessMove for off screen elements not\n* rendering when animated on screen.\n* @REFACTOR NOTE: Genricise animate_interface to work with all animation types and directions through move and animate.\n* @REFACTOR NOTE: JC Could do to break aaprt functions, some are getting rather long!\n*/\n\nvar ANIMATOR_INTERFACE =\n{\n\t/************************** PLACEHOLDERS **************************/\n\tbooCSSCapable : null,\n\t_domCurrentElement : null,\n\t_arrAnimations : null,\n\t_strType : null,\n\t_objHashtableAnimations : {},\n\t_objHashtableStates : {},\n\n\t/************************* HANDLE EVENTS *************************/\n\thandleEvent_primeDOMReferences : function (_objWhatDOM)\n\t{\n\t\tif (!this._objCurrDOM)\n\t\t{\n\t\t\tthis._objCurrDOM = _objWhatDOM;\n\t\t}\n\t},\n\n\t/************************* PUBLIC METHODS *************************/\n\t/* Currently accpeted arguments\n\t * _strType: play() || seekTo(1) || seekTo(0) || reverse()\n\t * _strTransition : bounce || elastic || easeIn || easeInOut\n\t * _arrAnimations : left || top || bottom || right\n\t */\n\tobjAnimate : function (_strType, _domCurrentElement, _arrAnimations, _intAnimateDuration, _strTransition, _OnComplete, _strAnimationAsset, _objOptionalCallbackData)\n\t{\n\t\tvar _objAnimateData = {domCurrentElement:_domCurrentElement,\n\t\t\t    arrAnimations : _arrAnimations,\n\t\t\t    strType : _strType,\n\t\t\t    intAnimateDuration : _intAnimateDuration,\n\t\t\t    strTransition : _strTransition,\n\t\t\t    strAnimationAsset : _strAnimationAsset,\n\t\t\t    objOptionalCallbackData : _objOptionalCallbackData };\n\t\tif (typeof _OnComplete == \"string\")\n\t\t{\n\t\t\t_objAnimateData.strOnComplete = _OnComplete;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t_objAnimateData.objOnComplete = _OnComplete;\n\t\t}\n\n\t\treturn _objAnimateData;\n\t},\n\n\tanimate : function (_objAnimateData)\n\t{\n\t\t//WBI.log(\"ANIMATOR_INTERFACE.animate() - About to start pre-processing animation code.\");\n\t\tif (this._isCSSCapable() && !BOO_FORCE_ANIMATE_API && OUTPUT_MODE_CHECKER.canHandleHardwareAnimation(_objAnimateData.strAnimationAsset))\n\t\t{\n\t\t\t//WBI.log(\"ANIMATOR_INTERFACE.animate() - Move choosen\");\n\t\t\tthis._preprocessMove(_objAnimateData);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//WBI.log(\"ANIMATOR_INTERFACE.animate() - Animator choosen\");\n\t\t\tthis._preprocessAnimator(_objAnimateData);\n\t\t}\n\t\t//WBI.log(\"ANIMATOR_INTERFACE.animate() - Finished pre-processing animation code.\");\n\t},\n\n\tstop : function (_domCurrentElementID)\n\t{\n\t\tif (this._isCSSCapable())\n\t\t{\n\t\t\t// REFACTOR NOTE: no out-fo-the-box 'stop' solution for move.js\tas CCS animations don't offer it\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._stopAnimator(_domCurrentElementID);\n\t\t}\n\t},\n\n\tgetState : function (_domCurrentElementID)\n\t{\n\t\tif (this._isCSSCapable())\n\t\t{\n\t\t\treturn this._objHashtableStates[_domCurrentElementID];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn this._objHashtableAnimations[_domCurrentElementID].state;\n\t\t}\n\t},\n\n\tresetElementForAnimation : function (_objAnimateData)\n\t{\n\t\tif (this._isCSSCapable() && OUTPUT_MODE_CHECKER.canHandleHardwareAnimation(_objAnimateData.strAnimationAsset))\n\t\t{\n\t\t\t_objAnimateData.domCurrentElement.style.webkitTransform = 'translate3d(0px, '+_objAnimateData.arrAnimations[0].value+'px, 0px)';\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (_objAnimateData.arrAnimations[0].style == 'top')\n\t\t\t{\n\t\t\t\t_objAnimateData.domCurrentElement.style.top = _objAnimateData.arrAnimations[0].value + \"px\";\n\t\t\t}\n\t\t\telse if (_objAnimateData.arrAnimations[0].style == 'bottom')\n\t\t\t{\n\t\t\t\t_objAnimateData.domCurrentElement.style.bottom = _objAnimateData.arrAnimations[0].value + \"px\";\n\t\t\t}\n\t\t\telse if (_objAnimateData.arrAnimations[0].style == 'margin-left')\n\t\t\t{\n\t\t\t\t_objAnimateData.domCurrentElement.style.marginLeft = _objAnimateData.arrAnimations[0].value + \"px\";\n\t\t\t}\n\t\t}\n\t},\n\n\t/************************ PRIVATE METHODS *************************/\n\n\t/*********** MOVE METHODS ************/\n\n\t_preprocessMove : function (_objAnimateData)\n\t{\n\t\t// REFACTOR NOTE: change to switch case with error if type doesn't exist\n\t\t// TODO NOTE: Add .stop method.\n\n\t\tthis._performMoveAnimation(_objAnimateData);\n\n\t\t//update hashtable for animation handles later\n\t\tif (this._objHashtableStates[_objAnimateData.domCurrentElement.id] && this._objHashtableStates[_objAnimateData.domCurrentElement.id] == 1)\n\t\t{\n\t\t\tthis._objHashtableStates[_objAnimateData.domCurrentElement.id] = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis._objHashtableStates[_objAnimateData.domCurrentElement.id] = 1;\n\t\t}\n\n\t\t/* CSS Refresh fix.\n\t\t* Some browsers (see OUTPUT_MODE_CHECK.cssDomRefreshFix for full list) aren't refreshing DOM's being 'transformed' from\n\t\t* off screen, on screen. The interval setting of a border on and off reminds the browser to render the div and fixes the fault.\n\t\t*/\n\t\tif ( OUTPUT_MODE_CHECKER.hasDomRefreshError() )\n\t\t{\n\t\t\tvar _strClass = 'border-top-color';\n\t\t\tvar _stringStyle = _objAnimateData.domCurrentElement.style[_strClass];\n\t\t\tif(!_stringStyle)\n\t\t\t{\n\t\t\t\tvar _objDefaultView = this._objCurrDOM.defaultView || window;\n\t\t\t\tif(_objDefaultView.getComputedStyle)\n\t\t\t\t{\n\t\t\t\t\t_stringStyle = _objDefaultView.getComputedStyle(_objAnimateData.domCurrentElement,'').getPropertyValue(_strClass);\n\t\t\t\t}\n\t\t\t\telse if(_objAnimateData.domCurrentElement.currentStyle)\n\t\t\t\t{\n\t\t\t\t\t_stringStyle = _objAnimateData.domCurrentElement.currentStyle[_strClass];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//console.log('Animator_interface.js is overriding ' + _objAnimateData.domCurrentElement.className + '\\'s CSS border in _preProcessMove().'); //'\n\n\t\t\t// REFACTOR NOTE: JC, Need to make sure this is cleaned up onunload!\n\t\t\tvar _funAndroidRefreshFix = setInterval(function()\n\t\t\t\t{\n\t\t\t\t\t_objAnimateData.domCurrentElement.style.cssText += ';border:solid red 1px';\n\t\t\t\t\t_objAnimateData.domCurrentElement.offsetHeight;\n\t\t\t\t\t_objAnimateData.domCurrentElement.style.cssText += ';border:none';\n\t\t\t\t}, 100);\n\n\t\t\tsetTimeout(function()\n\t\t\t\t{\n\t\t\t\t\tclearInterval(_funAndroidRefreshFix);\n\t\t\t\t}, 1000);\n\t\t}\n\t},\n\n\t_performMoveAnimation : function (_objAnimateData)\n\t{\n\t\tif (_objAnimateData.strType == \"play()\" || _objAnimateData.strMoveType == \"reverse()\")\n\t\t{\n\t\t\tthis._moveAnimateToDirection(_objAnimateData);\n\t\t}\n\t\telse if (_objAnimateData.strType == \"seekTo(1)\" || _objAnimateData.strType == \"seekTo(0)\")\n\t\t{\n\t\t\tthis._moveAnimateFromToDirection(_objAnimateData);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// TO LOCALISE\n\t\t\talert(\"ERROR: Unknown type of '\" + _objAnimateData.strType + \"' found in ANIMATOR_INTERFACE._performMoveAnimation(), animator_interface.js\")\n\t\t}\n\t},\n\n\t_moveAnimateToDirection : function (_objAnimateData)\n\t{\n\t\tvar intMoveDirectionFrom = null;\n\t\tvar intMoveDirectionTo = null;\n\n\t\tif (_objAnimateData.strType == \"play()\")\n\t\t{\n\t\t\tintMoveDirectionFrom = 0;\n\t\t\tintMoveDirectionTo = 1;\n\t\t}\n\t\telse if (_objAnimateData.strType == \"reverse()\")\n\t\t{\n\t\t\tintMoveDirectionFrom = 1;\n\t\t\tintMoveDirectionTo = 0;\n\t\t}\n\n\t\tif (_objAnimateData.arrAnimations[0].style == 'left' || _objAnimateData.arrAnimations[0].style == 'margin-left' || _objAnimateData.arrAnimations[0].style == 'right')\n\t\t{\n\t\t\tmove(_objAnimateData.domCurrentElement.id)\n\t\t\t\t.ease('in-out')\n\t\t\t\t.x(_objAnimateData.arrAnimations[intMoveDirectionTo].value)\n\t\t\t\t.duration(_objAnimateData.intAnimateDuration)\n\t\t\t\t.end( function (){ANIMATOR_INTERFACE._moveEndFunction(_objAnimateData)});\n\t\t}\n\t\telse if (_objAnimateData.arrAnimations[0].style == 'top' || _objAnimateData.arrAnimations[0].style == 'bottom')\n\t\t{\n\t\t\tmove(_objAnimateData.domCurrentElement.id)\n\t\t\t\t.ease('in-out')\n\t\t\t\t.y(_objAnimateData.arrAnimations[intMoveDirectionTo].value)\n\t\t\t\t.duration(_objAnimateData.intAnimateDuration)\n\t\t\t\t.end( function (){ANIMATOR_INTERFACE._moveEndFunction(_objAnimateData)});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tmove(_objAnimateData.domCurrentElement.id)\n\t\t\t\t.ease('in-out')\n\t\t\t\t.set(_objAnimateData.arrAnimations[0].style, _objAnimateData.arrAnimations[intMoveDirectionFrom].value + \"px\")\n\t\t\t\t.set(_objAnimateData.arrAnimations[1].style, _objAnimateData.arrAnimations[intMoveDirectionTo].value + \"px\")\n\t\t\t\t.duration(_objAnimateData.intAnimateDuration)\n\t\t\t\t.end( function (){ANIMATOR_INTERFACE._moveEndFunction(_objAnimateData)});\n\t\t}\n\t},\n\n\t_moveAnimateFromToDirection : function (_objAnimateData)\n\t{\n\t\t/* Clear CSS top override to force subscreens off screen for flicker affect when\n\t\t * display:none removed by asset_interface */\n\t\t if(typeof _objAnimateData.preservePositions == 'undefined' ||\n       _objAnimateData.preservePositions !== true){ \n\t\t\tif (_objAnimateData.arrAnimations[0].style == 'left')\n\t\t\t{\n\t\t\t\t_objAnimateData.domCurrentElement.style.left = '0px';\n\t\t\t}\n\t\t\tif (_objAnimateData.arrAnimations[0].style == 'right')\n\t\t\t{\n\t\t\t\t_objAnimateData.domCurrentElement.style.right = '0px';\n\t\t\t}\n\t\t\tif (_objAnimateData.arrAnimations[0].style == 'top')\n\t\t\t{\n\t\t\t\t_objAnimateData.domCurrentElement.style.top = '0px';\n\t\t\t}\n\t\t\tif (_objAnimateData.arrAnimations[0].style == 'bottom')\n\t\t\t{\n\t\t\t\t_objAnimateData.domCurrentElement.style.bottom = '0px';\n\t\t\t}\n\t\t}\n\n\t\tvar intMoveDirectionFrom = null;\n\t\tvar intMoveDirectionTo = null;\n\n\t\tif (_objAnimateData.strType == \"seekTo(1)\")\n\t\t{\n\t\t\tintMoveDirectionFrom = 0;\n\t\t\tintMoveDirectionTo = 1;\n\t\t}\n\t\telse if (_objAnimateData.strType == \"seekTo(0)\")\n\t\t{\n\t\t\tintMoveDirectionFrom = 1;\n\t\t\tintMoveDirectionTo = 0;\n\t\t}\n\n\t\t_objAnimateData = this._moveConvertValues(_objAnimateData);\n\n\t\tif (_objAnimateData.arrAnimations[0].style == 'left' || _objAnimateData.arrAnimations[0].style == 'margin-left' || _objAnimateData.arrAnimations[0].style == 'right')\n\t\t\t{\n\t\t\t\tmove(_objAnimateData.domCurrentElement.id)\n\t\t\t\t\t.ease('in-out')\n\t\t\t\t\t.x(_objAnimateData.arrAnimations[intMoveDirectionFrom].value)\n\t\t\t\t\t.duration(0)\n\t\t\t\t\t.end(\n\t\t\t\t\tfunction()\n\t\t\t\t\t{\n\t\t\t\t\t\tmove(_objAnimateData.domCurrentElement.id)\n\t\t\t\t\t\t.ease('in-out')\n\t\t\t\t\t\t.x(_objAnimateData.arrAnimations[intMoveDirectionTo].value)\n\t\t\t\t\t\t.duration(_objAnimateData.intAnimateDuration)\n\t\t\t\t\t\t.end( function (){ANIMATOR_INTERFACE._moveEndFunction(_objAnimateData)})\n\t\t\t\t\t});\n\t\t\t}\n\t\t\telse if (_objAnimateData.arrAnimations[0].style == 'top' || _objAnimateData.arrAnimations[0].style == 'bottom')\n\t\t\t{\n\t\t\t\tmove(_objAnimateData.domCurrentElement.id)\n\t\t\t\t\t.ease('in-out')\n\t\t\t\t\t.y(_objAnimateData.arrAnimations[intMoveDirectionFrom].value)\n\t\t\t\t\t.duration(0)\n\t\t\t\t\t.end(\n\t\t\t\t\tfunction()\n\t\t\t\t\t{\n\t\t\t\t\t\tmove(_objAnimateData.domCurrentElement.id)\n\t\t\t\t\t\t.ease('in-out')\n\t\t\t\t\t\t.y(_objAnimateData.arrAnimations[intMoveDirectionTo].value)\n\t\t\t\t\t\t.duration(_objAnimateData.intAnimateDuration)\n\t\t\t\t\t\t.end( function (){ANIMATOR_INTERFACE._moveEndFunction(_objAnimateData)})\n\t\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tmove(_objAnimateData.domCurrentElement.id)\n\t\t\t\t\t.ease('in-out')\n\t\t\t\t\t.set(_objAnimateData.arrAnimations[0].style, _objAnimateData.arrAnimations[intMoveDirectionFrom].value + \"px\")\n\t\t\t\t\t.set(_objAnimateData.arrAnimations[1].style, _objAnimateData.arrAnimations[intMoveDirectionTo].value + \"px\")\n\t\t\t\t\t.duration(_objAnimateData.intAnimateDuration)\n\t\t\t\t\t.end( function (){ANIMATOR_INTERFACE._moveEndFunction(_objAnimateData)});\n\t\t\t}\n\t},\n\n\t_moveConvertValues : function (_objAnimateData)\n\t{\n\t\tif (_objAnimateData.arrAnimations[0].style == 'right' || _objAnimateData.arrAnimations[0].style == \"bottom\")\n\t\t{\n\t\t\t_objAnimateData.arrAnimations[0].value = Math.abs(_objAnimateData.arrAnimations[0].value);\n\t\t\t_objAnimateData.arrAnimations[1].value = Math.abs(_objAnimateData.arrAnimations[1].value);\n\t\t\treturn _objAnimateData;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn _objAnimateData;\n\t\t}\n\t},\n\n\t// May be called externally via Move.js or Animate.js as this. object is passed through to these.\n\t_moveEndFunction : function (_objAnimateData)\n\t{\n\t\tif (_objAnimateData.strOnComplete)\n\t\t{\n\t\t\tvar _objOptions = {strWhatSubScreenElementID : _objAnimateData.domCurrentElement.id, _arrAnimations : _objAnimateData.arrAnimations};\n\t\t\tif (_objAnimateData.objOptionalCallbackData != null)\n\t\t\t{\n\t\t\t\t_objOptions.objOptionalCallbackData = _objAnimateData.objOptionalCallbackData;\n\t\t\t}\n\t\t\tEM.trigger(_objAnimateData.strOnComplete, _objOptions);\n\t\t}\n\t\telse if (_objAnimateData.objOnComplete)\n\t\t{\n\t\t\t_objAnimateData.objOnComplete();\n\t\t}\n\t},\n\n\t/*********** ANIMATOR METHODS ************/\n\t_preprocessAnimator : function (_objAnimateData)\n\t{\n\n\t\tif (_objAnimateData.strOnComplete)\n\t\t{\n\t\t\tvar _objOptions = {strWhatSubScreenElementID : _objAnimateData.domCurrentElement.id, _arrAnimations : _objAnimateData.arrAnimations};\n\t\t\tif (_objAnimateData.objOptionalCallbackData != null)\n\t\t\t{\n\t\t\t\t_objOptions.objOptionalCallbackData = _objAnimateData.objOptionalCallbackData;\n\t\t\t}\n\t\t\tvar funOnComplete = function (){ EM.trigger(_objAnimateData.strOnComplete, _objOptions)};\n\t\t}\n\t\telse if (_objAnimateData.objOnComplete)\n\t\t{\n\t\t\tvar funOnComplete = _objAnimateData.objOnComplete;\n\t\t}\n\n\t\t// REFACTOR NOTE: change to switch case with error if type doesn't exist\n\t\tif (_objAnimateData.strTransition == 'bounce')\n\t\t{\n\t\t\t_objAnimateData.objAnimatorTransition = {transition: Animator.makeBounce(0.75),duration: _objAnimateData.intAnimateDuration, onComplete : function (){funOnComplete()} };\n\t\t}\n\t\telse if (_objAnimateData.strTransition == 'elastic')\n\t\t{\n\t\t\t_objAnimateData.objAnimatorTransition = {transition: Animator.makeElastic(0.75),duration: _objAnimateData.intAnimateDuration, onComplete : function (){funOnComplete()} };\n\t\t}\n\t\telse if (_objAnimateData.strTransition == 'easeIn')\n\t\t{\n\t\t\t_objAnimateData.objAnimatorTransition = {transition: Animator.makeEaseIn(0.75),duration: _objAnimateData.intAnimateDuration, onComplete : function (){funOnComplete()} };\n\t\t}\n\t\telse if (_objAnimateData.strTransition == 'easeInOut')\n\t\t{\n\t\t\t_objAnimateData.objAnimatorTransition = {transition: Animator.makeEaseOut(0.75),duration: _objAnimateData.intAnimateDuration, onComplete : function (){funOnComplete()} };\n\t\t}\n\n\t\tif (this._objHashtableAnimations[_objAnimateData.domCurrentElement.id])\n\t\t{\n\t\t\tthis._stopAnimator(_objAnimateData.domCurrentElement.id);\n\t\t\tdelete this._objHashtableAnimations[_objAnimateData.domCurrentElement.id];\n\t\t}\n\n\t\tthis._performAnimatorAnimation(_objAnimateData);\n\t},\n\n\t_performAnimatorAnimation : function (_objAnimateData)\n\t{\n\t\tthis._objHashtableAnimations[_objAnimateData.domCurrentElement.id] = new Animator(_objAnimateData.objAnimatorTransition);\n\t\tvar objAnimator = this._objHashtableAnimations[_objAnimateData.domCurrentElement.id];\n\t\tvar objNumericalStyle = new NumericalStyleSubject(\n\t\t\t\t\t_objAnimateData.domCurrentElement.id,\n\t\t\t\t\t_objAnimateData.arrAnimations[0].style,\n\t\t\t\t\t_objAnimateData.arrAnimations[0].value + \"px\",\n\t\t\t\t\t_objAnimateData.arrAnimations[1].value + \"px\");\n\n\t\t/* REFACTOR NOTE: This only allows for values to move one axis and with numbers.\n\t\t* Need to add transition control (another new()) object\n\t\t*/\n\t\tif (_objAnimateData.strType == 'play()')\n\t\t{\n\t\t\tobjAnimator.addSubject(objNumericalStyle).play();\n\t\t}\n\t\telse if (_objAnimateData.strType == 'reverse()')\n\t\t{\n\t\t\tobjAnimator.addSubject(objNumericalStyle).reverse();\n\t\t}\n\t\telse if (_objAnimateData.strType == 'seekTo(1)')\n\t\t{\n\t\t\tobjAnimator.addSubject(objNumericalStyle).seekTo(1);\n\t\t}\n\t\telse if (_objAnimateData.strType == 'seekTo(0)')\n\t\t{\n\t\t\tobjAnimator.addSubject(objNumericalStyle).seekFromTo(1,0);\n\t\t}\n\t},\n\n\t_stopAnimator : function (domCurrentElementId)\n\t{\n\t\tthis._objHashtableAnimations[domCurrentElementId].stop();\n\t},\n\n\t/**\n\t * Currently just testing if in Smartphone or Tablet version\n\t */\n\t_isCSSCapable : function ()\n\t{\n\t\t// If this._booCSSCapable has already been set, there's no point in checking again.\n\t\tif (this.booCSSCapable == null)\n\t\t{\n\t\t\tif ((OUTPUT_MODE_CHECKER.strCurrentMode == 'smartphoneC' || OUTPUT_MODE_CHECKER.strCurrentMode == 'tabletC')\n\t\t\t    && (OUTPUT_MODE_CHECKER.booIsIE() == false))\n\t\t\t{\n\t\t\t\tthis.booCSSCapable = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthis.booCSSCapable = false;\n\t\t\t}\n\t\t}\n\t\treturn this.booCSSCapable;\n\t}\n}\nEM.register(ANIMATOR_INTERFACE);\n"},function(t,n,e){e(0)(e(17))},function(t,n){t.exports='/* globals OUTPUT_MODE_CHECKER, $, EM */\n/* eslint new-cap: 0 */\n\n/**\n * @title Animator Interface\n * @description animator_interface is used to add a layer between animation calls and animation APIs\n *  Currently Animtor_interface uses animator.js or move.js depending on the devices CSS\n *  capabilities.\n *\n * @author JamesH\n * @version 1.0 10-12-12\n * @version 2.0 20-12-12 - James Hough - Refresh CSS \'if statement\' added to _preprocessMove for off\n * screen elements not rendering when animated on screen.\n * @REFACTOR NOTE: Genricise animate_interface to work with all animation types and directions\n * through move and animate.\n * @REFACTOR NOTE: JC Could do to break aaprt functions, some are getting rather long!\n */\n\nvar ANIMATOR_INTERFACE_2 = {\n  // _whatScreenElement can be dom or id\n  assignRegisteredAnimation: function(_whatScreenElement, _strAnimation, _objAnimationOptions) {\n    if (OUTPUT_MODE_CHECKER.booIsIE8() || OUTPUT_MODE_CHECKER.booIE8CompatibilityMode()) {\n      // Check for IE8 version\n      if ($.Velocity.Sequences[_strAnimation + \'IE8\']) {\n        _strAnimation = _strAnimation + \'IE8\';\n      }\n    }\n\n    var intDelay = null;\n    var intDuration = null;\n    var funComplete = null;\n\n    if (_objAnimationOptions) {\n      // Validate animation delay\n      if (_objAnimationOptions.delay) {\n        if (_objAnimationOptions.delay > 0 && _objAnimationOptions.delay < 201) {\n          _objAnimationOptions.delay = _objAnimationOptions.delay * 1000;\n        }\n        intDelay = _objAnimationOptions.delay;\n      }\n      // Validate animation duration!\n      if (_objAnimationOptions.duration) {\n        if (_objAnimationOptions.duration > 0 && _objAnimationOptions.duration < 201) {\n          _objAnimationOptions.duration = _objAnimationOptions.duration * 1000;\n        }\n        intDuration = _objAnimationOptions.duration;\n      }\n      // Animation complete method!\n      if (_objAnimationOptions.complete) {\n        funComplete = _objAnimationOptions.complete;\n      }\n    }\n\n    intDelay = intDelay == null ? 0 : intDelay;\n    intDuration = intDuration == null ? 100 : intDuration;\n    $(_whatScreenElement).velocity(_strAnimation, {\n      delay: intDelay,\n      duration: intDuration,\n      complete: funComplete\n    });\n  },\n\n  // ----------- START Gomo Custom Animations -----------------\n  // _whatScreenElement can be dom or id\n  applyOpacityToElement: function(_whatScreenElement, _objAnimationOptions) {\n    var intOpacity = 0;\n    var intDelay = 0;\n    var intDuration = 0;\n    var funComplete = null;\n\n    if (_objAnimationOptions) {\n      if (_objAnimationOptions.opacity) {\n        intOpacity = _objAnimationOptions.opacity;\n      }\n      if (_objAnimationOptions.delay) {\n        intDelay = _objAnimationOptions.delay;\n      }\n      if (_objAnimationOptions.duration) {\n        intDuration = _objAnimationOptions.duration;\n      }\n      if (_objAnimationOptions.complete) {\n        funComplete = _objAnimationOptions.complete;\n      }\n    }\n\n    $(_whatScreenElement).velocity(\n      {\n        opacity: intOpacity\n      },\n      {\n        delay: intDelay,\n        duration: intDuration,\n        complete: funComplete\n      }\n    );\n  },\n\n  animateHorizontalSide: function(_whatScreenElement, _objAnimationOptions) {\n    var intStartPoint = 0;\n    var intEndPoint = 0;\n    var intDelay = 0;\n    var intDuration = 0;\n    var funComplete = null;\n\n    if (_objAnimationOptions) {\n      if (_objAnimationOptions.startPoint) {\n        intStartPoint = _objAnimationOptions.startPoint;\n      }\n      if (_objAnimationOptions.endPoint) {\n        intEndPoint = _objAnimationOptions.endPoint;\n      }\n      if (_objAnimationOptions.delay) {\n        intDelay = _objAnimationOptions.delay;\n      }\n      if (_objAnimationOptions.duration) {\n        intDuration = _objAnimationOptions.duration;\n      }\n      if (_objAnimationOptions.complete) {\n        funComplete = _objAnimationOptions.complete;\n      }\n    }\n\n    $(_whatScreenElement).velocity(\n      {\n        translateY: 0\n      },\n      {\n        delay: 0,\n        duration: 0\n      }\n    );\n    $(_whatScreenElement).velocity(\n      {\n        translateX: [intEndPoint, intStartPoint]\n      },\n      {\n        delay: intDelay,\n        duration: intDuration,\n        complete: funComplete\n      }\n    );\n  },\n\n  addVerticalSlideCss: function(domElement) {\n    $(domElement).css({\n      \'height\': \'100vh\',\n      \'overflow-y\': \'hidden\'\n    });\n    if (!$(\'#contentWrapperL\').hasClass(\'continousScrolling\')) {\n      $(\'#contentWrapperL\').css({\'overflow-y\': \'hidden\'});\n    }\n  },\n\n  removeVerticalSlideCss: function(domElement) {\n    $(domElement).css({\n      \'height\': \'\',\n      \'overflow-y\': \'\'\n    });\n    // Auto offers fallback for older browser that don\'t support overlay\n    if (!$(\'#contentWrapperL\').hasClass(\'continousScrolling\')) {\n      $(\'#contentWrapperL\').css({\'overflow-y\': \'auto\'});\n      $(\'#contentWrapperL\').css({\'overflow-y\': \'overlay\'});\n    }\n  },\n\n  // ----------- END Gomo Custom Animations -----------------\n\n  setAnimationRegisters: function() {\n    var _screenWidth = $(window).width();\n    var _screenHeight = $(window).height();\n    var popupYpos = _screenHeight;\n\n    // For devices that can change orientation always use the largest dimension to avoid popups\n    // remaining on screen after orientation changes from landscape to portrait.\n    if (!gomo.outputChecker.isDesktop()) {\n      popupYpos = _screenWidth > _screenHeight ? _screenWidth : _screenHeight;\n    }\n\n    // gomo Core animations\n    $.Velocity.RegisterUI(\'gomo.horizontalSlideShowNormal\', {\n      defaultDuration: 800,\n      calls: [[{translateX: [0, _screenWidth], translateY: 0, translateZ: 0}]]\n    });\n    $.Velocity.RegisterUI(\'gomo.horizontalSlideHideNormal\', {\n      defaultDuration: 800,\n      calls: [[{translateX: [-_screenWidth, 0], translateY: 0, translateZ: 0}]]\n    });\n    $.Velocity.RegisterUI(\'gomo.horizontalSlideShowReverse\', {\n      defaultDuration: 800,\n      calls: [[{translateX: [0, -_screenWidth], translateY: 0, translateZ: 0}]]\n    });\n    $.Velocity.RegisterUI(\'gomo.horizontalSlideHideReverse\', {\n      defaultDuration: 800,\n      calls: [[{translateX: [_screenWidth, 0], translateY: 0, translateZ: 0}]]\n    });\n\n    $.Velocity.RegisterUI(\'gomo.verticalSlideShowNormal\', {\n      defaultDuration: 800,\n      calls: [[{translateY: [0, _screenHeight], translateX: 0, translateZ: 0}]]\n    });\n    $.Velocity.RegisterUI(\'gomo.verticalSlideShowReverse\', {\n      defaultDuration: 800,\n      calls: [[{translateY: [0, -_screenHeight], translateX: 0, translateZ: 0}]]\n    });\n    $.Velocity.RegisterUI(\'gomo.verticalSlideHideNormal\', {\n      defaultDuration: 800,\n      calls: [[{translateY: [-_screenHeight, 0], translateX: 0, translateZ: 0}]]\n    });\n    $.Velocity.RegisterUI(\'gomo.verticalSlideHideReverse\', {\n      defaultDuration: 800,\n      calls: [[{translateY: [_screenHeight, 0], translateX: 0, translateZ: 0}]]\n    });\n\n    $.Velocity.RegisterUI(\'gomo.verticalPopupSlideShowNormal\', {\n      defaultDuration: 800,\n      calls: [[{opacity: [1, 0], translateY: [0, popupYpos], translateX: 0, translateZ: 0}]]\n    });\n    $.Velocity.RegisterUI(\'gomo.verticalPopupSlideShowReverse\', {\n      defaultDuration: 800,\n      calls: [[{opacity: [1, 0], translateY: [0, -popupYpos], translateX: 0, translateZ: 0}]]\n    });\n    $.Velocity.RegisterUI(\'gomo.verticalPopupSlideHideNormal\', {\n      defaultDuration: 800,\n      calls: [[{translateY: [-popupYpos, 0], translateX: 0, translateZ: 0}]]\n    });\n    $.Velocity.RegisterUI(\'gomo.verticalPopupSlideHideReverse\', {\n      defaultDuration: 800,\n      calls: [[{translateY: [popupYpos, 0], translateX: 0, translateZ: 0}]]\n    });\n\n    // IE8 gomo Core animations\n    $.Velocity.RegisterUI(\'gomo.horizontalSlideShowNormalIE8\', {\n      defaultDuration: 800,\n      calls: [[{opacity: [1, 0], left: [0, _screenWidth]}]]\n    });\n    $.Velocity.RegisterUI(\'gomo.horizontalSlideShowReverseIE8\', {\n      defaultDuration: 800,\n      calls: [[{opacity: [1, 0], left: [0, -_screenWidth]}]]\n    });\n    $.Velocity.RegisterUI(\'gomo.horizontalSlideHideNormalIE8\', {\n      defaultDuration: 800,\n      calls: [[{left: [-_screenWidth, 0]}]]\n    });\n    $.Velocity.RegisterUI(\'gomo.horizontalSlideHideReverseIE8\', {\n      defaultDuration: 800,\n      calls: [[{left: [_screenWidth, 0]}]]\n    });\n\n    $.Velocity.RegisterUI(\'gomo.verticalSlideShowNormalIE8\', {\n      defaultDuration: 800,\n      calls: [[{opacity: [1, 0], top: [0, _screenHeight]}]]\n    });\n    $.Velocity.RegisterUI(\'gomo.verticalSlideShowReverseIE8\', {\n      defaultDuration: 800,\n      calls: [[{opacity: [1, 0], top: [0, -_screenHeight]}]]\n    });\n    $.Velocity.RegisterUI(\'gomo.verticalSlideHideNormalIE8\', {\n      defaultDuration: 800,\n      calls: [[{top: [-_screenHeight, 0]}]]\n    });\n    $.Velocity.RegisterUI(\'gomo.verticalSlideHideReverseIE8\', {\n      defaultDuration: 800,\n      calls: [[{top: [_screenHeight, 0]}]]\n    });\n\n    // overriden with opacity\n    $.Velocity.RegisterUI(\'callout.bounce\', {\n      defaultDuration: 550,\n      calls: [\n        [{opacity: [1, 0]}],\n        [{translateY: -30}, 0.25],\n        [{translateY: 0}, 0.125],\n        [{translateY: -15}, 0.125],\n        [{translateY: 0}, 0.25]\n      ]\n    });\n    // overriden with opacity\n    $.Velocity.RegisterUI(\'callout.shake\', {\n      defaultDuration: 800,\n      calls: [\n        [{opacity: [1, 0]}],\n        [{translateX: -11}, 0.125],\n        [{translateX: 11}, 0.125],\n        [{translateX: -11}, 0.125],\n        [{translateX: 11}, 0.125],\n        [{translateX: -11}, 0.125],\n        [{translateX: 11}, 0.125],\n        [{translateX: -11}, 0.125],\n        [{translateX: 0}, 0.125]\n      ]\n    });\n    /* Animate.css\n            "callout.flash": {\n                defaultDuration: 1100,\n                calls: [\n                    [ { opacity: [ 0, "easeInOutQuad", 1 ] }, 0.25 ],\n                    [ { opacity: [ 1, "easeInOutQuad" ] }, 0.25 ],\n                    [ { opacity: [ 0, "easeInOutQuad" ] }, 0.25 ],\n                    [ { opacity: [ 1, "easeInOutQuad" ] }, 0.25 ]\n                ]\n            },*/\n\n    // overriden with opacity\n    $.Velocity.RegisterUI(\'callout.pulse\', {\n      defaultDuration: 825,\n      calls: [[{opacity: [1, 0]}], [{scaleX: 1.1}, 0.5], [{scaleX: 1}, 0.5]]\n    });\n\n    // overriden with opacity\n    $.Velocity.RegisterUI(\'callout.swing\', {\n      defaultDuration: 950,\n      calls: [\n        [{opacity: [1, 0]}],\n        [{rotateZ: 15}, 0.2],\n        [{rotateZ: -10}, 0.2],\n        [{rotateZ: 5}, 0.2],\n        [{rotateZ: -5}, 0.2],\n        [{rotateZ: 0}, 0.2]\n      ]\n    });\n\n    // overriden with opacity\n    $.Velocity.RegisterUI(\'callout.tada\', {\n      defaultDuration: 1000,\n      calls: [\n        [{opacity: [1, 0]}],\n        [{scaleX: 0.9, scaleY: 0.9, rotateZ: -3}, 0.1],\n        [{scaleX: 1.1, scaleY: 1.1, rotateZ: 3}, 0.1],\n        [{scaleX: 1.1, scaleY: 1.1, rotateZ: -3}, 0.1],\n        [\'reverse\', 0.125],\n        [\'reverse\', 0.125],\n        [\'reverse\', 0.125],\n        [\'reverse\', 0.125],\n        [\'reverse\', 0.125],\n        [{scaleX: 1, scaleY: 1, rotateZ: 0}, 0.2]\n      ]\n    });\n\n    // Built in velocity animations which we don\'t use but could be in future.\n    // "transition.fadeIn": {\n    //     defaultDuration: 500,\n    //     calls: [\n    //         [ { opacity: [ 1, 0 ] } ]\n    //     ]\n    // },\n    // /* Support: Loses rotation in IE9/Android 2.3 (fades only). */\n    // "transition.flipXIn": {\n    //     defaultDuration: 700,\n    //     calls: [\n    //         [ {\n    //           opacity: [ 1, 0 ],\n    //           transformPerspective: [ 800, 800 ],\n    //           rotateY: [ 0, -55 ]\n    //         } ]\n    //     ],\n    //     reset: { transformPerspective: 0 }\n    // },\n    // /* Support: Loses rotation in IE9/Android 2.3 (fades only). */\n    // "transition.flipYIn": {\n    //     defaultDuration: 800,\n    //     calls: [\n    //         [ {\n    //           opacity: [ 1, 0 ], transformPerspective: [ 800, 800 ], rotateX: [ 0, -45 ]\n    //         } ]\n    //     ],\n    //     reset: { transformPerspective: 0 }\n    // },\n    // /* Animate.css */\n    // /* Support: Loses rotation in IE9/Android 2.3 (fades only). */\n    // "transition.flipBounceXIn": {\n    //     defaultDuration: 900,\n    //     calls: [\n    //         [ {\n    //           opacity: [ 0.725, 0 ],\n    //           transformPerspective: [ 400, 400 ],\n    //           rotateY: [ -10, 90 ]\n    //         }, 0.50 ],\n    //         [ { opacity: 0.80, rotateY: 10 }, 0.25 ],\n    //         [ { opacity: 1, rotateY: 0 }, 0.25 ]\n    //     ],\n    //     reset: { transformPerspective: 0 }\n    // },\n    // /* Animate.css */\n    // /* Support: Loses rotation in IE9/Android 2.3 (fades only).*/\n    // "transition.flipBounceYIn": {\n    //     defaultDuration: 850,\n    //     calls: [\n    //         [ {\n    //           opacity: [ 0.725, 0 ],\n    //           transformPerspective: [ 400, 400 ],\n    //           rotateX: [ -10, 90 ]\n    //         }, 0.50 ],\n    //         [ { opacity: 0.80, rotateX: 10 }, 0.25 ],\n    //         [ { opacity: 1, rotateX: 0 }, 0.25 ]\n    //     ],\n    //     reset: { transformPerspective: 0 }\n    // },\n    // /* Magic.css */\n    // "transition.swoopIn": {\n    //     defaultDuration: 850,\n    //     calls: [\n    //         [ { opacity: [ 1, 0 ], transformOriginX: [ "100%", "50%" ],\n    //            transformOriginY: [ "100%", "100%" ], scaleX: [ 1, 0 ],\n    //            scaleY: [ 1, 0 ], translateX: [ 0, -700 ], translateZ: 0\n  //            } ]\n    //     ],\n    //     reset: { transformOriginX: "50%", transformOriginY: "50%" }\n    // },\n    // /* Magic.css */\n    // /* Support: Loses rotation in IE9/Android 2.3. (Fades and scales only.) */\n    // "transition.whirlIn": {\n    //     defaultDuration: 900,\n    //     calls: [\n    //         [ { opacity: [ 1, 0 ], transformOriginX: [ "50%", "50%" ],\n  //              transformOriginY: [ "50%", "50%" ], scaleX: [ 1, 0 ],\n  //              scaleY: [ 1, 0 ], rotateY: [ 0, 160 ]\n  //              } ]\n    //     ]\n    // },\n\n    // "transition.shrinkIn": {\n    //     defaultDuration: 700,\n    //     calls: [\n    //         [ { opacity: [ 1, 0 ], transformOriginX: [ "50%", "50%" ],\n    //            transformOriginY: [ "50%", "50%" ], scaleX: [ 1, 1.5 ],\n    //            scaleY: [ 1, 1.5 ], translateZ: 0\n    //          } ]\n    //     ]\n    // },\n\n    // "transition.expandIn": {\n    //     defaultDuration: 700,\n    //     calls: [\n    //         [ { opacity: [ 1, 0 ], transformOriginX: [ "50%", "50%" ],\n    //            transformOriginY: [ "50%", "50%" ],\n    //            scaleX: [ 1, 0.625 ],\n    //            scaleY: [ 1, 0.625 ],\n    //            translateZ: 0\n    //          } ]\n    //     ]\n    // },\n    // /* Animate.css */\n    // "transition.bounceIn": {\n    //     defaultDuration: 800,\n    //     calls: [\n    //         [ { opacity: [ 1, 0 ], scaleX: [ 1.05, 0.3 ], scaleY: [ 1.05, 0.3 ] }, 0.40 ],\n    //         [ { scaleX: 0.9, scaleY: 0.9, translateZ: 0 }, 0.20 ],\n    //         [ { scaleX: 1, scaleY: 1 }, 0.50 ]\n    //     ]\n    // },\n    // /* Animate.css */\n    // "transition.bounceUpIn": {\n    //     defaultDuration: 800,\n    //     calls: [\n    //         [ {\n    //          opacity: [ 1, 0 ],\n    //          translateY: [ -30, 1000 ] },\n    //          0.60, { easing: "easeOutCirc" }\n    //          }],\n    //         [ { translateY: 10 }, 0.20 ],\n    //         [ { translateY: 0 }, 0.20 ]\n    //     ]\n    // },\n    // /* Animate.css */\n    // "transition.bounceDownIn": {\n    //     defaultDuration: 800,\n    //     calls: [\n    //         [ {\n    //           opacity: [ 1, 0 ],\n    //           translateY: [ 30, -1000 ] },\n    //           0.60, { easing: "easeOutCirc" }\n    //          } ],\n    //         [ { translateY: -10 }, 0.20 ],\n    //         [ { translateY: 0 }, 0.20 ]\n    //     ]\n    // },\n    // /* Animate.css */\n    // "transition.bounceLeftIn": {\n    //     defaultDuration: 750,\n    //     calls: [\n    //         [ {\n    //            opacity: [ 1, 0 ],\n    //            translateX: [ 30, -1250 ] },\n    //            0.60, { easing: "easeOutCirc" }\n  //            }],\n    //         [ { translateX: -10 }, 0.20 ],\n    //         [ { translateX: 0 }, 0.20 ]\n    //     ]\n    // },\n    // /* Animate.css */\n    // "transition.bounceRightIn": {\n    //     defaultDuration: 750,\n    //     calls: [\n    //         [ {\n    //            opacity: [ 1, 0 ],\n    //            translateX: [ -30, 1250 ] },\n    //            0.60, { easing: "easeOutCirc" }\n  //            } ],\n    //         [ { translateX: 10 }, 0.20 ],\n    //         [ { translateX: 0 }, 0.20 ]\n    //     ]\n    // },\n\n    // "transition.slideUpIn": {\n    //     defaultDuration: 900,\n    //     calls: [\n    //         [ { opacity: [ 1, 0 ], translateY: [ 0, 20 ], translateZ: 0 } ]\n    //     ]\n    // },\n    // "transition.slideDownIn": {\n    //     defaultDuration: 900,\n    //     calls: [\n    //         [ { opacity: [ 1, 0 ], translateY: [ 0, -20 ], translateZ: 0 } ]\n    //     ]\n    // },\n    // "transition.slideLeftIn": {\n    //     defaultDuration: 1000,\n    //     calls: [\n    //         [ { opacity: [ 1, 0 ], translateX: [ 0, -20 ], translateZ: 0 } ]\n    //     ]\n    // },\n    // "transition.slideRightIn": {\n    //     defaultDuration: 1000,\n    //     calls: [\n    //         [ { opacity: [ 1, 0 ], translateX: [ 0, 20 ], translateZ: 0 } ]\n    //     ]\n    // },\n    // "transition.slideUpBigIn": {\n    //     defaultDuration: 850,\n    //     calls: [\n    //         [ { opacity: [ 1, 0 ], translateY: [ 0, 75 ], translateZ: 0 } ]\n    //     ]\n    // },\n    // "transition.slideDownBigIn": {\n    //     defaultDuration: 850,\n    //     calls: [\n    //         [ { opacity: [ 1, 0 ], translateY: [ 0, -75 ], translateZ: 0 } ]\n    //     ]\n    // },\n    // "transition.slideLeftBigIn": {\n    //     defaultDuration: 800,\n    //     calls: [\n    //         [ { opacity: [ 1, 0 ], translateX: [ 0, -75 ], translateZ: 0 } ]\n    //     ]\n    // },\n    // "transition.slideRightBigIn": {\n    //     defaultDuration: 800,\n    //     calls: [\n    //         [ { opacity: [ 1, 0 ], translateX: [ 0, 75 ], translateZ: 0 } ]\n    //     ]\n    // },\n    // /* Magic.css */\n    // "transition.perspectiveUpIn": {\n    //     defaultDuration: 800,\n    //     calls: [\n    //         [ {\n    //            opacity: [ 1, 0 ],\n    //            transformPerspective: [ 800, 800 ],\n    //            transformOriginX: [ 0, 0 ],\n    //            transformOriginY: [ "100%", "100%" ],\n    //            rotateX: [ 0, -180 ]\n  //            } ]\n    //     ],\n    //     reset: { transformPerspective: 0, transformOriginX: "50%", transformOriginY: "50%" }\n    // },\n    // /* Magic.css */\n    // /* Support: Loses rotation in IE9/Android 2.3 (fades only). */\n    // "transition.perspectiveDownIn": {\n    //     defaultDuration: 800,\n    //     calls: [\n    //         [ {\n    //            opacity: [ 1, 0 ],\n    //            transformPerspective: [ 800, 800 ],\n    //            transformOriginX: [ 0, 0 ],\n    //            transformOriginY: [ 0, 0 ],\n    //            rotateX: [ 0, 180 ]\n  //            } ]\n    //     ],\n    //     reset: { transformPerspective: 0, transformOriginX: "50%", transformOriginY: "50%" }\n    // },\n    // /* Magic.css */\n    // /* Support: Loses rotation in IE9/Android 2.3 (fades only). */\n    // "transition.perspectiveLeftIn": {\n    //     defaultDuration: 950,\n    //     calls: [\n    //         [ {\n    //            opacity: [ 1, 0 ],\n    //            transformPerspective: [ 2000, 2000 ],\n    //            transformOriginX: [ 0, 0 ],\n    //            transformOriginY: [ 0, 0 ],\n    //            rotateY: [ 0, -180 ]\n  //            } ]\n    //     ],\n    //     reset: { transformPerspective: 0, transformOriginX: "50%", transformOriginY: "50%" }\n    // },\n    // /* Magic.css */\n    // /* Support: Loses rotation in IE9/Android 2.3 (fades only). */\n    // "transition.perspectiveRightIn": {\n    //     defaultDuration: 950,\n    //     calls: [\n    //         [ {\n    //            opacity: [ 1, 0 ],\n    //            transformPerspective: [ 2000, 2000 ],\n    //            transformOriginX: [ "100%", "100%" ],\n    //            transformOriginY: [ 0, 0 ],\n    //            rotateY: [ 0, 180 ]\n  //              } ]\n    //     ],\n    //     reset: { transformPerspective: 0, transformOriginX: "50%", transformOriginY: "50%" }\n    // },\n  }\n};\nEM.register(ANIMATOR_INTERFACE_2);\n'},function(t,n,e){e(0)(e(19))},function(t,n){t.exports="/* globals CORE, DEBUG, EM, INTERACTIVE_BLANKER, $, POPUP_MANANGER, SUB_SCREEN_INTERACTIONS */\n/**\n * @title The blanking layer object\n * @description This object shows and hides the blanking layer upon request.\n *\n * @author JohnC\n * @version 2.0 01/12/10\n */\n\nvar BLANKER = {\n  strObjID: 'The blanking layer object',\n\n  _objBlankLayer: null,\n  _objCurrDOM: null,\n\n  _strBlankingLayerClassKey: 'blankingLayerC',\n\n  handleEvent_primeDOMReferences: function(_objWhatDOM) {\n    if (!this._objCurrDOM) {\n      this._objCurrDOM = _objWhatDOM;\n    }\n  },\n\n  handleEvent_toggleBlanking: function(_objParams) {\n    if (_objParams['objWhatDOM']) {\n      this._objBlankLayer = CORE.getElementsByClassName(\n        _objParams['objWhatDOM'],\n        this._strBlankingLayerClassKey\n      )[0];\n    } else {\n      this._objBlankLayer = CORE.getElementsByClassName(\n        this._objCurrDOM,\n        this._strBlankingLayerClassKey\n      )[0];\n    }\n\n    var strState = _objParams['strState'];\n    var _intNewZIndex = false;\n\n    if (_objParams['intNewZIndex']) {\n      _intNewZIndex = _objParams['intNewZIndex'];\n    }\n\n    if (this._objBlankLayer) {\n      // Hide blanking layer\n      if (strState == 'OFF') {\n        if (this._objBlankLayer.intOldZIndex) {\n          this._objBlankLayer.style.zIndex = this._objBlankLayer.intOldZIndex;\n        }\n        this._objBlankLayer.className = this._objBlankLayer.className.replace(\n          'blankOnC',\n          'blankOffC'\n        );\n        if (typeof INTERACTIVE_BLANKER !== 'undefined' && INTERACTIVE_BLANKER) {\n          // Remove any click events on the blanking layer and remove the styling.\n          $(this._objBlankLayer).off('click');\n          $('html').removeClass('interactiveBlanker');\n        }\n      } else {\n        // Show blanking layer\n        if (_intNewZIndex) {\n          this._objBlankLayer.intOldZIndex = this._objBlankLayer.style.zIndex;\n          this._objBlankLayer.style.zIndex = _intNewZIndex;\n        }\n        this._objBlankLayer.className = this._objBlankLayer.className.replace(\n          'blankOffC',\n          'blankOnC'\n        );\n        // If we want to close modals with a click on the blanking layer, add a click\n        // event to the blanking layer to close all subscreens and popups\n        if (typeof INTERACTIVE_BLANKER !== 'undefined' && INTERACTIVE_BLANKER) {\n          // Add class to help blanker styling.\n          $('html').addClass('interactiveBlanker');\n          // Add event listener to the blanking layer\n          $(this._objBlankLayer)\n            .on('click', function() {\n              // Check for any animating subscreens and do not close/hide all popups/subscreens\n              // if there are.\n              if (!SUB_SCREEN_INTERACTIONS.isSubscreenAnimating()) {\n                POPUP_MANANGER.closeAllPopups();\n                SUB_SCREEN_INTERACTIONS.hideSubScreens(true);\n              }\n            });\n        }\n      }\n    } else {\n      console.log('BLANKER_LAYER_MISSING_ERROR');\n    }\n  },\n\n  debug: function(strMessage, intPriority, objCallerObject, booCalleeChain) {\n    if (DEBUG) {\n      DEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n    }\n  }\n};\n\nEM.register(BLANKER);\n"},function(t,n,e){e(0)(e(21))},function(t,n){t.exports="/* global EM, OUTPUT_MODE_CHECKER, SCROLLING_MANAGER, CORE, LOCALISER, IScroll */\n/* global $, BOO_DYNAMIC_CONTINUOUS_SCROLLING, SCREEN_INTERACTIONS */\n/**\n * @title    iScroll Interface\n * @description  This object will add the iScroll component to DOM objects where required.\n *                Objects should have the attribute rel='checkScrolling' added to them in\n *                order to be detected.\n *\n * @author    Chris Tebbit\n * @version    1.0 12/07/11\n * @version    2.0 14/05/12 - JC: Reworked to remove the existing scrolling code in favour\n *             of iScroll and to act as a generic interface for tracking and destroying iScrolls.\n */\n\nvar ISCROLL_INTERFACE = {\n  strObjID: 'Overflow Scroll',\n  strObjDescription: 'Adds scroll buttons to DOM objects where overflow is accessed via scrolling.',\n\n  _objCurrDOM: null,\n\n  _objIScrollReferences: {},\n\n  _strPendingID: '',\n  _arrPendingDOMObjectsToInspect: [],\n  _objTimeoutRef: null,\n\n  _booDebug: false,\n\n  handleEvent_primeDOMReferences: function(_objWhatContentDOM) {\n    this._objCurrDOM = _objWhatContentDOM;\n  },\n\n  handleEvent_screenSizeChanged: function() {\n    /** This might be the only way to force iscroll on desktop small/medium mode,\n     * but it will kill off other iscroll within the document (could set to screen dom level).\n     * this.parseChildDOMElements(document, false, false);\n     */\n  },\n\n  handleEvent_imageLoadCompleted: function() {\n    this.refreshIScrolls();\n  },\n\n  handleEvent_disableParentIScrollInstaces: function() {\n    for (var _strKeyID in this._objIScrollReferences) {\n      if (this._objIScrollReferences.hasOwnProperty(_strKeyID)) {\n        var _objCurrIScrollInstance = this._objIScrollReferences[_strKeyID];\n        var _booIsChildIscroll = _objCurrIScrollInstance.options.booIsChildIscroll;\n        if (!_booIsChildIscroll) {\n          _objCurrIScrollInstance.disable();\n        }\n      }\n    }\n  },\n\n  handleEvent_enableParentIScrollInstaces: function() {\n    for (var _strKeyID in this._objIScrollReferences) {\n      if (this._objIScrollReferences.hasOwnProperty(_strKeyID)) {\n        var _objCurrIScrollInstance = this._objIScrollReferences[_strKeyID];\n        var _booIsChildIscroll = _objCurrIScrollInstance.options.booIsChildIscroll;\n        if (!_booIsChildIscroll) {\n          _objCurrIScrollInstance.enable();\n        }\n      }\n    }\n  },\n\n  parseForContinuousScrollContentWrapper: function() {\n    // Blackberry's wouldn't cope with the iScroll so they get long scrolling\n    // pages, other modes should use the native scrollbar.\n    if (!OUTPUT_MODE_CHECKER.applyScrolling()) {\n      return;\n    }\n\n    // If we're in BOO_DYNAMIC_CONTINUOUS_SCROLLING mode then we need to use\n    // a hardcoded element to scroll\n    window.setTimeout(function() {\n      var contentWrapper = $('#contentWrapperL')[0];\n      ISCROLL_INTERFACE._applyIscroll(contentWrapper, false, true, false, false);\n    }, 0);\n  },\n\n  // Adds the elements to a queue array to be applied after a timeout to allow the DOM to catch up.\n  parseChildDOMElements: function(\n    _domWhatElement,\n    _booIsChildIScroll,\n    _objSurpressDirections,\n    _booAddPinchZoom\n  ) {\n    // Blackberry's wouldn't cope with the iScroll so they get long scrolling\n    // pages, other modes should use the native scrollbar.\n    if (!OUTPUT_MODE_CHECKER.applyScrolling()) {\n      return;\n    }\n\n    this._debug('ISCROLL_INTERFACE.parseChildDOMElements()');\n\n    this._arrPendingDOMObjectsToInspect.push({\n      domElement: _domWhatElement,\n      booIsChildIScroll: _booIsChildIScroll,\n      objSurpressDirections: _objSurpressDirections,\n      booAddPinchZoom: _booAddPinchZoom\n    });\n\n    // If there is a timeout set to go on the next 'frame', cancel it so we don't have multiple\n    // timeouts.\n    if (this._objTimeoutRef) {\n      window.clearTimeout(this._objTimeoutRef);\n    }\n\n    window.setTimeout(function() {\n      ISCROLL_INTERFACE._doQueuedParseElements();\n    }, 0);\n  },\n\n  recycleScroller: function(_domWhatElement) {\n    if (_domWhatElement) {\n      // Check that we're looking in the parent element of the one static single ID we\n      // use for continuous scrolling\n      if (typeof BOO_DYNAMIC_CONTINUOUS_SCROLLING !== 'undefined') {\n        if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n          var domScrollingElement = $(_domWhatElement).find('#contentWrapperL')[0];\n          if (domScrollingElement) {\n            this._recycleScroller(domScrollingElement.id);\n          }\n        }\n      }\n\n      // Check for all other instances\n      var _arrHTMLtags = _domWhatElement.getElementsByTagName('*');\n      var count = 0;\n      while (count < _arrHTMLtags.length) {\n        var _domCurrTag = _arrHTMLtags[count];\n        if (\n          _domCurrTag.className &&\n          _domCurrTag.className['indexOf'] &&\n          _domCurrTag.className.indexOf('checkScrollingC') > -1\n        ) {\n          this._recycleScroller(_domCurrTag.id);\n          break;\n        }\n        count++;\n      }\n      _arrHTMLtags = null;\n\n      if (\n        _domWhatElement.className &&\n        _domWhatElement.className['indexOf'] &&\n        _domWhatElement.className.indexOf('checkScrollingC') > -1\n      ) {\n        this._recycleScroller(_domWhatElement.id);\n      }\n    }\n  },\n\n  getCurrScrollPos: function(elementId) {\n    var currScrollPos = {};\n    currScrollPos.x = ISCROLL_INTERFACE._objIScrollReferences[elementId].x;\n    currScrollPos.y = ISCROLL_INTERFACE._objIScrollReferences[elementId].y;\n    return currScrollPos;\n  },\n\n  scrollToPosition: function(elementId, xPosition, yPosition, duration) {\n    if (ISCROLL_INTERFACE._objIScrollReferences[elementId]) {\n      ISCROLL_INTERFACE._objIScrollReferences[elementId].scrollTo(xPosition, yPosition, duration);\n    }\n  },\n\n  disableMomentum: function() {\n    for (var elementIds in this._objIScrollReferences) {\n      if (this._objIScrollReferences.hasOwnProperty(elementIds)) {\n        this._objIScrollReferences[elementIds].options.momentum = false;\n      }\n    }\n  },\n\n  enableMomentum: function() {\n    for (var elementIds in this._objIScrollReferences) {\n      if (this._objIScrollReferences.hasOwnProperty(elementIds)) {\n        this._objIScrollReferences[elementIds].options.momentum = true;\n      }\n    }\n  },\n\n  refreshIScrolls: function() {\n    for (var _strCurrID in ISCROLL_INTERFACE._objIScrollReferences) {\n      if (ISCROLL_INTERFACE._objIScrollReferences.hasOwnProperty(_strCurrID)) {\n        ISCROLL_INTERFACE._objIScrollReferences[_strCurrID].refresh();\n        this._debug('ISCROLL_INTERFACE::refreshIScrolls: ' + _strCurrID);\n      }\n    }\n  },\n\n  disableScroller: function(_domWhatElement) {\n    this._debug(\n      'ISCROLL_INTERFACE.disableScroller(_domWhatElement.id: ' + _domWhatElement.id + ')'\n    );\n    var _arrHTMLtags = _domWhatElement.getElementsByTagName('*');\n\n    var count = 0;\n    while (count < _arrHTMLtags.length) {\n      var _domCurrTag = _arrHTMLtags[count];\n      if (\n        _domCurrTag.className &&\n        _domCurrTag.className['indexOf'] &&\n        _domCurrTag.className.indexOf('checkScrollingC') > -1\n      ) {\n        this._disableScroller(_domCurrTag.id);\n        break;\n      }\n      count++;\n    }\n    _arrHTMLtags = null;\n\n    if (\n      _domWhatElement.className &&\n      _domWhatElement.className['indexOf'] &&\n      _domWhatElement.className.indexOf('checkScrollingC') > -1\n    ) {\n      this._disableScroller(_domWhatElement.id);\n    }\n  },\n\n  enableScroller: function(_domWhatElement) {\n    var _arrHTMLtags = _domWhatElement.getElementsByTagName('*');\n\n    var count = 0;\n    while (count < _arrHTMLtags.length) {\n      var _domCurrTag = _arrHTMLtags[count];\n      if (\n        _domCurrTag.className &&\n        _domCurrTag.className['indexOf'] &&\n        _domCurrTag.className.indexOf('checkScrollingC') > -1\n      ) {\n        this._enableScroller(_domCurrTag.id);\n        break;\n      }\n      count++;\n    }\n    _arrHTMLtags = null;\n\n    if (\n      _domWhatElement.className &&\n      _domWhatElement.className['indexOf'] &&\n      _domWhatElement.className.indexOf('checkScrollingC') > -1\n    ) {\n      this._enableScroller(_domWhatElement.id);\n    }\n  },\n\n  // Called by iScroll on the _start internal method\n  hideScrollMarker: function(_iscrollObject) {\n    var _domOverflowLayer = _iscrollObject.wrapper;\n    var _arrScrollMarkers = CORE.getElementsByClassName(_domOverflowLayer, 'scrollMarkerC');\n    if (_arrScrollMarkers.length > 0) {\n      // On occasions something is passed to this that can't be removed\n      // even though it appears to be a valid DOM element. As there is no\n      // scroll marker visible at the time, suppression is the order of\n      // the day\n      try {\n        _domOverflowLayer.removeChild(_arrScrollMarkers[0]);\n      } catch (_strErr) {\n        this._debug(_strErr);\n      }\n    }\n  },\n\n  // This function is used to prevent the iScroll from triggering on any elements with the\n  // class attached. This can be used to prevent the bug whereby the iScroll causes an onclick\n  // and ontouch to be triggered, resulting in a button being selected then unselected\n  // (Android tabelt).\n  checkForiScrollInhibitingClass: function(_domWhatEventTarget) {\n    if (\n      _domWhatEventTarget &&\n      _domWhatEventTarget.className &&\n      (_domWhatEventTarget.className.indexOf('inhibitIScrollForAndroidC') > -1 ||\n        _domWhatEventTarget.className.indexOf('buttonTextC') > -1)\n    ) {\n      if (OUTPUT_MODE_CHECKER.isAndroidDevice()) {\n        return true;\n      }\n    }\n    return false;\n  },\n\n  // This is used to temporarily remove the iScroll whilst fixing the scroll element in place\n  // so that it doesn't shift. It is currently used by the matching pairs to prevent a rendering\n  // glitch that occured whilst drawing the lines using Rapheal whilst an iScroll was present.\n  pauseScroller: function(_domWhatElement) {\n    if (this._objIScrollReferences[_domWhatElement.id]) {\n      var _domScroller = CORE.getElementsByClassName(_domWhatElement, 'scrollWrapperC')[0];\n\n      // Store the offesets\n      var _intYPos = this._objIScrollReferences[_domWhatElement.id].y;\n      var _intXPos = this._objIScrollReferences[_domWhatElement.id].x;\n\n      // Remove the iScroll\n      this.recycleScroller(_domWhatElement);\n\n      // Set the scroll element to those CO_ORDS.\n      _domScroller.style.top = _intYPos + 'px';\n      _domScroller.style.left = _intXPos + 'px';\n    }\n  },\n\n  // This is used to restore the iScroll from a pauseScroller command. It will pre-set the iScroll\n  // with the positions set on the scrolling element and should result in no shifting.\n  resumeScroller: function(_domWhatElement) {\n    var _domScroller = CORE.getElementsByClassName(_domWhatElement, 'scrollWrapperC')[0];\n\n    // Capture the current positions\n    var _objOffsets = {\n      intTop: parseInt(_domScroller.style.top),\n      intLeft: parseInt(_domScroller.style.left)\n    };\n\n    // Reset them to prevent doubling of the offsets\n    _domScroller.style.top = 'auto';\n    _domScroller.style.left = 'auto';\n\n    // Apply the iScroll, passing in the stored CO_ORDS.\n    this._applyIscroll(_domWhatElement, false, false, _objOffsets, false);\n  },\n\n  _doQueuedParseElements: function() {\n    var count = 0;\n    while (count < this._arrPendingDOMObjectsToInspect.length) {\n      this._parseElementAndChildren(this._arrPendingDOMObjectsToInspect[count]);\n      count++;\n    }\n    this._arrPendingDOMObjectsToInspect = [];\n    this._objTimeoutRef = null;\n  },\n\n  _parseElementAndChildren: function(_objWhatElementInfo) {\n    var _domWhatElement = _objWhatElementInfo['domElement'];\n    var _booIsChildIScroll = _objWhatElementInfo['booIsChildIScroll'];\n    var _objSurpressDirections = _objWhatElementInfo['objSurpressDirections'];\n    var _booAddPinchZoom = _objWhatElementInfo['booAddPinchZoom'];\n\n    if (!_domWhatElement) {\n      return;\n    }\n    // Finds all elements with 'checkScrollingC' in the classname property\n    var _arrHTMLtags = _domWhatElement.getElementsByTagName('*');\n\n    var count = 0;\n    while (count < _arrHTMLtags.length) {\n      var _domCurrTag = _arrHTMLtags[count];\n      if (\n        _domCurrTag.className &&\n        _domCurrTag.className['indexOf'] &&\n        _domCurrTag.className.indexOf('checkScrollingC') > -1\n      ) {\n        this._checkForScrolling(\n          _domCurrTag,\n          _booIsChildIScroll,\n          false,\n          _objSurpressDirections,\n          _booAddPinchZoom\n        );\n        break;\n      }\n      count++;\n    }\n    _arrHTMLtags = null;\n\n    if (\n      _domWhatElement.className &&\n      _domWhatElement.className['indexOf'] &&\n      _domWhatElement.className.indexOf('checkScrollingC') > -1\n    ) {\n      this._checkForScrolling(\n        _domWhatElement,\n        _booIsChildIScroll,\n        false,\n        _objSurpressDirections,\n        _booAddPinchZoom\n      );\n    }\n  },\n\n  getFirstScrollerChild: function(domId) {\n    var returnId = false;\n    var childScroller = $('#' + domId + ' .checkScrollingC').first();\n    if (childScroller.length > 0) {\n      returnId = childScroller[0].id;\n    }\n    return returnId;\n  },\n\n  setMaxScrollY: function(elementId, newMaxYPosition) {\n    if (ISCROLL_INTERFACE._objIScrollReferences[elementId]) {\n      ISCROLL_INTERFACE._objIScrollReferences[elementId].maxScrollY = newMaxYPosition;\n    }\n  },\n\n  getMaxScrollY: function(elementId) {\n    if (ISCROLL_INTERFACE._objIScrollReferences[elementId]) {\n      return ISCROLL_INTERFACE._objIScrollReferences[elementId].maxScrollY;\n    }\n    return false;\n  },\n\n  _checkForScrolling: function(\n    _domItemToCheck,\n    _booIsChildIScroll,\n    _booDebug,\n    _objSurpressDirections,\n    _booAddPinchZoom\n  ) {\n    // Detects whether this element needs scrolling\n    if (_domItemToCheck) {\n      if (\n        (_objSurpressDirections && !_objSurpressDirections['booHorizontal']) ||\n        !_objSurpressDirections\n      ) {\n        var _booIsWider = _domItemToCheck.scrollWidth > _domItemToCheck.offsetWidth;\n      }\n      if (\n        (_objSurpressDirections && !_objSurpressDirections['booVertical']) ||\n        !_objSurpressDirections\n      ) {\n        var _booIsHigher = _domItemToCheck.scrollHeight > _domItemToCheck.offsetHeight;\n      }\n\n      this._debug(\n        '_domItemToCheck.id: \\'' +\n          _domItemToCheck.id +\n          '\\' _booIsWider: ' +\n          _booIsWider +\n          ' _booIsHigher: ' +\n          _booIsHigher\n      );\n\n      if ((_booIsWider || _booIsHigher) && _domItemToCheck.lastChild.className != 'scrollWrapper') {\n        if (_booDebug) {\n          LOCALISER.l_alert('ISCROLL_INTERFACE_DEBUG_ADD_SCROLLING_MESSAGE');\n        }\n        this._debug('Adding iScroll with marker to ID: ' + _domItemToCheck.id);\n\n        // Filmstrip subscreens are built differently to normal subscreens. They do not have the\n        // checkscrollingC class where the _checkForParentIScrollInstances() function expects it to\n        // be so here we check if we are filmstrip subscreen and force _booIsChildIscroll to true.\n        var isFilmstripSubscreen =\n          _domItemToCheck.parentElement.parentElement.className.indexOf(\n            'filmstripStepWrapperC'\n          ) > -1;\n        if (isFilmstripSubscreen) {\n          _booIsChildIScroll = true;\n        } else {\n          _booIsChildIScroll = this._checkForParentIScrollInstances(_domItemToCheck);\n        }\n        this._applyIscroll(_domItemToCheck, _booIsChildIScroll, true, false, _booAddPinchZoom);\n      } else {\n        this._debug('Adding iScroll with NO marker to ID: ' + _domItemToCheck.id);\n        _booIsChildIScroll = this._checkForParentIScrollInstances(_domItemToCheck);\n        this._applyIscroll(_domItemToCheck, _booIsChildIScroll, false, false, _booAddPinchZoom);\n\n        if (_booDebug) {\n          LOCALISER.l_alert('ISCROLL_INTERFACE_DEBUG_NO_SCROLLING_MESSAGE');\n        }\n      }\n    }\n  },\n\n  _checkForParentIScrollInstances: function(_domItemToCheck) {\n    var _domCurrNode = _domItemToCheck.parentElement;\n    // Sometimes we pass in an element without a parent\n    if (_domCurrNode !== null) {\n      if (_domCurrNode.tagName && _domCurrNode.tagName.toLowerCase) {\n        while (_domCurrNode.tagName.toLowerCase() != 'body') {\n          if (\n            _domCurrNode.className &&\n            _domCurrNode.className['indexOf'] &&\n            _domCurrNode.className.indexOf('checkScrollingC') > -1\n          ) {\n            return true;\n          }\n          _domCurrNode = _domCurrNode.parentElement;\n          /* We're at the top of the dom tree without finding a checkScrolingC class.\n           * This can happen when we navigate away from a screen and change display\n           * conditions at the same time.\n           */\n          if (_domCurrNode !== null) {\n            break;\n          }\n        }\n      }\n    }\n    return false;\n  },\n\n  _applyIscroll: function(\n    _domOverflowLayer,\n    _booIsChildIScroll,\n    _booAddMarkerImage,\n    _objInitialOffsets,\n    _booAddPinchZoom\n  ) {\n    if (!_domOverflowLayer.id) {\n      this._addRandomID(_domOverflowLayer);\n    }\n\n    if (!this._objIScrollReferences[_domOverflowLayer.id]) {\n      var _arrScrollWrappers = false;\n      if (BOO_DYNAMIC_CONTINUOUS_SCROLLING) {\n        _arrScrollWrappers = [$('#contentWrapperInnerL')[0]];\n      } else {\n        _arrScrollWrappers = CORE.getElementsByClassName(_domOverflowLayer, 'scrollWrapperC');\n      }\n      var _intNonWhitespaceChildCount = this._getNonWhitespaceAndCommentChildCount(\n        _domOverflowLayer\n      );\n\n      if (_arrScrollWrappers.length == 0 && _intNonWhitespaceChildCount > 1) {\n        this._addScrollWrapper(_domOverflowLayer);\n      }\n\n      if (_booAddMarkerImage) {\n        this._addScrollMarker(_domOverflowLayer);\n      }\n\n      this._strPendingID = _domOverflowLayer.id;\n      this._addIScroll(_domOverflowLayer, _booIsChildIScroll, _objInitialOffsets, _booAddPinchZoom);\n    } else {\n      if (_booAddMarkerImage) {\n        this._addScrollMarker(_domOverflowLayer);\n      }\n      this._objIScrollReferences[_domOverflowLayer.id].enable();\n      this._objIScrollReferences[_domOverflowLayer.id].refresh();\n    }\n  },\n\n  _getNonWhitespaceAndCommentChildCount: function(_domOverflowLayer) {\n    var _arrChildNodes = _domOverflowLayer.childNodes;\n    var _arrNonTextChildNodes = [];\n    var count = 0;\n    while (count < _arrChildNodes.length) {\n      var _domCurrChild = _arrChildNodes[count];\n      if (_domCurrChild.nodeType != 3 && _domCurrChild.nodeType != 8) {\n        _arrNonTextChildNodes.push(_domCurrChild);\n      }\n      count++;\n    }\n    return _arrNonTextChildNodes.length;\n  },\n\n  _addScrollWrapper: function(_domOverflowLayer) {\n    _domOverflowLayer.innerHTML =\n      '<div class=\"scrollWrapperC\">' + _domOverflowLayer.innerHTML + '</div>';\n  },\n\n  _addRandomID: function(_domOverflowLayer) {\n    var _intDateString = new Date().getTime();\n    var _intRandomNumber = Math.ceil(Math.random() * 100000000);\n    var _strNewID = 'randomID_' + _intDateString + _intRandomNumber + 'L';\n    _domOverflowLayer.id = _strNewID;\n  },\n\n  _addIScroll: function(\n    _domOverflowLayer,\n    _booIsChildIScroll,\n    _objInitialOffsets,\n    _booAddPinchZoom\n  ) {\n    this._debug(\n      '_addIScroll(_domOverflowLayer.id: ' +\n        _domOverflowLayer.id +\n        ', _booIsChildIScroll: ' +\n        _booIsChildIScroll +\n        ', _objInitialOffsets: ' +\n        _objInitialOffsets +\n        ')'\n    );\n    if (this._objIScrollReferences[this._strPendingID]) {\n      this._debug('_addIScroll()::Recycling past instance...');\n      this._recycleScroller(this._strPendingID);\n    }\n\n    // Should prevent the propogation of events up to parent iScroll elements. Used\n    // for Filmstrip amougst others.\n    var _objConfigData = {};\n\n    _objConfigData['booIsChildIscroll'] = _booIsChildIScroll;\n    _objConfigData['hideScrollbar'] = true;\n    _objConfigData['fadeScrollbar'] = true;\n    _objConfigData['click'] = true;\n\n    if (_booAddPinchZoom) {\n      _objConfigData['zoom'] = true;\n      _objConfigData['zoomMin'] = 0.25;\n      _objConfigData['zoomMax'] = 8;\n      _objConfigData['zoomStart'] = 1;\n      _objConfigData['mouseWheel'] = true;\n      _objConfigData['wheelAction'] = 'zoom';\n      _objConfigData['freeScroll'] = true;\n    }\n\n    _objConfigData['freeScroll'] = true;\n    _objConfigData['scrollX'] = true;\n\n    _objConfigData['preventDefaultException'] = {\n      tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT|VIDEO)$/\n    };\n\n    _objConfigData['unscrollableElements'] = {\n      tagName: /^(TEXTAREA|VIDEO)$/\n    };\n\n    if (_objInitialOffsets) {\n      _objConfigData['x'] = _objInitialOffsets['intLeft'];\n      _objConfigData['y'] = _objInitialOffsets['intTop'];\n    }\n\n    var _funBeforeScrollStartHanlder = function(_objEventData) {\n      // PLEASE NOTE: 'booIsChildIscroll' is a config option we're adding an build time.\n      if (this.options.booIsChildIscroll) {\n        ISCROLL_INTERFACE._debug(\n          'onBeforeScrollStart()::_booIsChildIScroll = true, default prevented...'\n        );\n        EM.trigger('disableParentIScrollInstaces');\n      }\n    };\n\n    var _funScrollEndHanlder = function(_objEventData) {\n      if (this.options.booIsChildIscroll) {\n        ISCROLL_INTERFACE._debug(\n          'onBeforeScrollStart()::_booIsChildIScroll = true, default prevented...'\n        );\n        EM.trigger('enableParentIScrollInstaces');\n      }\n      SCROLLING_MANAGER.pollIscrollScrolling(this.y);\n    };\n\n    var _funScrollStartHandler = function(_objEventData) {\n      // Remove focus from any text areas to stop the stuck cursor issue.\n      var currScreenId = SCREEN_INTERACTIONS.getCurrentScreenData().strObjID;\n      if ( $('#screenWrapper_' + currScreenId + 'L').find('textarea').length ) {\n        $('#screenWrapper_' + currScreenId + 'L').find('textarea').blur();\n      }\n    };\n\n    this._objIScrollReferences[this._strPendingID] = new IScroll(_domOverflowLayer, _objConfigData);\n    this._objIScrollReferences[this._strPendingID].on(\n      'beforeScrollStart',\n      _funBeforeScrollStartHanlder\n    );\n    this._objIScrollReferences[this._strPendingID].on(\n      'scrollStart',\n      _funScrollStartHandler\n    );\n    this._objIScrollReferences[this._strPendingID].on('beforeScrollStart', function() {\n      ISCROLL_INTERFACE.hideScrollMarker(this);\n    });\n    this._objIScrollReferences[this._strPendingID].on('scrollEnd', _funScrollEndHanlder);\n\n    this._debug('_addIScroll()::iScroll added for element \\'' + this._strPendingID + '\\'');\n    this._debug('ISCROLL_INTERFACE::_addIScroll: ' + this._strPendingID);\n  },\n\n  _addScrollMarker: function(_domOverflowLayer) {\n    var _arrScrollMarkers = CORE.getElementsByClassName(_domOverflowLayer, 'scrollMarkerC');\n    if (_arrScrollMarkers.length == 0) {\n      var _domMarkerDiv = this._objCurrDOM.createElement('div');\n      _domMarkerDiv.className = 'scrollMarkerC';\n      var _domScrollMarkSprite = this._objCurrDOM.createElement('div');\n      _domMarkerDiv.appendChild(_domScrollMarkSprite);\n      _domOverflowLayer.appendChild(_domMarkerDiv);\n    }\n  },\n\n  _recycleScroller: function(_strWhatID) {\n    if (this._objIScrollReferences[_strWhatID]) {\n      this._objIScrollReferences[_strWhatID]['destroy']();\n      delete this._objIScrollReferences[_strWhatID];\n      this._debug('ISCROLL_INTERFACE::_recycleScroller: ' + _strWhatID);\n    }\n  },\n\n  _disableScroller: function(_strWhatID) {\n    this._debug('ISCROLL_INTERFACE._disableScroller');\n    if (this._objIScrollReferences[_strWhatID]) {\n      this._objIScrollReferences[_strWhatID]['disable']();\n      this._debug('ISCROLL_INTERFACE::_disableScroller: ' + _strWhatID);\n    }\n  },\n\n  _enableScroller: function(_strWhatID) {\n    if (this._objIScrollReferences[_strWhatID]) {\n      this._objIScrollReferences[_strWhatID]['enable']();\n      this._debug('ISCROLL_INTERFACE::_enableScroller: ' + _strWhatID);\n    }\n  },\n\n  // Only called by iScroll\n  allowTransformsOnElements: function(_domLayerToCheck) {\n    // Check for audio/video/other possible AV tags.\n    var _intNumberOfVideoTagChildren = _domLayerToCheck.getElementsByTagName('video').length;\n\n    // Issue has only been reported for video so far.\n    if (_intNumberOfVideoTagChildren > 0) {\n      // Detects the iOS version\n      var _booUseTransform = OUTPUT_MODE_CHECKER.useTransformForScrollingWithVideoAssets();\n      return _booUseTransform;\n    }\n\n    return true;\n  },\n\n  _debug: function(_strMessage) {\n    if (window['console'] && window.console.log && this._booDebug) {\n      console.log('ISCROLL_INTERFACE: ' + _strMessage);\n    }\n  }\n};\n\nEM.register(ISCROLL_INTERFACE);\n"},function(t,n,e){e(0)(e(23))},function(t,n){t.exports="/* eslint-disable */\n/* ! iScroll v5.1.2 ~ (c) 2008-2014 Matteo Spinelli ~ http://cubiq.org/license */\n// Added a CORE.pollIscrollScrolling call from the event handler - J.Hough\n\n(function(window, document, Math) {\n  var rAF =\n    window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.oRequestAnimationFrame ||\n    window.msRequestAnimationFrame ||\n    function(callback) {\n      window.setTimeout(callback, 1000 / 60);\n    };\n\n  var utils = (function() {\n    var me = {};\n\n    var _elementStyle = document.createElement('div').style;\n    var _vendor = (function() {\n      var vendors = ['t', 'webkitT', 'MozT', 'msT', 'OT'],\n        transform,\n        i = 0,\n        l = vendors.length;\n\n      for (; i < l; i++) {\n        transform = vendors[i] + 'ransform';\n        if (transform in _elementStyle) return vendors[i].substr(0, vendors[i].length - 1);\n      }\n\n      return false;\n    })();\n\n    function _prefixStyle(style) {\n      if (_vendor === false) return false;\n      if (_vendor === '') return style;\n      return _vendor + style.charAt(0).toUpperCase() + style.substr(1);\n    }\n\n    me.getTime =\n      Date.now ||\n      function getTime() {\n        return new Date().getTime();\n      };\n\n    me.extend = function(target, obj) {\n      for (var i in obj) {\n        target[i] = obj[i];\n      }\n    };\n\n    me.addEvent = function(el, type, fn, capture) {\n      el.addEventListener(type, fn, !!capture);\n    };\n\n    me.removeEvent = function(el, type, fn, capture) {\n      el.removeEventListener(type, fn, !!capture);\n    };\n\n    me.prefixPointerEvent = function(pointerEvent) {\n      return window.MSPointerEvent\n        ? 'MSPointer' + pointerEvent.charAt(9).toUpperCase() + pointerEvent.substr(10)\n        : pointerEvent;\n    };\n\n    me.momentum = function(current, start, time, lowerMargin, wrapperSize, deceleration) {\n      var distance = current - start,\n        speed = Math.abs(distance) / time,\n        destination,\n        duration;\n\n      deceleration = deceleration === undefined ? 0.0006 : deceleration;\n\n      destination = current + ((speed * speed) / (2 * deceleration)) * (distance < 0 ? -1 : 1);\n      duration = speed / deceleration;\n\n      if (destination < lowerMargin) {\n        destination = wrapperSize ? lowerMargin - (wrapperSize / 2.5) * (speed / 8) : lowerMargin;\n        distance = Math.abs(destination - current);\n        duration = distance / speed;\n      } else if (destination > 0) {\n        destination = wrapperSize ? (wrapperSize / 2.5) * (speed / 8) : 0;\n        distance = Math.abs(current) + destination;\n        duration = distance / speed;\n      }\n\n      return {\n        destination: Math.round(destination),\n        duration: duration\n      };\n    };\n\n    var _transform = _prefixStyle('transform');\n\n    me.extend(me, {\n      hasTransform: _transform !== false,\n      hasPerspective: _prefixStyle('perspective') in _elementStyle,\n      hasTouch: 'ontouchstart' in window,\n      hasPointer: window.PointerEvent || window.MSPointerEvent, // IE10 is prefixed\n      hasTransition: _prefixStyle('transition') in _elementStyle\n    });\n\n    // This should find all Android browsers lower than build 535.19 (both stock browser and webview)\n    me.isBadAndroid =\n      /Android /.test(window.navigator.appVersion) &&\n      !/Chrome\\/\\d/.test(window.navigator.appVersion);\n\n    me.extend((me.style = {}), {\n      transform: _transform,\n      transitionTimingFunction: _prefixStyle('transitionTimingFunction'),\n      transitionDuration: _prefixStyle('transitionDuration'),\n      transitionDelay: _prefixStyle('transitionDelay'),\n      transformOrigin: _prefixStyle('transformOrigin')\n    });\n\n    me.hasClass = function(e, c) {\n      var re = new RegExp('(^|\\\\s)' + c + '(\\\\s|$)');\n      return re.test(e.className);\n    };\n\n    me.addClass = function(e, c) {\n      if (me.hasClass(e, c)) {\n        return;\n      }\n\n      var newclass = e.className.split(' ');\n      newclass.push(c);\n      e.className = newclass.join(' ');\n    };\n\n    me.removeClass = function(e, c) {\n      if (!me.hasClass(e, c)) {\n        return;\n      }\n\n      var re = new RegExp('(^|\\\\s)' + c + '(\\\\s|$)', 'g');\n      e.className = e.className.replace(re, ' ');\n    };\n\n    me.offset = function(el) {\n      var left = -el.offsetLeft,\n        top = -el.offsetTop;\n\n      // jshint -W084\n      while ((el = el.offsetParent)) {\n        left -= el.offsetLeft;\n        top -= el.offsetTop;\n      }\n      // jshint +W084\n\n      return {\n        left: left,\n        top: top\n      };\n    };\n\n    me.preventDefaultException = function(el, exceptions) {\n      for (var i in exceptions) {\n        if (exceptions[i].test(el[i])) {\n          return true;\n        }\n      }\n\n      return false;\n    };\n\n    me.extend((me.eventType = {}), {\n      touchstart: 1,\n      touchmove: 1,\n      touchend: 1,\n\n      mousedown: 2,\n      mousemove: 2,\n      mouseup: 2,\n\n      pointerdown: 3,\n      pointermove: 3,\n      pointerup: 3,\n\n      MSPointerDown: 3,\n      MSPointerMove: 3,\n      MSPointerUp: 3\n    });\n\n    me.extend((me.ease = {}), {\n      quadratic: {\n        style: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)',\n        fn: function(k) {\n          return k * (2 - k);\n        }\n      },\n      circular: {\n        style: 'cubic-bezier(0.1, 0.57, 0.1, 1)', // Not properly \"circular\" but this looks better, it should be (0.075, 0.82, 0.165, 1)\n        fn: function(k) {\n          return Math.sqrt(1 - --k * k);\n        }\n      },\n      back: {\n        style: 'cubic-bezier(0.175, 0.885, 0.32, 1.275)',\n        fn: function(k) {\n          var b = 4;\n          return (k = k - 1) * k * ((b + 1) * k + b) + 1;\n        }\n      },\n      bounce: {\n        style: '',\n        fn: function(k) {\n          if ((k /= 1) < 1 / 2.75) {\n            return 7.5625 * k * k;\n          } else if (k < 2 / 2.75) {\n            return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;\n          } else if (k < 2.5 / 2.75) {\n            return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;\n          } else {\n            return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;\n          }\n        }\n      },\n      elastic: {\n        style: '',\n        fn: function(k) {\n          var f = 0.22,\n            e = 0.4;\n\n          if (k === 0) {\n            return 0;\n          }\n          if (k == 1) {\n            return 1;\n          }\n\n          return e * Math.pow(2, -10 * k) * Math.sin(((k - f / 4) * (2 * Math.PI)) / f) + 1;\n        }\n      }\n    });\n\n    me.tap = function(e, eventName) {\n      var ev = document.createEvent('Event');\n      ev.initEvent(eventName, true, true);\n      ev.pageX = e.pageX;\n      ev.pageY = e.pageY;\n      e.target.dispatchEvent(ev);\n    };\n\n    me.click = function(e) {\n      var target = e.target,\n        ev;\n\n      if (!/(SELECT|INPUT|TEXTAREA)/i.test(target.tagName)) {\n        ev = document.createEvent('MouseEvents');\n        ev.initMouseEvent(\n          'click',\n          true,\n          true,\n          e.view,\n          1,\n          target.screenX,\n          target.screenY,\n          target.clientX,\n          target.clientY,\n          e.ctrlKey,\n          e.altKey,\n          e.shiftKey,\n          e.metaKey,\n          0,\n          null\n        );\n\n        ev._constructed = true;\n        target.dispatchEvent(ev);\n      }\n    };\n\n    return me;\n  })();\n\n  function IScroll(el, options) {\n    this.wrapper = typeof el == 'string' ? document.querySelector(el) : el;\n    this.scroller = this.wrapper.children[0];\n    this.scrollerStyle = this.scroller.style; // cache style for better performance\n\n    this.options = {\n      zoomMin: 1,\n      zoomMax: 4,\n      startZoom: 1,\n\n      resizeScrollbars: true,\n\n      mouseWheelSpeed: 20,\n\n      snapThreshold: 0.334,\n\n      // INSERT POINT: OPTIONS\n\n      startX: 0,\n      startY: 0,\n      scrollY: true,\n      directionLockThreshold: 5,\n      momentum: true,\n\n      bounce: true,\n      bounceTime: 600,\n      bounceEasing: '',\n\n      preventDefault: true,\n      preventDefaultException: {tagName: /^(INPUT|TEXTAREA|BUTTON|SELECT)$/},\n\n      HWCompositing: true,\n      useTransition: true,\n      useTransform: true\n    };\n\n    for (var i in options) {\n      this.options[i] = options[i];\n    }\n\n    // Normalize options\n    this.translateZ = this.options.HWCompositing && utils.hasPerspective ? ' translateZ(0)' : '';\n\n    this.options.useTransition = utils.hasTransition && this.options.useTransition;\n    this.options.useTransform = utils.hasTransform && this.options.useTransform;\n\n    this.options.eventPassthrough =\n      this.options.eventPassthrough === true ? 'vertical' : this.options.eventPassthrough;\n    this.options.preventDefault = !this.options.eventPassthrough && this.options.preventDefault;\n\n    // If you want eventPassthrough I have to lock one of the axes\n    this.options.scrollY =\n      this.options.eventPassthrough == 'vertical' ? false : this.options.scrollY;\n    this.options.scrollX =\n      this.options.eventPassthrough == 'horizontal' ? false : this.options.scrollX;\n\n    // With eventPassthrough we also need lockDirection mechanism\n    this.options.freeScroll = this.options.freeScroll && !this.options.eventPassthrough;\n    this.options.directionLockThreshold = this.options.eventPassthrough\n      ? 0\n      : this.options.directionLockThreshold;\n\n    this.options.bounceEasing =\n      typeof this.options.bounceEasing == 'string'\n        ? utils.ease[this.options.bounceEasing] || utils.ease.circular\n        : this.options.bounceEasing;\n\n    this.options.resizePolling =\n      this.options.resizePolling === undefined ? 60 : this.options.resizePolling;\n\n    if (this.options.tap === true) {\n      this.options.tap = 'tap';\n    }\n\n    if (this.options.shrinkScrollbars == 'scale') {\n      this.options.useTransition = false;\n    }\n\n    this.options.invertWheelDirection = this.options.invertWheelDirection ? -1 : 1;\n\n    // INSERT POINT: NORMALIZATION\n\n    // Some defaults\n    this.x = 0;\n    this.y = 0;\n    this.directionX = 0;\n    this.directionY = 0;\n    this._events = {};\n\n    this.scale = Math.min(\n      Math.max(this.options.startZoom, this.options.zoomMin),\n      this.options.zoomMax\n    );\n\n    // INSERT POINT: DEFAULTS\n\n    this._init();\n    this.refresh();\n\n    this.scrollTo(this.options.startX, this.options.startY);\n    this.enable();\n  }\n\n  IScroll.prototype = {\n    version: '5.1.2',\n\n    _init: function() {\n      this._initEvents();\n\n      if (this.options.zoom) {\n        this._initZoom();\n      }\n\n      if (this.options.scrollbars || this.options.indicators) {\n        this._initIndicators();\n      }\n\n      if (this.options.mouseWheel) {\n        this._initWheel();\n      }\n\n      if (this.options.snap) {\n        this._initSnap();\n      }\n\n      if (this.options.keyBindings) {\n        this._initKeys();\n      }\n\n      // INSERT POINT: _init\n    },\n\n    destroy: function() {\n      this._initEvents(true);\n\n      this._execEvent('destroy');\n    },\n\n    _transitionEnd: function(e) {\n      if (e.target != this.scroller || !this.isInTransition) {\n        return;\n      }\n\n      this._transitionTime();\n      if (!this.resetPosition(this.options.bounceTime)) {\n        this.isInTransition = false;\n        this._execEvent('scrollEnd');\n      }\n    },\n\n    // Certain elements shouldn't be scrollable because they cause lots of issues when they are\n    testForUnscrollableElements: function(e) {\n      if (typeof e.target !== 'undefined' && typeof e.target.tagName !== 'undefined') {\n        for (var i in this.options.unscrollableElements) {\n          if (this.options.unscrollableElements[i].test(e.target[i])) {\n            return true;\n          }\n        }\n      }\n      return false;\n    },\n\n    _start: function(e) {\n      // React to left mouse button only\n      if (utils.eventType[e.type] != 1) {\n        if (e.button !== 0) {\n          return;\n        }\n      }\n\n      if (!this.enabled || (this.initiated && utils.eventType[e.type] !== this.initiated)) {\n        return;\n      }\n\n      // If ipad video element\n      if (this.testForUnscrollableElements(e)) {\n        return;\n      }\n\n      if (\n        this.options.preventDefault &&\n        !utils.isBadAndroid &&\n        !utils.preventDefaultException(e.target, this.options.preventDefaultException)\n      ) {\n        e.preventDefault();\n      }\n\n      var point = e.touches ? e.touches[0] : e,\n        pos;\n\n      this.initiated = utils.eventType[e.type];\n      this.moved = false;\n      this.distX = 0;\n      this.distY = 0;\n      this.directionX = 0;\n      this.directionY = 0;\n      this.directionLocked = 0;\n\n      this._transitionTime();\n\n      this.startTime = utils.getTime();\n\n      if (this.options.useTransition && this.isInTransition) {\n        this.isInTransition = false;\n        pos = this.getComputedPosition();\n        this._translate(Math.round(pos.x), Math.round(pos.y));\n        this._execEvent('scrollEnd');\n      } else if (!this.options.useTransition && this.isAnimating) {\n        this.isAnimating = false;\n        this._execEvent('scrollEnd');\n      }\n\n      this.startX = this.x;\n      this.startY = this.y;\n      this.absStartX = this.x;\n      this.absStartY = this.y;\n      this.pointX = point.pageX;\n      this.pointY = point.pageY;\n\n      this._execEvent('beforeScrollStart');\n    },\n\n    _move: function(e) {\n      if (!this.enabled || utils.eventType[e.type] !== this.initiated) {\n        return;\n      }\n\n      // If ipad video element\n      if (this.testForUnscrollableElements(e)) {\n        return;\n      }\n\n      if (this.options.preventDefault) {\n        // increases performance on Android? TODO: check!\n        e.preventDefault();\n      }\n\n      var point = e.touches ? e.touches[0] : e,\n        deltaX = point.pageX - this.pointX,\n        deltaY = point.pageY - this.pointY,\n        timestamp = utils.getTime(),\n        newX,\n        newY,\n        absDistX,\n        absDistY;\n\n      this.pointX = point.pageX;\n      this.pointY = point.pageY;\n\n      this.distX += deltaX;\n      this.distY += deltaY;\n      absDistX = Math.abs(this.distX);\n      absDistY = Math.abs(this.distY);\n\n      // We need to move at least 10 pixels for the scrolling to initiate\n      if (timestamp - this.endTime > 300 && (absDistX < 10 && absDistY < 10)) {\n        return;\n      }\n\n      // If you are scrolling in one direction lock the other\n      if (!this.directionLocked && !this.options.freeScroll) {\n        if (absDistX > absDistY + this.options.directionLockThreshold) {\n          this.directionLocked = 'h'; // lock horizontally\n        } else if (absDistY >= absDistX + this.options.directionLockThreshold) {\n          this.directionLocked = 'v'; // lock vertically\n        } else {\n          this.directionLocked = 'n'; // no lock\n        }\n      }\n\n      if (this.directionLocked == 'h') {\n        if (this.options.eventPassthrough == 'vertical') {\n          e.preventDefault();\n        } else if (this.options.eventPassthrough == 'horizontal') {\n          this.initiated = false;\n          return;\n        }\n\n        deltaY = 0;\n      } else if (this.directionLocked == 'v') {\n        if (this.options.eventPassthrough == 'horizontal') {\n          e.preventDefault();\n        } else if (this.options.eventPassthrough == 'vertical') {\n          this.initiated = false;\n          return;\n        }\n\n        deltaX = 0;\n      }\n\n      deltaX = this.hasHorizontalScroll ? deltaX : 0;\n      deltaY = this.hasVerticalScroll ? deltaY : 0;\n\n      newX = this.x + deltaX;\n      newY = this.y + deltaY;\n\n      // Slow down if outside of the boundaries\n      if (newX > 0 || newX < this.maxScrollX) {\n        newX = this.options.bounce ? this.x + deltaX / 3 : newX > 0 ? 0 : this.maxScrollX;\n      }\n      if (newY > 0 || newY < this.maxScrollY) {\n        newY = this.options.bounce ? this.y + deltaY / 3 : newY > 0 ? 0 : this.maxScrollY;\n      }\n\n      this.directionX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;\n      this.directionY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;\n\n      if (!this.moved) {\n        this._execEvent('scrollStart');\n      }\n\n      this.moved = true;\n\n      this._translate(newX, newY);\n\n      /* REPLACE START: _move */\n\n      if (timestamp - this.startTime > 300) {\n        this.startTime = timestamp;\n        this.startX = this.x;\n        this.startY = this.y;\n      }\n\n      /* REPLACE END: _move */\n    },\n\n    _end: function(e) {\n      if (!this.enabled || utils.eventType[e.type] !== this.initiated) {\n        return;\n      }\n\n      // If ipad video element\n      if (this.testForUnscrollableElements(e)) {\n        return;\n      }\n\n      if (\n        this.options.preventDefault &&\n        !utils.preventDefaultException(e.target, this.options.preventDefaultException)\n      ) {\n        e.preventDefault();\n      }\n\n      var point = e.changedTouches ? e.changedTouches[0] : e,\n        momentumX,\n        momentumY,\n        duration = utils.getTime() - this.startTime,\n        newX = Math.round(this.x),\n        newY = Math.round(this.y),\n        distanceX = Math.abs(newX - this.startX),\n        distanceY = Math.abs(newY - this.startY),\n        time = 0,\n        easing = '';\n\n      this.isInTransition = 0;\n      this.initiated = 0;\n      this.endTime = utils.getTime();\n\n      // reset if we are outside of the boundaries\n      if (this.resetPosition(this.options.bounceTime)) {\n        return;\n      }\n\n      this.scrollTo(newX, newY); // ensures that the last position is rounded\n\n      // we scrolled less than 10 pixels\n      if (!this.moved) {\n        if (this.options.tap) {\n          utils.tap(e, this.options.tap);\n        }\n\n        if (this.options.click) {\n          utils.click(e);\n        }\n\n        this._execEvent('scrollCancel');\n        return;\n      }\n\n      if (this._events.flick && duration < 200 && distanceX < 100 && distanceY < 100) {\n        this._execEvent('flick');\n        return;\n      }\n\n      // start momentum animation if needed\n      if (this.options.momentum && duration < 300) {\n        momentumX = this.hasHorizontalScroll\n          ? utils.momentum(\n            this.x,\n            this.startX,\n            duration,\n            this.maxScrollX,\n            this.options.bounce ? this.wrapperWidth : 0,\n            this.options.deceleration\n          )\n          : {destination: newX, duration: 0};\n        momentumY = this.hasVerticalScroll\n          ? utils.momentum(\n            this.y,\n            this.startY,\n            duration,\n            this.maxScrollY,\n            this.options.bounce ? this.wrapperHeight : 0,\n            this.options.deceleration\n          )\n          : {destination: newY, duration: 0};\n        newX = momentumX.destination;\n        newY = momentumY.destination;\n        time = Math.max(momentumX.duration, momentumY.duration);\n        this.isInTransition = 1;\n\n        // JH - gomo function to run 10 updates to the scrollmanager while the final animation renders\n        var animationPoll = setInterval(function() {\n          SCROLLING_MANAGER.pollIscrollScrolling();\n          $('#contentWrapperInnerL').trigger('iscroll');\n        }, time / 60);\n\n        setTimeout(function() {\n          clearInterval(animationPoll);\n        }, time);\n      }\n\n      if (this.options.snap) {\n        var snap = this._nearestSnap(newX, newY);\n        this.currentPage = snap;\n        time =\n          this.options.snapSpeed ||\n          Math.max(\n            Math.max(\n              Math.min(Math.abs(newX - snap.x), 1000),\n              Math.min(Math.abs(newY - snap.y), 1000)\n            ),\n            300\n          );\n        newX = snap.x;\n        newY = snap.y;\n\n        this.directionX = 0;\n        this.directionY = 0;\n        easing = this.options.bounceEasing;\n      }\n\n      // INSERT POINT: _end\n\n      if (newX != this.x || newY != this.y) {\n        // change easing function when scroller goes out of the boundaries\n        if (newX > 0 || newX < this.maxScrollX || newY > 0 || newY < this.maxScrollY) {\n          easing = utils.ease.quadratic;\n        }\n\n        this.scrollTo(newX, newY, time, easing);\n        return;\n      }\n\n      this._execEvent('scrollEnd');\n    },\n\n    _resize: function() {\n      var that = this;\n\n      clearTimeout(this.resizeTimeout);\n\n      this.resizeTimeout = setTimeout(function() {\n        that.refresh();\n      }, this.options.resizePolling);\n    },\n\n    resetPosition: function(time) {\n      var x = this.x,\n        y = this.y;\n\n      time = time || 0;\n\n      if (!this.hasHorizontalScroll || this.x > 0) {\n        x = 0;\n      } else if (this.x < this.maxScrollX) {\n        x = this.maxScrollX;\n      }\n\n      if (!this.hasVerticalScroll || this.y > 0) {\n        y = 0;\n      } else if (this.y < this.maxScrollY) {\n        y = this.maxScrollY;\n      }\n\n      if (x == this.x && y == this.y) {\n        return false;\n      }\n\n      this.scrollTo(x, y, time, this.options.bounceEasing);\n\n      return true;\n    },\n\n    disable: function() {\n      this.enabled = false;\n    },\n\n    enable: function() {\n      this.enabled = true;\n    },\n\n    refresh: function() {\n      var rf = this.wrapper.offsetHeight; // Force reflow\n\n      this.wrapperWidth = this.wrapper.clientWidth;\n      this.wrapperHeight = this.wrapper.clientHeight;\n\n      /* REPLACE START: refresh */\n      this.scrollerWidth = Math.round(this.scroller.offsetWidth * this.scale);\n      this.scrollerHeight = Math.round(this.scroller.offsetHeight * this.scale);\n\n      this.maxScrollX = this.wrapperWidth - this.scrollerWidth;\n      this.maxScrollY = this.wrapperHeight - this.scrollerHeight;\n      /* REPLACE END: refresh */\n\n      this.hasHorizontalScroll = this.options.scrollX && this.maxScrollX < 0;\n      this.hasVerticalScroll = this.options.scrollY && this.maxScrollY < 0;\n\n      if (!this.hasHorizontalScroll) {\n        this.maxScrollX = 0;\n        this.scrollerWidth = this.wrapperWidth;\n      }\n\n      if (!this.hasVerticalScroll) {\n        this.maxScrollY = 0;\n        this.scrollerHeight = this.wrapperHeight;\n      }\n\n      this.endTime = 0;\n      this.directionX = 0;\n      this.directionY = 0;\n\n      this.wrapperOffset = utils.offset(this.wrapper);\n\n      this._execEvent('refresh');\n\n      this.resetPosition();\n\n      // INSERT POINT: _refresh\n    },\n\n    on: function(type, fn) {\n      if (!this._events[type]) {\n        this._events[type] = [];\n      }\n\n      this._events[type].push(fn);\n    },\n\n    off: function(type, fn) {\n      if (!this._events[type]) {\n        return;\n      }\n\n      var index = this._events[type].indexOf(fn);\n\n      if (index > -1) {\n        this._events[type].splice(index, 1);\n      }\n    },\n\n    _execEvent: function(type) {\n      if (!this._events[type]) {\n        return;\n      }\n\n      var i = 0,\n        l = this._events[type].length;\n\n      if (!l) {\n        return;\n      }\n\n      for (; i < l; i++) {\n        this._events[type][i].apply(this, [].slice.call(arguments, 1));\n      }\n    },\n\n    scrollBy: function(x, y, time, easing) {\n      x = this.x + x;\n      y = this.y + y;\n      time = time || 0;\n\n      this.scrollTo(x, y, time, easing);\n    },\n\n    scrollTo: function(x, y, time, easing) {\n      easing = easing || utils.ease.circular;\n\n      this.isInTransition = this.options.useTransition && time > 0;\n\n      if (!time || (this.options.useTransition && easing.style)) {\n        this._transitionTimingFunction(easing.style);\n        this._transitionTime(time);\n        this._translate(x, y);\n      } else {\n        this._animate(x, y, time, easing.fn);\n      }\n    },\n\n    scrollToElement: function(el, time, offsetX, offsetY, easing) {\n      el = el.nodeType ? el : this.scroller.querySelector(el);\n\n      if (!el) {\n        return;\n      }\n\n      var pos = utils.offset(el);\n\n      pos.left -= this.wrapperOffset.left;\n      pos.top -= this.wrapperOffset.top;\n\n      // if offsetX/Y are true we center the element to the screen\n      if (offsetX === true) {\n        offsetX = Math.round(el.offsetWidth / 2 - this.wrapper.offsetWidth / 2);\n      }\n      if (offsetY === true) {\n        offsetY = Math.round(el.offsetHeight / 2 - this.wrapper.offsetHeight / 2);\n      }\n\n      pos.left -= offsetX || 0;\n      pos.top -= offsetY || 0;\n\n      pos.left = pos.left > 0 ? 0 : pos.left < this.maxScrollX ? this.maxScrollX : pos.left;\n      pos.top = pos.top > 0 ? 0 : pos.top < this.maxScrollY ? this.maxScrollY : pos.top;\n\n      time =\n        time === undefined || time === null || time === 'auto'\n          ? Math.max(Math.abs(this.x - pos.left), Math.abs(this.y - pos.top))\n          : time;\n\n      this.scrollTo(pos.left, pos.top, time, easing);\n    },\n\n    _transitionTime: function(time) {\n      time = time || 0;\n\n      this.scrollerStyle[utils.style.transitionDuration] = time + 'ms';\n\n      if (!time && utils.isBadAndroid) {\n        this.scrollerStyle[utils.style.transitionDuration] = '0.001s';\n      }\n\n      if (this.indicators) {\n        for (var i = this.indicators.length; i--; ) {\n          this.indicators[i].transitionTime(time);\n        }\n      }\n\n      // INSERT POINT: _transitionTime\n    },\n\n    _transitionTimingFunction: function(easing) {\n      this.scrollerStyle[utils.style.transitionTimingFunction] = easing;\n\n      if (this.indicators) {\n        for (var i = this.indicators.length; i--; ) {\n          this.indicators[i].transitionTimingFunction(easing);\n        }\n      }\n\n      // INSERT POINT: _transitionTimingFunction\n    },\n\n    _translate: function(x, y) {\n      if (this.options.useTransform) {\n        /* REPLACE START: _translate */ this.scrollerStyle[utils.style.transform] =\n          'translate(' +\n          x +\n          'px,' +\n          y +\n          'px) scale(' +\n          this.scale +\n          ') ' +\n          this.translateZ; /* REPLACE END: _translate */\n      } else {\n        x = Math.round(x);\n        y = Math.round(y);\n        this.scrollerStyle.left = x + 'px';\n        this.scrollerStyle.top = y + 'px';\n      }\n\n      this.x = x;\n      this.y = y;\n\n      if (this.indicators) {\n        for (var i = this.indicators.length; i--; ) {\n          this.indicators[i].updatePosition();\n        }\n      }\n\n      // INSERT POINT: _translate\n    },\n\n    _initEvents: function(remove) {\n      var eventType = remove ? utils.removeEvent : utils.addEvent,\n        target = this.options.bindToWrapper ? this.wrapper : window;\n\n      eventType(window, 'orientationchange', this);\n      eventType(window, 'resize', this);\n\n      if (this.options.click) {\n        eventType(this.wrapper, 'click', this, true);\n      }\n\n      if (!this.options.disableMouse) {\n        eventType(this.wrapper, 'mousedown', this);\n        eventType(target, 'mousemove', this);\n        eventType(target, 'mousecancel', this);\n        eventType(target, 'mouseup', this);\n      }\n\n      if (utils.hasPointer && !this.options.disablePointer) {\n        eventType(this.wrapper, utils.prefixPointerEvent('pointerdown'), this);\n        eventType(target, utils.prefixPointerEvent('pointermove'), this);\n        eventType(target, utils.prefixPointerEvent('pointercancel'), this);\n        eventType(target, utils.prefixPointerEvent('pointerup'), this);\n      }\n\n      if (utils.hasTouch && !this.options.disableTouch) {\n        eventType(this.wrapper, 'touchstart', this);\n        eventType(target, 'touchmove', this);\n        eventType(target, 'touchcancel', this);\n        eventType(target, 'touchend', this);\n      }\n\n      eventType(this.scroller, 'transitionend', this);\n      eventType(this.scroller, 'webkitTransitionEnd', this);\n      eventType(this.scroller, 'oTransitionEnd', this);\n      eventType(this.scroller, 'MSTransitionEnd', this);\n    },\n\n    getComputedPosition: function() {\n      var matrix = window.getComputedStyle(this.scroller, null),\n        x,\n        y;\n\n      if (this.options.useTransform) {\n        matrix = matrix[utils.style.transform].split(')')[0].split(', ');\n        x = +(matrix[12] || matrix[4]);\n        y = +(matrix[13] || matrix[5]);\n      } else {\n        x = +matrix.left.replace(/[^-\\d.]/g, '');\n        y = +matrix.top.replace(/[^-\\d.]/g, '');\n      }\n\n      return {x: x, y: y};\n    },\n\n    _initIndicators: function() {\n      var interactive = this.options.interactiveScrollbars,\n        customStyle = typeof this.options.scrollbars != 'string',\n        indicators = [],\n        indicator;\n\n      var that = this;\n\n      this.indicators = [];\n\n      if (this.options.scrollbars) {\n        // Vertical scrollbar\n        if (this.options.scrollY) {\n          indicator = {\n            el: createDefaultScrollbar('v', interactive, this.options.scrollbars),\n            interactive: interactive,\n            defaultScrollbars: true,\n            customStyle: customStyle,\n            resize: this.options.resizeScrollbars,\n            shrink: this.options.shrinkScrollbars,\n            fade: this.options.fadeScrollbars,\n            listenX: false\n          };\n\n          this.wrapper.appendChild(indicator.el);\n          indicators.push(indicator);\n        }\n\n        // Horizontal scrollbar\n        if (this.options.scrollX) {\n          indicator = {\n            el: createDefaultScrollbar('h', interactive, this.options.scrollbars),\n            interactive: interactive,\n            defaultScrollbars: true,\n            customStyle: customStyle,\n            resize: this.options.resizeScrollbars,\n            shrink: this.options.shrinkScrollbars,\n            fade: this.options.fadeScrollbars,\n            listenY: false\n          };\n\n          this.wrapper.appendChild(indicator.el);\n          indicators.push(indicator);\n        }\n      }\n\n      if (this.options.indicators) {\n        // TODO: check concat compatibility\n        indicators = indicators.concat(this.options.indicators);\n      }\n\n      for (var i = indicators.length; i--; ) {\n        this.indicators.push(new Indicator(this, indicators[i]));\n      }\n\n      // TODO: check if we can use array.map (wide compatibility and performance issues)\n      function _indicatorsMap(fn) {\n        for (var i = that.indicators.length; i--; ) {\n          fn.call(that.indicators[i]);\n        }\n      }\n\n      if (this.options.fadeScrollbars) {\n        this.on('scrollEnd', function() {\n          _indicatorsMap(function() {\n            this.fade();\n          });\n        });\n\n        this.on('scrollCancel', function() {\n          _indicatorsMap(function() {\n            this.fade();\n          });\n        });\n\n        this.on('scrollStart', function() {\n          _indicatorsMap(function() {\n            this.fade(1);\n          });\n        });\n\n        this.on('beforeScrollStart', function() {\n          _indicatorsMap(function() {\n            this.fade(1, true);\n          });\n        });\n      }\n\n      this.on('refresh', function() {\n        _indicatorsMap(function() {\n          this.refresh();\n        });\n      });\n\n      this.on('destroy', function() {\n        _indicatorsMap(function() {\n          this.destroy();\n        });\n\n        delete this.indicators;\n      });\n    },\n\n    _initZoom: function() {\n      this.scrollerStyle[utils.style.transformOrigin] = '0 0';\n    },\n\n    _zoomStart: function(e) {\n      var c1 = Math.abs(e.touches[0].pageX - e.touches[1].pageX),\n        c2 = Math.abs(e.touches[0].pageY - e.touches[1].pageY);\n\n      this.touchesDistanceStart = Math.sqrt(c1 * c1 + c2 * c2);\n      this.startScale = this.scale;\n\n      this.originX =\n        Math.abs(e.touches[0].pageX + e.touches[1].pageX) / 2 + this.wrapperOffset.left - this.x;\n      this.originY =\n        Math.abs(e.touches[0].pageY + e.touches[1].pageY) / 2 + this.wrapperOffset.top - this.y;\n\n      this._execEvent('zoomStart');\n    },\n\n    _zoom: function(e) {\n      if (!this.enabled || utils.eventType[e.type] !== this.initiated) {\n        return;\n      }\n\n      if (this.options.preventDefault) {\n        e.preventDefault();\n      }\n\n      var c1 = Math.abs(e.touches[0].pageX - e.touches[1].pageX),\n        c2 = Math.abs(e.touches[0].pageY - e.touches[1].pageY),\n        distance = Math.sqrt(c1 * c1 + c2 * c2),\n        scale = (1 / this.touchesDistanceStart) * distance * this.startScale,\n        lastScale,\n        x,\n        y;\n\n      this.scaled = true;\n\n      if (scale < this.options.zoomMin) {\n        scale = 0.5 * this.options.zoomMin * Math.pow(2.0, scale / this.options.zoomMin);\n      } else if (scale > this.options.zoomMax) {\n        scale = 2.0 * this.options.zoomMax * Math.pow(0.5, this.options.zoomMax / scale);\n      }\n\n      lastScale = scale / this.startScale;\n      x = this.originX - this.originX * lastScale + this.startX;\n      y = this.originY - this.originY * lastScale + this.startY;\n\n      this.scale = scale;\n\n      this.scrollTo(x, y, 0);\n    },\n\n    _zoomEnd: function(e) {\n      if (!this.enabled || utils.eventType[e.type] !== this.initiated) {\n        return;\n      }\n\n      if (this.options.preventDefault) {\n        e.preventDefault();\n      }\n\n      var newX, newY, lastScale;\n\n      this.isInTransition = 0;\n      this.initiated = 0;\n\n      if (this.scale > this.options.zoomMax) {\n        this.scale = this.options.zoomMax;\n      } else if (this.scale < this.options.zoomMin) {\n        this.scale = this.options.zoomMin;\n      }\n\n      // Update boundaries\n      this.refresh();\n\n      lastScale = this.scale / this.startScale;\n\n      newX = this.originX - this.originX * lastScale + this.startX;\n      newY = this.originY - this.originY * lastScale + this.startY;\n\n      if (newX > 0) {\n        newX = 0;\n      } else if (newX < this.maxScrollX) {\n        newX = this.maxScrollX;\n      }\n\n      if (newY > 0) {\n        newY = 0;\n      } else if (newY < this.maxScrollY) {\n        newY = this.maxScrollY;\n      }\n\n      if (this.x != newX || this.y != newY) {\n        this.scrollTo(newX, newY, this.options.bounceTime);\n      }\n\n      this.scaled = false;\n\n      this._execEvent('zoomEnd');\n    },\n\n    zoom: function(scale, x, y, time) {\n      if (scale < this.options.zoomMin) {\n        scale = this.options.zoomMin;\n      } else if (scale > this.options.zoomMax) {\n        scale = this.options.zoomMax;\n      }\n\n      if (scale == this.scale) {\n        return;\n      }\n\n      var relScale = scale / this.scale;\n\n      x = x === undefined ? this.wrapperWidth / 2 : x;\n      y = y === undefined ? this.wrapperHeight / 2 : y;\n      time = time === undefined ? 300 : time;\n\n      x = x + this.wrapperOffset.left - this.x;\n      y = y + this.wrapperOffset.top - this.y;\n\n      x = x - x * relScale + this.x;\n      y = y - y * relScale + this.y;\n\n      this.scale = scale;\n\n      this.refresh(); // update boundaries\n\n      if (x > 0) {\n        x = 0;\n      } else if (x < this.maxScrollX) {\n        x = this.maxScrollX;\n      }\n\n      if (y > 0) {\n        y = 0;\n      } else if (y < this.maxScrollY) {\n        y = this.maxScrollY;\n      }\n\n      this.scrollTo(x, y, time);\n    },\n\n    _wheelZoom: function(e) {\n      var wheelDeltaY,\n        deltaScale,\n        that = this;\n\n      // Execute the zoomEnd event after 400ms the wheel stopped scrolling\n      clearTimeout(this.wheelTimeout);\n      this.wheelTimeout = setTimeout(function() {\n        that._execEvent('zoomEnd');\n      }, 400);\n\n      if ('deltaX' in e) {\n        wheelDeltaY = -e.deltaY / Math.abs(e.deltaY);\n      } else if ('wheelDeltaX' in e) {\n        wheelDeltaY = e.wheelDeltaY / Math.abs(e.wheelDeltaY);\n      } else if ('wheelDelta' in e) {\n        wheelDeltaY = e.wheelDelta / Math.abs(e.wheelDelta);\n      } else if ('detail' in e) {\n        wheelDeltaY = -e.detail / Math.abs(e.wheelDelta);\n      } else {\n        return;\n      }\n\n      deltaScale = this.scale + wheelDeltaY / 5;\n\n      this.zoom(deltaScale, e.pageX, e.pageY, 0);\n    },\n\n    _initWheel: function() {\n      utils.addEvent(this.wrapper, 'wheel', this);\n      utils.addEvent(this.wrapper, 'mousewheel', this);\n      utils.addEvent(this.wrapper, 'DOMMouseScroll', this);\n\n      this.on('destroy', function() {\n        utils.removeEvent(this.wrapper, 'wheel', this);\n        utils.removeEvent(this.wrapper, 'mousewheel', this);\n        utils.removeEvent(this.wrapper, 'DOMMouseScroll', this);\n      });\n    },\n\n    _wheel: function(e) {\n      if (!this.enabled) {\n        return;\n      }\n\n      e.preventDefault();\n      e.stopPropagation();\n\n      var wheelDeltaX,\n        wheelDeltaY,\n        newX,\n        newY,\n        that = this;\n\n      if (this.wheelTimeout === undefined) {\n        that._execEvent('scrollStart');\n      }\n\n      // Execute the scrollEnd event after 400ms the wheel stopped scrolling\n      clearTimeout(this.wheelTimeout);\n      this.wheelTimeout = setTimeout(function() {\n        that._execEvent('scrollEnd');\n        that.wheelTimeout = undefined;\n      }, 400);\n\n      if ('deltaX' in e) {\n        wheelDeltaX = -e.deltaX;\n        wheelDeltaY = -e.deltaY;\n      } else if ('wheelDeltaX' in e) {\n        wheelDeltaX = (e.wheelDeltaX / 120) * this.options.mouseWheelSpeed;\n        wheelDeltaY = (e.wheelDeltaY / 120) * this.options.mouseWheelSpeed;\n      } else if ('wheelDelta' in e) {\n        wheelDeltaX = wheelDeltaY = (e.wheelDelta / 120) * this.options.mouseWheelSpeed;\n      } else if ('detail' in e) {\n        wheelDeltaX = wheelDeltaY = (-e.detail / 3) * this.options.mouseWheelSpeed;\n      } else {\n        return;\n      }\n\n      wheelDeltaX *= this.options.invertWheelDirection;\n      wheelDeltaY *= this.options.invertWheelDirection;\n\n      if (!this.hasVerticalScroll) {\n        wheelDeltaX = wheelDeltaY;\n        wheelDeltaY = 0;\n      }\n\n      if (this.options.snap) {\n        newX = this.currentPage.pageX;\n        newY = this.currentPage.pageY;\n\n        if (wheelDeltaX > 0) {\n          newX--;\n        } else if (wheelDeltaX < 0) {\n          newX++;\n        }\n\n        if (wheelDeltaY > 0) {\n          newY--;\n        } else if (wheelDeltaY < 0) {\n          newY++;\n        }\n\n        this.goToPage(newX, newY);\n\n        return;\n      }\n\n      newX = this.x + Math.round(this.hasHorizontalScroll ? wheelDeltaX : 0);\n      newY = this.y + Math.round(this.hasVerticalScroll ? wheelDeltaY : 0);\n\n      if (newX > 0) {\n        newX = 0;\n      } else if (newX < this.maxScrollX) {\n        newX = this.maxScrollX;\n      }\n\n      if (newY > 0) {\n        newY = 0;\n      } else if (newY < this.maxScrollY) {\n        newY = this.maxScrollY;\n      }\n\n      this.scrollTo(newX, newY, 0);\n\n      // INSERT POINT: _wheel\n    },\n\n    _initSnap: function() {\n      this.currentPage = {};\n\n      if (typeof this.options.snap == 'string') {\n        this.options.snap = this.scroller.querySelectorAll(this.options.snap);\n      }\n\n      this.on('refresh', function() {\n        var i = 0,\n          l,\n          m = 0,\n          n,\n          cx,\n          cy,\n          x = 0,\n          y,\n          stepX = this.options.snapStepX || this.wrapperWidth,\n          stepY = this.options.snapStepY || this.wrapperHeight,\n          el;\n\n        this.pages = [];\n\n        if (\n          !this.wrapperWidth ||\n          !this.wrapperHeight ||\n          !this.scrollerWidth ||\n          !this.scrollerHeight\n        ) {\n          return;\n        }\n\n        if (this.options.snap === true) {\n          cx = Math.round(stepX / 2);\n          cy = Math.round(stepY / 2);\n\n          while (x > -this.scrollerWidth) {\n            this.pages[i] = [];\n            l = 0;\n            y = 0;\n\n            while (y > -this.scrollerHeight) {\n              this.pages[i][l] = {\n                x: Math.max(x, this.maxScrollX),\n                y: Math.max(y, this.maxScrollY),\n                width: stepX,\n                height: stepY,\n                cx: x - cx,\n                cy: y - cy\n              };\n\n              y -= stepY;\n              l++;\n            }\n\n            x -= stepX;\n            i++;\n          }\n        } else {\n          el = this.options.snap;\n          l = el.length;\n          n = -1;\n\n          for (; i < l; i++) {\n            if (i === 0 || el[i].offsetLeft <= el[i - 1].offsetLeft) {\n              m = 0;\n              n++;\n            }\n\n            if (!this.pages[m]) {\n              this.pages[m] = [];\n            }\n\n            x = Math.max(-el[i].offsetLeft, this.maxScrollX);\n            y = Math.max(-el[i].offsetTop, this.maxScrollY);\n            cx = x - Math.round(el[i].offsetWidth / 2);\n            cy = y - Math.round(el[i].offsetHeight / 2);\n\n            this.pages[m][n] = {\n              x: x,\n              y: y,\n              width: el[i].offsetWidth,\n              height: el[i].offsetHeight,\n              cx: cx,\n              cy: cy\n            };\n\n            if (x > this.maxScrollX) {\n              m++;\n            }\n          }\n        }\n\n        this.goToPage(this.currentPage.pageX || 0, this.currentPage.pageY || 0, 0);\n\n        // Update snap threshold if needed\n        if (this.options.snapThreshold % 1 === 0) {\n          this.snapThresholdX = this.options.snapThreshold;\n          this.snapThresholdY = this.options.snapThreshold;\n        } else {\n          this.snapThresholdX = Math.round(\n            this.pages[this.currentPage.pageX][this.currentPage.pageY].width *\n              this.options.snapThreshold\n          );\n          this.snapThresholdY = Math.round(\n            this.pages[this.currentPage.pageX][this.currentPage.pageY].height *\n              this.options.snapThreshold\n          );\n        }\n      });\n\n      this.on('flick', function() {\n        var time =\n          this.options.snapSpeed ||\n          Math.max(\n            Math.max(\n              Math.min(Math.abs(this.x - this.startX), 1000),\n              Math.min(Math.abs(this.y - this.startY), 1000)\n            ),\n            300\n          );\n\n        this.goToPage(\n          this.currentPage.pageX + this.directionX,\n          this.currentPage.pageY + this.directionY,\n          time\n        );\n      });\n    },\n\n    _nearestSnap: function(x, y) {\n      if (!this.pages.length) {\n        return {x: 0, y: 0, pageX: 0, pageY: 0};\n      }\n\n      var i = 0,\n        l = this.pages.length,\n        m = 0;\n\n      // Check if we exceeded the snap threshold\n      if (\n        Math.abs(x - this.absStartX) < this.snapThresholdX &&\n        Math.abs(y - this.absStartY) < this.snapThresholdY\n      ) {\n        return this.currentPage;\n      }\n\n      if (x > 0) {\n        x = 0;\n      } else if (x < this.maxScrollX) {\n        x = this.maxScrollX;\n      }\n\n      if (y > 0) {\n        y = 0;\n      } else if (y < this.maxScrollY) {\n        y = this.maxScrollY;\n      }\n\n      for (; i < l; i++) {\n        if (x >= this.pages[i][0].cx) {\n          x = this.pages[i][0].x;\n          break;\n        }\n      }\n\n      l = this.pages[i].length;\n\n      for (; m < l; m++) {\n        if (y >= this.pages[0][m].cy) {\n          y = this.pages[0][m].y;\n          break;\n        }\n      }\n\n      if (i == this.currentPage.pageX) {\n        i += this.directionX;\n\n        if (i < 0) {\n          i = 0;\n        } else if (i >= this.pages.length) {\n          i = this.pages.length - 1;\n        }\n\n        x = this.pages[i][0].x;\n      }\n\n      if (m == this.currentPage.pageY) {\n        m += this.directionY;\n\n        if (m < 0) {\n          m = 0;\n        } else if (m >= this.pages[0].length) {\n          m = this.pages[0].length - 1;\n        }\n\n        y = this.pages[0][m].y;\n      }\n\n      return {\n        x: x,\n        y: y,\n        pageX: i,\n        pageY: m\n      };\n    },\n\n    goToPage: function(x, y, time, easing) {\n      easing = easing || this.options.bounceEasing;\n\n      if (x >= this.pages.length) {\n        x = this.pages.length - 1;\n      } else if (x < 0) {\n        x = 0;\n      }\n\n      if (y >= this.pages[x].length) {\n        y = this.pages[x].length - 1;\n      } else if (y < 0) {\n        y = 0;\n      }\n\n      var posX = this.pages[x][y].x,\n        posY = this.pages[x][y].y;\n\n      time =\n        time === undefined\n          ? this.options.snapSpeed ||\n            Math.max(\n              Math.max(\n                Math.min(Math.abs(posX - this.x), 1000),\n                Math.min(Math.abs(posY - this.y), 1000)\n              ),\n              300\n            )\n          : time;\n\n      this.currentPage = {\n        x: posX,\n        y: posY,\n        pageX: x,\n        pageY: y\n      };\n\n      this.scrollTo(posX, posY, time, easing);\n    },\n\n    next: function(time, easing) {\n      var x = this.currentPage.pageX,\n        y = this.currentPage.pageY;\n\n      x++;\n\n      if (x >= this.pages.length && this.hasVerticalScroll) {\n        x = 0;\n        y++;\n      }\n\n      this.goToPage(x, y, time, easing);\n    },\n\n    prev: function(time, easing) {\n      var x = this.currentPage.pageX,\n        y = this.currentPage.pageY;\n\n      x--;\n\n      if (x < 0 && this.hasVerticalScroll) {\n        x = 0;\n        y--;\n      }\n\n      this.goToPage(x, y, time, easing);\n    },\n\n    _initKeys: function(e) {\n      // default key bindings\n      var keys = {\n        pageUp: 33,\n        pageDown: 34,\n        end: 35,\n        home: 36,\n        left: 37,\n        up: 38,\n        right: 39,\n        down: 40\n      };\n      var i;\n\n      // if you give me characters I give you keycode\n      if (typeof this.options.keyBindings == 'object') {\n        for (i in this.options.keyBindings) {\n          if (typeof this.options.keyBindings[i] == 'string') {\n            this.options.keyBindings[i] = this.options.keyBindings[i].toUpperCase().charCodeAt(0);\n          }\n        }\n      } else {\n        this.options.keyBindings = {};\n      }\n\n      for (i in keys) {\n        this.options.keyBindings[i] = this.options.keyBindings[i] || keys[i];\n      }\n\n      utils.addEvent(window, 'keydown', this);\n\n      this.on('destroy', function() {\n        utils.removeEvent(window, 'keydown', this);\n      });\n    },\n\n    _key: function(e) {\n      if (!this.enabled) {\n        return;\n      }\n\n      var snap = this.options.snap, // we are using this alot, better to cache it\n        newX = snap ? this.currentPage.pageX : this.x,\n        newY = snap ? this.currentPage.pageY : this.y,\n        now = utils.getTime(),\n        prevTime = this.keyTime || 0,\n        acceleration = 0.25,\n        pos;\n\n      if (this.options.useTransition && this.isInTransition) {\n        pos = this.getComputedPosition();\n\n        this._translate(Math.round(pos.x), Math.round(pos.y));\n        this.isInTransition = false;\n      }\n\n      this.keyAcceleration =\n        now - prevTime < 200 ? Math.min(this.keyAcceleration + acceleration, 50) : 0;\n\n      switch (e.keyCode) {\n        case this.options.keyBindings.pageUp:\n          if (this.hasHorizontalScroll && !this.hasVerticalScroll) {\n            newX += snap ? 1 : this.wrapperWidth;\n          } else {\n            newY += snap ? 1 : this.wrapperHeight;\n          }\n          break;\n        case this.options.keyBindings.pageDown:\n          if (this.hasHorizontalScroll && !this.hasVerticalScroll) {\n            newX -= snap ? 1 : this.wrapperWidth;\n          } else {\n            newY -= snap ? 1 : this.wrapperHeight;\n          }\n          break;\n        case this.options.keyBindings.end:\n          newX = snap ? this.pages.length - 1 : this.maxScrollX;\n          newY = snap ? this.pages[0].length - 1 : this.maxScrollY;\n          break;\n        case this.options.keyBindings.home:\n          newX = 0;\n          newY = 0;\n          break;\n        case this.options.keyBindings.left:\n          newX += snap ? -1 : (5 + this.keyAcceleration) >> 0;\n          break;\n        case this.options.keyBindings.up:\n          newY += snap ? 1 : (5 + this.keyAcceleration) >> 0;\n          break;\n        case this.options.keyBindings.right:\n          newX -= snap ? -1 : (5 + this.keyAcceleration) >> 0;\n          break;\n        case this.options.keyBindings.down:\n          newY -= snap ? 1 : (5 + this.keyAcceleration) >> 0;\n          break;\n        default:\n          return;\n      }\n\n      if (snap) {\n        this.goToPage(newX, newY);\n        return;\n      }\n\n      if (newX > 0) {\n        newX = 0;\n        this.keyAcceleration = 0;\n      } else if (newX < this.maxScrollX) {\n        newX = this.maxScrollX;\n        this.keyAcceleration = 0;\n      }\n\n      if (newY > 0) {\n        newY = 0;\n        this.keyAcceleration = 0;\n      } else if (newY < this.maxScrollY) {\n        newY = this.maxScrollY;\n        this.keyAcceleration = 0;\n      }\n\n      this.scrollTo(newX, newY, 0);\n\n      this.keyTime = now;\n    },\n\n    _animate: function(destX, destY, duration, easingFn) {\n      var that = this,\n        startX = this.x,\n        startY = this.y,\n        startTime = utils.getTime(),\n        destTime = startTime + duration;\n\n      function step() {\n        var now = utils.getTime(),\n          newX,\n          newY,\n          easing;\n\n        if (now >= destTime) {\n          that.isAnimating = false;\n          that._translate(destX, destY);\n\n          if (!that.resetPosition(that.options.bounceTime)) {\n            that._execEvent('scrollEnd');\n          }\n\n          return;\n        }\n\n        now = (now - startTime) / duration;\n        easing = easingFn(now);\n        newX = (destX - startX) * easing + startX;\n        newY = (destY - startY) * easing + startY;\n        that._translate(newX, newY);\n\n        if (that.isAnimating) {\n          rAF(step);\n        }\n      }\n\n      this.isAnimating = true;\n      step();\n    },\n    handleEvent: function(e) {\n      switch (e.type) {\n        case 'touchstart':\n        // Removed due to android double click bug where chrome introduced pointerdown and touchstart to all anchor events. GA-2044\n        // case 'pointerdown':\n        case 'MSPointerDown':\n        case 'mousedown':\n          this._start(e);\n\n          if (this.options.zoom && e.touches && e.touches.length > 1) {\n            this._zoomStart(e);\n          }\n          break;\n        case 'touchmove':\n        case 'pointermove':\n        case 'MSPointerMove':\n        case 'mousemove':\n          if (this.options.zoom && e.touches && e.touches[1]) {\n            this._zoom(e);\n            return;\n          }\n          this._move(e);\n          SCROLLING_MANAGER.pollIscrollScrolling(this.y);\n          $('#contentWrapperInnerL').trigger('iscroll');\n          break;\n        case 'touchend':\n        // Removed due to android double click bug where chrome introduced pointerdown and touchstart to all anchor events. GA-2044\n        // case 'pointerup':\n        case 'MSPointerUp':\n        case 'mouseup':\n        case 'touchcancel':\n        case 'pointercancel':\n        case 'MSPointerCancel':\n        case 'mousecancel':\n          if (this.scaled) {\n            this._zoomEnd(e);\n            return;\n          }\n          this._end(e);\n          break;\n        case 'orientationchange':\n        case 'resize':\n          this._resize();\n          break;\n        case 'transitionend':\n        case 'webkitTransitionEnd':\n        case 'oTransitionEnd':\n        case 'MSTransitionEnd':\n          this._transitionEnd(e);\n          break;\n        case 'wheel':\n        case 'DOMMouseScroll':\n        case 'mousewheel':\n          if (this.options.wheelAction == 'zoom') {\n            this._wheelZoom(e);\n            return;\n          }\n          this._wheel(e);\n          break;\n        case 'keydown':\n          this._key(e);\n          break;\n      }\n    }\n  };\n  function createDefaultScrollbar(direction, interactive, type) {\n    var scrollbar = document.createElement('div'),\n      indicator = document.createElement('div');\n\n    if (type === true) {\n      scrollbar.style.cssText = 'position:absolute;z-index:9999';\n      indicator.style.cssText =\n        '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:absolute;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);border-radius:3px';\n    }\n\n    indicator.className = 'iScrollIndicator';\n\n    if (direction == 'h') {\n      if (type === true) {\n        scrollbar.style.cssText += ';height:7px;left:2px;right:2px;bottom:0';\n        indicator.style.height = '100%';\n      }\n      scrollbar.className = 'iScrollHorizontalScrollbar';\n    } else {\n      if (type === true) {\n        scrollbar.style.cssText += ';width:7px;bottom:2px;top:2px;right:1px';\n        indicator.style.width = '100%';\n      }\n      scrollbar.className = 'iScrollVerticalScrollbar';\n    }\n\n    scrollbar.style.cssText += ';overflow:hidden';\n\n    if (!interactive) {\n      scrollbar.style.pointerEvents = 'none';\n    }\n\n    scrollbar.appendChild(indicator);\n\n    return scrollbar;\n  }\n\n  function Indicator(scroller, options) {\n    this.wrapper = typeof options.el == 'string' ? document.querySelector(options.el) : options.el;\n    this.wrapperStyle = this.wrapper.style;\n    this.indicator = this.wrapper.children[0];\n    this.indicatorStyle = this.indicator.style;\n    this.scroller = scroller;\n\n    this.options = {\n      listenX: true,\n      listenY: true,\n      interactive: false,\n      resize: true,\n      defaultScrollbars: false,\n      shrink: false,\n      fade: false,\n      speedRatioX: 0,\n      speedRatioY: 0\n    };\n\n    for (var i in options) {\n      this.options[i] = options[i];\n    }\n\n    this.sizeRatioX = 1;\n    this.sizeRatioY = 1;\n    this.maxPosX = 0;\n    this.maxPosY = 0;\n\n    if (this.options.interactive) {\n      if (!this.options.disableTouch) {\n        utils.addEvent(this.indicator, 'touchstart', this);\n        utils.addEvent(window, 'touchend', this);\n      }\n      if (!this.options.disablePointer) {\n        utils.addEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);\n        utils.addEvent(window, utils.prefixPointerEvent('pointerup'), this);\n      }\n      if (!this.options.disableMouse) {\n        utils.addEvent(this.indicator, 'mousedown', this);\n        utils.addEvent(window, 'mouseup', this);\n      }\n    }\n\n    if (this.options.fade) {\n      this.wrapperStyle[utils.style.transform] = this.scroller.translateZ;\n      this.wrapperStyle[utils.style.transitionDuration] = utils.isBadAndroid ? '0.001s' : '0ms';\n      this.wrapperStyle.opacity = '0';\n    }\n  }\n\n  Indicator.prototype = {\n    handleEvent: function(e) {\n      switch (e.type) {\n        case 'touchstart':\n        case 'pointerdown':\n        case 'MSPointerDown':\n        case 'mousedown':\n          this._start(e);\n          break;\n        case 'touchmove':\n        case 'pointermove':\n        case 'MSPointerMove':\n        case 'mousemove':\n          this._move(e);\n          break;\n        case 'touchend':\n        case 'pointerup':\n        case 'MSPointerUp':\n        case 'mouseup':\n        case 'touchcancel':\n        case 'pointercancel':\n        case 'MSPointerCancel':\n        case 'mousecancel':\n          this._end(e);\n          break;\n      }\n    },\n\n    destroy: function() {\n      if (this.options.interactive) {\n        utils.removeEvent(this.indicator, 'touchstart', this);\n        utils.removeEvent(this.indicator, utils.prefixPointerEvent('pointerdown'), this);\n        utils.removeEvent(this.indicator, 'mousedown', this);\n\n        utils.removeEvent(window, 'touchmove', this);\n        utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);\n        utils.removeEvent(window, 'mousemove', this);\n\n        utils.removeEvent(window, 'touchend', this);\n        utils.removeEvent(window, utils.prefixPointerEvent('pointerup'), this);\n        utils.removeEvent(window, 'mouseup', this);\n      }\n\n      if (this.options.defaultScrollbars) {\n        this.wrapper.parentNode.removeChild(this.wrapper);\n      }\n    },\n\n    _start: function(e) {\n      var point = e.touches ? e.touches[0] : e;\n\n      e.preventDefault();\n      e.stopPropagation();\n\n      this.transitionTime();\n\n      this.initiated = true;\n      this.moved = false;\n      this.lastPointX = point.pageX;\n      this.lastPointY = point.pageY;\n\n      this.startTime = utils.getTime();\n\n      if (!this.options.disableTouch) {\n        utils.addEvent(window, 'touchmove', this);\n      }\n      if (!this.options.disablePointer) {\n        utils.addEvent(window, utils.prefixPointerEvent('pointermove'), this);\n      }\n      if (!this.options.disableMouse) {\n        utils.addEvent(window, 'mousemove', this);\n      }\n\n      this.scroller._execEvent('beforeScrollStart');\n    },\n\n    _move: function(e) {\n      var point = e.touches ? e.touches[0] : e,\n        deltaX,\n        deltaY,\n        newX,\n        newY,\n        timestamp = utils.getTime();\n\n      if (!this.moved) {\n        this.scroller._execEvent('scrollStart');\n      }\n\n      this.moved = true;\n\n      deltaX = point.pageX - this.lastPointX;\n      this.lastPointX = point.pageX;\n\n      deltaY = point.pageY - this.lastPointY;\n      this.lastPointY = point.pageY;\n\n      newX = this.x + deltaX;\n      newY = this.y + deltaY;\n\n      this._pos(newX, newY);\n\n      // INSERT POINT: indicator._move\n\n      e.preventDefault();\n      e.stopPropagation();\n    },\n\n    _end: function(e) {\n      if (!this.initiated) {\n        return;\n      }\n\n      this.initiated = false;\n\n      e.preventDefault();\n      e.stopPropagation();\n\n      utils.removeEvent(window, 'touchmove', this);\n      utils.removeEvent(window, utils.prefixPointerEvent('pointermove'), this);\n      utils.removeEvent(window, 'mousemove', this);\n\n      if (this.scroller.options.snap) {\n        var snap = this.scroller._nearestSnap(this.scroller.x, this.scroller.y);\n\n        var time =\n          this.options.snapSpeed ||\n          Math.max(\n            Math.max(\n              Math.min(Math.abs(this.scroller.x - snap.x), 1000),\n              Math.min(Math.abs(this.scroller.y - snap.y), 1000)\n            ),\n            300\n          );\n\n        if (this.scroller.x != snap.x || this.scroller.y != snap.y) {\n          this.scroller.directionX = 0;\n          this.scroller.directionY = 0;\n          this.scroller.currentPage = snap;\n          this.scroller.scrollTo(snap.x, snap.y, time, this.scroller.options.bounceEasing);\n        }\n      }\n\n      if (this.moved) {\n        this.scroller._execEvent('scrollEnd');\n      }\n    },\n\n    transitionTime: function(time) {\n      time = time || 0;\n      this.indicatorStyle[utils.style.transitionDuration] = time + 'ms';\n\n      if (!time && utils.isBadAndroid) {\n        this.indicatorStyle[utils.style.transitionDuration] = '0.001s';\n      }\n    },\n\n    transitionTimingFunction: function(easing) {\n      this.indicatorStyle[utils.style.transitionTimingFunction] = easing;\n    },\n\n    refresh: function() {\n      this.transitionTime();\n\n      if (this.options.listenX && !this.options.listenY) {\n        this.indicatorStyle.display = this.scroller.hasHorizontalScroll ? 'block' : 'none';\n      } else if (this.options.listenY && !this.options.listenX) {\n        this.indicatorStyle.display = this.scroller.hasVerticalScroll ? 'block' : 'none';\n      } else {\n        this.indicatorStyle.display =\n          this.scroller.hasHorizontalScroll || this.scroller.hasVerticalScroll ? 'block' : 'none';\n      }\n\n      if (this.scroller.hasHorizontalScroll && this.scroller.hasVerticalScroll) {\n        utils.addClass(this.wrapper, 'iScrollBothScrollbars');\n        utils.removeClass(this.wrapper, 'iScrollLoneScrollbar');\n\n        if (this.options.defaultScrollbars && this.options.customStyle) {\n          if (this.options.listenX) {\n            this.wrapper.style.right = '8px';\n          } else {\n            this.wrapper.style.bottom = '8px';\n          }\n        }\n      } else {\n        utils.removeClass(this.wrapper, 'iScrollBothScrollbars');\n        utils.addClass(this.wrapper, 'iScrollLoneScrollbar');\n\n        if (this.options.defaultScrollbars && this.options.customStyle) {\n          if (this.options.listenX) {\n            this.wrapper.style.right = '2px';\n          } else {\n            this.wrapper.style.bottom = '2px';\n          }\n        }\n      }\n\n      var r = this.wrapper.offsetHeight; // force refresh\n\n      if (this.options.listenX) {\n        this.wrapperWidth = this.wrapper.clientWidth;\n        if (this.options.resize) {\n          this.indicatorWidth = Math.max(\n            Math.round(\n              (this.wrapperWidth * this.wrapperWidth) /\n                (this.scroller.scrollerWidth || this.wrapperWidth || 1)\n            ),\n            8\n          );\n          this.indicatorStyle.width = this.indicatorWidth + 'px';\n        } else {\n          this.indicatorWidth = this.indicator.clientWidth;\n        }\n\n        this.maxPosX = this.wrapperWidth - this.indicatorWidth;\n\n        if (this.options.shrink == 'clip') {\n          this.minBoundaryX = -this.indicatorWidth + 8;\n          this.maxBoundaryX = this.wrapperWidth - 8;\n        } else {\n          this.minBoundaryX = 0;\n          this.maxBoundaryX = this.maxPosX;\n        }\n\n        this.sizeRatioX =\n          this.options.speedRatioX ||\n          (this.scroller.maxScrollX && this.maxPosX / this.scroller.maxScrollX);\n      }\n\n      if (this.options.listenY) {\n        this.wrapperHeight = this.wrapper.clientHeight;\n        if (this.options.resize) {\n          this.indicatorHeight = Math.max(\n            Math.round(\n              (this.wrapperHeight * this.wrapperHeight) /\n                (this.scroller.scrollerHeight || this.wrapperHeight || 1)\n            ),\n            8\n          );\n          this.indicatorStyle.height = this.indicatorHeight + 'px';\n        } else {\n          this.indicatorHeight = this.indicator.clientHeight;\n        }\n\n        this.maxPosY = this.wrapperHeight - this.indicatorHeight;\n\n        if (this.options.shrink == 'clip') {\n          this.minBoundaryY = -this.indicatorHeight + 8;\n          this.maxBoundaryY = this.wrapperHeight - 8;\n        } else {\n          this.minBoundaryY = 0;\n          this.maxBoundaryY = this.maxPosY;\n        }\n\n        this.maxPosY = this.wrapperHeight - this.indicatorHeight;\n        this.sizeRatioY =\n          this.options.speedRatioY ||\n          (this.scroller.maxScrollY && this.maxPosY / this.scroller.maxScrollY);\n      }\n\n      this.updatePosition();\n    },\n\n    updatePosition: function() {\n      var x = (this.options.listenX && Math.round(this.sizeRatioX * this.scroller.x)) || 0,\n        y = (this.options.listenY && Math.round(this.sizeRatioY * this.scroller.y)) || 0;\n\n      if (!this.options.ignoreBoundaries) {\n        if (x < this.minBoundaryX) {\n          if (this.options.shrink == 'scale') {\n            this.width = Math.max(this.indicatorWidth + x, 8);\n            this.indicatorStyle.width = this.width + 'px';\n          }\n          x = this.minBoundaryX;\n        } else if (x > this.maxBoundaryX) {\n          if (this.options.shrink == 'scale') {\n            this.width = Math.max(this.indicatorWidth - (x - this.maxPosX), 8);\n            this.indicatorStyle.width = this.width + 'px';\n            x = this.maxPosX + this.indicatorWidth - this.width;\n          } else {\n            x = this.maxBoundaryX;\n          }\n        } else if (this.options.shrink == 'scale' && this.width != this.indicatorWidth) {\n          this.width = this.indicatorWidth;\n          this.indicatorStyle.width = this.width + 'px';\n        }\n\n        if (y < this.minBoundaryY) {\n          if (this.options.shrink == 'scale') {\n            this.height = Math.max(this.indicatorHeight + y * 3, 8);\n            this.indicatorStyle.height = this.height + 'px';\n          }\n          y = this.minBoundaryY;\n        } else if (y > this.maxBoundaryY) {\n          if (this.options.shrink == 'scale') {\n            this.height = Math.max(this.indicatorHeight - (y - this.maxPosY) * 3, 8);\n            this.indicatorStyle.height = this.height + 'px';\n            y = this.maxPosY + this.indicatorHeight - this.height;\n          } else {\n            y = this.maxBoundaryY;\n          }\n        } else if (this.options.shrink == 'scale' && this.height != this.indicatorHeight) {\n          this.height = this.indicatorHeight;\n          this.indicatorStyle.height = this.height + 'px';\n        }\n      }\n\n      this.x = x;\n      this.y = y;\n\n      if (this.scroller.options.useTransform) {\n        this.indicatorStyle[utils.style.transform] =\n          'translate(' + x + 'px,' + y + 'px)' + this.scroller.translateZ;\n      } else {\n        this.indicatorStyle.left = x + 'px';\n        this.indicatorStyle.top = y + 'px';\n      }\n    },\n\n    _pos: function(x, y) {\n      if (x < 0) {\n        x = 0;\n      } else if (x > this.maxPosX) {\n        x = this.maxPosX;\n      }\n\n      if (y < 0) {\n        y = 0;\n      } else if (y > this.maxPosY) {\n        y = this.maxPosY;\n      }\n\n      x = this.options.listenX ? Math.round(x / this.sizeRatioX) : this.scroller.x;\n      y = this.options.listenY ? Math.round(y / this.sizeRatioY) : this.scroller.y;\n\n      this.scroller.scrollTo(x, y);\n    },\n\n    fade: function(val, hold) {\n      if (hold && !this.visible) {\n        return;\n      }\n\n      clearTimeout(this.fadeTimeout);\n      this.fadeTimeout = null;\n\n      var time = val ? 250 : 500,\n        delay = val ? 0 : 300;\n\n      val = val ? '1' : '0';\n\n      this.wrapperStyle[utils.style.transitionDuration] = time + 'ms';\n\n      this.fadeTimeout = setTimeout(\n        function(val) {\n          this.wrapperStyle.opacity = val;\n          this.visible = +val;\n        }.bind(this, val),\n        delay\n      );\n    }\n  };\n\n  IScroll.utils = utils;\n\n  if (typeof module != 'undefined' && module.exports) {\n    module.exports = IScroll;\n  } else {\n    window.IScroll = IScroll;\n  }\n})(window, document, Math);\n"},function(t,n,e){e(0)(e(25))},function(t,n){t.exports="/* globals $, POPUP_MANANGER, EM, OUTPUT_MODE_CHECKER, SETTINGS_EXTRA, ANIMATOR_INTERFACE_2,\nINT_TRANSITION_TIMER, ISCROLL_INTERFACE, TOPIC_MANAGER, TEMPLATE_MANANGER, ASSET_RENDERER, OBJ_REF\nLOCALISER, CORE, DEBUG */\n\n/**\n * @title Last Page Visited\n * @description To be described.\n *\n *\n * @author GoMo\n * @version 2.0 17/12/12\n */\n\nvar LAST_PAGE_VISITIED_EXTRA = {\n  strObjID: 'The last page visitied extra',\n  strObjDescription: 'The extra responsible for showing the last page visited as set by the LMS',\n\n  _objCurrDOM: null,\n\n  _strCurrOutputModeClass: 'graphicalC',\n\n  _strCurrHelpLocation: null,\n\n  _strPopupTemplateID: 'lastPageVisitedPopupC',\n  _strCloseButtonID: 'closeLastPageVisitedPopupL',\n  _strContentWrapperID: 'lastPageVisitedContentWrapperL',\n\n  _htmBaseLastPageVisitedTemplate: null,\n\n  booPopupShown: false,\n  _booPopupVisible: false,\n\n  _domAssetReturnFocusItemElement: '',\n  _domCurrInsertionNode: '',\n\n  _objCurrLocationData: null,\n\n  popupLocaleTitle: 'LAST_PAGE_POPUP_TITLE',\n\n  handleEvent_primeDOMReferences: function(_objWhatDOM) {\n    this._objCurrDOM = _objWhatDOM;\n  },\n\n  handleEvent_outputModeChanged: function(_objOutputChangeData) {\n    this._strCurrOutputModeClass = _objOutputChangeData['strNewOutputMode'];\n  },\n\n  handleEvent_popupAnimationComplete: function() {\n    // Generic function for all Extras tidyup call\n  },\n\n  popupAnimationComplete: function(lastPageDomElement) {\n    if (!this._booPopupVisible) {\n      POPUP_MANANGER.unlockPopups();\n      this._cleanUpAndHide();\n    } else {\n      gomo.tabManager.focusModalContent(lastPageDomElement, '#lastPageVisitedPopupHolderL');\n    }\n  },\n\n  handleEvent_gotoLastLocation: function() {\n    EM.trigger('closePopup', {strPopupID: 'lastPageVisited'});\n\n    if (this._bookmarkedScreenIsLocked()) {\n      // Warn users when linking to locked screen\n      gomo.alertManager.create(\n        'warning',\n        false,\n        gomo.localiser.get('NAVIGATION_HIDDEN_SCREEN_WARNING'),\n        [{label: gomo.localiser.get('NAVIGATION_ERROR_CLOSE'), type: 'secondary', action: null}]\n      );\n      return;\n    }\n\n    EM.trigger('prepForTopicExit');\n    EM.trigger('preLoadTopicObject', {\n      strTopicID: this._objCurrLocationData['topicId'],\n      strScreenID: this._objCurrLocationData['pageId']\n    });\n    EM.trigger('loadTopicObject', {\n      strTopicID: this._objCurrLocationData['topicId'],\n      strScreenID: this._objCurrLocationData['pageId'],\n      _objActionData: {}\n    });\n    EM.trigger('postLoadTopicObject', {\n      strTopicID: this._objCurrLocationData['topicId'],\n      strScreenID: this._objCurrLocationData['pageId']\n    });\n  },\n\n  showPopup: function(_domWhatNodeToInsertInto, _objPopupData) {\n    this._getTemplateHTML();\n    this._domCurrInsertionNode = _domWhatNodeToInsertInto;\n    this._objCurrLocationData = _objPopupData['objLocationData'];\n\n    /* REFACTOR NOTE : this needs a cleaner method. Maybe in popupmanager */\n    if (OUTPUT_MODE_CHECKER.booIsIE8()) {\n      _domWhatNodeToInsertInto.style.display = 'block';\n    }\n\n    var _htmLastPagePopup = this._createLastPagePopupHTML();\n\n    if (window['SETTINGS_EXTRA']) {\n      _htmLastPagePopup = SETTINGS_EXTRA.parseForSettingsClasses(_htmLastPagePopup);\n    }\n\n    this._domCurrInsertionNode.innerHTML = _htmLastPagePopup;\n\n    EM.trigger('disableSwiping');\n\n    /* REFACTOR NOTE: put the default animator settings (pre _objAnimateData)into\n     * a global object in config. Then place an object at the top of this class\n     * with overrides. These overrides can then be altered per project with a\n     * config_override.js\n     **/\n    if (\n      this._strCurrOutputModeClass != 'accessibleC' &&\n      OUTPUT_MODE_CHECKER.canHandleAnimationType(this._strAnimationAsset)\n    ) {\n      $(this._domCurrInsertionNode).velocity(\n        {\n          translateY: '9999px'\n        },\n        {\n          delay: 0,\n          duration: 0\n        }\n      );\n\n      this._booPopupVisible = true;\n\n      var _strTransition = 'gomo.verticalPopupSlideShowNormal';\n      var lastPageDomElement = this._domCurrInsertionNode;\n      var funComplete = function() {\n        LAST_PAGE_VISITIED_EXTRA.popupAnimationComplete(lastPageDomElement);\n      };\n      ANIMATOR_INTERFACE_2.assignRegisteredAnimation(this._domCurrInsertionNode, _strTransition, {\n        duration: INT_TRANSITION_TIMER,\n        complete: funComplete\n      });\n    }\n\n    this.booPopupShown = true;\n  },\n\n  hidePopup: function() {\n    if (\n      this._strCurrOutputModeClass != 'accessibleC' &&\n      OUTPUT_MODE_CHECKER.canHandleAnimationType(this._strAnimationAsset)\n    ) {\n      if (this._booPopupVisible) {\n        this._booPopupVisible = false;\n\n        var _strTransition = 'gomo.verticalPopupSlideHideNormal';\n        var funComplete = function() {\n          LAST_PAGE_VISITIED_EXTRA.popupAnimationComplete();\n        };\n        ANIMATOR_INTERFACE_2.assignRegisteredAnimation(this._domCurrInsertionNode, _strTransition, {\n          duration: INT_TRANSITION_TIMER,\n          complete: funComplete\n        });\n      }\n    } else {\n      POPUP_MANANGER.unlockPopups();\n      this._cleanUpAndHide();\n    }\n\n    /* REFACTOR NOTE : this needs a cleaner method. Maybe in popupmanager */\n    if (OUTPUT_MODE_CHECKER.booIsIE8()) {\n      this._domCurrInsertionNode.style.display = 'none';\n    }\n\n    EM.trigger('enableSwipe');\n  },\n\n  _cleanUpAndHide: function() {\n    if (this._domCurrInsertionNode) {\n      if (typeof ISCROLL_INTERFACE != 'undefined') {\n        ISCROLL_INTERFACE.recycleScroller(this._domCurrInsertionNode);\n      }\n      this._domCurrInsertionNode.innerHTML = '';\n      this._domCurrInsertionNode = null;\n      this.booPopupShown = false;\n    }\n  },\n\n  _getTemplateHTML: function() {\n    this._htmBaseLastPageVisitedTemplate = TEMPLATE_MANANGER.getTemplate(\n      this._strPopupTemplateID\n    ).htmData;\n  },\n\n  _createLastPagePopupHTML: function() {\n    var _htmLastPagePopup = this._htmBaseLastPageVisitedTemplate;\n    var _htmLastPageDetails = this._generateLastPagePopupMessage();\n    _htmLastPagePopup = _htmLastPagePopup.replace(\n      'XX_LAST_PAGE_LOCATION_XX',\n      ASSET_RENDERER.insertFormattedHtml(_htmLastPageDetails)\n    );\n    return _htmLastPagePopup;\n  },\n\n  _generateLastPagePopupMessage: function() {\n    var _strCourseObjectID = this._objCurrLocationData['topicId'];\n    var _strTopicTitle = this._objCurrLocationData['topicTitle'] ||\n    this._getBookmarkedTopicTitle(_strCourseObjectID);\n    var _strScreenTitle = this._objCurrLocationData['pageTitle'];\n\n    return (\n      '<p class=\"last-page-modal__topic-wrapper\">' +\n      '<b class=\\'last-page-modal__section-title\\'>' +\n      LOCALISER.get('LAST_PAGE_VISITIED_TOPIC_TITLE') +\n      ' </b>' +\n      '<span class=\\'lastPageVisitedLocationC last-page-modal__section-name\\'>' +\n      unescape(_strTopicTitle) +\n      '</span>' +\n      '</p>' +\n      '<p class=\"last-page-modal__screen-wrapper\">' +\n      '<b class=\\'last-page-modal__section-title\\'>' +\n      LOCALISER.get('LAST_PAGE_VISITIED_PAGE_TITLE') +\n      ' </b>' +\n      '<span class=\\'lastPageVisitedLocationC last-page-modal__section-name\\'>' +\n      unescape(_strScreenTitle) +\n      '</span>' +\n      '</p>'\n    );\n  },\n\n  _getBookmarkedTopicTitle: function(_strCourseObjectID) {\n    var _objTheTopic = CORE.objCourseData.findTopic(_strCourseObjectID);\n    if (_objTheTopic) {\n      // REFACTOR NOTE: this needs to be updated when we have dynamic\n      // loading from server in the Player\n      if (_objTheTopic.booTopicLoaded == false) {\n        var objTopicData = TOPIC_MANAGER.getTopicDataFromUnloadedTopic(_objTheTopic);\n        if (\n          typeof objTopicData != 'undefined' &&\n          typeof objTopicData.topic != 'undefined' &&\n          typeof objTopicData.topic.strTitle != 'undefined'\n        ) {\n          return objTopicData.topic.strTitle;\n        }\n      }\n      return _objTheTopic.strTitle;\n    }\n    return '';\n  },\n\n  _bookmarkedScreenIsLocked: function() {\n    TOPIC_MANAGER.silentlyLoadTopicObject({strTopicID: this._objCurrLocationData['topicId']});\n    var targetObject = OBJ_REF.get(this._objCurrLocationData['pageId']);\n    return !targetObject.booIsDisplayed;\n  },\n\n  _focusPopup: function() {\n    if (!OUTPUT_MODE_CHECKER.isIOSDevice()) {\n      this._objCurrDOM.getElementById(this._strCloseButtonID).focus();\n    } else {\n      var _domContentWrapper = this._objCurrDOM.getElementById(this._strContentWrapperID);\n      if (typeof ISCROLL_INTERFACE != 'undefined') {\n        ISCROLL_INTERFACE.parseChildDOMElements(_domContentWrapper);\n      }\n    }\n  },\n\n  debug: function(strMessage, intPriority, objCallerObject, booCalleeChain) {\n    if (DEBUG) {\n      DEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n    }\n  }\n};\n\nEM.register(LAST_PAGE_VISITIED_EXTRA);\nPOPUP_MANANGER.registerPopup('lastPageVisited', LAST_PAGE_VISITIED_EXTRA);\n"},function(t,n,e){e(0)(e(27))},function(t,n){t.exports='/**\n* @title Local Storage Interface\n* @description Simple cla$$ to make sure that we have control over all local storage and clean \n* up anything we don\'t need.\n*\n* There is a _clearTemporaryLocalStorage() function that gets run by core on starting \n* and ending course interation.\n* This removes the temporary files. To keep a file in browser storage, \n* set the _booPermanent argument to true when setting data setValue(_strKey, _strValue, _booPermanent).\n*\n* @author James Hough\n* @version 1.0 14/05/13\n*/\n\nvar LOCAL_STORAGE_INTERFACE =\n{\n\tbooLocalStorageSupported : null,\n\t_strStorageKeySeperator : "|=|",\n\t_objLocalStorageData : {},\n\t_strStorageLocation : null,\n\t\n\tinit : function()\n\t{\n\t\tif (!this.booLocalStorageSupported)\n\t\t{\n\t\t\tthis.booLocalStorageSupported = this._isStorageSupported();\n\t\t}\n\t\tthis._strStorageLocation = this._getStorageLocation();\n\t},\n\t\n\tsetValue : function( _strKey, _strValue, _booPermanent )\n\t{\n\t\t//If required a storage request can be made permanent to prevent cleanup of temp files on exit.\n\t\tif(_booPermanent == null || _booPermanent == false)\n\t\t{\n\t\t\tvar _strPermanent = "permanent=false";\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar _strPermanent = "permanent=true";\n\t\t}\n\t\t\n\t\tif(this._objLocalStorageData == null || this._objLocalStorageData[_strKey] == null)\n\t\t{\n\t\t\tthis._objLocalStorageData[_strKey] = new LocalStorageData();\n\t\t}\n\t\t\t\t\n\t\tif (BOO_HTML_LOCAL_STORAGE)\n\t\t{\n\t\t\tif (BOO_HTML_LOCAL_STORAGE)\n\t\t\t{\n\t\t\t\tthis._setLocalStorage(_strKey, _strValue, _strPermanent);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t//console.log( "Local Storage is switched off in \\nFile: config.js \\nVariable: BOO_HTML_LOCAL_STORAGE " );\n\t\t\t}\n\t\t}\n\t},\n\t\n\t_setLocalStorage : function (_strKey, _strValue, _strPermanent)\n\t{\n\t\tif (this.booLocalStorageSupported)\n\t\t{\t\n\t\t\tvar _strDateString = new Date().getTime().toString();\n\t\t\t\t\n\t\t\ttry\n\t\t\t{\n\t\t\t\tthis._removePreviousDataForKey(_strKey);\n\t\t\t\twindow.localStorage[this._strStorageLocation + this._strStorageKeySeperator + _strKey + this._strStorageKeySeperator + _strDateString + this._strStorageKeySeperator + _strPermanent] = _strValue;\n\t\t\t\tthis._objLocalStorageData[_strKey] = _strValue;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tcatch (_objError)\n\t\t\t{\n\t\t\t\tvar _booResult = window.confirm(LOCALISER.get("LOCAL_STORAGE_SAVE_ERROR"));\n\t\t\t\tif (_booResult)\n\t\t\t\t{\n\t\t\t\t\tthis._clearAllLocalStorage();\n\t\t\t\t\tthis._setLocalStorage(_strKey, _strValue);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t\n\tgetLocalStorage : function (_strKey)\n\t{\n\t\tvar _arrMatchingDatestamps = [];\n\t\tvar _arrStorageObjKeys = []; \n\t\t\n\t\tfor (var _strCurrKey in window.localStorage)\n\t\t{\n\t\t\tvar _strCurrKeyLocationSplit = _strCurrKey.split(this._strStorageKeySeperator)[0];\n\t\t\tvar _strCurrKeyStorageKeySplit = _strCurrKey.split(this._strStorageKeySeperator)[1];\n\t\t\tvar _strCurrKeyDateStampSplit = _strCurrKey.split(this._strStorageKeySeperator)[2];\n\t\t\t\n\t\t\tif (_strCurrKeyLocationSplit == this._strStorageLocation && _strCurrKeyStorageKeySplit == _strKey)\n\t\t\t{\n\t\t\t\t_arrMatchingDatestamps.push(_strCurrKeyDateStampSplit);\n\t\t\t\t_arrStorageObjKeys[_strCurrKeyDateStampSplit] = _strCurrKey;\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t\tvar _strLatestStorageDate = Math.max.apply( Math, _arrMatchingDatestamps );\n\t\tvar _strLatestStorage = window.localStorage.getItem(_arrStorageObjKeys[_strLatestStorageDate]);\n\t\t\t\t\t\t\n\t\treturn _strLatestStorage;\n\t},\n\t\n\t_isStorageSupported : function()\n\t{\n\t\tif ( typeof(Storage) !== "undefined" )\n\t\t{\n\t\t\tif(OUTPUT_MODE_CHECKER.isRunningFromFile() && navigator.appVersion.indexOf("MSIE") > -1)\n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t//console.log("WARNING: Browser Local Storage is not supported. Warning message created in TRACKING_BACKUP._isStorageSupported(), tracking_local_backup.js");\n\t\t\treturn false;\n\t\t}\n\t},\n\t\n\t_removePreviousDataForKey : function(_strKey)\n\t{\n\t\tfor (var _strCurrKey in window.localStorage)\n\t\t{\n\t\t\tvar _strCurrKeyLocationSplit = _strCurrKey.split(this._strStorageKeySeperator)[0];\n\t\t\tvar _strCurrKeyStorageKeySplit = _strCurrKey.split(this._strStorageKeySeperator)[1];\n\t\t\tif (_strCurrKeyLocationSplit == this._strStorageLocation && _strCurrKeyStorageKeySplit == _strKey)\n\t\t\t{\n\t\t\t\twindow.localStorage.removeItem(_strCurrKey);\n\t\t\t}\n\t\t}\n\t},\n\t\n\t_clearTemporaryLocalStorage : function ()\n\t{\n\t\tfor (var _strCurrKey in window.localStorage)\n\t\t{\n\t\t\tvar _strCurrKeyLocationSplit = _strCurrKey.split(this._strStorageKeySeperator)[0];\n\t\t\tvar _strCurrKeyStrPermanent = _strCurrKey.split(this._strStorageKeySeperator)[3];\n\t\t\tif(_strCurrKeyLocationSplit == this._strStorageLocation && _strCurrKeyStrPermanent == "permanent=false")\n\t\t\t{\n\t\t\t\twindow.localStorage.removeItem(_strCurrKey);\n\t\t\t}\n\t\t}\n\t},\n\t\n\t_clearAllLocalStorage : function ()\n\t{\n\t\tfor (var _strCurrKey in window.localStorage)\n\t\t{\n\t\t\twindow.localStorage.removeItem(_strCurrKey);\n\t\t}\n\t},\n\t\n\t_getStorageLocation : function ()\n\t{\n\t\t//get the url without the screen_size_manager.htm or index.htm appended so the data can be used across the project\n\t\t\tvar _strStorageLocation = escape(document.location);\n\t\t\tvar _arrLocationPath = document.location.pathname.split( \'/\' );\n\t\t\tvar _strLocationPage = _arrLocationPath[_arrLocationPath.length - 1];\t\t\t\n\t\t\t_strStorageLocation = _strStorageLocation.replace(_strLocationPage, \'\');\n\t\t\t\n\t\t\treturn _strStorageLocation;\n\t}\n\t\n};\n\nfunction LocalStorageData()\n{\n    this.strStatus = null;\n    this.strData = null;\n    this.intDateStamp = null;\n};\n\nLOCAL_STORAGE_INTERFACE.init();'},function(t,n,e){e(0)(e(29))},function(t,n){t.exports='/**\n* @title Swipe Control\n* @description The object detects and interprets swipe motions with\n* either touch or mouse gestures.  Can be disabled entirely by setting\n* the BOO_ENABLE_SWIPE constant to false in config.js, and similarly,\n* just the menu swiping can be disabled by changing the value of BOO_ENABLE_SWIPE_MENU.\n*\n* @author ChrisTeb\n* @version 2.0 18-04-12\n*/\n\nvar SWIPE_CONTROL =\n{\n\tstrObjID : "Swipe Control",\n\tstrObjDescription : "Handles navigation from page to page with a swipe motion",\n\n\t_intMouseSwipeStartX : 0,\n\t_intMouseSwipeStartY : 0,\n\n\t_objWhatDOM : null,\n\n\t// ************* Start Configuration *************\n\n\t// The minimum proportion of the page that should be swiped across to activate the navigation (decimal)\n\t_decRequiredMoveAmount : 1 / 3,\n\n\t// The maximum angle (0-90, against the baseline) that should register as a horizontal swipe, if this function is expanded in the future to handle vertical events, this will become redundant as it will have to default to 45 degrees\n\t_intHorizontalBoundaryAngle : 30,\n\t_intVerticalBoundaryAngle : 60,\n\n\t// Button IDs\n\t_strSkipButton : \'skipButtonL\',\n\t_strPageWrapper : \'pageWrapperL\',\n\t_strMenuId : \'menuItemsL\',\n\n\t// [id] is the portion of the menu link\'s ID that is substituted with the topic ID\n\t_strMenuItem : \'menuItem[id]L\',\n\t_intTrackingStateComplete : INT_COMPLETED,\n\n\t_strDisabledClass : \'disabled\',\n\n\t_strCurrTopicModel : "",\n\n\t// Used to remove the swipe functionality temporarly. (JC 30-04-2012)\n\t_booSwipeEnabled : true,\n\n\t//Blacklists certain elements from being the target element of a swipe gesture.\n\t_objBlackListedTargetElements :\n\t{\n\t\t"textarea" : true,\n\t\t"select": true,\n\t\t"option": true,\n\t\t"video" : true\n\t},\n\n\t_objBlackListedElementIds : {},\n\n\t_objBlackListedElementClassnames : {},\n\n\thandleEvent_primeDOMReferences : function(_objWhatDOM)\n\t{\n\t\tthis._objWhatDOM = _objWhatDOM;\n\t},\n\n\thandleEvent_setTopicModelType : function (_strWhatTopicModel)\n\t{\n\t\tthis._strCurrTopicModel = _strWhatTopicModel;\n\t},\n\n\thandleEvent_menuButtonClicked : function ()\n\t{\n\t\tthis._strCurrTopicModel = "";\n\t},\n\n\thandleEvent_disableSwiping : function()\n\t{\n\t\tthis._booSwipeEnabled = false;\n\t},\n\n\thandleEvent_enableSwipe : function()\n\t{\n\t\tthis._booSwipeEnabled = true;\n\t},\n\n\tdisableSwipingOnElementId : function(_strElementId)\n\t{\n\t\tthis._objBlackListedElementIds[_strElementId] = true;\n\t},\n\n\tdisableSwipingOnElementClassname : function(_strElementClassname)\n\t{\n\t\tthis._objBlackListedElementClassnames[_strElementClassname] = true;\n\t},\n\n\t// Nothing else should need to be edited on a project to project basis from here on in...\n\n\t// ************* Start Public Methods *************\n\n\t// Function called as mouse is depressed or finger first touches screen, stores initial scrolling positions\n\t// May be called from the CORE._addAdditionalEvents() bindings OR the ISCROLL_INTERFACE._addIScroll() onBeforeScrollStart override\n\t//\n\t// Accepts 1 parameter:\n\t//  - The event object\n\t//\n\t// Returns: Nothing\n\t// Proceeds to: Nothing\n\tstartSwipeGesture : function (e)\n\t{\n\t\t//WBI.log("SWIPE_CONTROL.startSwipeGesture()");\n\t\tif ((this[\'strObjID\']) && (this[\'strObjID\'] == "strObjID"))\n\t\t{\n\t\t\tvar _objThis = this;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar _objThis = SWIPE_CONTROL;\n\t\t}\n\n\t\t//console.log("Swipe test start...");\n\t\tif(!_objThis._checkBlackListedElements(e))\n\t\t{\n\t\t\t_objThis._intMouseSwipeStartX = _objThis._getPosition(e, \'X\');\n\t\t\t_objThis._intMouseSwipeStartY = _objThis._getPosition(e, \'Y\');\n\t\t}\n\t},\n\n\t// Function called as mouse is released or finger leaves the screen to calculate distance, direction and angle\n\t// May be called from the CORE._addAdditionalEvents() bindings OR the ISCROLL_INTERFACE._addIScroll() onBeforeScrollStart override\n\t//\n\t// Accepts 1 parameter:\n\t//  - The event object\n\t//\n\t// Returns: Nothing\n\t// Proceeds to: this._handleSwipe()\n\tendSwipeGesture : function (e)\n\t{\n\t\t//WBI.log("SWIPE_CONTROL.endSwipeGesture() - START");\n\t\tif ((this[\'strObjID\']) && (this[\'strObjID\'] == "strObjID"))\n\t\t{\n\t\t\tvar _objThis = this;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar _objThis = SWIPE_CONTROL;\n\t\t}\n\t\t//WBI.log("SWIPE_CONTROL.endSwipeGesture() - ABOUT TO CHECK");\n\n\t\t//this._invokeDOM();\n\t\tif(!_objThis._checkBlackListedElements(e))\n\t\t{\n\t\t\t// Compare start and finish positions\n\t\t\tvar _intMouseSwipeEndX = _objThis._getPosition(e, \'X\');\n\t\t\tvar _intMouseSwipeEndY = _objThis._getPosition(e, \'Y\');\n\n\t\t\t//console.log("_objThis._intMouseSwipeStartX: " + _objThis._intMouseSwipeStartX + "\\n_objThis._intMouseSwipeStartY: " + _objThis._intMouseSwipeStartY + "\\n_intMouseSwipeEndX: " + _intMouseSwipeEndX + "\\n_intMouseSwipeEndY: " + _intMouseSwipeEndY);\n\n\t\t\tvar _intDiffX = _intMouseSwipeEndX - _objThis._intMouseSwipeStartX;\n\t\t\tvar _intDiffY = _intMouseSwipeEndY - _objThis._intMouseSwipeStartY;\n\n\t\t\t// Calculate the angle of the swipe against the baseline, this could probably be done without so much trigonometry, but at least it\'s accurate\n\t\t\tvar _decAngle = Math.atan2(Math.abs(_intDiffY), Math.abs(_intDiffX));\n\t\t\t_decAngle *= 180 / Math.PI;\n\n\t\t\t// Calculate the proportion of the page the swipe went across\n\t\t\tvar _intPageWidth = _objThis._getWindowSize("Width");\n\t\t\tvar _decHowFarMovedX = Math.abs(_intDiffX) / _intPageWidth;\n\t\t\tvar _intPageHeight = _objThis._getWindowSize("Height");\n\t\t\tvar _decHowFarMovedY = Math.abs(_intDiffY) / _intPageHeight;\n\n\t\t\t//WBI.log("Guestimated page width: " + _intPageWidth + "\\n_decHowFarMoved: " + _decHowFarMoved);\n\t\t\tvar _intScreenSizerWidth = _objThis._getWindowSize("Width");\n\t\t\t//alert("Guestimated page width: " + _intPageWidth + "\\n_decHowFarMoved: " + _decHowFarMoved + "\\n_intScreenSizerWidth: " + _intScreenSizerWidth);\n\n\t\t\t_objThis._handleSwipe(_decAngle, _decHowFarMovedX, _decHowFarMovedY, _intDiffX, _intDiffY);\n\t\t}\n\t\t//WBI.log("SWIPE_CONTROL.endSwipeGesture() - ALL COMPLETE?");\n\t},\n\n\t// ************* Start Private Methods *************\n\n\t// Function to get X or Y position of the mouse cursor or touch event.  This function can be expanded with further options if we come across any devices with inconsistent data for these events.  Use object detection, rather that checking against navigator.userAgent for this.\n\t//\n\t// Accepts 2 parameters:\n\t//  - The event object\n\t//  - The axis required\n\t//\n\t// Returns: Single axis position of the touch or mouse event, or 0 if the object does not contain the expected data\n\t// Proceeds to: Nothing\n\n\t_getWindowSize : function(_strWhatAxis)\n\t{\n\t\tvar _intWinSize = 0;\n\n\t\tif (typeof(window.innerWidth) == \'number\')\n\t\t{\n\t\t\t//alert("window.innerWidth")\n\t\t\t//Non-IE\n\t\t\t_intWinSize = window["inner" + _strWhatAxis];\n\t\t}\n\t\telse if ((document.documentElement) && (document.documentElement.clientHeight))\n\t\t{\n\t\t\t//alert("document.documentElement.clientHeight")\n\t\t\t//IE 6+ in \'standards compliant mode\'\n\t\t\t_intWinSize = document.documentElement["client" + _strWhatAxis];\n\t\t}\n\t\telse if ((document.body) && (document.body.clientHeight))\n\t\t{\n\t\t\t//alert("document.body.clientHeight")\n\t\t\t//IE 4 compatible\n\t\t\t_intWinSize = document.body["client" + _strWhatAxis];\n \t\t}\n \t\treturn _intWinSize;\n\t},\n\n\t_getPosition : function(e, axis)\n\t{\n\t\tif (typeof(e.changedTouches) != \'undefined\')\n\t\t{\n\t\t\treturn e.changedTouches[0][\'page\' + axis];\n\t\t}\n\t\telse if (typeof(e.clientY) != \'undefined\')\n\t\t{\n\t\t\treturn e[\'client\' + axis];\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t},\n\n\n\t// Handles swipe events based on supplied criteria after it has been calculated by endSwipeGesture()\n\t//\n\t// Accepts 4 parameters:\n\t//  - The angle of the swipe relative to the baseline (always positive from 0-90, 0 = baseline, 90 = vertical)\n\t//  - The proportion of the swipe relative to the width of the learning\n\t//  - The distance moved across the X axis\n\t//  - The distance moved across the Y axis (currently unused, included for possible future use)\n\t//\n\t// Returns: Nothing\n\t// Proceeds to: this._activateButton()\n\n\t_handleSwipe : function (_decAngle, _decHowFarMovedX, _decHowFarMovedY, _intDiffX, _intDiffY)\n\t{\n\t\tif (BOO_ENABLE_SWIPE && this._booSwipeEnabled)\n\t\t{\n\t\t\t// Have the thresholds been met?\n\t\t\tif (_decAngle < this._intHorizontalBoundaryAngle && _decHowFarMovedX > this._decRequiredMoveAmount)\n\t\t\t{\n\t\t\t\tif (_intDiffX > 0)\n\t\t\t\t{\n\t\t\t\t\tEM.trigger(\'swipeRight\');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tEM.trigger(\'swipeLeft\');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (_decAngle > this._intVerticalBoundaryAngle && _decHowFarMovedY > this._decRequiredMoveAmount)\n\t\t\t{\n\t\t\t\tif (_intDiffY < 0)\n\t\t\t\t{\n\t\t\t\t\tEM.trigger(\'swipeUp\');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tEM.trigger(\'swipeDown\');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\t\n\n\t_checkBlackListedElements : function (_domElement)\n\t{\n\t\tvar _booReturn = false;\n\n\t\tif (this._checkTargetInBlackListedTargetElements(_domElement))\n\t\t{\n\t\t\t_booReturn = true;\n\t\t};\n\t\tif (this._checkTargetInBlackListedElementIds(_domElement))\n\t\t{\n\t\t\t_booReturn = true;\n\t\t};\n\t\tif (this._checkTargetInBlackListedElementClassnames(_domElement))\n\t\t{\n\t\t\t_booReturn = true;\n\t\t};\n\n\t\treturn _booReturn;\n\t},\n\n\t// Checks if the target element of the event has been blacklisted.\n\t//\n\t// Accepts 1 parameter:\n\t//  - The event\n\t//\n\t// Returns: Boolean\n\t_checkTargetInBlackListedTargetElements : function(_domElement)\n\t{\n\t\t_objTarget = _domElement.target;\n\t\tif(!_objTarget)\n\t\t{\n\t\t\t_objTarget = _domElement.srcElement;\n\t\t}\n\t\tif(_objTarget.nodeType == 3)\n\t\t{\n\t\t\t_objTarget = _objTarget.parentNode;\n\t\t}\n\t\tif (this._objBlackListedTargetElements[_objTarget.tagName.toLowerCase()])\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_checkTargetInBlackListedElementIds : function(_domElement)\n\t{\n\t\t_objTarget = _domElement.target;\n\t\tif(!_objTarget)\n\t\t{\n\t\t\t_objTarget = _domElement.srcElement;\n\t\t}\n\t\tif (this._objBlackListedElementIds[_objTarget.id])\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t},\n\n\t_checkTargetInBlackListedElementClassnames : function(_domElement)\n\t{\n\t\t_objTarget = _domElement.target;\n\t\tif(!_objTarget)\n\t\t{\n\t\t\t_objTarget = _domElement.srcElement;\n\t\t}\n\t\tif (this._objBlackListedElementClassnames[_objTarget.className])\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n};\n\nEM.register(SWIPE_CONTROL);\n\n// Event listeners are not used in favour of attaching onmouseup, onmousedown, ontouchstart and ontouchend events to the <body> tag, as the event object does not appear to be parsed into the functions otherwise.'},function(t,n,e){e(0)(e(31))},function(t,n){t.exports="/* globals EM, LogManager, DISPLAY_CONDITIONS_INTERACTIONS, CONTENT_TRACKING, TEMPLATE_MANANGER,\nTOPIC_INTERACTIONS, CORE, $, _, PREVIEW_DATA, SUB_SCREEN_INTERACTIONS */\n/**\n * @title The variables holder\n * @description An object to recieve, store, parse objects for and store references to runtime\n *              variables\n *\n * @author JohnC\n * @version 1.0 7/6/13\n */\n\nvar VARIABLES_HOLDER = {\n  strObjID: 'The variables holder',\n  strObjDescription:\n    'An object to recieve, store, parse objects for and store references too runtime variables',\n\n  _objCurrDOM: null,\n\n  _arrRawVariables: null,\n  _objSourceVariablesHash: {},\n  _objVariablesHash: {},\n  _objAssetVariables: {},\n\n  _objSystemVariablesHash: {\n    gomo_accessibility_state: 'false',\n    gomo_device_type: 'desktop',\n    gomo_course_completion_percentage: '0',\n    gomo_course_completion: 'null',\n    gomo_course_score: 'null'\n  },\n  // object containing persisted variables and callback functions\n  _objPersistedVariables: {\n    gomo_active_language: 'applyActiveLanguageAsTranslation'\n  },\n\n  _strGroupVariablesRenderArtifactID: 'groupVariablesRenderArtifactC',\n  _strVariableInsertPrefix: '{{',\n  _strVariableInsertSuffix: '}}',\n\n  _strVariableEntityClassNamePrefix: 'groupVar_',\n  _strVariableEntityClassNameSuffix: '_C',\n\n  _strImagePathVariablePrefix: '?variable_image_path_',\n  _strBaseImageFilenamePrefix: 'baseFilename=',\n\n  _strDynamicVariableKey1: 'DYNAMIC_VARIABLE_',\n  _strDynamicVariableKey2: 'DYNAMIC_VALUE_',\n  _strCurrDynamicVariableSuffix: 'AR',\n\n  _strInteractedAssetStatePrefix: 'gomo_asset_interacted',\n  _strQuestionAssetStatePrefix: 'gomo_asset_correct',\n  _strCompletedAssetStatePrefix: 'gomo_asset_completed',\n\n  _strTopicIncorrectQuestionsStatePrefix: 'gomo_topic_incorrect_questions',\n  _strTopicCorrectQuestionsStatePrefix: 'gomo_topic_score',\n  _strTopicScoreAsPercentStatePrefix: 'gomo_topic_score_as_percent',\n  _strTopicCompletionPrefix: 'gomo_topic_completion',\n\n  _strScreenStatusPrefix: 'gomo_screen_status',\n  _strScreenCorrectPrefix: 'gomo_screen_correct',\n\n  handleEvent_primeDOMReferences: function(_objWhatDOM) {\n    if (!this._objCurrDOM) {\n      this._objCurrDOM = _objWhatDOM;\n    }\n  },\n\n  updateCourseCompletionPercentage: function(_floNewPercentage) {\n    var _strVariableName = 'gomo_course_completion_percentage';\n    var _objEventData = {\n      strVariableName: _strVariableName,\n      strVariableValue: _floNewPercentage.toString(),\n      strCallbackEvent: false,\n      booIsSystemVariable: true\n    };\n\n    EM.trigger('updateVariableValue', _objEventData);\n    EM.trigger('systemVariablesChanged', {arrChangedSystemVariables: [_strVariableName]});\n  },\n\n  // If an asset has been hidden by display conditions we may need to update everything as it's\n  // not had previous updates\n  updateAllVariablesForAnElement: function(domId) {\n    for (var variable in this._objVariablesHash) {\n      if (Object.prototype.hasOwnProperty.call(this._objVariablesHash, variable)) {\n        this._updateHTMLEntities(variable, domId);\n      }\n    }\n  },\n\n  updateCourseScore: function(_intWhatScore) {\n    var _strVariableName = 'gomo_course_score';\n    var _objEventData = {\n      strVariableName: _strVariableName,\n      strVariableValue: _intWhatScore.toString(),\n      strCallbackEvent: false,\n      booIsSystemVariable: true\n    };\n\n    EM.trigger('updateVariableValue', _objEventData);\n    EM.trigger('systemVariablesChanged', {arrChangedSystemVariables: [_strVariableName]});\n  },\n\n  setAssetVariables: function(variableData) {\n    var initialisingVar = false;\n    if (variableData.initialise) {\n      initialisingVar = true;\n      delete variableData.initialise;\n    }\n    for (var variable in variableData.variables) {\n      if (Object.prototype.hasOwnProperty.call(variableData.variables, variable)) {\n        var currentVarData = variableData.variables[variable];\n        var _strVariableValue = currentVarData;\n        var assetId = variableData.assetId;\n        // If we're initialising the var and it already exists, skip to the next\n        if (initialisingVar && this._objAssetVariables[assetId]\n          && typeof this._objAssetVariables[assetId]._strVariableName !== 'undefined') {\n          continue;\n        }\n        this._objAssetVariables[assetId] = {_strVariableName: _strVariableValue};\n      }\n    }\n\n    this._objVariablesHash['asset_variable.' + assetId] = variableData.variablesStringify;\n  },\n\n  updateAssetDomValue: function(assetId) {\n    var _strVariableName = 'asset_variable.' + assetId;\n\n    // Update the DOM elements\n    this._updateImages(_strVariableName);\n    this._updateHTMLEntities(_strVariableName);\n  },\n\n  setCoursePassFail: function(passed) {\n    var _strVariableName = 'gomo_course_completion';\n    var _objEventData = {\n      strVariableName: _strVariableName,\n      strVariableValue: passed ? 'passed' : 'failed',\n      strCallbackEvent: false,\n      booIsSystemVariable: true\n    };\n\n    EM.trigger('updateVariableValue', _objEventData);\n    EM.trigger('systemVariablesChanged', {arrChangedSystemVariables: [_strVariableName]});\n  },\n\n  setCourseCompleted: function() {\n    var _strVariableName = 'gomo_course_completion';\n    var _objEventData = {\n      strVariableName: _strVariableName,\n      strVariableValue: 'completed',\n      strCallbackEvent: false,\n      booIsSystemVariable: true\n    };\n\n    EM.trigger('updateVariableValue', _objEventData);\n    EM.trigger('systemVariablesChanged', {arrChangedSystemVariables: [_strVariableName]});\n  },\n\n  setCourseStarted: function() {\n    var _strVariableName = 'gomo_course_completion';\n    var _objEventData = {\n      strVariableName: _strVariableName,\n      strVariableValue: 'incomplete',\n      strCallbackEvent: false,\n      booIsSystemVariable: true\n    };\n\n    EM.trigger('updateVariableValue', _objEventData);\n    EM.trigger('systemVariablesChanged', {arrChangedSystemVariables: [_strVariableName]});\n  },\n\n  setActiveLanguage: function(language) {\n    var _strVariableName = 'gomo_active_language';\n    var _objEventData = {\n      strVariableName: _strVariableName,\n      strVariableValue: language,\n      strCallbackEvent: false,\n      booIsSystemVariable: true\n    };\n\n    EM.trigger('updateVariableValue', _objEventData);\n    EM.trigger('systemVariablesChanged', {arrChangedSystemVariables: [_strVariableName]});\n  },\n\n  handleEvent_applyActiveLanguageAsTranslation: function() {\n    if (gomo && gomo.translationManager) {\n      var callbackFun = function() {};\n      gomo.translationManager.setTranslation(\n        this._objVariablesHash['gomo_active_language'], true, callbackFun\n      );\n    }\n  },\n\n  addItemCallback: function(item) {\n    if (this._objPersistedVariables.hasOwnProperty(item.strVariableName)) {\n      item.strCallbackEvent = this._objPersistedVariables[item.strVariableName];\n    }\n    return item;\n  },\n\n  handleEvent_assetCreated: function(_objEventData) {\n    var _objAssetData = _objEventData.objAssetData;\n\n    if (_objAssetData.objRawData.booInteractive) {\n      this._addInteractiveAssetVariables(_objAssetData);\n      this._addCompletedAssetVariables(_objAssetData);\n    }\n\n    if (_objAssetData.strAssetGroup == 'question') {\n      this._addQuestionAssetVariables(_objAssetData);\n    }\n  },\n\n  handleEvent_screenCreated: function(screenData) {\n    this._addScreenStatus(screenData);\n  },\n\n  handleEvent_topicCreated: function(_objEventData) {\n    var _objTopicData = _objEventData.objTopicData;\n    this._addTopicScoreVariables(_objTopicData);\n    this._addTopicCompletion(_objTopicData);\n  },\n\n  handleEvent_outputModeChanged: function(_objEventData) {\n    var _strNewOutputMode = _objEventData['strNewOutputMode'];\n    var _strCurrAccessibilityState = this.getVariableValue('gomo_accessibility_state');\n    var _strCurrDeviceType = this.getVariableValue('gomo_device_type');\n    var _arrChangedVariables = [];\n\n    switch (_strNewOutputMode) {\n      case 'graphicalC':\n        if (_strCurrAccessibilityState == 'true') {\n          EM.trigger('updateVariableValue', {\n            strVariableName: 'gomo_accessibility_state',\n            strVariableValue: 'false',\n            strCallbackEvent: false,\n            booIsSystemVariable: true\n          });\n          _arrChangedVariables.push('gomo_accessibility_state');\n        }\n        if (_strCurrDeviceType != 'desktop') {\n          EM.trigger('updateVariableValue', {\n            strVariableName: 'gomo_device_type',\n            strVariableValue: 'desktop',\n            strCallbackEvent: false,\n            booIsSystemVariable: true\n          });\n          _arrChangedVariables.push('gomo_device_type');\n        }\n        break;\n      case 'accessibleC':\n        if (_strCurrAccessibilityState == 'false') {\n          EM.trigger('updateVariableValue', {\n            strVariableName: 'gomo_accessibility_state',\n            strVariableValue: 'true',\n            strCallbackEvent: false,\n            booIsSystemVariable: true\n          });\n          _arrChangedVariables.push('gomo_accessibility_state');\n        }\n        if (_strCurrDeviceType != 'desktop') {\n          EM.trigger('updateVariableValue', {\n            strVariableName: 'gomo_device_type',\n            strVariableValue: 'desktop',\n            strCallbackEvent: false,\n            booIsSystemVariable: true\n          });\n          _arrChangedVariables.push('gomo_device_type');\n        }\n        break;\n      case 'smartphoneC':\n        if (_strCurrAccessibilityState == 'true') {\n          EM.trigger('updateVariableValue', {\n            strVariableName: 'gomo_accessibility_state',\n            strVariableValue: 'false',\n            strCallbackEvent: false,\n            booIsSystemVariable: true\n          });\n          _arrChangedVariables.push('gomo_accessibility_state');\n        }\n        if (_strCurrDeviceType != 'smartphoneC') {\n          EM.trigger('updateVariableValue', {\n            strVariableName: 'gomo_device_type',\n            strVariableValue: 'smartphone',\n            strCallbackEvent: false,\n            booIsSystemVariable: true\n          });\n          _arrChangedVariables.push('gomo_device_type');\n        }\n        break;\n      case 'tabletC':\n        if (_strCurrAccessibilityState == 'true') {\n          EM.trigger('updateVariableValue', {\n            strVariableName: 'gomo_accessibility_state',\n            strVariableValue: 'false',\n            strCallbackEvent: false,\n            booIsSystemVariable: true\n          });\n          _arrChangedVariables.push('gomo_accessibility_state');\n        }\n        if (_strCurrDeviceType != 'tabletC') {\n          EM.trigger('updateVariableValue', {\n            strVariableName: 'gomo_device_type',\n            strVariableValue: 'tablet',\n            strCallbackEvent: false,\n            booIsSystemVariable: true\n          });\n          _arrChangedVariables.push('gomo_device_type');\n        }\n        break;\n      default:\n        gomo.utility.alert(\n          'ERROR: Unknown output mode of \\'' +\n            _strNewOutputMode +\n            '\\' found in handleEvent_outputModeChanged, variables_holder.js'\n        );\n        break;\n    }\n\n    if (_arrChangedVariables.length > 0) {\n      // We need to suppress updates to the dom, as we've stopped tracking bindings in translations\n      // but haven't yet reset the content Dom so we would get a multiple binding error\n      EM.trigger('systemVariablesChanged', {\n        arrChangedSystemVariables: _arrChangedVariables,\n        suppressDomUpdates: true\n      });\n    }\n  },\n\n  handleEvent_questionAssetAnswered: function(_objWhatAssetData) {\n    var _strVariableValue;\n\n    var _strVariableName =\n      this._strQuestionAssetStatePrefix +\n      '.' +\n      (_objWhatAssetData.strObjID || _objWhatAssetData.strID);\n\n    if (_objWhatAssetData.booIsCorrect) {\n      _strVariableValue = 'true';\n    } else {\n      _strVariableValue = 'false';\n    }\n\n    var _objEventData = {\n      strVariableName: _strVariableName,\n      strVariableValue: _strVariableValue,\n      strCallbackEvent: false,\n      booIsSystemVariable: true\n    };\n\n    EM.trigger('updateVariableValue', _objEventData);\n    EM.trigger('systemVariablesChanged', {arrChangedSystemVariables: [_strVariableName]});\n\n    this._updateTopicScoreVariables(_objWhatAssetData);\n  },\n\n  checkTopicCompletion: function(objTopicData) {\n    if (objTopicData.intTrackingState == 2) {\n      var _strVariableName = this._strTopicCompletionPrefix + '.' + objTopicData.strObjID;\n      var _strVariableValue = 'true';\n\n      var _objEventData = {\n        strVariableName: _strVariableName,\n        strVariableValue: _strVariableValue,\n        strCallbackEvent: false,\n        booIsSystemVariable: true\n      };\n\n      EM.trigger('updateVariableValue', _objEventData);\n      EM.trigger('systemVariablesChanged', {arrChangedSystemVariables: [_strVariableName]});\n    }\n  },\n\n  screenAssetInteractingUpdated: function(_objWhatAssetData) {\n    this.interactingAssetState(_objWhatAssetData);\n    this.completedAssetState(_objWhatAssetData);\n    this.assetValueCheck();\n  },\n\n  handleEvent_postLoadTopicObject: function() {\n    this.assetValueCheck();\n  },\n\n  interactingAssetState: function(_objWhatAssetData) {\n    if (typeof _objWhatAssetData == 'undefined') {\n      var errorMessage = 'Error : Missing asset data';\n      var opts = {includeStack: true};\n      if (typeof LogManager !== 'undefined') {\n        LogManager.add('TEXT', errorMessage, opts);\n      } else {\n        console.log(errorMessage);\n      }\n      return;\n    }\n\n    var assetId = _objWhatAssetData.strObjID || _objWhatAssetData.strID;\n\n    // If the asset belongs to a cloned subscreen then use the original asset id.\n    if (\n      _objWhatAssetData &&\n      _objWhatAssetData.objParent &&\n      _objWhatAssetData.objParent.strObjType === 'subscreen' &&\n      _objWhatAssetData.objParent.strObjID\n    ) {\n      var originalSubscreenId =\n        SUB_SCREEN_INTERACTIONS.getOriginalSubscreenId(_objWhatAssetData.objParent.strObjID);\n      if (originalSubscreenId) {\n        assetId = assetId.replace(_objWhatAssetData.objParent.strObjID, originalSubscreenId);\n      }\n    }\n\n    var _strVariableName =\n      this._strInteractedAssetStatePrefix +\n      '.' +\n      assetId;\n    var _strVariableValue = 'true';\n\n    var _objEventData = {\n      strVariableName: _strVariableName,\n      strVariableValue: _strVariableValue,\n      strCallbackEvent: false,\n      booIsSystemVariable: true\n    };\n\n    EM.trigger('updateVariableValue', _objEventData);\n    EM.trigger('systemVariablesChanged', {arrChangedSystemVariables: [_strVariableName]});\n  },\n\n  completedAssetState: function(_objWhatAssetData) {\n    if (typeof _objWhatAssetData == 'undefined') {\n      var errorMessage = 'Error : Missing asset data';\n      var opts = {includeStack: true};\n      if (typeof LogManager !== 'undefined') {\n        LogManager.add('TEXT', errorMessage, opts);\n      } else {\n        console.log(errorMessage);\n      }\n      return;\n    }\n\n    var assetId = _objWhatAssetData.strObjID || _objWhatAssetData.strID;\n\n    // If the asset belongs to a cloned subscreen then use the original asset id.\n    if (\n      _objWhatAssetData &&\n      _objWhatAssetData.objParent &&\n      _objWhatAssetData.objParent.strObjType === 'subscreen' &&\n      _objWhatAssetData.objParent.strObjID\n    ) {\n      var originalSubscreenId =\n        SUB_SCREEN_INTERACTIONS.getOriginalSubscreenId(_objWhatAssetData.objParent.strObjID);\n      if (originalSubscreenId) {\n        assetId = assetId.replace(_objWhatAssetData.objParent.strObjID, originalSubscreenId);\n      }\n    }\n\n    var _strVariableName =\n      this._strCompletedAssetStatePrefix +\n      '.' +\n      assetId;\n    var _strVariableValue = 'false';\n    if (_objWhatAssetData.booComplete) {\n      _strVariableValue = 'true';\n    }\n\n    var _objEventData = {\n      strVariableName: _strVariableName,\n      strVariableValue: _strVariableValue,\n      strCallbackEvent: false,\n      booIsSystemVariable: true\n    };\n\n    EM.trigger('updateVariableValue', _objEventData);\n    EM.trigger('systemVariablesChanged', {arrChangedSystemVariables: [_strVariableName]});\n  },\n\n  assetValueCheck: function() {\n    var variableObjects = DISPLAY_CONDITIONS_INTERACTIONS.getRegisteredVariableObjects();\n    if (variableObjects.asset_variable !== undefined) {\n      var count = 0;\n      while (count < variableObjects.asset_variable.length) {\n        if (\n          variableObjects.asset_variable[count].objRawData &&\n          variableObjects.asset_variable[count].objRawData.arrDisplayConditions &&\n          variableObjects.asset_variable[count].objRawData.arrDisplayConditions[0]\n        ) {\n          var displayCondition =\n            variableObjects.asset_variable[count].objRawData.arrDisplayConditions[0];\n        }\n        DISPLAY_CONDITIONS_INTERACTIONS._checkCondition_customVariableDisplayCondition(\n          displayCondition\n        );\n        count++;\n      }\n    }\n  },\n\n  // Collects the loaded data from CORE and parses into the reference and current HASH tables.\n  handleEvent_broadcastGroupVariablesData: function(_objWhatJSON) {\n    if (_objWhatJSON) {\n      if (_objWhatJSON['arrVariables']) {\n        this._arrRawVariables = _objWhatJSON['arrVariables'];\n        this._parseIntoHashTable();\n      } else {\n        this._arrRawVariables = [];\n      }\n    }\n  },\n\n  // This is used for Instant Preview which can extend the list of vars\n  updateVariable: function(newVariables) {\n    _(newVariables).each(function(newVariable, i) {\n      var foundVar = _.find(VARIABLES_HOLDER._arrRawVariables, function(rawVar) {\n        return rawVar.strName === newVariable.strName;\n      });\n      if (foundVar) {\n        // If the variable exits then replace the value in case it's new\n        foundVar.strValue = newVariable.strValue;\n      } else {\n        // If the variable doesn't exit then add it\n        VARIABLES_HOLDER._arrRawVariables.push(newVariable);\n      }\n    });\n    this._parseIntoHashTable();\n  },\n\n  // Not currently supported but this is a mechanism for having multiple values for a given\n  // variable, in the case of the initial VWG 12144 implamentation, based on user type.\n  handleEvent_setDynamicVariableSuffix: function(_strWhatSuffix) {\n    this._strCurrDynamicVariableSuffix = _strWhatSuffix;\n  },\n\n  handleEvent_updateVariableValue: function(_objEventData) {\n    var _strVariableName = _objEventData['strVariableName'];\n    var _strVariableValue = _objEventData['strVariableValue'];\n    var _strCallbackEvent = _objEventData['strCallbackEvent'];\n    var _booIsSystemVariable = _objEventData['booIsSystemVariable'];\n\n    this._objVariablesHash[_strVariableName] = _strVariableValue;\n\n    // Update the DOM elements\n    this._updateImages(_strVariableName);\n    this._updateHTMLEntities(_strVariableName);\n\n    if (!_booIsSystemVariable) {\n      // Update anything else that may require a more specific update\n      EM.trigger('groupVariableUpdated', _objEventData);\n    } else {\n      this._objSystemVariablesHash[_strVariableName] = _strVariableValue;\n    }\n    var variablePersists = this.getVariablePersistence(_strVariableName);\n    // If variable persistance is enabled store it.\n    if (variablePersists) {\n      CONTENT_TRACKING.saveVariable(_objEventData);\n    }\n\n    if (_strCallbackEvent) {\n      EM.trigger(_strCallbackEvent);\n    }\n  },\n\n  // Currently not used, this will reset the variables to the stored initial state.\n  // Useful to allow a user to retake a topic and return it to the base state.\n  // REFACTOR NOTE: It would be useful to extend this to allow a more selective reset\n  // and preserve some variables whilst resetting others.\n  handleEvent_resetGroupVariables: function() {\n    for (var _strCurrName in this._objVariablesHash) {\n      if (this._objVariablesHash[_strCurrName] != this._objSourceVariablesHash[_strCurrName]) {\n        var _objEventData = {\n          strVariableName: _strCurrName,\n          strVariableValue: this._objSourceVariablesHash[_strCurrName],\n          strCallbackEvent: false\n        };\n\n        EM.trigger('updateVariableValue', _objEventData);\n      }\n    }\n  },\n\n  // Retrieves the value for a given variable, will recurse in the case of nested variables\n  // and selects the relevant dynamic variable value if required.\n  getVariableValue: function(_strWhatVariableName) {\n    if (\n      this._objVariablesHash[_strWhatVariableName] ||\n      this._objVariablesHash[_strWhatVariableName] == '' ||\n      this._objVariablesHash[_strWhatVariableName] == 0\n    ) {\n      var _strVariableValue = this._objVariablesHash[_strWhatVariableName];\n\n      if (\n        _strVariableValue.indexOf(this._strDynamicVariableKey1) > -1 ||\n        _strVariableValue.indexOf(this._strDynamicVariableKey2) > -1\n      ) {\n        _strVariableValue = this._resolveDynamicVariableValue(_strVariableValue);\n      }\n\n      if (\n        _strVariableValue &&\n        _strVariableValue.indexOf &&\n        _strVariableValue.indexOf(this._strVariableInsertPrefix) != -1\n      ) {\n        var _objItemsToInsert = {};\n        // eslint-disable-next-line no-useless-escape\n        var _regVariableInsert = /\\{\\{([^\\}\\}])+\\}\\}/g;\n        var _objExecResult;\n        while ((_objExecResult = _regVariableInsert.exec(_strVariableValue)) != null) {\n          var _strMatch = _objExecResult[0];\n          _objItemsToInsert[_strMatch] = this.getVariableValue(_strMatch);\n        }\n\n        for (var _strCurrMatch in _objItemsToInsert) {\n          if (Object.prototype.hasOwnProperty.call(_objItemsToInsert, _strCurrMatch)) {\n            _strVariableValue = _strVariableValue\n              .split(_strCurrMatch)\n              .join(_objItemsToInsert[_strCurrMatch]);\n          }\n        }\n      }\n\n      return _strVariableValue;\n    } else if (_strWhatVariableName.indexOf('asset_variable') == -1) {\n      gomo.utility.alert('ERROR: I was asked for a variable name of \\'' +\n      _strWhatVariableName +\n      '\\', but I don\\'t seem to have a variable of that name. ' +\n      'VARIABLES_HOLDER.getVariableValue(), variables_holder.js');\n    }\n    return false;\n  },\n\n  getVariablePersistence: function(variableName) {\n    var persists = false;\n    var variable = _.find(this._arrRawVariables, function(variable) {\n      return variable.strName === variableName;\n    });\n    if (variable && variable.booPersist\n      || this._objPersistedVariables.hasOwnProperty(variableName)) {\n      persists = true;\n    }\n    return persists;\n  },\n\n  // Resolves the image path for any variables to allow retrieval of image\n  // meta data.\n  getFilenameForMetaDataCheck: function(_strWhatFilename) {\n    if (\n      _strWhatFilename &&\n      _strWhatFilename.indexOf &&\n      _strWhatFilename.indexOf(this._strVariableInsertPrefix) != -1\n    ) {\n      // eslint-disable-next-line no-useless-escape\n      var _regVariableInsert = /\\{\\{([^\\}\\}])+\\}\\}/g;\n\n      var _arrMatchs = _strWhatFilename.match(_regVariableInsert);\n\n      if (_arrMatchs.length > 1) {\n        gomo.utility.alert(\n          'ERROR: Mutliple variables for images are not supported. ' +\n          'VARIABLES_HOLDER.parseImagePathForVariableMarkup(), variables_holder.js'\n        );\n        return _strWhatFilename;\n      }\n\n      _strWhatFilename = _strWhatFilename.replace(\n        _arrMatchs[0],\n        this.getVariableValue(_arrMatchs[0])\n      );\n    }\n    return _strWhatFilename;\n  },\n\n  // Replaces the {{VARIABLE_NAME}} markup with the relevent value wrapped in an\n  // HTML entity for later updating.\n  parseHTMLForVariableMarkup: function(_htmWhatContent, _booVariableValueOnly) {\n    if (\n      _htmWhatContent &&\n      _htmWhatContent.indexOf &&\n      _htmWhatContent.indexOf(this._strVariableInsertPrefix) != -1\n    ) {\n      var _objItemsToInsert = {};\n      // Matches the {{VARIABLE_NAME}} syntax.\n      // eslint-disable-next-line no-useless-escape\n      var _regVariableInsert = /\\{\\{([^\\}\\}])+\\}\\}/g;\n      var _objExecResult;\n      while ((_objExecResult = _regVariableInsert.exec(_htmWhatContent)) != null) {\n        var _strMatch = _objExecResult[0];\n\n        if (!_booVariableValueOnly) {\n          _objItemsToInsert[_strMatch] = this._generateHTMLVariableRenderArtifact(_strMatch);\n        } else {\n          var _strCleanVariableName = _strMatch.replace(/\\{\\{/g, '').replace(/\\}\\}/g, '');\n          _objItemsToInsert[_strMatch] = this.getVariableValue(_strCleanVariableName);\n        }\n      }\n\n      for (var _strCurrMatch in _objItemsToInsert) {\n        if (Object.prototype.hasOwnProperty.call(_objItemsToInsert, _strCurrMatch)) {\n          _htmWhatContent = _htmWhatContent\n            .split(_strCurrMatch)\n            .join(_objItemsToInsert[_strCurrMatch]);\n        }\n      }\n    }\n    return _htmWhatContent;\n  },\n\n  // Resolves any variable markup inside an image path and sets a query string param to\n  // allow updating.\n  parseImagePathForVariableMarkup: function(_strWhatPath) {\n    if (\n      _strWhatPath &&\n      _strWhatPath.indexOf &&\n      _strWhatPath.indexOf(this._strVariableInsertPrefix) != -1\n    ) {\n      // eslint-disable-next-line no-useless-escape\n      var _regVariableInsert = /\\{\\{([^\\}\\}])+\\}\\}/g;\n\n      var _arrMatchs = _strWhatPath.match(_regVariableInsert);\n\n      if (_arrMatchs.length > 1) {\n        gomo.utility.alert(\n          'ERROR: Mutliple variables for images are not supported. ' +\n          'VARIABLES_HOLDER.parseImagePathForVariableMarkup(), variables_holder.js'\n        );\n        return _strWhatPath;\n      }\n\n      var _strModifiedPath = this._resolvePathForImage(_strWhatPath, _arrMatchs[0]);\n      return _strModifiedPath;\n    }\n    return _strWhatPath;\n  },\n\n  // Checks the base value and appends the relevent dynamic suffix to reference the correct\n  // dynamic variable.\n  //\n  // Not currently supported but this is a mechanism for having multiple values for a given\n  // variable, in the case of the initial VWG 12144 implamentation, based on user type.\n  _resolveDynamicVariableValue: function(_strWhatValue) {\n    var _objItemsToInsert = {};\n    // eslint-disable-next-line no-useless-escape\n    var _regVariableInsert = /\\{\\{([^\\}\\}])+\\}\\}/g;\n    var _objExecResult;\n    while ((_objExecResult = _regVariableInsert.exec(_strWhatValue)) != null) {\n      var _strMatch = _objExecResult[0];\n      _objItemsToInsert[_strMatch] = this.getVariableValue(\n        _strMatch.replace('}}', '_' + this._strCurrDynamicVariableSuffix + '}}')\n      );\n    }\n\n    for (var _strCurrMatch in _objItemsToInsert) {\n      if (Object.prototype.hasOwnProperty.call(_objItemsToInsert, _strCurrMatch)) {\n        _strWhatValue = _strWhatValue.split(_strCurrMatch).join(_objItemsToInsert[_strCurrMatch]);\n      }\n    }\n    return _strWhatValue;\n  },\n\n  // Generates the HTML to wrap around the variable value to allow updating of\n  // values.\n  _generateHTMLVariableRenderArtifact: function(_strWhatName) {\n    var _htmRenderArtifact = TEMPLATE_MANANGER.getTemplate(this._strGroupVariablesRenderArtifactID)\n      .htmData;\n    var _strFirstParseVariableName = _strWhatName.replace(/\\{\\{/g, '').replace(/\\}\\}/g, '');\n    var _strCleanVariableName = this._tidyUpSystemVariables(_strFirstParseVariableName);\n    _htmRenderArtifact = _htmRenderArtifact.replace(/XX_VARIABLE_NAME_XX/g, _strCleanVariableName);\n    _htmRenderArtifact = _htmRenderArtifact.replace(\n      /XX_VARIABLE_NAME_AS_CLASS_XX/g,\n      this._strVariableEntityClassNamePrefix +\n        _strCleanVariableName +\n        this._strVariableEntityClassNameSuffix\n    );\n\n    if (\n      this._objVariablesHash[_strCleanVariableName] ||\n      this._objVariablesHash[_strCleanVariableName] == '' ||\n      this._objVariablesHash[_strCleanVariableName] == 0 ||\n      this._objVariablesHash[_strFirstParseVariableName]\n    ) {\n      var _strVariableValue;\n      // get the variable value using the correct string\n      if (this._objVariablesHash[_strFirstParseVariableName]) {\n        _strVariableValue = this._objVariablesHash[_strFirstParseVariableName];\n      } else {\n        _strVariableValue = this.getVariableValue(_strCleanVariableName);\n      }\n\n      if (_strVariableValue == null || _strVariableValue == 'null') {\n        // JC Temporarily hard coded whilst awaiting portal manifest/localisation fix\n        // _strVariableValue = LOCALISER.get(\"UNSET_VARIABLE_VALUE\");\n        _strVariableValue = 'Value not set.';\n      }\n\n      _htmRenderArtifact = _htmRenderArtifact.replace(/XX_VARIABLE_VALUE_XX/g, _strVariableValue);\n    } else {\n      _htmRenderArtifact = _htmRenderArtifact.replace(/XX_VARIABLE_VALUE_XX/g, '');\n    }\n    return _htmRenderArtifact;\n  },\n\n  // Populates the _objVariablesHash and the _objSourceVariablesHash properties.\n  _parseIntoHashTable: function() {\n    var count = 0;\n    while (count < this._arrRawVariables.length) {\n      var _objCurrVariablePair = this._arrRawVariables[count];\n      // If a value is already set from suspend data then do not overwrite it\n      if (this._objVariablesHash[_objCurrVariablePair['strName']] === undefined) {\n        this._objVariablesHash[_objCurrVariablePair['strName']] = _objCurrVariablePair['strValue'];\n      }\n\n      // Create a source variable link also, to allow for resetting.\n      this._objSourceVariablesHash[_objCurrVariablePair['strName']] =\n        _objCurrVariablePair['strValue'];\n      count++;\n    }\n\n    // Add in the system variables\n    for (var _strCurrName in this._objSystemVariablesHash) {\n      if (Object.prototype.hasOwnProperty.call(this._objSystemVariablesHash, _strCurrName)) {\n        this._objSourceVariablesHash[_strCurrName] = this._objSystemVariablesHash[_strCurrName];\n        this._objVariablesHash[_strCurrName] = this._objSystemVariablesHash[_strCurrName];\n      }\n    }\n  },\n\n  _addInteractiveAssetVariables: function(_objWhatAssetData) {\n    var _strVariableName =\n      this._strInteractedAssetStatePrefix +\n      '.' +\n      (_objWhatAssetData.strObjID || _objWhatAssetData.strID);\n    var _strVariableValue = 'false';\n    this._addVariableToHashTables(_strVariableName, _strVariableValue, true);\n  },\n\n  _addCompletedAssetVariables: function(_objWhatAssetData) {\n    var _strVariableName =\n      this._strCompletedAssetStatePrefix +\n      '.' +\n      (_objWhatAssetData.strObjID || _objWhatAssetData.strID);\n    var _strVariableValue = 'false';\n    this._addVariableToHashTables(_strVariableName, _strVariableValue, true);\n  },\n\n  _addQuestionAssetVariables: function(_objWhatAssetData) {\n    var _strVariableName =\n      this._strQuestionAssetStatePrefix +\n      '.' +\n      (_objWhatAssetData.strObjID || _objWhatAssetData.strID);\n    var _strVariableValue = 'null';\n    this._addVariableToHashTables(_strVariableName, _strVariableValue, true);\n  },\n\n  _addScreenStatus: function(screenData) {\n    var _strVariableName = this._strScreenStatusPrefix + '.' + screenData.strObjID;\n    var _strVariableValue = '0';\n    this._addVariableToHashTables(_strVariableName, _strVariableValue, true);\n  },\n\n  handleEvent_reportScreenInteractedStatus: function(screenData) {\n    var _strVariableName = this._strScreenStatusPrefix + '.' + screenData.strObjID;\n    var _objEventData = {\n      strVariableName: _strVariableName,\n      strVariableValue: screenData.screenInteractedState.toString(),\n      strCallbackEvent: false,\n      booIsSystemVariable: true\n    };\n\n    EM.trigger('updateVariableValue', _objEventData);\n    EM.trigger('systemVariablesChanged', {arrChangedSystemVariables: [_strVariableName]});\n  },\n\n  handleEvent_reportScreenCorrectStatus: function(screenData) {\n    var _strVariableName = this._strScreenCorrectPrefix + '.' + screenData.strObjID;\n    var _objEventData = {\n      strVariableName: _strVariableName,\n      strVariableValue: screenData.screenCorrectState.toString(),\n      strCallbackEvent: false,\n      booIsSystemVariable: true\n    };\n\n    EM.trigger('updateVariableValue', _objEventData);\n    EM.trigger('systemVariablesChanged', {arrChangedSystemVariables: [_strVariableName]});\n  },\n\n  _addTopicCompletion: function(_objWhatTopicData) {\n    var _strVariableName =\n      this._strTopicCompletionPrefix +\n      '.' +\n      (_objWhatTopicData.strObjID || _objWhatTopicData.strID);\n    var _strVariableValue = 'false';\n    this._addVariableToHashTables(_strVariableName, _strVariableValue, true);\n  },\n\n  _addTopicScoreVariables: function(_objWhatTopicData) {\n    var _strVariableValue = 'null';\n    var _strVariableName =\n      this._strTopicIncorrectQuestionsStatePrefix +\n      '.' +\n      (_objWhatTopicData.strObjID || _objWhatTopicData.strID);\n    this._addVariableToHashTables(_strVariableName, _strVariableValue, true);\n\n    _strVariableName =\n      this._strTopicCorrectQuestionsStatePrefix +\n      '.' +\n      (_objWhatTopicData.strObjID || _objWhatTopicData.strID);\n    this._addVariableToHashTables(_strVariableName, _strVariableValue, true);\n\n    _strVariableName =\n      this._strTopicScoreAsPercentStatePrefix +\n      '.' +\n      (_objWhatTopicData.strObjID || _objWhatTopicData.strID);\n    this._addVariableToHashTables(_strVariableName, _strVariableValue, true);\n  },\n\n  _updateTopicScoreVariables: function(_objWhatAssetData) {\n    var _objParentTopic;\n    if (_objWhatAssetData.objParent.strObjType == 'screen') {\n      _objParentTopic = _objWhatAssetData.objParent.objParent;\n    } else {\n      _objParentTopic = _objWhatAssetData.objParent.objParent.objParent;\n    }\n    var _strParentTopicID = _objParentTopic.strObjID;\n\n    var _objAnsweredQuestionAssets = TOPIC_INTERACTIONS.getAnsweredQuestionAssets();\n\n    var _objScoreData = {\n      intPercentage: 0,\n      intTotal: 0,\n      intCorrect: 0,\n      intWrong: 0\n    };\n\n    for (var _strCurrAssetID in _objAnsweredQuestionAssets) {\n      if (Object.prototype.hasOwnProperty.call(_objAnsweredQuestionAssets, _strCurrAssetID)) {\n        var _objCurrAsset = _objAnsweredQuestionAssets[_strCurrAssetID];\n        if (_objCurrAsset.booIsCorrect === true) {\n          _objScoreData['intCorrect']++;\n        } else if (_objCurrAsset.booIsCorrect === false) {\n          _objScoreData['intWrong']++;\n        }\n        _objScoreData['intTotal']++;\n      }\n    }\n    _objScoreData['intPercentage'] = parseInt(\n      (_objScoreData['intCorrect'] / _objScoreData['intTotal']) * 100\n    );\n\n    this._updateTopicIncorrect(_strParentTopicID, _objScoreData['intWrong'].toString());\n    this._updateTopicCorrect(_strParentTopicID, _objScoreData['intCorrect'].toString());\n    this._updateTopicPercentage(_strParentTopicID, _objScoreData['intPercentage'].toString());\n  },\n\n  _updateTopicIncorrect: function(_strParentTopicID, _strNewValue) {\n    var _strVariableName = this._strTopicIncorrectQuestionsStatePrefix + '.' + _strParentTopicID;\n    var _objEventData = {\n      strVariableName: _strVariableName,\n      strVariableValue: _strNewValue,\n      strCallbackEvent: false,\n      booIsSystemVariable: true\n    };\n\n    EM.trigger('updateVariableValue', _objEventData);\n    EM.trigger('systemVariablesChanged', {arrChangedSystemVariables: [_strVariableName]});\n  },\n\n  _updateTopicCorrect: function(_strParentTopicID, _strNewValue) {\n    var _strVariableName = this._strTopicCorrectQuestionsStatePrefix + '.' + _strParentTopicID;\n    var _objEventData = {\n      strVariableName: _strVariableName,\n      strVariableValue: _strNewValue,\n      strCallbackEvent: false,\n      booIsSystemVariable: true\n    };\n\n    EM.trigger('updateVariableValue', _objEventData);\n    EM.trigger('systemVariablesChanged', {arrChangedSystemVariables: [_strVariableName]});\n  },\n\n  _updateTopicPercentage: function(_strParentTopicID, _strNewValue) {\n    var _strVariableName = this._strTopicScoreAsPercentStatePrefix + '.' + _strParentTopicID;\n    var _objEventData = {\n      strVariableName: _strVariableName,\n      strVariableValue: _strNewValue,\n      strCallbackEvent: false,\n      booIsSystemVariable: true\n    };\n\n    EM.trigger('updateVariableValue', _objEventData);\n    EM.trigger('systemVariablesChanged', {arrChangedSystemVariables: [_strVariableName]});\n  },\n\n  _addVariableToHashTables: function(_strVariableName, _strVariableValue, _booIsSystemVariable) {\n    if (PREVIEW_DATA && PREVIEW_DATA.editorMode\n      && typeof this._objSourceVariablesHash[_strVariableName] !== 'undefined') {\n      return;\n    }\n    this._objSourceVariablesHash[_strVariableName] = _strVariableValue;\n    this._objVariablesHash[_strVariableName] = _strVariableValue;\n\n    if (_booIsSystemVariable) {\n      this._objSystemVariablesHash[_strVariableName] = _strVariableValue;\n    }\n  },\n\n  // Updates the path with the relevant variable value and appends the\n  // initial path as a query string param.\n  // REFACTOR NOTE: This should double check that a query string already exists\n  // rather than assuming it will (which it currently should)\n  _resolvePathForImage: function(_strWhatPath, _strWhatVariableName) {\n    var _strNewPath = _strWhatPath;\n\n    _strNewPath = _strNewPath.replace(\n      _strWhatVariableName,\n      this.getVariableValue(_strWhatVariableName)\n    );\n    _strNewPath +=\n      this._strImagePathVariablePrefix +\n      _strWhatVariableName\n        .replace(this._strVariableInsertPrefix, '')\n        .replace(this._strVariableInsertSuffix, '');\n\n    var _strBaseFilename = '&' + this._strBaseImageFilenamePrefix + escape(_strWhatPath);\n\n    _strNewPath += _strBaseFilename;\n\n    return _strNewPath;\n  },\n\n  // Retrieves all images in the current DOM and checks them for the query string markup\n  // that denotes a variable based image. It then updates as required.\n  _updateImages: function(_strWhatVariableName) {\n    if (this._objCurrDOM) {\n      var _arrImages = this._objCurrDOM.getElementsByTagName('img');\n      var count = 0;\n      while (count < _arrImages.length) {\n        var _domCurrImage = _arrImages[count];\n        if (\n          _domCurrImage.src.indexOf(this._strImagePathVariablePrefix) > -1 &&\n          _domCurrImage.src.indexOf(\n            _strWhatVariableName\n              .replace(this._strVariableInsertPrefix, '')\n              .replace(this._strVariableInsertSuffix, '')\n          ) > -1\n        ) {\n          var _strInitialFilename = this._getBaseFilenameQueryVariableValue(_domCurrImage.src);\n\n          var _strNewPath = this._resolvePathForImage(_strInitialFilename, _strWhatVariableName);\n\n          var _arrFolderPathSplit = _domCurrImage.src.split('/');\n          _arrFolderPathSplit.pop();\n          var _strFolderPath = _arrFolderPathSplit.join('/') + '/';\n\n          _domCurrImage.src = _strFolderPath + _strNewPath;\n        }\n        count++;\n      }\n    }\n  },\n\n  // Retrieves the variable name from the query string and returns it's value\n  _getBaseFilenameQueryVariableValue: function(_strWhatPath) {\n    var _strQueryString = _strWhatPath.slice(_strWhatPath.indexOf('?'), _strWhatPath.length);\n    var _arrQueryStringSplit = _strQueryString.split('&');\n    var count = 0;\n    while (count < _arrQueryStringSplit.length) {\n      var _strCurrSplitItem = _arrQueryStringSplit[count];\n      if (_strCurrSplitItem.indexOf(this._strBaseImageFilenamePrefix) > -1) {\n        var _arrBasePathSplit = _strCurrSplitItem.split('=');\n        var _strBasePath = unescape(_arrBasePathSplit[1]);\n        return _strBasePath;\n      }\n      count++;\n    }\n    gomo.utility.alert(\n      'ERROR: Unable to find base path variable in filepath of \\'' +\n        _strWhatPath +\n        '\\'. VARIABLES_HOLDER._getBasePathQueryVariableValue(), variables_holder.js'\n    );\n    return '';\n  },\n\n  // Updates all the HTML entities variable values.\n  _updateHTMLEntities: function(_strWhatName, optionalDomId) {\n    var _strClassNameToMatch =\n      this._strVariableEntityClassNamePrefix +\n      _strWhatName.replace(/\\{\\{/g, '').replace(/\\}\\}/g, '') +\n      this._strVariableEntityClassNameSuffix;\n    _strClassNameToMatch = this._tidyUpSystemVariables(_strClassNameToMatch);\n    var elementToUpdate = this._objCurrDOM;\n    if (optionalDomId) {\n      elementToUpdate = $('#' + optionalDomId)[0];\n    }\n    var _arrCurrentVariableEntities = CORE.getElementsByClassName(\n      elementToUpdate,\n      _strClassNameToMatch\n    );\n\n    var count = 0;\n    while (count < _arrCurrentVariableEntities.length) {\n      var _domCurrEntity = _arrCurrentVariableEntities[count];\n      _domCurrEntity.innerHTML = gomo.utility.formatHTML(this.getVariableValue(_strWhatName));\n      count++;\n    }\n  },\n\n  _tidyUpSystemVariables: function(_strWhatVariableName) {\n    _strWhatVariableName = _strWhatVariableName.replace(/\\./g, '_');\n    return _strWhatVariableName;\n  },\n\n  booTerminal: true\n};\n\nEM.register(VARIABLES_HOLDER);\n"},function(t,n,e){e(0)(e(33))},function(t,n){t.exports="/**\n* BACK Extra\n* ---\n* @author GoMo\n*/\n\nvar global = this;\n\nif(global.Mustache === undefined){\n\tconsole.log('ERROR: Mustache not found!');\n}\n\nvar BACK_EXTRA =\n{\n\tstrObjID : \"The back button extra\",\n\tstrObjDescription : \"The extra responsible for display of the back button.\",\n\n\t_strManifestID : \"backExtra\",\n\t_objCurrDOM : null,\n\t_domCurrInsertionNode : null,\n\t_booDebug : false,\n\n\thandleEvent_primeDOMReferences : function (_objWhatDOM){\n\t\tthis._objCurrDOM = _objWhatDOM;\n\t},\n\n\thandleEvent_outputModeChanged : function (_objOutputChangeData){\n\t},\n\n\thandleEvent_screenSizeChanged : function (_objOutputChangeData){\n\t},\n\n\t// Debug message\n\t_debug : function (_strMessage){\n\t\tif ((window['console']) && (window.console.log) && (this._booDebug)){\n\t\t\tconsole.log(_strManifestID + ' : ' + _strMessage);\n\t\t}\n\t}\n}\n\nEM.register(BACK_EXTRA);"},function(t,n,e){e(0)(e(35))},function(t,n){t.exports="/**\n* Next Extra\n* ---\n* @author GoMo\n*/\n\nvar global = this;\n\nif(global.Mustache === undefined){\n\tconsole.log('ERROR: Mustache not found!');\n}\n\nvar NEXT_EXTRA =\n{\n\tstrObjID : \"The next button extra\",\n\tstrObjDescription : \"The extra responsible for display of the next button.\",\n\n\t_strManifestID : \"nextExtra\",\n\t_objCurrDOM : null,\n\t_domCurrInsertionNode : null,\n\t_booDebug : false,\n\n\thandleEvent_primeDOMReferences : function (_objWhatDOM){\n\t\tthis._objCurrDOM = _objWhatDOM;\n\t},\n\n\thandleEvent_outputModeChanged : function (_objOutputChangeData){\n\t},\n\n\thandleEvent_screenSizeChanged : function (_objOutputChangeData){\n\t},\n\n\t// Debug message\n\t_debug : function (_strMessage){\n\t\tif ((window['console']) && (window.console.log) && (this._booDebug)){\n\t\t\tconsole.log(_strManifestID + ' : ' + _strMessage);\n\t\t}\n\t}\n}\n\nEM.register(NEXT_EXTRA);"},function(t,n,e){e(0)(e(37))},function(t,n){t.exports="/* globals NavigationManager, $, SCREEN_INTERACTIONS, BOO_GRAPHICAL_PAGE_COUNT, TEMPLATE_MANANGER,\nSTR_PAGE_SEPERATOR, EM, Mustache, PAGE_COUNT_WITH_NAVIGATION */\n\n/**\n * Progress Bar Extra\n * ---\n * @author GoMo\n */\n\nvar global = this;\n\nif (global.Mustache === undefined) {\n  console.log('ERROR: Mustache not found!');\n}\n\n// Set a global max progress dots count to offer theme overrides\nvar MAX_PROGRESS_DOTS_COUNT = 4;\nvar PROGRESS_BAR = {\n  strObjID: 'The progress bar extra',\n  strObjDescription: 'The extra responsible for display of the progress.',\n\n  _strManifestID: 'progressBarExtra',\n  _objCurrDOM: null,\n  _domCurrInsertionNode: null,\n  _booDebug: false,\n\n  progressBarId: 'pageNumberL',\n  progressBarClass: 'gomoProgressBar',\n  activeDotClass: 'activePaginationLinkC',\n\n  handleEvent_primeDOMReferences: function(_objWhatDOM) {\n    this._objCurrDOM = _objWhatDOM;\n  },\n\n  handleEvent_outputModeChanged: function(_objOutputChangeData) {},\n\n  handleEvent_screenSizeChanged: function(_objOutputChangeData) {},\n\n  /**\n  * Update the progress everytime the nav is rebuilt\n  * @param {object} courseData\n  */\n  handleEvent_rebuiltNavMenu: function(courseData) {\n    var me = this;\n    me.updateProgress(courseData);\n  },\n\n  updateProgress: function(courseData, options) {\n    var me = this;\n    var holder = $('#' + me.progressBarId);\n    options = options === undefined ? {} : options;\n\n    // Check if progress is set to be displayed in the screen!\n    var screenNav = NavigationManager.getNavigationGroupById('screen');\n    var progressControl =\n      screenNav && screenNav.getControlsByType ? screenNav.getControlsByType('progress') : [];\n    var $currentScreen = $(\n      SCREEN_INTERACTIONS.getScreenWrapper(SCREEN_INTERACTIONS.strCurrentScreenId)\n    );\n\n    if (progressControl.length) {\n      // Use dots if requested.\n      options.useDots = BOO_GRAPHICAL_PAGE_COUNT;\n      // If so we will have to add the holder\n      if ($currentScreen.length) {\n        var pHolder = $currentScreen.find('#' + me.progressBarId);\n        if (!pHolder.length) {\n          $currentScreen\n            .find('.screenContentC')\n            .prepend(\n              '<div class=\"pageNumberScreenC\"><div class=\"pageNumberInnerC\">' +\n                screenNav.renderControlsByType('progress') +\n                '</div></div>'\n            );\n          holder = $currentScreen.find('#' + me.progressBarId);\n        } else {\n          holder = pHolder;\n        }\n      }\n    } else {\n      // If progress bar is not @ screen level\n      // then conditional dots should be used...\n      options.conditionalDots = BOO_GRAPHICAL_PAGE_COUNT;\n      holder = $('#' + me.progressBarId);\n    }\n\n    if (holder && holder.length) {\n      holder.html(me.renderProgress(courseData, options));\n\n      // When page count is shown with screen nav, do not show it if there is only one screen, this\n      // is because the screen nav will not be shown.\n      var displayClass = '';\n      if (\n        PAGE_COUNT_WITH_NAVIGATION\n      ) {\n        displayClass =\n          courseData.arrScreens.length > 1 ? 'progress-bar--visible' : 'progress-bar--hidden';\n      }\n      holder.addClass(displayClass);\n      $(holder).parent().addClass(displayClass);\n      // Set aira label for page count.\n      $(holder).attr(\n        'aria-label',\n        gomo.localiser.get('PROGRESS_BAR_PAGE_LABEL') + ' ' +\n        (courseData.intNavigationIndex + 1) + ' ' +\n        gomo.localiser.get('PROGRESS_BAR_SEPERATOR_LABEL') + ' ' +\n        courseData.arrScreens.length\n      );\n    }\n  },\n\n  renderProgress: function(courseData, options) {\n    var me = this;\n    var data = {};\n    var html = '';\n\n    options = options || {};\n    options.useDots = options.useDots == undefined ? false : options.useDots;\n    options.conditionalDots =\n      options.conditionalDots == undefined ? false : options.conditionalDots;\n    options.pageOverride = options.pageOverride || null;\n\n    // Have we exceeded the maximum number of dots? If so use the numbers!\n    if (options.conditionalDots && courseData.arrScreens.length > MAX_PROGRESS_DOTS_COUNT) {\n      options.useDots = false;\n    } else if (options.conditionalDots) {\n      options.useDots = true;\n    }\n\n    if (options.useDots) {\n      data.dots = [];\n      // Loop the screens and add a dot for each!\n      for (var i = 0; i < courseData.arrScreens.length; i++) {\n        // If we have a page index override and currently on that\n        // or if we have just found the current active index according to courseData\n        var active =\n          (options.pageOverride && options.pageOverride == i) ||\n          (!options.pageOverride && i == courseData.intNavigationIndex);\n        // Add a new dot\n        var dot = {\n          active: active,\n          style: active ? me.activeDotClass : '',\n          title: courseData.arrScreens[i].strTitle,\n          link: courseData.arrScreens[i].strObjID\n        };\n        data.dots.push(dot);\n      }\n      // Get the html\n      html = me.render(\n        TEMPLATE_MANANGER.getTemplate('progressDots_generalTemplateC').htmData,\n        data\n      );\n    } else {\n      data = {\n        seperator: STR_PAGE_SEPERATOR,\n        pageNo: courseData.intNavigationIndex + 1,\n        pageOf: courseData.arrScreens.length\n      };\n      html = me.render(\n        TEMPLATE_MANANGER.getTemplate('progressNumber_generalTemplateC').htmData,\n        data\n      );\n    }\n    return html;\n  },\n\n  render: function(partial, data) {\n    return Mustache.render(partial, data);\n  },\n\n  // Debug message\n  _debug: function(_strMessage) {\n    var me = this;\n    if (window['console'] && window.console.log && this._booDebug) {\n      console.log(me._strManifestID + ' : ' + _strMessage);\n    }\n  }\n};\n\nEM.register(PROGRESS_BAR);\n"},function(t,n,e){e(0)(e(39))},function(t,n){t.exports='/**\r\n* @title User Registration Extra\r\n* @description To be described.\r\n*\r\n*\r\n* @author GoMo\r\n* @version 2.0 13/02/18\r\n*/\r\n\r\nvar USER_REGISTRATION_EXTRA =\r\n{\r\n\tstrObjID : "User registration extra",\r\n\tstrObjDescription : "The extra blocks the content until the user has given credentials to send off to the LMS",\r\n\ttranslationId : "userRegistrationTranslation",\r\n\r\n\t_objCurrDOM : null,\r\n\t_strCurrOutputModeClass : "graphicalC",\r\n\t_strContentWrapperID : "lastPageVisitedContentWrapperL",\r\n\t_strTemplateID : \'userRegistrationPopupC\',\r\n\r\n\t_htmBaseLastPageVisitedTemplate : null,\r\n\r\n\tbooPopupShown : false,\r\n\t_booPopupVisible : false,\r\n\r\n\t_domAssetReturnFocusItemElement : "",\r\n\t_domCurrInsertionNode : "",\r\n\r\n\t_objCurrLocationData : null,\r\n\r\n\thandleEvent_primeDOMReferences : function (_objWhatDOM)\r\n\t{\r\n\t\tthis._objCurrDOM = _objWhatDOM;\r\n\t},\r\n\r\n\thandleEvent_outputModeChanged : function (_objOutputChangeData)\r\n\t{\r\n\t\tthis._strCurrOutputModeClass = _objOutputChangeData[\'strNewOutputMode\'];\r\n\t},\r\n\r\n\tpreCourseLoad : function ()\r\n\t{\r\n\t\tvar deferred = new $.Deferred();\r\n\r\n\t\tthis.registrationDefer = deferred;\r\n\t\tthis.showUserRegistration();\r\n\r\n\t\treturn deferred.promise();\r\n\t},\r\n\r\n\tpreCourseLoadChecks : function ()\r\n\t{\r\n\t\t//Change this check depending on what data is actually sent\r\n\t\tif(trackingData && trackingData.userRegistration){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\telse{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t},\r\n\r\n\tsubmitUserRegistration : function ()\r\n\t{\r\n\t\tvar emailValue = $("#userRegistrationContainer input[name=\'email\']")[0].value;\r\n\t\tvar firstnameValue = $("#userRegistrationContainer input[name=\'firstname\']")[0].value;\r\n\t\tvar surnameValue = $("#userRegistrationContainer input[name=\'surname\']")[0].value;\r\n\r\n\t\tvar registrationValid = true;\r\n\t\tvar validationFeedback = "";\r\n\r\n\t\tif(this.validateEmail(emailValue) == false){\r\n\t\t\tregistrationValid = false;\r\n\t\t\tvalidationFeedback += LOCALISER.get("USER_REG_POPUP_INVAID_ENTRY")+" Email<br/>";\r\n\t\t}\r\n\t\tif(this.validateExists(emailValue) == false){\r\n\t\t\tregistrationValid = false;\r\n\t\t\tvalidationFeedback += LOCALISER.get("USER_REG_POPUP_MISSING_REQUIRED_FIELD")+" Email<br/>";\r\n\t\t}\r\n\t\tif(this.validateExists(firstnameValue) == false){\r\n\t\t\tregistrationValid = false;\r\n\t\t\tvalidationFeedback += LOCALISER.get("USER_REG_POPUP_MISSING_REQUIRED_FIELD")+" Firstname<br/>";\r\n\t\t}\r\n\t\tif(this.validateExists(surnameValue) == false){\r\n\t\t\tregistrationValid = false;\r\n\t\t\tvalidationFeedback += LOCALISER.get("USER_REG_POPUP_MISSING_REQUIRED_FIELD")+" Surname<br/>";\r\n\t\t}\r\n\r\n\t\t//Success\r\n\t\tif(registrationValid == true){\r\n\t\t\t$(\'#userRegistrationModal\').modal(\'hide\');\r\n\t\t\tthis.registrationDefer.resolve({\'email\':emailValue,\'firstname\':firstnameValue,\'surname\':surnameValue});\r\n\t\t}\r\n\t\t//failure\r\n\t\telse{\r\n\t\t\t$("#userRegistrationContainer .feedback").html(validationFeedback);\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tvalidateEmail : function (email)\r\n\t{\r\n    var re = /^[a-zA-Z0-9.!#$%&\'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\r\n    return re.test(String(email).toLowerCase());\r\n\t},\r\n\r\n\tvalidateExists : function (fieldString)\r\n\t{\r\n\t\tif(typeof fieldString == "undefined" || fieldString == null || fieldString == "" || fieldString == " "){\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\telse{\r\n\t\t\treturn true;\r\n\t\t}\r\n\t},\r\n\r\n\tshowUserRegistration : function ()\r\n\t{\r\n\t\t// Do this to allow all other events to propogate before re-rendering.\r\n\t\tif(gomo.translationManager){\r\n\t\t\tgomo.translationManager.resetTopicData();\r\n\t\t}\r\n\r\n\t\tvar htmlTemplate = this._getTemplateHTML();\r\n\t\t$(\'<div id="userRegistrationContainer"></div>\').appendTo(\'body\');\r\n\t\t$(\'#userRegistrationContainer\').html(htmlTemplate);\r\n\t\tvar registrationContainerDom = $(\'#userRegistrationContainer\')[0];\r\n\t\tgomo.translationManager.translateLocalisations(registrationContainerDom, this.translationId, {\'group\':\'popup\'});\r\n\t\tvar options = {\'show\':true, \'keyboard\':false, \'backdrop\':"static"};\r\n\t\t$(\'#userRegistrationModal\').modal(options);\r\n\r\n\t\t//Destroy the modal after it\'s hidden\r\n\t\t$("#userRegistrationModal").on(\'hidden.bs.modal\', function () {\r\n\t    var element = document.getElementById("userRegistrationModal");\r\n\t\t\telement.parentNode.removeChild(element);\r\n\t\t});\r\n\t},\r\n\r\n\t_getTemplateHTML : function ()\r\n\t{\r\n\t\treturn TEMPLATE_MANANGER.getTemplate(this._strTemplateID).htmData;\r\n\t},\r\n\r\n\tdebug : function (strMessage, intPriority, objCallerObject, booCalleeChain)\r\n\t{\r\n\t\tif (DEBUG)\r\n\t\t{\r\n\t\t\tDEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nEM.register(USER_REGISTRATION_EXTRA);\r\nPOPUP_MANANGER.registerPopup("userRegistrationPopup", USER_REGISTRATION_EXTRA);\r\n'},function(t,n,e){e(0)(e(41))},function(t,n){t.exports="/* global $, SCREEN_INTERACTIONS, ASSET_INTERACTIONS, POPUP_MANANGER, EM, TOPIC_MANAGER, _ */\n\n/**\n * Tab manager extra responsible for setting and managing tab indexes within a course.\n *\n * @author J.Gowen\n */\ngomo.tabManager = (function() {\n  var screenFocusedElement = '';\n  var initialised = false;\n  var isUserTabbing = false;\n  var tabIndexRange = [];\n  var openModalElement = false;\n  var reverseTabDirection = false;\n\n  return {\n    /**\n     * Listeners to add and remove the focus css class which will show focus outlines.\n     */\n    addTabKeyListener: function() {\n      var me = this;\n      $(document).on('keyup', function(e) {\n        if (e.keyCode === 16) {\n          reverseTabDirection = false;\n        }\n      });\n      $(document).on('keydown', function(e) {\n        if (e.keyCode === 16) {\n          reverseTabDirection = true;\n        }\n        if (e.keyCode === 9) {\n          $('body').addClass('show-focus-outlines');\n          isUserTabbing = true;\n          me.checkTabRange(e);\n        }\n      });\n      $(document).on('mousemove', function(e) {\n        $('body').removeClass('show-focus-outlines');\n        isUserTabbing = false;\n      });\n    },\n\n    /**\n     * Gets all items that should be accessible and applies a tab index to them.\n     */\n    processContent: function() {\n      var me = this;\n      var accessibleItems = [];\n      var tabIndexValue = 0;\n\n      // screen and all assets on it\n      accessibleItems = accessibleItems.concat(me.getScreenContent());\n      // nav items\n      accessibleItems = accessibleItems.concat(me.getNavigationItems());\n      // top strap items\n      accessibleItems = accessibleItems.concat(me.getTopStrapItems());\n      // bottom strap items\n      accessibleItems = accessibleItems.concat(me.getBottomStrapItems());\n\n      // set tab indexes\n      $.each(accessibleItems, function(index, val) {\n        $(val).attr('tabindex', tabIndexValue);\n      });\n    },\n\n    /**\n     * Set tab indexes on the subscreen elements.\n     * @param {String} subscreenId - The subscreen data.\n     */\n    processSubscreen: function(subscreenId) {\n      var me = this;\n      var count = 0;\n      var subscreenElements = me.getSubscreenElements(subscreenId);\n\n      // set all tab indexes\n      while (count < subscreenElements.length) {\n        $(subscreenElements[count]).attr('tabindex', 0);\n        count++;\n      }\n    },\n\n    /**\n     * Set tab index on the popup elements\n     */\n    processPopup: function() {\n      var me = this;\n      var count = 0;\n      var popupElements = me.getPopupElements();\n\n      // set all tab indexes\n      if (popupElements) {\n        while (count < popupElements.length) {\n          $(popupElements[count]).attr('tabindex', 0);\n          count++;\n        }\n      }\n    },\n\n    /**\n     * Returns a list of elements to apply tabbing to from the current screen or all screens\n     * within the topic depending on whether the topic is continuous scrolling or not\n     * @return {Array} screenAccessibleElements - The accessible screen and asset elements\n     */\n    getScreenContent: function() {\n      var me = this;\n      var screenAccessibleElements = [];\n      if (gomo.topicManager.isContinuousScrollEnabled()) {\n        var topicScreens = TOPIC_MANAGER.getCurrentTopic().arrScreens;\n        for (var i = 0; i < topicScreens.length; i++) {\n          screenAccessibleElements.push(\n            SCREEN_INTERACTIONS.getScreenWrapper(topicScreens[i].strObjID)\n          );\n          screenAccessibleElements = screenAccessibleElements.concat(\n            me.getScreenContentItems(topicScreens[i])\n          );\n        }\n      } else {\n        screenAccessibleElements.push(SCREEN_INTERACTIONS._getCurrentPage());\n        screenAccessibleElements = screenAccessibleElements.concat(\n          me.getScreenContentItems(SCREEN_INTERACTIONS.getCurrentScreenData())\n        );\n      }\n      return screenAccessibleElements;\n    },\n\n    /**\n     * Gets the accessible elements for each asset as defined in each asset.\n     *\n     * @param {Object} screenData - The current screen data.\n     * @return {Array} accessibleScreenItems - The elements to apply tab indexes to.\n     */\n    getScreenContentItems: function(screenData) {\n      var me = this;\n      var accessibleScreenItems = [];\n      if (\n        screenData &&\n        screenData.strObjID &&\n        screenData.arrAssets &&\n        screenData.arrAssets.length > 0\n      ) {\n        var domScreen = $('#screenWrapper_' + screenData.strObjID + 'L');\n        accessibleScreenItems = me.getAccessibElementsInScreen(domScreen);\n      }\n      return accessibleScreenItems;\n    },\n\n    /**\n     * Sets focus to the first screen element after a navigation action\n     * unless it's the first time we're calling this function/on course load\n     * and some navigation elements are present.\n     * */\n    setFocusToCurrentScreen: function() {\n      if (!initialised) {\n        initialised = true;\n        if ($('.header__controls .control[aria-hidden=false]').length) {\n          return;\n        }\n      }\n      var currentScreen = SCREEN_INTERACTIONS._getCurrentScreen();\n      $('#screenWrapper_' + currentScreen.strObjID + 'L')\n        .attr('tabindex', '-1')[0]\n        .focus();\n    },\n\n    /**\n     * Gets a list of accessible elements from each asset on screen.\n     * @param {Object} assetData - The current asset data.\n     * @return {Array} accessibleAssetElements - The accessible asset elements.\n     */\n    getAccessibleTabElementsForAsset: function(assetData) {\n      var assetElements = [];\n      var asset = ASSET_INTERACTIONS.getNewAsset(assetData);\n      var count = 0;\n      var accessibleAssetElements = [];\n      var assetElement;\n\n      // get classnames/id's from each asset.\n      if (asset) {\n        if (typeof asset.getAccessibleElements !== 'undefined') {\n          assetElements = asset.getAccessibleElements(assetData);\n        }\n      } else {\n        if (ASSET_INTERACTIONS['getAccessibleElements_' + assetData.strAssetType]) {\n          assetElements = ASSET_INTERACTIONS['getAccessibleElements_' + assetData.strAssetType](\n            assetData\n          );\n        } else if (ASSET_INTERACTIONS['getAccessibleElements_' + assetData.objRawData.strGroup]) {\n          assetElements = ASSET_INTERACTIONS[\n            'getAccessibleElements_' + assetData.objRawData.strGroup\n          ](assetData);\n        }\n      }\n\n      // get asset from dom.\n      assetElement = $(\n        '#' + assetData.strAssetType + 'Asset_YY' + assetData.strObjID + 'YY_WrapperL'\n      );\n\n      // convert to jquery objects for ease of use later.\n      while (count < assetElements.length) {\n        var elem = $(assetElement).find(assetElements[count]);\n        if (elem.length > 1) {\n          var elemIndex = 0;\n          while (elemIndex < elem.length) {\n            accessibleAssetElements.push($(elem[elemIndex]));\n            elemIndex++;\n          }\n        } else if (elem.length === 1) {\n          accessibleAssetElements.push(elem);\n        }\n        count++;\n      }\n      return accessibleAssetElements;\n    },\n\n    /**\n     * Gets the accessible nav items, currently just back and next.\n     * @return {Array} accessibleNavElements - The accessible nav elements.\n     */\n    getNavigationItems: function() {\n      var accessibleNavElements = [];\n\n      if ($('#nextButtonL').hasClass('activeButtonC')) {\n        accessibleNavElements.push($('#nextButtonL'));\n      }\n\n      if ($('#backButtonL').hasClass('activeButtonC')) {\n        accessibleNavElements.push($('#backButtonL'));\n      }\n\n      return accessibleNavElements;\n    },\n\n    /**\n     * Gets the accessible top strap items\n     * @return {Array} accessibleTopStrapElements - The accessible top strap elements.\n     */\n    getTopStrapItems: function() {\n      var accessibleTopStrapElements = [];\n      var topStrapItems = $('#topStrapL > .strapControls > .control > a.activeButtonC').not(\n        '.hiddenC'\n      );\n\n      if (topStrapItems.length == 0) {\n        topStrapItems = $('#topStrapL > section > .strapControls > .control > a.activeButtonC').not(\n          '.hiddenC'\n        );\n      }\n      for (var i = 0; i < topStrapItems.length; i++) {\n        accessibleTopStrapElements.push($(topStrapItems[i]));\n      }\n      return accessibleTopStrapElements;\n    },\n\n    /**\n     * Gets the accessible bottom strap items\n     * @return {Array} accessibleBottomStrapElements - The accessible bottom strap elements.\n     */\n    getBottomStrapItems: function() {\n      var accessibleBottomStrapElements = [];\n      var bottomStrapItems = $('#navWrapperL  a');\n      for (var i = 0; i < bottomStrapItems.length; i++) {\n        accessibleBottomStrapElements.push($(bottomStrapItems[i]));\n      }\n      return accessibleBottomStrapElements;\n    },\n\n    /**\n     * Gets the accessible items within any active popups. ie. help, glossary etc.\n     * @return {Array} accessiblePopupElements - The accessible popup elements.\n     */\n    getPopupElements: function() {\n      var accessiblePopupElements = [];\n      var popupElements = POPUP_MANANGER.getAccessibleItems();\n      var count = 0;\n\n      if (popupElements) {\n        while (count < popupElements.length) {\n          if ($(popupElements[count]).length == 1) {\n            accessiblePopupElements.push($(popupElements[count]));\n          } else if ($(popupElements[count]).length > 1) {\n            $(popupElements[count]).each(function() {\n              accessiblePopupElements.push($(this));\n            });\n          }\n          count++;\n        }\n      }\n\n      return accessiblePopupElements;\n    },\n\n    /**\n     * Gets the accessible items within any active subscreens.\n     * @param {string} subscreenId - The subscreen data.\n     * @return {Array} accessiblePopupElements - The accessible subscreen elements.\n     */\n    getSubscreenElements: function(subscreenId) {\n      var me = this;\n      var subscreenElements = [];\n      var subscreen;\n\n      // get subscreen data\n      for (var i = 0; i < SCREEN_INTERACTIONS.getCurrentScreenData().arrSubScreens.length; i++) {\n        if (\n          SCREEN_INTERACTIONS.getCurrentScreenData().arrSubScreens[i].strObjID ==\n          subscreenId\n        ) {\n          subscreen = SCREEN_INTERACTIONS.getCurrentScreenData().arrSubScreens[i];\n          break;\n        }\n      }\n\n      // get all subscreen assets\n      // content wrapper\n      var domSubscreen = $('#subScreenContent_' + subscreenId + 'L');\n      // subscreen assets\n      if (\n        domSubscreen.length &&\n        subscreen &&\n        subscreen.arrAssets &&\n        subscreen.arrAssets.length > 0\n      ) {\n        subscreenElements = subscreenElements.concat(\n          me.getAccessibElementsInScreen(domSubscreen)\n        );\n      }\n      // close button\n      var subscreenCloseButton = $('#subScreenWrapper_' + subscreenId + 'L .subScreenCloseButtonC');\n      if ($(subscreenCloseButton).length) {\n        subscreenElements.push($(subscreenCloseButton));\n      }\n      return subscreenElements;\n    },\n\n    /**\n     * Returns all accessible elements in a given screen.\n     * @param {object} screenElement\n     * @return {array} accessibleScreenItems\n     */\n    getAccessibElementsInScreen: function(screenElement) {\n      var me = this;\n      var accessibleScreenItems = [];\n\n      // Find all assets inside the given screen.\n      var domAssets = $(screenElement).find('.genericAssetWrapperC');\n      if (domAssets.length === 0) return [];\n\n      // For each asset in the screen find the elements that can have a tabindex applied.\n      _.each(domAssets, function(asset) {\n        var assetId = asset.id.split('YY')[1]; // assetWrapperFor_YYp45i01s02a01YY_L\n        var assetData = ASSET_INTERACTIONS.getAssetData(assetId);\n        if (!_.isUndefined(assetData)) {\n          accessibleScreenItems = accessibleScreenItems.concat(\n            me.getAccessibleTabElementsForAsset(assetData)\n          );\n        }\n      });\n\n      return accessibleScreenItems;\n    },\n\n    /**\n     * Removes any current tab indexes, processes new ones and focuses the first element.\n     */\n    applyTabIndexes: function() {\n      var me = this;\n      me.processContent();\n    },\n\n    /**\n     * Keeps tabbing within a range, used to restict tabbing within a subscreen or popup.\n     * @param {Object} e - Default tab keypress event which we will ignore if out of range.\n     */\n    checkTabRange: function(e) {\n      if (tabIndexRange.length > 0) {\n        var activeElem = document.activeElement;\n        // if the currently focused element is the last in the range and we are tabbing forwards,\n        // move focus to the first element.\n        if (!reverseTabDirection && activeElem === tabIndexRange[tabIndexRange.length - 1]) {\n          e.preventDefault();\n          tabIndexRange[0].focus();\n        }\n        // if the currently focused element is the first in the range and we are tabbing backwards,\n        // move focus to the last element.\n        if (reverseTabDirection && activeElem === tabIndexRange[0]) {\n          e.preventDefault();\n          tabIndexRange[tabIndexRange.length - 1].focus();\n        }\n      }\n    },\n\n    /**\n     * Apply tab indexes when a page has animated into view.\n     */\n    handleEvent_screenAnimationComplete: function() {\n      var me = this;\n      me.applyTabIndexes();\n      me.setFocusToCurrentScreen();\n    },\n\n    /**\n     * Focus the first element in the active modal.\n     * @param {string} modalElement\n     * @param {object} firstFocusItem HTML element or string to find.\n     */\n    focusModalContent: function(modalElement, firstFocusItem) {\n      var me = this;\n      if (gomo.outputChecker.isIOSDevice()) return;\n\n      // store open modal for updating tab range if required\n      openModalElement = modalElement;\n\n      // get all elements in the popup with a tab index and focus the first.\n      if (modalElement) {\n        me.setTabRange(openModalElement);\n        if (firstFocusItem) {\n          // firstFocusItem could be an element but if its a string go find it.\n          if (typeof(firstFocusItem) === 'string') {\n            firstFocusItem = $(modalElement).find(firstFocusItem)[0];\n          }\n        } else {\n          firstFocusItem = tabIndexRange.length ? tabIndexRange[0] : false;\n        }\n      }\n\n      if (firstFocusItem) {\n        firstFocusItem.focus({preventScroll: true});\n      }\n    },\n\n    /**\n     * Gathers all elements within a modal with a tab index, used to limit tabbing range.\n     * @param {Object} modalElement\n     */\n    setTabRange: function(modalElement) {\n      if (!modalElement) return;\n      var modalFocusItems = false;\n      modalFocusItems = $(modalElement).find('*[tabindex=\\'0\\'], button, a');\n      if (modalFocusItems) {\n        tabIndexRange = Array.prototype.slice.call(modalFocusItems);\n      }\n    },\n\n    /**\n     * Apply tab indexes to elements within a popup when it is opened if required.\n     */\n    handleEvent_showPopup: function() {\n      var me = this;\n      me.setActiveFocus();\n      me.processPopup();\n    },\n\n    /**\n     * Store id or the element of the currently focused element so focus can be returned to it.\n     */\n    setActiveFocus: function() {\n      if (!document.activeElement.id) {\n        screenFocusedElement = document.activeElement;\n      } else {\n        screenFocusedElement = document.activeElement.id;\n      }\n    },\n\n    /**\n     * Focus the last active screen element when a popup or subscreen has been closed.\n     */\n    focusLastScreenElement: function() {\n      tabIndexRange = [];\n      if (isUserTabbing && screenFocusedElement) {\n        if (typeof(screenFocusedElement) === 'object') {\n          $(screenFocusedElement.focus());\n        }\n        if (typeof(screenFocusedElement) === 'string') {\n          $('#'+ screenFocusedElement)[0].focus();\n        }\n        screenFocusedElement = '';\n      }\n    },\n\n    /**\n     * Refresh tab indexes when content changes, currently used for search results and display\n     * conditions.\n     * @param {String} type - The type of content that has changed.\n     * @param {Object} elements - The dom element to check for range. Used for popups.\n     */\n    refreshTabIndexes: function(type, elements) {\n      var me = this;\n\n      if (type === 'popup') {\n        // Apply a tab indexes to the popup content.\n        me.processPopup();\n        // Setup the range limiting.\n        me.setTabRange(elements);\n      }\n\n      // Apply tab index to items shown with a display condition and update the tab range if element\n      // is in a subscreen.\n      if (type === 'displayConditions' && elements && elements.length) {\n        // Apply tab indexes to elements now visible after a display condition changes.\n        var elemCount = 0;\n        while (elemCount < elements.length) {\n          if (\n            elements[elemCount].objParent &&\n            elements[elemCount].objParent.strObjType === 'subscreen' &&\n            elements[elemCount].objParent.strObjID\n          ) {\n            me.processSubscreen(elements[elemCount].objParent.strObjID);\n          } else {\n            me.applyTabIndexes();\n          }\n          elemCount++;\n        }\n        me.setTabRange(openModalElement);\n      }\n    },\n\n    /**\n     * Move the focus of a question asset to the previous or next option\n     * @param {object} elem\n     * @param {number} charCode\n     */\n    questionOptionNav: function(elem, charCode) {\n      var currentElementId = $(elem).attr('id');\n      var nextElement;\n      if (charCode === 38) {\n        // Move up\n        nextElement = $('#' + currentElementId).prev();\n      } else if (charCode === 40) {\n        // Move down\n        nextElement = $('#' + currentElementId).next();\n      }\n      if (nextElement !== undefined) {\n        $(nextElement).focus();\n      }\n    }\n  };\n})();\n\ngomo.tabManager.addTabKeyListener();\n\nEM.register(gomo.tabManager);\n"},function(t,n,e){e(0)(e(43))},function(t,n){t.exports="/* global POLL_CONNECTION, $ */\n/**\n * Connection checker extra responsible for warning on dropped internet connection.\n *\n * @author J.Hough\n */\ngomo.connectionChecker = (function() {\n  var maxRetryCount = 3;\n  var currentRetryCount = 0;\n  var pollingFrequency = 5; // in seconds\n  var pollingPaused = false;\n  var connectionInterval = null;\n  var activeConnection = null; // unknown\n\n  // Set Event listener to trigger polling\n  $( document ).on( 'gomoLoaded', function() {\n    gomo.connectionChecker.pollForConnection();\n  });\n\n  return {\n    /**\n     * Set polling for a connection\n     */\n    pollForConnection: function() {\n      // Only run on supported browsers\n      if (typeof navigator.onLine !== 'boolean') {\n        console.log('Warning - Connection-checker Extra not supported.');\n        return;\n      }\n      if (!POLL_CONNECTION) {\n        return;\n      }\n\n      // Convert seconds to milliseconds\n      pollingFrequency = pollingFrequency * 1000;\n\n      connectionInterval = setInterval(function() {\n        var maxRetryCount = gomo.connectionChecker.getMaxRetryCount();\n        var currentRetryCount = gomo.connectionChecker.getCurrentRetryCount();\n\n        // If paused then don't continue\n        if (pollingPaused) {\n          return;\n        }\n\n        if (navigator.onLine) {\n          gomo.connectionChecker.setActiveConnection(true);\n          gomo.connectionChecker.setCurrentRetryCount(0);\n        } else {\n          if (maxRetryCount <= currentRetryCount) {\n            gomo.connectionChecker.setActiveConnection(false);\n            // Show warning\n            // To-do - double check we don't have a popup lib. If not then find one to use\n            var alertType = 'warning';\n            var message = gomo.localiser.get('CONNECTION_CHECKER_WARNING');\n            var buttons = [\n              {\n                label: gomo.localiser.get('CONNECTION_CHECKER_IGNORE'),\n                type: 'secondary',\n                action: gomo.connectionChecker.stopPolling\n              },\n              {\n                label: gomo.localiser.get('CONNECTION_CHECKER_CONTINUE'),\n                type: 'primary',\n                action: gomo.connectionChecker.startPolling\n              }\n            ];\n            gomo.alertManager.create(alertType, false, message, buttons);\n            gomo.connectionChecker.setCurrentRetryCount(0);\n            gomo.connectionChecker.pausePolling();\n          } else {\n            // Increment currentRetryCount\n            gomo.connectionChecker.setCurrentRetryCount(currentRetryCount + 1);\n          }\n        }\n      }, pollingFrequency);\n    },\n\n    /**\n     * Set Active connection status\n     * @param {boolean} status\n     */\n    setActiveConnection: function(status) {\n      activeConnection = status;\n    },\n\n    /**\n     * Get Active connection status\n     * @return {boolean}\n     */\n    isConnectionActive: function() {\n      return activeConnection;\n    },\n\n    /**\n     * Get the max retry count\n     * @return {number}\n     */\n    getMaxRetryCount: function() {\n      return maxRetryCount;\n    },\n\n    /**\n     * Get current retry count\n     * @return {number}\n     */\n    getCurrentRetryCount: function() {\n      return currentRetryCount;\n    },\n\n    /**\n     * Set current retry count\n     * @param {number} value\n     */\n    setCurrentRetryCount: function(value) {\n      currentRetryCount = value;\n    },\n\n    /**\n     * Pause polling\n     */\n    pausePolling: function() {\n      pollingPaused = true;\n    },\n\n    /**\n     * Start polling\n     */\n    startPolling: function() {\n      pollingPaused = false;\n    },\n\n    /**\n     * Stop polling\n     */\n    stopPolling: function() {\n      if (connectionInterval) {\n        clearInterval(connectionInterval);\n      }\n    }\n  };\n})();\n"},function(t,n,e){e(0)(e(45))},function(t,n){t.exports="/* globals POPUP_MANANGER, EM, DEBUG, ANIMATOR_INTERFACE_2, TEMPLATE_MANANGER, $, CORE,\nTOPIC_MANAGER, LOADER, TOC_SLIDE_ANIMATION */\n\n/**\n * @title Settings\n * @description To be described.\n *\n *\n * @author GoMo\n * @version 2.0 17/12/12\n */\n\nvar TABLE_OF_CONTENTS_EXTRA = {\n  strObjID: 'The Table of Contents extra',\n  strObjDescription:\n    'Displays a list of topics and allows quick navigation to those topics',\n\n  _objCurrDOM: null,\n\n  _strCurrOutputModeClass: 'graphicalC',\n\n  _domCurrInsertionNode: '',\n\n  _strPopupWrapperID: 'tableOfContentsPopupHolderL',\n  _strPopupTemplateID: 'tableOfContentsPopupC',\n  _strButtonID: 'tableOfContentsL',\n  _strItemTemplateID: 'tableOfContentsItemC',\n\n  _htmBaseWrapperTemplate: '',\n  _htmBaseItemTemplate: '',\n\n  _strDisplayElement: 'visibleC',\n  _strHideElement: 'hiddenC',\n\n  _strContentWrapperId: '#pageWrapperL',\n\n  _intAnimationDuration: 500,\n\n  booPopupShown: false,\n  _booPopupVisible: false,\n\n  handleEvent_primeDOMReferences: function(_objWhatDOM) {\n    this._objCurrDOM = _objWhatDOM;\n  },\n\n  handleEvent_outputModeChanged: function(_objOutputChangeData) {\n    this._strCurrOutputModeClass = _objOutputChangeData['strNewOutputMode'];\n    if (this.booPopupShown) {\n      this.hidePopup({booResetSettings: true});\n      POPUP_MANANGER.unlockPopups();\n      this._cleanUpAndHide();\n    }\n  },\n\n  handleEvent_navigationRendered: function() {\n    $('#' + this._strButtonID).attr('aria-controls', this._strPopupWrapperID);\n  },\n\n  handleEvent_popupAnimationComplete: function() {},\n\n  handleEvent_swipeLeft: function() {\n    if (this._booPopupVisible) {\n      this._forceClosePopup();\n    }\n  },\n\n  handleEvent_tableOfContentAction: function(_objButtonData) {\n    var _objActionOptions = {};\n    _objActionOptions.objActions = [\n      {\n        objParameters: {target_id: _objButtonData.strTargetID},\n        strActionGroup: 'navigation',\n        strObjectType: 'action',\n        strType: 'internal_link'\n      }\n    ];\n    _objActionOptions.objOptionalExtraData = {};\n    _objActionOptions.objOptionalExtraData.domLink = _objButtonData.domLink;\n\n    // Example feed back for completion of subscreen display.\n    _objActionOptions.objOptionalExtraData.funTriggerCallBack = function() {\n      TABLE_OF_CONTENTS_EXTRA._forceClosePopup();\n    };\n\n    EM.trigger('processActions', _objActionOptions);\n  },\n\n  popupAnimationComplete: function(tocDomElement) {\n    if (!this._booPopupVisible) {\n      POPUP_MANANGER.unlockPopups();\n      this._cleanUpAndHide();\n    } else {\n      gomo.tabManager.focusModalContent(tocDomElement, tocDomElement);\n    }\n  },\n\n  showPopup: function(_domWhatNodeToInsertInto) {\n    EM.trigger('disableScreenSwiping');\n\n    this._getTemplateHTML();\n    this._domCurrInsertionNode = _domWhatNodeToInsertInto;\n\n    var _htmTableOfContentsPopup = this._createTableOfContentsPopupHTML();\n    this._domCurrInsertionNode.innerHTML = _htmTableOfContentsPopup;\n    this._domTableOfContents = this._objCurrDOM.getElementById(this._strPopupWrapperID);\n\n    if (this._strCurrOutputModeClass != 'accessibleC') {\n      this._booPopupVisible = true;\n\n      // Popup animation\n      var _objOptions = {};\n\n      _objOptions.startPoint = this._domTableOfContents.clientWidth * -1;\n      _objOptions.duration = this._intAnimationDuration;\n      var tocDomElement = this._domTableOfContents;\n      _objOptions.complete = function() {\n        TABLE_OF_CONTENTS_EXTRA.popupAnimationComplete(tocDomElement);\n      };\n\n      ANIMATOR_INTERFACE_2.animateHorizontalSide(this._domCurrInsertionNode, _objOptions);\n\n      // Page animation\n      _objOptions = {};\n\n      _objOptions.endPoint = this._domTableOfContents.clientWidth;\n      _objOptions.duration = this._intAnimationDuration;\n\n      if (!TOC_SLIDE_ANIMATION) {\n        ANIMATOR_INTERFACE_2.animateHorizontalSide(this._strContentWrapperId, _objOptions);\n      }\n    }\n\n    // If already displayed in normal mode, reset the transform so accessible mode can be displayed\n    if (this._strCurrOutputModeClass == 'accessibleC') {\n      if (typeof $(this._domCurrInsertionNode).css('transform') !== 'undefined') {\n        $(this._domCurrInsertionNode).css('transform', 'none');\n      }\n    }\n\n    this.booPopupShown = true;\n    $('#' + this._strButtonID).attr('aria-expanded', true);\n    EM.trigger('showPopup');\n  },\n\n  hidePopup: function(_objPopupData) {\n    if (this._strCurrOutputModeClass != 'accessibleC') {\n      if (this._booPopupVisible) {\n        this._booPopupVisible = false;\n\n        // Popup animation\n        var _objOptions = {};\n\n        _objOptions.endPoint = this._domTableOfContents.clientWidth * -1;\n        _objOptions.duration = this._intAnimationDuration;\n        _objOptions.complete = function() {\n          TABLE_OF_CONTENTS_EXTRA.popupAnimationComplete();\n        };\n\n        ANIMATOR_INTERFACE_2.animateHorizontalSide(this._domCurrInsertionNode, _objOptions);\n\n        // Page animation\n        _objOptions = {};\n\n        _objOptions.startPoint = this._domTableOfContents.clientWidth;\n        _objOptions.duration = this._intAnimationDuration;\n\n        if (!TOC_SLIDE_ANIMATION) {\n          ANIMATOR_INTERFACE_2.animateHorizontalSide(this._strContentWrapperId, _objOptions);\n        }\n      }\n    } else {\n      this._cleanUpAndHide();\n    }\n    EM.trigger('enableScreenSwipe');\n  },\n\n  _forceClosePopup: function() {\n    EM.trigger('closePopup', {strPopupID: 'tableOfContents'});\n  },\n\n  _cleanUpAndHide: function() {\n    POPUP_MANANGER.unlockPopups();\n    if (this._domCurrInsertionNode) {\n      this._domCurrInsertionNode.innerHTML = '';\n      this._domCurrInsertionNode = null;\n      this.booPopupShown = false;\n      $('#' + this._strButtonID).attr('aria-expanded', false);\n      POPUP_MANANGER.postAnimationTidyUp();\n    }\n  },\n\n  _getTemplateHTML: function() {\n    this._htmBaseWrapperTemplate = TEMPLATE_MANANGER.getTemplate(this._strPopupTemplateID).htmData;\n    this._htmBaseItemTemplate = TEMPLATE_MANANGER.getTemplate(this._strItemTemplateID).htmData;\n  },\n\n  _createTableOfContentsPopupHTML: function() {\n    var _htmTableOfContentsPopup = this._htmBaseWrapperTemplate;\n\n    _htmTableOfContentsPopup = _htmTableOfContentsPopup.replace(\n      'XX_TABLE_OF_CONTENTS_POPUP_TITLE_XX',\n      'Contents'\n    );\n    var _htmItemsList = this._getContentItems();\n    _htmTableOfContentsPopup = _htmTableOfContentsPopup.replace(\n      'XX_CONTENT_ITEMS_XX',\n      _htmItemsList\n    );\n\n    return _htmTableOfContentsPopup;\n  },\n\n  _getContentItems: function() {\n    var _htmItemsListings = '';\n    var _arrQuickLaunchTopics = [];\n    if (CORE.objCourseData.objRawData.arrQuickLaunchTopics) {\n      _arrQuickLaunchTopics = CORE.objCourseData.objRawData.arrQuickLaunchTopics;\n    } else {\n      _arrQuickLaunchTopics = this._autoGeneratedListOfItems();\n    }\n    var _objCurrentTopicId = TOPIC_MANAGER.getCurrentTopic().strObjID;\n\n    if (typeof _arrQuickLaunchTopics != 'undefined') {\n      var count = 0;\n      while (count < _arrQuickLaunchTopics.length) {\n        var objCurrentTopic = _arrQuickLaunchTopics[count];\n        var _htmCurrItem = this._htmBaseItemTemplate;\n        var topicTitle = '';\n\n        if (typeof objCurrentTopic.titles !== 'undefined') {\n          topicTitle =\n            objCurrentTopic.titles[gomo.translationManager.langCode] ||\n            objCurrentTopic.titles['default'];\n        } else {\n          topicTitle = objCurrentTopic.strTitle;\n        }\n\n        _htmCurrItem = _htmCurrItem.replace(/XX_TABLE_OF_CONTENTS_NAME_XX/g, topicTitle);\n        _htmCurrItem = _htmCurrItem.replace(/XX_SCREEN_ID_XX/g, objCurrentTopic.strTopicID);\n\n        var _strItemClass = 'inactiveItemC';\n        if (objCurrentTopic.strTopicID === _objCurrentTopicId) {\n          _strItemClass = 'activeItemC';\n        }\n        _htmCurrItem = _htmCurrItem.replace(/XX_TABLE_OF_CONTENTS_CLASS_XX/g, _strItemClass);\n\n        _htmItemsListings += _htmCurrItem;\n\n        count++;\n      }\n      return _htmItemsListings;\n    } else {\n      return 'Please select one or more topics in the Portal to quick launch to.';\n    }\n  },\n\n  _autoGeneratedListOfItems: function() {\n    var arrTopics = CORE.objCourseData.arrContainers;\n    var arrItemList = [];\n    var count = 0;\n    while (count < arrTopics.length) {\n      if (arrTopics[count].strTitle === '') {\n        var topicObject = LOADER.loadTopicData(arrTopics[count].strTopicDataFilename);\n        if (topicObject && topicObject.topic) {\n          topicObject.topic.strTopicID = topicObject.topic.strID;\n          arrItemList.push(topicObject.topic);\n        }\n      } else {\n        arrItemList.push({\n          strTitle: arrTopics[count].strTitle,\n          strTopicID: arrTopics[count].strObjID\n        });\n      }\n      count++;\n    }\n\n    return arrItemList;\n  },\n\n  debug: function(strMessage, intPriority, objCallerObject, booCalleeChain) {\n    if (DEBUG) {\n      DEBUG.lert(strMessage, intPriority, objCallerObject, booCalleeChain);\n    }\n  },\n\n  /**\n   * Return all elements within this asset that should be included in the tab list.\n   * @return {Array} The elements we want to include in the tab list.\n   */\n  getAccessibleElements: function() {\n    var accessibleElements = [\n      '.tableOfContentsItemC',\n      '#closeTableOfContentsPopupL'\n    ];\n    return accessibleElements;\n  }\n};\n\nEM.register(TABLE_OF_CONTENTS_EXTRA);\nPOPUP_MANANGER.registerPopup('tableOfContents', TABLE_OF_CONTENTS_EXTRA);\n"},function(t,n,e){e(0)(e(47))},function(t,n){t.exports="/**\n* BACK Extra\n* ---\n* @author GoMo\n*/\n\nvar global = this;\n\nif(global.Mustache === undefined){\n\tconsole.log('ERROR: Mustache not found!');\n}\n\nvar BACK_EXTRA =\n{\n\tstrObjID : \"The back button extra\",\n\tstrObjDescription : \"The extra responsible for display of the back button.\",\n\n\t_strManifestID : \"backExtra\",\n\t_objCurrDOM : null,\n\t_domCurrInsertionNode : null,\n\t_booDebug : false,\n\n\thandleEvent_primeDOMReferences : function (_objWhatDOM){\n\t\tthis._objCurrDOM = _objWhatDOM;\n\t},\n\n\thandleEvent_outputModeChanged : function (_objOutputChangeData){\n\t},\n\n\thandleEvent_screenSizeChanged : function (_objOutputChangeData){\n\t},\n\n\t// Debug message\n\t_debug : function (_strMessage){\n\t\tif ((window['console']) && (window.console.log) && (this._booDebug)){\n\t\t\tconsole.log(_strManifestID + ' : ' + _strMessage);\n\t\t}\n\t}\n}\n\nEM.register(BACK_EXTRA);"},function(t,n,e){e(0)(e(49))},function(t,n){t.exports="/* global $, BOO_WRAP_TEXT_ASSET_CONTENT, INT_LEFT_TEXT_FILL_PADDING, INT_TOP_TEXT_FILL_PADDING */\n(function() {\n  // Create new TextAsset\n  var TextAsset = gomo.Asset.extend({\n    handleOwnEnabledState: true,\n\n    processData: function(data) {\n      var me = this;\n      var rawData = data.objRawData;\n\n      rawData.alignment = rawData.strTextAlign + 'C';\n      rawData.importedStyle = rawData.strTextStyle + me.importedStyleSuffix;\n      // Do we apply a content wrapper?\n      rawData.wrapContent = BOO_WRAP_TEXT_ASSET_CONTENT;\n      rawData.padding = {\n        horizontal: INT_LEFT_TEXT_FILL_PADDING,\n        vertical: INT_TOP_TEXT_FILL_PADDING\n      };\n\n      // Set the background colour if required\n      if (rawData.strScreenBackgroundColor) {\n        rawData.bgFillClass = 'bgFill';\n        rawData.bgFillStyle = this.getInlineStyle(data);\n      }\n\n      // Are we handling instructions texts?\n      if (isInstructionTextStyle(rawData.strTextStyle)) {\n        var screenData = data.objParent;\n        var visibilityPattern = '';\n        var collectionId = '';\n        var childInstructionTexts = getChildInstructionTexts(rawData, screenData);\n        // Find all child instructions and link them via a collection id etc.\n        if (childInstructionTexts.length > 1) {\n          collectionId = generateCollectionId();\n          visibilityPattern = collectionVisibilityPattern(childInstructionTexts);\n          var count = 0;\n          while (count < childInstructionTexts.length) {\n            var currentText = childInstructionTexts[count];\n            currentText['collectionId'] = collectionId;\n            currentText['visibilityPattern'] = visibilityPattern;\n            if (isInstructionTextStyle(currentText.strTextStyle)) {\n              currentText['instructionText'] = currentText.strTextStyle + visibilityPattern;\n            }\n            count++;\n          }\n          // Only one child instruction\n        } else if (childInstructionTexts.length == 1) {\n          visibilityPattern = '_GroupOfOneInstructionC';\n        }\n\n        rawData.instructionText = rawData.strTextStyle + rawData['visibilityPattern'];\n      }\n\n      // Is this a heading? Add heading role if it is.\n      var headingStyle = isHeadingTextStyle(rawData.strTextStyle);\n      if (headingStyle) {\n        rawData.role = 'heading';\n        rawData.headingLevel = headingStyle.match(/\\d/g);\n      }\n    },\n\n    // Before we render the asset ...\n    beforeRender: function() {\n      var me = this;\n      var rawData = me.data.objRawData;\n      rawData.textContent = me.formatHTML(rawData.strContent);\n    },\n\n    // Before the asset is shown ...\n    beforeShown: function() {},\n\n    translationPreprocess: function() {\n      var found =\n        gomo.translationManager.findDataByAssetId(this.data.strObjID);\n      if (found) {\n        this.updateTextAlignment(found);\n      }\n    },\n\n    updateTextAlignment: function(data) {\n      var textElement = $('#textAsset_YY' + data.id + 'YY_WrapperL');\n      if (textElement.length && typeof data.strTextAlign !== 'undefined') {\n        textElement[0].className =\n          textElement[0].className.replace(/\\b[A-Za-z]*-alignC\\b/, '');\n        textElement.addClass(data.strTextAlign + 'C');\n      }\n    },\n\n\n    checkAndHandleEnabledState: function() {\n      var me = this;\n      me.switchState();\n    },\n\n    // update inline actions states\n    switchState: function() {\n      var me = this;\n      var textContent = me.data.objRawData.strContent;\n\n      var asRegex = /\\[actionset=([^\\]]+)\\]/g;\n      var linkStates = [];\n      textContent.replace(asRegex, function(match, groupOne) {\n        if (typeof groupOne !== 'undefined') {\n          var breakUp = groupOne.split('.');\n          var actionId = 'actionSetLink_' + breakUp[1] + '_L';\n          var linkState = 'enabledAction';\n          if (me.checkEnabledState(groupOne) == false) {\n            linkState = 'disabledAction';\n          }\n          linkStates.push({actionId: actionId, state: linkState});\n        }\n      });\n\n      linkStates.forEach(function(element) {\n        var toggleState = 'enabledAction';\n        if (element.state === toggleState) {\n          toggleState = 'disabledAction';\n        }\n        me.$el.find('#' + element.actionId).removeClass(toggleState).addClass(element.state);\n      });\n    },\n\n    //\n    registerEvents: function() {},\n\n    /**\n     * @return {string}\n     */\n    getContent: function() {\n      return this.formatHTML(this.data.objRawData.strContent);\n    },\n\n    /**\n     * @return {array} accessibleElements\n     */\n    getAccessibleElements: function() {\n      var accessibleElements = ['span[role=\"button\"]', 'a'];\n      return accessibleElements;\n    }\n  });\n\n  // Register the new asset definition...\n  gomo.assetManager.register('text', TextAsset);\n\n  /**\n   *\n   * Private support methods....\n   *\n   */\n\n  var instructionStyles = {\n    initial: 'gomo-initialInstruction',\n    intermediate: 'gomo-intermediateInstruction',\n    finalInstruction: 'gomo-finalInstruction'\n  };\n\n  /**\n   * @private\n   * @function isInstructionTextStyle\n   * @param {string} textStyle\n   * @return {boolean} If text style is an instruction\n   */\n  function isInstructionTextStyle(textStyle) {\n    var found = false;\n    for (var i in instructionStyles) {\n      if (Object.prototype.hasOwnProperty.call(instructionStyles, i)) {\n        found = found || instructionStyles[i] == textStyle;\n      }\n    }\n    return found;\n  }\n\n  var headingStyles = {\n    h1: 'gomo-h1Title',\n    h2: 'gomo-h2SubHeading',\n    h3: 'gomo-h3SubHeading'\n  };\n\n  /**\n   * @private\n   * @function isHeadingTextStyle\n   * @param {string} textStyle\n   * @return {boolean} If text style is an heading\n   */\n  function isHeadingTextStyle(textStyle) {\n    var found = false;\n    for (var i in headingStyles) {\n      if (Object.prototype.hasOwnProperty.call(headingStyles, i)) {\n        found = found || headingStyles[i] == textStyle;\n        if (found) break;\n      }\n    }\n    return found ? i : found;\n  }\n\n  /**\n   * @private\n   * @function collectionVisibilityPattern\n   * @param {Object[]} textAssets\n   * @return {string} The visibility pattern name\n   */\n  function collectionVisibilityPattern(textAssets) {\n    if (textAssets.length == 3) {\n      return '_GroupOfThreeInstructionsType1C';\n    }\n\n    var firstInstruction = textAssets[0];\n    var secondInstruction = textAssets[1];\n    var combinedStyle = firstInstruction.strTextStyle + ' ' + secondInstruction.strTextStyle;\n\n    // Initial and intermediate instruction...\n    if (\n      ~combinedStyle.indexOf(instructionStyles.initial) &&\n      ~combinedStyle.indexOf(instructionStyles.intermediate)\n    ) {\n      return '_GroupOfTwoInstructionsType1C';\n    }\n\n    // Initial and final instruction...\n    if (\n      ~combinedStyle.indexOf(instructionStyles.initial) &&\n      ~combinedStyle.indexOf(instructionStyles.finalInstruction)\n    ) {\n      return '_GroupOfTwoInstructionsType2C';\n    }\n\n    // Intermediate and final instruction...\n    if (\n      ~combinedStyle.indexOf(instructionStyles.intermediate) &&\n      ~combinedStyle.indexOf(instructionStyles.finalInstruction)\n    ) {\n      return '_GroupOfTwoInstructionsType3C';\n    }\n  }\n\n  /**\n   * @private\n   * @function generateCollectionId\n   * @return {string} A randomly generated id\n   */\n  function generateCollectionId() {\n    var dateString = new Date().getTime();\n    var randomNumber = Math.ceil(Math.random() * 100000000);\n    var id = 'asset-set_' + dateString + randomNumber;\n    return id;\n  }\n\n  /**\n   * @private\n   * @function getChildInstructionTexts\n   * @param {Object} rawAssetData\n   * @param {Object} screenData\n   * @return {Array} The child instruction text assets\n   */\n  function getChildInstructionTexts(rawAssetData, screenData) {\n    if (!screenData.getIntructionTextTriggered) {\n      screenData.getIntructionTextTriggered = true;\n      var childInstructionTexts = [];\n      var childInstructionTextIds = [];\n      var instructionTextTypes = {};\n\n      var screenAssets = screenData.arrAssets;\n      // Look for instruction text in each asset\n      var assetCount = 0;\n      while (assetCount < screenAssets.length) {\n        // Found another instruction?\n        var currentAsset = screenAssets[assetCount].objRawData;\n        if (isInstructionTextStyle(currentAsset.strTextStyle)) {\n          // Add to child instructions\n          childInstructionTexts.push(currentAsset);\n          childInstructionTextIds.push(currentAsset['strID']);\n          //\n          if (!instructionTextTypes[currentAsset.strTextStyle]) {\n            instructionTextTypes[currentAsset.strTextStyle] = 1;\n          } else {\n            instructionTextTypes[currentAsset.strTextStyle]++;\n          }\n        }\n        assetCount++;\n      }\n\n      if (childInstructionTextIds.length > 3) {\n        // 4 or more text assets set to an instruction text style detected. Please group no more\n        // than 3 at a time.\n        gomo.localiser.localisedAlert('TEXT_TOO_MANY_GROUPED_ERROR', [\n          childInstructionTextIds.join('\\n')\n        ]);\n      }\n      checkForDuplicateInstructionTypes(instructionTextTypes);\n      return childInstructionTexts;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @private\n   * @function checkForDuplicateInstructionTypes\n   * @param {string[]} instructionTypes\n   */\n  function checkForDuplicateInstructionTypes(instructionTypes) {\n    var foundDuplicate = false;\n    var duplicateErrorMessage = gomo.localiser.get('TEXT_SAME_TYPE_GROUPING_ERROR_PREFIX');\n    // Check for duplicates and build the error message.\n    for (var instructionType in instructionTypes) {\n      if (instructionTypes[instructionType] > 1) {\n        duplicateErrorMessage += instructionType + ' : ' + instructionTypes[instructionType] + '\\n';\n        foundDuplicate = true;\n      }\n    }\n    // If we have duplicates, show the error message.\n    if (foundDuplicate) {\n      duplicateErrorMessage += gomo.localiser.get('TEXT_SAME_TYPE_GROUPING_ERROR_SUFFIX');\n      alert(duplicateErrorMessage);\n    }\n  }\n})();\n"},function(t,n,e){e(0)(e(51))},function(t,n){t.exports="/* globals ASSET_RENDERER, LOCALISER, MASTER_RENDERER, BOO_SHOW_HIDDEN_ELEMENTS, O_EXTENDER, $, EM,\nBOO_USE_SPRITE_SHEET_HOTSPOTS, CORE, SCREEN_INTERACTIONS, ASSET_INTERACTIONS,\nTOPIC_STRUCTURE_PARSER, _\n*/\n\n/**\n * @title Image asset extension collection\n * @description A series of objects designed to extend the ASSET_INSPECTOR and ASSET_RENDERER\n * object literals via the O_EXTENDER object to be able to process the image asset\n * type.\n *\n * @author Johnathan Castle\n * @version 0.1 23/09/10\n * @version 2.0 12/03/12\n */\n\nvar objCurrSupportData = {\n  graphicalC: true,\n  accessibleC: true,\n  tabletC: true,\n  smartphoneC: true\n};\nASSET_RENDERER.addAssetSupportData('imagehotspot', objCurrSupportData);\n\nvar IMAGE_HOTSPOT_ASSET_RENDERER = {\n  strObjID: 'The hotspot image asset inspector extension object',\n\n  // ***************************** Property extensions *****************************\n  _arrAssetHTMLTemplateIDs: [\n    ['imagehotspot', 'imagehotspotAssetTemplateWrapperC']\n  ],\n  _arrSubAssetHTMLTemplateIDs: [\n    ['hotspot', 'imagehotspotAssetHotspotTemplateWrapperC'],\n    ['hotspot_sprite', 'imagehotspotAssetHotspotSpriteWrapperC']\n  ],\n\n  // ***************************** Render methods extensions *****************************\n\n  _render_imagehotspot_Asset: function(_objRenderData) {\n    var _objWhatAssetCourseObject = _objRenderData.objWhatAssetCourseObject;\n    var _booPreviewMode = _objRenderData.booPreviewMode;\n    var _objWhatRawAssetData = _objWhatAssetCourseObject.objRawData;\n\n    if (this._objAssetTemplates[_objWhatRawAssetData.strType]) {\n      var _htmReturnData = this._objAssetTemplates[\n        _objWhatRawAssetData.strType\n      ];\n      if (_booPreviewMode) {\n        _htmReturnData = _htmReturnData.replace(\n          'XX_ASSET_ID_XX',\n          'YY' + _objWhatRawAssetData.strID + 'YYPreview'\n        );\n      } else {\n        _htmReturnData = _htmReturnData.replace(\n          'XX_ASSET_ID_XX',\n          'YY' + _objWhatRawAssetData.strID + 'YY'\n        );\n      }\n      _htmReturnData = _htmReturnData.replace(\n        'resources/trans.gif?',\n        gomo.utility.getSrcPath(_objWhatRawAssetData.objNormalSrc.strSrc) +\n          decodeURIComponent(_objWhatRawAssetData.objNormalSrc.strSrc)\n      );\n\n      // Note: on asset conversion sanitiseAltText has changed to convertStringQuote.\n      if (_objWhatRawAssetData.objNormalSrc.strAltText) {\n        _htmReturnData = _htmReturnData.replace(\n          /XX_TEXT_XX/g,\n          this.sanitiseAltText(_objWhatRawAssetData.objNormalSrc.strAltText)\n        );\n      } else {\n        _htmReturnData = _htmReturnData.replace(/XX_TEXT_XX/g, '');\n      }\n\n      _htmReturnData = _htmReturnData.replace(\n        'XXIMAGE_HOTSPOTSXX',\n        this._renderImageHotspotSubAssets(\n          _objWhatRawAssetData,\n          _objWhatAssetCourseObject\n        )\n      );\n\n      // Add alignment classname\n      _htmReturnData = _htmReturnData.replace(\n        'XX_ALIGNMENT_CLASS_XX',\n        _objWhatRawAssetData.strAlignment || ''\n      );\n\n      return _htmReturnData;\n    } else {\n      var _strDebugError = LOCALISER.get('IMAGE_HOTSPOT_DEBUG_TEMPLATE_ERROR', [\n        _objWhatRawAssetData.strType\n      ]);\n      this.debug(_strDebugError, 3);\n\n      var _strReturnValue = LOCALISER.get(\n        'IMAGE_HOTSPOT_RETURN_TEMPLATE_ERROR',\n        [_objWhatRawAssetData.strID]\n      );\n      return _strReturnValue;\n    }\n  },\n\n  _renderImageHotspotSubAssets: function(\n    _objWhatRawAssetData,\n    _objWhatAssetCourseObject\n  ) {\n    if (\n      _objWhatRawAssetData['arrHotspots'] &&\n      _objWhatRawAssetData['arrHotspots'].length > 0\n    ) {\n      var count = 0;\n      var _htmHotspots = '';\n\n      var _objImageMetaData = MASTER_RENDERER.getImageProperties(\n        decodeURIComponent(_objWhatRawAssetData.objNormalSrc.strSrc)\n      );\n\n      var _intImageWidth = _objImageMetaData.strWidth;\n      var _intImageHeight = _objImageMetaData.strHeight;\n\n      while (count < _objWhatRawAssetData['arrHotspots'].length) {\n        var _objCurrHotspotData = _objWhatRawAssetData['arrHotspots'][count];\n        var _objCurrHotspotCoordsData = _objCurrHotspotData['objCoords'];\n\n        var _htmCurrHotspot = this._objSubAssetTemplates['hotspot'];\n\n        _htmCurrHotspot = _htmCurrHotspot.replace(\n          /XX_ASSET_ID_XX/g,\n          _objWhatRawAssetData['strID']\n        );\n        _htmCurrHotspot = _htmCurrHotspot.replace(\n          /XX_SUB_ASSET_ID_XX/g,\n          _objWhatRawAssetData['arrHotspots'][count]['strID']\n        );\n        _htmCurrHotspot = _htmCurrHotspot.replace(\n          /XX_TAB_INDEX_XX/g,\n          (count + 1) * 5\n        );\n        var _objCSSData = this._generatePercentileHotspotWrapperCSS(\n          _objCurrHotspotCoordsData,\n          _intImageWidth,\n          _intImageHeight\n        );\n        var _strCSSText = _objCSSData['strCSSText'];\n        var _objCoordsData = _objCSSData['objCoordsData'];\n\n        if (BOO_SHOW_HIDDEN_ELEMENTS && !BOO_USE_SPRITE_SHEET_HOTSPOTS) {\n          _htmCurrHotspot = _htmCurrHotspot.replace(\n            'class=\"hotspotSubAssetC\"',\n            'class=\"hotspotSubAssetC shownHotspotItemC\" ' + _strCSSText\n          );\n        } else {\n          _htmCurrHotspot = _htmCurrHotspot.replace(\n            'class=\"hotspotSubAssetC\"',\n            'class=\"hotspotSubAssetC\" ' + _strCSSText\n          );\n        }\n\n        if (BOO_USE_SPRITE_SHEET_HOTSPOTS) {\n          var _htmHotspotContent = this._generateImageHotspotSprite(\n            _objWhatRawAssetData,\n            _objCurrHotspotData,\n            _intImageWidth,\n            _intImageHeight,\n            _objCoordsData,\n            count\n          );\n          _htmCurrHotspot = _htmCurrHotspot.replace(\n            /XX_HOTSPOT_CONTENT_XX/g,\n            _htmHotspotContent\n          );\n        } else {\n          _htmCurrHotspot = _htmCurrHotspot.replace(\n            /XX_HOTSPOT_CONTENT_XX/g,\n            _objCurrHotspotData['strText']\n          );\n        }\n\n        _htmCurrHotspot = _htmCurrHotspot.replace(\n          /XX_HOTSPOT_ALT_TEXT_XX/g,\n          _objCurrHotspotData['strText']\n        );\n\n        _htmCurrHotspot = _htmCurrHotspot.replace(\n          /XX_HOTSPOT_INDEX_XX/g,\n          count\n        );\n\n        _htmHotspots += _htmCurrHotspot;\n        count++;\n      }\n      return _htmHotspots;\n    } else {\n      return '';\n    }\n  },\n\n  // <img src=\"resources/trans.gif?\" alt=\"XX_SPRITE_TEXT_XX\" class=\"hotspotSpriteImageC\"/>\n  _generateImageHotspotSprite: function(\n    _objWhatRawAssetData,\n    _objWhatHotspotData,\n    _intImageWidth,\n    _intImageHeight,\n    _objParentWrapperCoordsData,\n    count\n  ) {\n    var _htmSpriteTemplate = this._objSubAssetTemplates['hotspot_sprite'];\n    _htmSpriteTemplate = _htmSpriteTemplate.replace(\n      /resources\\/trans.gif\\?/g,\n      gomo.utility.getSrcPath(_objWhatRawAssetData.objNormalSrc.strSrc)\n    );\n    _htmSpriteTemplate = _htmSpriteTemplate.replace(\n      'XX_HOTSPOT_SRC_XX',\n      decodeURIComponent(_objWhatRawAssetData.objNormalSrc.strSrc)\n    );\n\n    _htmSpriteTemplate = _htmSpriteTemplate.replace(\n      /alt=\"XX_SPRITE_TEXT_XX\"/g,\n      'alt=\"' + _objWhatHotspotData['strText'] + '\"'\n    );\n    _htmSpriteTemplate = _htmSpriteTemplate.replace(\n      /alt=XX_SPRITE_TEXT_XX/g,\n      'alt=\"' + _objWhatHotspotData['strText'] + '\"'\n    );\n\n    var _strCSSInfo = '';\n    _strCSSInfo = this._generatePercentileHotspotImageCSS(\n      _objWhatHotspotData['objCoords'],\n      _intImageWidth,\n      _intImageHeight,\n      _objParentWrapperCoordsData\n    );\n\n    _htmSpriteTemplate = _htmSpriteTemplate.replace(\n      'class=\"hotspotSpriteImageC\"',\n      'class=\"hotspotSpriteImageC\" ' + _strCSSInfo\n    );\n    _htmSpriteTemplate = _htmSpriteTemplate.replace(\n      'class=hotspotSpriteImageC',\n      'class=\"hotspotSpriteImageC\" ' + _strCSSInfo\n    );\n\n    _htmSpriteTemplate = _htmSpriteTemplate.replace(/XX_HOTSPOT_ID_XX/g, count);\n\n    return _htmSpriteTemplate;\n  }\n};\n\nO_EXTENDER.extend(ASSET_RENDERER, IMAGE_HOTSPOT_ASSET_RENDERER);\n\nvar IMAGE_HOTSPOT_ASSET_INTERACTIONS = {\n  strObjID: 'The hotspot image asset interactions extension object',\n\n  _strImageHotspotIDPrefix: 'imageHotspot_',\n  _strImageHotspotIDSuffix: '_L',\n\n  _strCurrentAssetID: '',\n\n  _strHotspotSpriteClass: 'hotspotSpriteImageC',\n  _strInitialInstructionText: 'initialInstructionC',\n  _strFinalInstructionText: 'finalInstructionC',\n\n  _strHotspotHighlightedState: 'highlighted',\n  _strHotspotVisitedState: 'visited',\n  _strCurrentHotspot: '',\n\n  _performLanguagePreprocess_imagehotspot_Asset: function(\n    _objWhatAssetCourseObject\n  ) {\n    var rawAssetData = _objWhatAssetCourseObject.objRawData;\n\n    // Convert image data for knockout updates\n    gomo.translationManager.setImage(rawAssetData.strID, 'objNormalSrc', {\n      newPath: 'renderPrimary'\n    });\n    var count = 0;\n    while (count < rawAssetData.arrHotspots.length) {\n      var newPathString = 'renderSecondary' + count;\n      gomo.translationManager.setImage(rawAssetData.strID, 'objNormalSrc', {\n        newPath: newPathString\n      });\n      count++;\n    }\n\n    // Update coords data in hotspot CSS\n    var imageMetaData = MASTER_RENDERER.getImageProperties(\n      decodeURIComponent(rawAssetData.objNormalSrc.strSrc)\n    );\n\n    var imageWidth = imageMetaData.strWidth;\n    var imageHeight = imageMetaData.strHeight;\n\n    count = 0;\n    while (count < rawAssetData['arrHotspots'].length) {\n      var _objCurrHotspotData = rawAssetData['arrHotspots'][count];\n      var _objCurrHotspotCoordsData = _objCurrHotspotData['objCoords'];\n\n      var _objCSSData = ASSET_RENDERER._generatePercentileHotspotWrapperCSS(\n        _objCurrHotspotCoordsData,\n        imageWidth,\n        imageHeight\n      );\n      var _objCoordsData = _objCSSData['objCoordsData'];\n\n      var hotspotElementId =\n        '#imageHotspot_' +\n        rawAssetData.strID +\n        '_' +\n        _objCurrHotspotData.strID +\n        '_L';\n      var hotspotElement = $(hotspotElementId);\n      hotspotElement.css(\n        'height',\n        _objCoordsData.objInPercentage.intHeight + '%'\n      );\n      hotspotElement.css(\n        'width',\n        _objCoordsData.objInPercentage.intWidth + '%'\n      );\n      hotspotElement.css('left', _objCoordsData.objInPercentage.intLeft + '%');\n      hotspotElement.css('top', _objCoordsData.objInPercentage.intTop + '%');\n\n      var hotspotElementImage = $(hotspotElementId + ' .hotspotSpriteImageC');\n      var imageCSSInfoString = ASSET_RENDERER._generatePercentileHotspotImageCSS(\n        _objCurrHotspotCoordsData,\n        imageWidth,\n        imageHeight,\n        _objCoordsData,\n        true\n      );\n      var imageCSSInfo = imageCSSInfoString.split(';');\n\n      var countCss = 0;\n      while (countCss < imageCSSInfo.length) {\n        var cssItem = imageCSSInfo[countCss].split(':');\n        hotspotElementImage.css(cssItem[0].replace(' ', ''), cssItem[1]);\n        countCss++;\n      }\n\n      // Translate hotspot description\n      this.translateHotspotTitle(_objWhatAssetCourseObject);\n\n      // Update the alignment\n      var found =\n        gomo.translationManager.findDataByAssetId(_objWhatAssetCourseObject.objRawData.strID);\n      if (found) {\n        this.updateImgHotspotAlignment(found);\n      }\n      count++;\n    }\n  },\n\n  updateImgHotspotAlignment: function(data) {\n    var imgHotspotElement = $('#imagehotspotAsset_YY' + data.id + 'YY_WrapperL');\n    if (imgHotspotElement.length && typeof data.strAlignment !== 'undefined') {\n      imgHotspotElement[0].className =\n        imgHotspotElement[0].className.replace(/\\b[A-Za-z]*-alignC\\b/, '');\n      imgHotspotElement.addClass(data.strAlignment);\n    }\n  },\n\n  /**\n   * Translate the hotspot description.\n   * @param {Object} _objWhatAssetData - The asset data containing the text to translate.\n   */\n  translateHotspotTitle: function(_objWhatAssetData) {\n    var assetId = _objWhatAssetData.objRawData.strID;\n    var countTopic = 0;\n    var countHotspots = 0;\n\n    if (gomo.translationManager.topicsData) {\n      // Check each topic\n      while (countTopic < gomo.translationManager.topicsData.length) {\n        if (\n          gomo.translationManager.topicsData[countTopic].topic &&\n          gomo.translationManager.topicsData[countTopic].topic.screens\n        ) {\n          var assets = gomo.translationManager.findAllAssets(\n            gomo.translationManager.topicsData[countTopic].topic.screens\n          );\n          var found = _.findWhere(assets, {id: assetId});\n\n          // Translate hotspot description\n          if (found && found['arrHotspots'] && found.arrHotspots.length > 0) {\n            while (countHotspots < found.arrHotspots.length) {\n              _objWhatAssetData.objRawData.arrHotspots[countHotspots].strText =\n                found.arrHotspots[countHotspots].strText;\n              gomo.translationManager.htmlDecodeAssetTranslations(\n                _objWhatAssetData.strObjID,\n                ['arrHotspots[' + countHotspots + '].strText']\n              );\n              countHotspots++;\n            }\n          }\n\n          if (found) {\n            break;\n          }\n        }\n        countTopic++;\n      }\n    }\n  },\n\n  handleEvent_showImageHotSpot: function(_objWhatHotSpotData) {\n    var _objAssetCourseData = this.getAssetData(\n      _objWhatHotSpotData['strAssetID']\n    );\n    var _objAssetRawData = _objAssetCourseData.objRawData;\n    var _intHotspotIndex = _objWhatHotSpotData.intHotspotIndex;\n\n    this._resetHotspotStates(_objAssetCourseData, false);\n\n    var _domCurrSprite = CORE.getElementsByClassName(\n      _objWhatHotSpotData['domLink'],\n      this._strHotspotSpriteClass\n    )[0];\n    var unescapedNormalImageSrc = decodeURIComponent(\n      _objAssetRawData.objNormalSrc.strSrc\n    );\n    var unescapedActiveImageSrc = decodeURIComponent(\n      _objAssetRawData.objActiveSrc.strSrc\n    );\n    var unescapedVisitedImageSrc = decodeURIComponent(\n      _objAssetRawData.objVisitedSrc.strSrc\n    );\n\n    var domCurrSpriteDecoded = decodeURIComponent(_domCurrSprite.src);\n\n    var fromImage = domCurrSpriteDecoded.indexOf(unescapedNormalImageSrc) > -1\n      ? unescapedNormalImageSrc\n      : unescapedVisitedImageSrc;\n    this._updateImageSource(_domCurrSprite, fromImage, unescapedActiveImageSrc);\n\n    // Update translation to active image\n    if (gomo && gomo.translationManager) {\n      var newPathString = 'renderSecondary' + _intHotspotIndex;\n      gomo.translationManager.setImage(_objAssetRawData.strID, 'objActiveSrc', {\n        newPath: newPathString\n      });\n    }\n\n    _objAssetCourseData.arrOptionStates[\n      _intHotspotIndex\n    ] = this._strHotspotHighlightedState;\n\n    _objAssetCourseData.strLastInteractedSubAssetID =\n      _objWhatHotSpotData.strSubAssetID;\n    _objAssetCourseData.strAssetID = _objWhatHotSpotData.strAssetID;\n    _objAssetCourseData.domLink = _objWhatHotSpotData.domLink;\n\n    EM.trigger('screenAssetInteracting', _objAssetCourseData);\n    this._strCurrentHotspot = _objWhatHotSpotData['strAssetID'];\n\n    if (\n      _objAssetRawData.arrHotspots[_intHotspotIndex].arrActions &&\n      _objAssetRawData.arrHotspots[_intHotspotIndex].arrActions.length > 0\n    ) {\n      var _objActionOptions = {};\n      _objActionOptions.objActions =\n        _objAssetRawData.arrHotspots[_intHotspotIndex].arrActions;\n      _objActionOptions.objOptionalExtraData = _objAssetCourseData;\n\n      EM.trigger('processActions', _objActionOptions);\n    } else {\n      console.log(\n        'No actions found for the hotspot attached to the asset \\'' +\n          _objWhatHotSpotData['strAssetID'] +\n          '\\'.'\n      );\n    }\n  },\n\n  handleEvent_screenSizeChanged: function() {\n    // Popups are hidden by subscreen manager on resize. So ensure the relevant resets are called.\n    if (this._strCurrentHotspot) {\n      var _objAssetCourseData = this.getAssetData(this._strCurrentHotspot);\n      this._resetHotspotStates(_objAssetCourseData, false);\n      SCREEN_INTERACTIONS.returnFocusToScreen();\n    }\n  },\n\n  is_imagehotspot_AssetCompletable: function(_objWhatAssetData) {\n    return true;\n  },\n\n  _resetHotspotStates: function(_objWhatAssetData, _booFullReset) {\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(\n      _objWhatAssetData.objRawData\n    );\n    var _arrHotspotSprites = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strHotspotSpriteClass\n    );\n    var _arrHotspotStates = _objWhatAssetData.arrOptionStates;\n    var count = 0;\n    var newPathString;\n    while (count < _arrHotspotSprites.length) {\n      var _domCurrSprite = _arrHotspotSprites[count];\n      var unescapedNormalImageSrc = decodeURIComponent(\n        _objWhatAssetData.objRawData.objNormalSrc.strSrc\n      );\n      var unescapedActiveImageSrc = decodeURIComponent(\n        _objWhatAssetData.objRawData.objActiveSrc.strSrc\n      );\n      var unescapedVisitedImageSrc = decodeURIComponent(\n        _objWhatAssetData.objRawData.objVisitedSrc.strSrc\n      );\n\n      if (_booFullReset) {\n        var domCurrSpriteDecoded = decodeURIComponent(_domCurrSprite.src);\n\n        var fromImage = domCurrSpriteDecoded.indexOf(unescapedVisitedImageSrc) > -1\n          ? unescapedVisitedImageSrc\n          : unescapedActiveImageSrc;\n        this._updateImageSource(_domCurrSprite, fromImage, unescapedNormalImageSrc);\n\n        // Reset translation to primary image\n        if (gomo && gomo.translationManager) {\n          newPathString = 'renderSecondary' + count;\n          gomo.translationManager.setImage(\n            _objWhatAssetData.objRawData.strID,\n            'objNormalSrc',\n            {\n              newPath: newPathString\n            }\n          );\n        }\n        _arrHotspotStates[count] = false;\n      } else {\n        if (_arrHotspotStates[count] === this._strHotspotHighlightedState) {\n          this._updateImageSource(\n            _domCurrSprite,\n            unescapedActiveImageSrc,\n            unescapedVisitedImageSrc\n          );\n\n          // Update translation to visited image\n          if (gomo && gomo.translationManager) {\n            newPathString = 'renderSecondary' + count;\n            gomo.translationManager.setImage(\n              _objWhatAssetData.objRawData.strID,\n              'objVisitedSrc',\n              {\n                newPath: newPathString\n              }\n            );\n          }\n\n          _arrHotspotStates[count] = this._strHotspotVisitedState;\n        }\n      }\n      count++;\n    }\n    this._strCurrentHotspot = '';\n  },\n\n  _returnFocusToIMAGEHOTSPOTAsset: function(\n    _domWhatAssetElement,\n    _objAssetData\n  ) {\n    var _strAssetID = _objAssetData['strObjID'];\n    var _strLastSubAssetID = _objAssetData['strLastInteractedSubAssetID'];\n    var _domHotspotLink = this._objWhatDOM.getElementById(\n      this._strImageHotspotIDPrefix +\n        _strAssetID +\n        '_' +\n        _strLastSubAssetID +\n        this._strImageHotspotIDSuffix\n    );\n    this._resetHotspotStates(_objAssetData, false);\n    if (\n      _domHotspotLink &&\n      _domHotspotLink !== undefined &&\n      _domHotspotLink.focus\n    ) {\n      _domHotspotLink.focus();\n    }\n  },\n\n  _reset_imagehotspot_Asset: function(_objWhatAssetData, _booFullReset) {\n    this._resetHotspotStates(_objWhatAssetData, true);\n    _objWhatAssetData.booComplete = false;\n    _objWhatAssetData.arrOptionStates = [];\n  },\n\n  _checkCompletion_imagehotspot_Asset: function(_objWhatAssetData) {\n    var _arrHotspots = _objWhatAssetData.objRawData.arrHotspots;\n    var _arrOptionStates = _objWhatAssetData.arrOptionStates;\n\n    if (_arrHotspots.length > _arrOptionStates.length) {\n      return false;\n    } else {\n      var _booAllVisited = true;\n\n      for (var i = 0; i < _arrOptionStates.length; i++) {\n        var _strCurrOptionState = _arrOptionStates[i];\n\n        var _booVisited =\n          _strCurrOptionState == this._strHotspotVisitedState ||\n          _strCurrOptionState == this._strHotspotHighlightedState;\n\n        if (!_booVisited) {\n          _booAllVisited = false;\n          break;\n        }\n\n        // _booAllVisited = true;\n      }\n\n      return _booAllVisited;\n    }\n  },\n\n  getAccessibleElements_imagehotspot: function() {\n    var accessibleElements = ['.hotspotSubAssetC'];\n    return accessibleElements;\n  },\n\n  /**\n   * Update the image element source path from the given image\n   * to the given destination image\n   *\n   * @param {HTMLImageElement} imgElement\n   * @param {string} from\n   * @param {string} to\n   * @private\n   */\n  _updateImageSource: function(imgElement, from, to) {\n    var imgSrcDecoded = decodeURIComponent(imgElement.src);\n    imgElement.src = imgSrcDecoded.replace(from, to);\n\n    gomo.eventManager.legacy('imageSourcesUpdated', {\n      arrImages: [imgElement],\n      strFrom: from,\n      strTo: to\n    });\n  }\n};\n\nO_EXTENDER.extend(ASSET_INTERACTIONS, IMAGE_HOTSPOT_ASSET_INTERACTIONS);\n\nvar IMAGE_HOTSPOT_ASSET_PREPROCESSOR = {\n  strObjID: 'The image asset pre  extension object',\n\n  // If they're blank, set the visited and/or active SRC's to the same the base src.\n  _preProcess_imagehotspot_Asset: function(\n    _objWhatRawAssetData,\n    _objWhatParentScreenObject\n  ) {\n    if (_objWhatRawAssetData.objVisitedSrc.strSrc == '') {\n      _objWhatRawAssetData.objVisitedSrc.strSrc =\n        _objWhatRawAssetData.objNormalSrc.strSrc;\n    }\n\n    if (_objWhatRawAssetData.objActiveSrc.strSrc == '') {\n      _objWhatRawAssetData.objActiveSrc.strSrc =\n        _objWhatRawAssetData.objNormalSrc.strSrc;\n    }\n\n    var _strPreProcessedEntry = LOCALISER.get('IMAGE_PREPROCESSOR_ENTRY');\n    this._addToPreProcessedAssetList(\n      _objWhatRawAssetData['strType'],\n      _strPreProcessedEntry,\n      _objWhatRawAssetData['strID']\n    );\n\n    return _objWhatRawAssetData;\n  }\n};\n\nO_EXTENDER.extend(TOPIC_STRUCTURE_PARSER, IMAGE_HOTSPOT_ASSET_PREPROCESSOR);\n"},function(t,n,e){e(0)(e(53))},function(t,n){t.exports="/* globals ASSET_RENDERER, O_EXTENDER, ASSET_INTERACTIONS, TOPIC_STRUCTURE_PARSER, CORE, $ */\n\n/**\n * @title Image asset extension collection\n * @description A series of objects designed to extend the ASSET_INSPECTOR and ASSET_RENDERER\n * object literals via the O_EXTENDER object to be able to process the image asset\n * type.\n *\n * @author Johnathan Castle\n * @version 0.1 23/09/10\n * @version 2.0 12/03/12\n */\n\nvar objCurrSupportData = {\n  graphicalC: true,\n  accessibleC: true,\n  tabletC: true,\n  smartphoneC: true\n};\nASSET_RENDERER.addAssetSupportData('imagestatic', objCurrSupportData);\n\nvar IMAGE_STATIC_ASSET_RENDERER = {\n  strObjID: 'The static image asset inspector extension object',\n\n  // ***************************** Property extensions *****************************\n  _arrAssetHTMLTemplateIDs: [\n    ['imagestatic', 'imagestaticAssetTemplateWrapperC']\n  ],\n  _arrSubAssetHTMLTemplateIDs: [],\n\n  _strAlignmentClassSuffix: '_AlignedImageC',\n\n  // ***************************** Render methods extensions *****************************\n\n  _render_imagestatic_Asset: function(_objRenderData) {\n    var _objWhatAssetCourseObject = _objRenderData.objWhatAssetCourseObject;\n    var _booPreviewMode = _objRenderData.booPreviewMode;\n\n    var _objWhatRawAssetData = _objWhatAssetCourseObject.objRawData;\n\n    if (this._objAssetTemplates[_objWhatRawAssetData.strType]) {\n      var _htmReturnData = this._objAssetTemplates[\n        _objWhatRawAssetData.strType\n      ];\n      if (_booPreviewMode) {\n        _htmReturnData = _htmReturnData.replace(\n          'XX_ASSET_ID_XX',\n          'YY' + _objWhatRawAssetData.strID + 'YYPreview'\n        );\n      } else {\n        _htmReturnData = _htmReturnData.replace(\n          'XX_ASSET_ID_XX',\n          'YY' + _objWhatRawAssetData.strID + 'YY'\n        );\n      }\n\n      _htmReturnData = _htmReturnData.replace(\n        'resources/trans.gif?',\n        gomo.utility.getSrcPath(_objWhatRawAssetData.objNormalSrc.strSrc) +\n          decodeURIComponent(_objWhatRawAssetData.objNormalSrc.strSrc)\n      );\n\n      var _strAlignmentClass =\n        _objWhatRawAssetData.strImageAlignment + this._strAlignmentClassSuffix;\n      _htmReturnData = _htmReturnData.replace(\n        'XX_ALIGNMENT_CLASS_XX',\n        _strAlignmentClass\n      );\n\n      var _strBorderStyleDeclaration = this._generateBorderStyle(\n        _objWhatRawAssetData\n      );\n      _htmReturnData = _htmReturnData.replace(\n        /class=\"imageAssetC\"/,\n        'class=\"imageAssetC\"' + _strBorderStyleDeclaration\n      );\n\n      // Note: on asset conversion sanitiseAltText has changed to convertStringQuote.\n      _htmReturnData = _htmReturnData.replace(\n        /XXTEXTXX/g,\n        this.sanitiseAltText(_objWhatRawAssetData.objNormalSrc.strAltText)\n      );\n      return _htmReturnData;\n    }\n  },\n\n  _generateBorderStyle: function(_objWhatRawAssetData) {\n    var _strBorderStyle = ' style=\\'border: ';\n    _strBorderStyle += _objWhatRawAssetData.strBorderWidth + 'px ';\n    _strBorderStyle += _objWhatRawAssetData.strBorderStyle + ' ';\n    _strBorderStyle += _objWhatRawAssetData.strBorderColour;\n    _strBorderStyle += ';\\' ';\n    return _strBorderStyle;\n  },\n\n  booTerminal: true\n};\n\nO_EXTENDER.extend(ASSET_RENDERER, IMAGE_STATIC_ASSET_RENDERER);\n\nvar IMAGE_STATIC_ASSET_INTERACTIONS = {\n  strObjID: 'The static image asset interactions extension object',\n\n  _strImageAssetClass: 'imageAssetC',\n\n  is_imagestatic_AssetCompletable: function(_objWhatAssetData) {\n    return false;\n  },\n\n  _performLanguagePreprocess_imagestatic_Asset: function(_objWhatAssetCourseObject) {\n    gomo.translationManager.setImage(_objWhatAssetCourseObject.objRawData.strID, 'objNormalSrc');\n    var found =\n      gomo.translationManager.findDataByAssetId(_objWhatAssetCourseObject.objRawData.strID);\n    if (found) {\n      this.updateImageAlignment(found);\n    }\n  },\n\n  _doPostRenderShowActions_imagestatic_Asset: function(assetData) {\n    if (assetData &&\n      assetData.objRawData &&\n      assetData.objRawData.objNormalSrc &&\n      assetData.objRawData.objNormalSrc.strSrc) {\n      // If we are using a gif, it may be animated so rewrite the source so it plays again.\n      if (assetData.objRawData.objNormalSrc.strSrc.indexOf('.gif') > -1 && assetData.strObjID) {\n        this._reset_gif(assetData.strObjID);\n      }\n    }\n  },\n  updateImageAlignment: function(data) {\n    var imageElement = $('#imagestaticAsset_YY' + data.id + 'YY_WrapperL');\n    if (imageElement.length && typeof data.strImageAlignment !== 'undefined') {\n      imageElement[0].className =\n        imageElement[0].className.replace(/\\b[A-Za-z]*_AlignedImageC\\b/, '');\n      imageElement.addClass(data.strImageAlignment + '_AlignedImageC');\n    }\n  },\n\n  _returnFocusToIMAGESTATICAsset: function(_domWhatAssetElement, _objAssetData) {},\n\n  _reset_imagestatic_Asset: function(_objWhatAssetData, _booFullReset) {\n    var _domAssetWrapper = ASSET_RENDERER.getAssetDOMElement(\n      _objWhatAssetData.objRawData\n    );\n    var _domImage = CORE.getElementsByClassName(\n      _domAssetWrapper,\n      this._strImageAssetClass\n    )[0];\n    var unescapedSrc = decodeURIComponent(\n      _objWhatAssetData.objRawData.objNormalSrc.strSrc\n    );\n\n    if (\n      _domImage.src != gomo.utility.getSrcPath(unescapedSrc) + unescapedSrc\n    ) {\n      _domImage.src =\n        gomo.utility.getSrcPath(unescapedSrc) + unescapedSrc;\n      _domImage.alt =\n        gomo.utility.decodeHtml(_objWhatAssetData.objRawData.objNormalSrc.strAltText);\n      _domImage.title =\n        gomo.utility.decodeHtml(_objWhatAssetData.objRawData.objNormalSrc.strAltText);\n    }\n  },\n\n  _reset_gif: function(assetId) {\n    // Get the image element.\n    var assetElement = $('#assetWrapperFor_YY' + assetId + 'YY_L');\n    if (assetElement) {\n      var imageElement = $(assetElement).find('img.imageAssetC');\n    }\n    if (imageElement && imageElement.length) {\n      var src = imageElement[0].src;\n      if (src) {\n        // Rewrite the src to trigger it to play again\n        $(imageElement).attr('src', src);\n      }\n    }\n  },\n\n  _checkCompletion_imagestatic_Asset: function(_objWhatAssetData) {\n    return true;\n  },\n\n  booTerminal: true\n};\n\nO_EXTENDER.extend(ASSET_INTERACTIONS, IMAGE_STATIC_ASSET_INTERACTIONS);\n\nvar IMAGE_STATIC_PREPROCESSOR = {\n  strObjID: 'The image asset pre  extension object',\n\n  // If they're blank, set the visited and/or active SRC's to the same the base src.\n  _preProcess_imagestatic_Asset: function(\n    _objWhatRawAssetData,\n    _objWhatParentScreenObject\n  ) {\n    return _objWhatRawAssetData;\n  }\n};\n\nO_EXTENDER.extend(TOPIC_STRUCTURE_PARSER, IMAGE_STATIC_PREPROCESSOR);\n"},function(t,n,e){e(0)(e(55))},function(t,n){t.exports="/* globals ASSET_RENDERER, O_EXTENDER, ASSET_INTERACTIONS */\n\n/**\n* @title FILMSTRIP asset extension collection\n* @description A series of objects designed to extend the ASSET_INSPECTOR and ASSET_RENDERER\n* object literals via the O_EXTENDER object to be able to process the filmstrip asset\n* type.\n*\n* @author Johnathan Castle\n* @version 2.0 23/09/10\n*/\n\nvar objCurrSupportData =\n{\n  'graphicalC': true,\n  'accessibleC': true,\n  'tabletC': true,\n  'smartphoneC': true\n};\nASSET_RENDERER.addAssetSupportData('rule', objCurrSupportData);\n\n/**\n* @title Horizontal rule asset\n* @description A series of objects designed to extend the ASSET_INSPECTOR and ASSET_RENDERER\n* object literals via the O_EXTENDER object to be able to process the rule asset\n* type.\n*\n* @author Johnathan Castle\n* @version 0.1 08/5/14\n*/\n\nvar RULE_ASSET_RENDERER = {\n  strObjID: 'The rule asset render extension object',\n\n  // ***************************** Property extensions *****************************\n  _arrAssetHTMLTemplateIDs: [['rule', 'ruleAssetTemplateWrapperC']],\n\n  // ***************************** Render methods extensions *****************************\n  _render_rule_Asset: function(_objRenderData) {\n    var _objWhatAssetCourseObject = _objRenderData.objWhatAssetCourseObject;\n    var _objWhatRawAssetData = _objWhatAssetCourseObject.objRawData;\n\n    if (this._objAssetTemplates[_objWhatRawAssetData['strType']]) {\n      var _htmReturnData = this._objAssetTemplates[_objWhatRawAssetData['strType']];\n\n      _htmReturnData = _htmReturnData.replace(\n        'XX_ASSET_ID_XX',\n        'YY' + _objWhatRawAssetData['strID'] + 'YY'\n      );\n\n      var _strCombinedCSS = 'border-width:' + _objWhatRawAssetData.strBorderWidth * 2 + 'px; ';\n      _strCombinedCSS += 'border-color:' + _objWhatRawAssetData.strBorderColour + '; ';\n      _strCombinedCSS += 'border-top-style:' + _objWhatRawAssetData.strBorderStyle + ';';\n\n      _htmReturnData = _htmReturnData.replace(\n        'XX_HR_ASSET_SELECTED_STYLE_XX\"',\n        'XX_HR_ASSET_SELECTED_STYLE_XX\" style=\"' + _strCombinedCSS + '\"'\n      );\n\n      return _htmReturnData;\n    } else {\n      this.debug('ASSET_RENDERER._renderRuleAsset(), ERROR: Unknown asset type of ' +\n        _objWhatRawAssetData['strType'] + '.', 3);\n      return 'Asset Error, no template found, ID: ' + _objWhatRawAssetData['strID'];\n    }\n  },\n\n  booTerminal: true\n};\n\nO_EXTENDER.extend(ASSET_RENDERER, RULE_ASSET_RENDERER);\n\n\nvar RULE_ASSET_INTERACTIONS = {\n  strObjID: 'The filmstrip asset interactions extension object',\n\n  is_rule_AssetCompletable: function(_objWhatAssetData) {\n    return false;\n  },\n\n  _doPostRenderShowActions_rule_Asset: function(_objWhatAssetDataHolder) {},\n\n  _returnFocusToRULEAsset: function(_domWhatAssetElement) {},\n\n  _reset_rule_Asset: function(_objWhatAssetData, _booForceReset) {},\n\n  _checkCompletion_rule_Asset: function(_objWhatAssetData) {\n    return true;\n  }\n\n};\nO_EXTENDER.extend(ASSET_INTERACTIONS, RULE_ASSET_INTERACTIONS);\n"},function(t,n,e){e(0)(e(57))},function(t,n){t.exports="/* globals $ */\n(function() {\n  // Create new Button\n  var Button = gomo.Asset.extend({\n\n    /**\n     * Perform any data processing prior to button rendering.\n     */\n    processData: function() {\n      var me = this;\n      var data = me.data;\n      var rawData = data.objRawData;\n      // Decode icon image source.\n      if (rawData.objIconImageFilename.strSrc) {\n        rawData.objIconImageFilename.decodedSrc = decodeURIComponent(\n          rawData.objIconImageFilename.strSrc\n        );\n\n        rawData.objIconImageFilename.decodedSrc =\n          gomo.utility.getSrcPath(rawData.objIconImageFilename.decodedSrc) +\n          rawData.objIconImageFilename.decodedSrc;\n      }\n      // Set the correct button classname. These are hard coded in the manifest unfortunately so\n      // need to remain or old courses with buttons have no type and incorrect styling.\n      rawData.buttonStyle = '';\n      switch (rawData.strButtonType) {\n        case 'dropdownValue2':\n        case 'btn-warning':\n          rawData.buttonStyle = 'btn-warning';\n          break;\n        case 'dropdownValue3':\n        case 'btn-danger':\n          rawData.buttonStyle = 'btn-danger';\n          break;\n        case 'dropdownValue4':\n        case 'btn-large':\n          rawData.buttonStyle = 'btn-large';\n          break;\n      }\n      // Format the label.\n      rawData.formattedLabel = me.formatHTML(rawData.strLabel);\n      // Set button enabled classname.\n      rawData.enabledClassname = '';\n      if (rawData.arrActions && rawData.arrActions.length) {\n        rawData.enabledClassname = me.checkEnabledState(rawData) ? '' : 'disableInteractions';\n      }\n    },\n\n    /**\n     * Perform any actions needed before the button is shown.\n     */\n    beforeShown: function() {\n      var me = this;\n      var data = me.data;\n      var rawData = data.objRawData;\n      // Add aria attribute for accessibility.\n      if (gomo.utility.checkForShowSubscreenAction(rawData.arrActions)) {\n        me.$el\n          .find('.buttonC')\n          .attr('aria-haspopup', 'dialog');\n      }\n    },\n\n    /**\n     * Triggered when the asset is hidden\n     */\n    translationProcessOnHidden: function() {\n      var me = this;\n      var data = me.data;\n      var rawData = data.objRawData;\n      /*\n      * We need to run translation preprocess here as we may have\n      * switched language while the asset was hidden by display conditions.\n      */\n      rawData.formattedLabel = me.formatHTML(rawData.strLabel);\n    },\n\n    /**\n     * Update the button on translation.\n     */\n    translationPreprocess: function() {\n      var me = this;\n      var data = me.data;\n      var found = gomo.translationManager.findDataByAssetId(me.id);\n\n      if (found) {\n        me.updateButtonAlignment(found);\n        var formatLabel = me.formatHTML(found.strLabel);\n        found.formattedLabel = formatLabel;\n        me.data.objRawData.formattedLabel = formatLabel;\n        gomo.translationManager.setImage(data.strObjID, 'objIconImageFilename');\n      }\n    },\n\n    /**\n     * Update the button alignment class.\n     * @param {Object} updateData\n     */\n    updateButtonAlignment: function(updateData) {\n      var me = this;\n      if (updateData.strAlignment) {\n        me.$el\n          .find('.buttonAssetWrapperC')\n          .removeClass('left-alignC right-alignC centre-alignC image-fit-to-widthC fit-to-widthC')\n          .addClass(updateData.strAlignment + 'C');\n      }\n    },\n\n    /**\n     * Register the button click event.\n     */\n    registerEvents: function() {\n      var me = this;\n      me.events = {\n        'click .buttonC': 'buttonAction'\n      };\n    },\n\n    /**\n     * Is the button a completable asset.\n     * @return {boolean}\n     */\n    isCompletable: function() {\n      return true;\n    },\n\n    /**\n     * Is the button asset complete.\n     * @return {boolean}\n     */\n    isComplete: function() {\n      var me = this;\n      var data = me.data;\n      var rawData = data.objRawData;\n      var completed = false;\n      if (rawData.booClicked) {\n        completed = true;\n      }\n      return completed;\n    },\n\n    /**\n     * Apply focus to the button.\n     */\n    returnFocusToSelf: function() {\n      var me = this;\n      me.$el.focus();\n    },\n\n    /**\n     * Returns all accesible parts of the button asset for the tab manager to apply tab indexes.\n     * @return {boolean}\n     */\n    getAccessibleElements: function() {\n      var accessibleElements = ['.buttonC'];\n      return accessibleElements;\n    },\n\n    /**\n     * When the button is clicked trigger its action(s).\n     */\n    buttonAction: function() {\n      var me = this;\n      var data = me.data;\n      var rawData = me.data.objRawData;\n      var actionOptions = {\n        objActions: rawData.arrActions,\n        objOptionalExtraData: data\n      };\n      actionOptions.objOptionalExtraData.strAssetID = data.strObjID,\n      actionOptions.objOptionalExtraData.domLink = me.$el.find('.buttonC');\n\n      rawData.booClicked = true;\n\n      gomo.eventManager.legacy('screenAssetInteracting', data);\n      gomo.eventManager.legacy('processActions', actionOptions);\n    },\n\n    /**\n     * Switch enabled state of the button.\n     * @param {Object} assetData\n     * @param {Boolean} enabled\n     */\n    switchState: function(assetData, enabled) {\n      var me = this;\n      var rawData = me.data.objRawData;\n      rawData.enabledClassname = enabled ? '' : 'disableInteractions';\n      $('#buttonAsset_YY' + assetData.strID + 'YY_WrapperL')\n        .find('.buttonC')\n        .toggleClass('disableInteractions', !enabled);\n    }\n  });\n\n  // Register the asset.\n  gomo.assetManager.register('button', Button);\n})();\n"},function(t,n,e){e(0)(e(59))},function(t,n){t.exports="/* globals $, _, SCREEN_INTERACTIONS */\n\n/**\n * Image Markers asset\n * Allows hotpost with various icons to be placed over an image. Hotpost can have actions assigned\n * to them.\n */\n(function() {\n  // Create new image marker asset\n  var ImageMarkers = gomo.Asset.extend({\n\n    processData: function(data) {\n      var me = this;\n      var rawData = me.data.objRawData;\n      me.data.isComplete = false;\n      me.maxIconSize = 25;\n\n      // Get image dimensions and calulate aspect ratio\n      var imageMetaData = gomo.getImageProperties(\n        decodeURIComponent(rawData.objNormalSrc.strSrc)\n      );\n\n      rawData.objNormalSrc.strPathAndSrc =\n        gomo.utility.getSrcPath(rawData.objNormalSrc.strSrc) + rawData.objNormalSrc.strSrc;\n\n      imageMetaData.aspectRatio = 1;\n      // These original render values are used when toggling display conditions\n      imageMetaData.originalRenderHeight = 0;\n      imageMetaData.originalRenderWidth = 0;\n      if (imageMetaData.strHeight && imageMetaData.strWidth) {\n        imageMetaData.aspectRatio =\n          parseInt(imageMetaData.strHeight) / parseInt(imageMetaData.strWidth);\n        imageMetaData.originalRenderHeight =\n          parseInt(imageMetaData.strHeight) * parseInt(imageMetaData.aspectRatio);\n      }\n      rawData.imageMetaData = imageMetaData;\n    },\n\n    afterRenderShown: function() {\n      var me = this;\n      me.initHotspots();\n    },\n\n    /**\n     * Before the asset is shown\n     */\n    beforeShown: function() {\n      var me = this;\n      // Reset all hotspots\n      me.resetImageMarkers();\n      // Resize the hotpot icons when screensize changes\n      var callbackFun = function() {\n        me.initHotspots();\n      };\n\n      gomo.outputChecker.addScreenSizeChangeListener(callbackFun);\n    },\n\n    translationPreprocess: function() {\n      var me = this;\n      var data = me.data;\n      var rawData = data.objRawData;\n      var found = gomo.translationManager.findDataByAssetId(me.id);\n      if (found) {\n        var countHotspots = 0;\n        // Translate image hotspot alt text\n        if (found && found['arrHotspots'] && found.arrHotspots.length > 0) {\n          while (countHotspots < found.arrHotspots.length) {\n            rawData.arrHotspots[countHotspots].strText =\n              found.arrHotspots[countHotspots].strText;\n            gomo.translationManager.htmlDecodeAssetTranslations(rawData.strID, [\n              'arrHotspots[' + countHotspots + '].strAltText'\n            ]);\n            countHotspots++;\n          }\n        }\n        gomo.translationManager.setImage(\n          rawData.strID,\n          'objNormalSrc'\n        );\n        me.updateImgMarkerAlignment(found);\n      }\n    },\n\n    updateImgMarkerAlignment: function(data) {\n      var imgMarkerElement = $('#image-markersAsset_YY' + data.id + 'YY_WrapperL');\n      if (imgMarkerElement.length && typeof data.strAlignment !== 'undefined') {\n        imgMarkerElement[0].className =\n        imgMarkerElement[0].className.replace(/\\b[A-Za-z]*-alignC\\b/, '');\n        imgMarkerElement.addClass(data.strAlignment);\n      }\n    },\n\n    registerEvents: function() {\n      var me = this;\n      me.events = {\n        'mouseenter .image-markers__hotspot': 'hotspotMouseEnter',\n        'mouseleave .image-markers__hotspot': 'hotspotMouseLeave',\n        'click .image-markers__hotspot': 'hotspotClick',\n        'keydown .image-markers__hotspot': 'hotspotClick'\n      };\n    },\n\n    initHotspots: function() {\n      var me = this;\n      var rawData = me.data.objRawData;\n      var imageMetaData = rawData.imageMetaData;\n      var imgParentWidth = me.$('.image-markers-wrapper').width();\n      var parsedMetaWidth = parseInt(imageMetaData.strWidth);\n      var parsedMetaHeight = parseInt(imageMetaData.strHeight);\n      var imgDomWidth = 0;\n      var imgDomHeight = 0;\n      // Check if display conditions are still hiding the element in the dom\n      if (!me.$el.hasClass('tempHiddenAssetC') && me.$('.image-markers__image').width() !== 0) {\n        imgDomWidth = me.$('.image-markers__image').width();\n        imgDomHeight = me.$('.image-markers__image').height();\n      } else {\n        imgDomWidth = imgParentWidth;\n        // Calculate the difference between the two image sizes\n        var diffBetweenImages = imgParentWidth / parsedMetaWidth;\n        imgDomHeight = parsedMetaHeight * diffBetweenImages;\n      }\n\n      var imageWidth = imgDomWidth;\n      var imageHeight = imgDomHeight;\n\n      // Adjust image size if fit to width is enabled\n      if (rawData.strAlignment === 'image-fit-to-widthC') {\n        imageWidth = imgParentWidth;\n        imageHeight = imageWidth * imageMetaData.aspectRatio;\n      }\n\n      // Calculate scale values to use for hotpost size and positioning if image is larger than\n      // the screen content width.\n      var widthScale = 1;\n      var heightScale = 1;\n      if (\n        parsedMetaWidth > imgParentWidth ||\n        imageWidth > parsedMetaWidth\n      ) {\n        widthScale = imageWidth / parsedMetaWidth;\n        heightScale = imageHeight / parsedMetaHeight;\n      }\n\n      // Set a max width on the hotspot wrapper so it is never larger than the image.\n      me.$('.image-markers__hotspots').css('max-width', parsedMetaWidth+'px');\n\n      // Apply size, position, font size and line height css to each hotspot.\n      _.each(rawData.arrHotspots, function(hotspot) {\n        var currHotspot = me.$('[data-hotspot-id=\"' + hotspot.strID + '\"]');\n\n        // Convert hotspot position and size values to percentages based on image size.\n        hotspot.objPercentCoords = {\n          width: ((parseInt(hotspot.objCoords.intWidth) * heightScale) / imageWidth) * 100,\n          height: ((parseInt(hotspot.objCoords.intHeight) * heightScale) / imageHeight) * 100,\n          top: ((parseInt(hotspot.objCoords.intTop) * heightScale) / imageHeight) * 100,\n          left: ((parseInt(hotspot.objCoords.intLeft) * widthScale) / imageWidth) * 100\n        };\n\n        var hotspotSize = Math.round(\n          (parseInt(imageHeight) / 100) * (parseInt(hotspot.objPercentCoords.height))\n        );\n\n        // Calculate a font size for the icon based on the size of the hotspot.\n        var padding = 12;\n        var fontSize = hotspotSize - padding;\n        if (fontSize > me.maxIconSize) {\n          fontSize = me.maxIconSize;\n        }\n\n        // Calculate line height for the icon based on the size of the hotspot.\n        var borderWidth = parseInt(\n          $(currHotspot).find('.image-markers__hotspot-icon').css('border-top-width')\n        );\n        var lineHeight = hotspotSize - borderWidth * 2;\n\n        // Apply the css to the hotspot.\n        currHotspot.css({\n          'top': (hotspot.objPercentCoords.top) + '%',\n          'left': (hotspot.objPercentCoords.left) + '%',\n          'width': (hotspot.objPercentCoords.width) + '%',\n          'height': (hotspot.objPercentCoords.height) + '%',\n          'font-size': fontSize + 'px',\n          'line-height': lineHeight + 'px'\n        });\n\n        // Disable the hotspot if it's linked to a hidden screen\n        if (this.arrActions && this.arrActions.length) {\n          if (!me.checkEnabledState(this, me.data.strObjID)) {\n            currHotspot.addClass('image-markers__hotspot-icon__disabled');\n          }\n        }\n\n        // Show the hotspot\n        currHotspot.removeClass('image-markers__hotspot-fade');\n      });\n    },\n\n    hotspotMouseEnter: function(event) {\n      var me = this;\n      // get hotspot id\n      var hotspotId = $(event.currentTarget).data('hotspot-id');\n      // get hotspot current state\n      var hotspotState = $(event.currentTarget).data('display-state');\n      var state = 'default';\n      switch (hotspotState) {\n        case 'default':\n          state = 'active';\n          break;\n        case 'active':\n          state = 'default';\n          break;\n        case 'visited':\n        case 'selected':\n          state = false;\n          break;\n      }\n      // change hotspot state\n      if (state) {\n        me.setState(hotspotId, state);\n      }\n    },\n\n    hotspotMouseLeave: function(event) {\n      var me = this;\n      // get hotspot id\n      var hotspotId = $(event.currentTarget).data('hotspot-id');\n      // get hotspot current state\n      var hotspotState = $(event.currentTarget).data('display-state');\n      var state = 'default';\n      switch (hotspotState) {\n        case 'default':\n          state = false;\n          break;\n        case 'active':\n          state = 'default';\n          break;\n        case 'visited':\n        case 'selected':\n          state = false;\n          break;\n      }\n      // change hotspot state\n      if (state) {\n        me.setState(hotspotId, state);\n      }\n    },\n\n    setState: function(hotspotId, state) {\n      var me = this;\n      // get the hotspot to change\n      var hotspot = me.$('[data-hotspot-id=\"'+hotspotId+'\"]');\n      // show the correct state\n      var newState = state;\n      if (state == 'selected') {\n        newState = 'active';\n      }\n      $(hotspot).find('.image-markers__hotspot-icon').each(function() {\n        if ($(this).data('display-state-name') == newState) {\n          $(this).removeClass('hidden');\n        } else {\n          $(this).addClass('hidden');\n        }\n      });\n      // set the state data\n      $(hotspot).data('display-state', state);\n    },\n\n    switchState: function(data, enabled) {\n      var me = this;\n      me.$('[data-hotspot-id=\"'+data.strID + '\"]').toggleClass(\n        'image-markers__hotspot-icon__disabled', !enabled\n      );\n    },\n\n    hotspotClick: function(event) {\n      var me = this;\n      // Check the keyboard and mouse events are supported\n      if (event.which !== 1 && event.which !== 32 && event.which !== 13) {\n        return;\n      }\n      var hotspot = $(event.currentTarget);\n      var hotspotId = $(hotspot).data('hotspot-id');\n      var hotspotState = $(hotspot).data('display-state');\n\n      if (hotspotState !='selected') {\n        // set hotspot to selected\n        $(hotspot).data('display-state', 'selected');\n        me.setState(hotspotId, 'selected');\n        me.checkVisitedStates(hotspotId);\n        me.checkCompletion();\n        me.triggerActions(hotspotId);\n      }\n    },\n\n    triggerActions: function(hotspotId) {\n      var me = this;\n      var data = me.data;\n      var rawData = me.data.objRawData;\n      var domLink = $('[data-hotspot-id=\"'+ hotspotId +'\"]');\n\n      // Find actions for selected hotspot and trigger them\n      _.each(rawData.arrHotspots, function(hotspot) {\n        if (hotspot.strID == hotspotId) {\n          var actionData = {};\n          actionData.objActions = hotspot.arrActions;\n          actionData.objOptionalExtraData = hotspot;\n          actionData.objOptionalExtraData.strAssetID = data.strObjID;\n          actionData.objOptionalExtraData.domLink = domLink;\n          actionData.objOptionalExtraData.objParent = SCREEN_INTERACTIONS.getCurrentScreenData();\n          gomo.eventManager.legacy('screenAssetInteracting', data);\n          gomo.eventManager.legacy('processActions', actionData);\n        }\n      });\n    },\n\n    checkVisitedStates: function(hotspotId) {\n      var me = this;\n      var allHotspots = me.$('.image-markers__hotspot');\n      // Look at all hotpspots except the current active one and set them to visited if they have\n      // been previously selected.\n      _.each(allHotspots, function(hotspot) {\n        if (\n          $(hotspot).data('display-state') == 'selected' &&\n          $(hotspot).data('hotspot-id') != hotspotId\n        ) {\n          me.setState($(hotspot).data('hotspot-id'), 'visited');\n        }\n      });\n    },\n\n    resetSelectedStates: function() {\n      var me = this;\n      var allHotspots = me.$('.image-markers__hotspot');\n      // Make sure no markers are still set to 'selected' on returning focus\n      _.each(allHotspots, function(hotspot) {\n        if ( $(hotspot).data('display-state') == 'selected' ) {\n          me.setState($(hotspot).data('hotspot-id'), 'visited');\n        }\n      });\n    },\n\n    returnFocusToSelf: function() {\n      var me = this;\n      me.resetSelectedStates();\n    },\n\n    checkCompletion: function() {\n      var me = this;\n      var isComplete = true;\n      var allHotspots = me.$('.image-markers__hotspot');\n      _.each(allHotspots, function(hotspot) {\n        if ($(hotspot).data('display-state') == 'default') {\n          isComplete = false;\n        }\n      });\n      if (isComplete) {\n        me.data.isComplete = true;\n      }\n    },\n\n    // Is asset completable?\n    isCompletable: function() {\n      return true;\n    },\n\n    /**\n     * @public\n     * @return {boolean}\n     */\n    isComplete: function() {\n      var me = this;\n      return me.data.isComplete;\n    },\n\n    resetImageMarkers: function() {\n      var me = this;\n      var allHotspots = me.$('.image-markers__hotspot');\n      // Remove the resize event\n      $(window).off('resize.me');\n      // Reset all hotspot data\n      _.each(allHotspots, function(hotspot) {\n        me.setState($(hotspot).data('hotspot-id'), 'default');\n        $(hotspot).addClass('image-markers__hotspot-fade');\n      });\n    },\n\n    getAccessibleElements: function() {\n      var accessibleElements = ['.image-markers__hotspot'];\n      return accessibleElements;\n    }\n  });\n\n  // Register the new asset definition...\n  gomo.assetManager.register('image-markers', ImageMarkers);\n})();\n"},function(t,n,e){e(0)(e(61))},function(t,n){t.exports="/* globals ASSET_RENDERER, MANIFEST_MANAGER, TEMPLATE_MANANGER, OUTPUT_MODE_CHECKER, Animator,\n ASSET_INTERACTIONS, MASTER_RENDERER, OBJ_REF, SUB_SCREEN_RENDERER, O_EXTENDER, CORE, EM,\n CSSStyleSubject, TOPIC_STRUCTURE_PARSER, $, _, SCREEN_INTERACTIONS, ISCROLL_INTERFACE,\n SUB_SCREEN_INTERACTIONS, CONTENT_TRACKING */\n\n/**\n * @title Comicstrip asset extension collection\n * @description Provides 'comicstrip' functionality, which displays a series of\n * cropped images, expanding out to full size on click, and displaying subscreen\n *\n * @author Paul Stanyer\n * @version 2.0 11/07/12\n * @ Refactor note: This file still makes extensive use of non-coding standard variable names,\n * despite being converted away from the old style @variablename data shape. It would be ideal to\n * re-write/refactor to be inline with standards.\n */\n\nASSET_RENDERER.addAssetSupportData('comicstrip', {\n  graphicalC: true,\n  accessibleC: true,\n  tabletC: true,\n  smartphoneC: true\n});\n\nvar COMICSTRIP_ASSET_RENDERER = {\n  strObjID: 'The comicstrip asset inspector extension object',\n\n  // ***************************** Property extensions *****************************\n  _arrAssetHTMLTemplateIDs: [['comicstrip', 'comicstripAssetTemplateWrapperC']],\n  // _arrSubAssetHTMLTemplateIDs : [[\"comicstripCell\",\"comicstripCellWrapperC\"]],\n\n  _objSubscreens: {},\n  _objComicStripRowClassNames: {\n    '1': 'comicStripOnlyRowC',\n    '2': 'comicStripTopRowC',\n    '3': 'comicStripBottomRowC',\n    '4': 'comicStripMiddleRowC'\n  },\n  _objComicStripCellClassNames: {\n    '1': 'comicStripOnlyCellC',\n    '2': 'comicStripFirstCellC',\n    '3': 'comicStripLastCellC',\n    '4': 'comicStripMiddleCellC'\n  },\n\n  _objDomWrappers: {},\n  _objAssetManifest: MANIFEST_MANAGER.getAssetManifest('asset-comic-strip'),\n\n  arrTempComicStripAssetData: [],\n\n  // ***************************** Render methods extensions *****************************\n\n  _render_comicstrip_Asset: function(_objRenderData) {\n    var _objWhatAssetCourseObject = _objRenderData.objWhatAssetCourseObject;\n    var _booPreviewMode = _objRenderData.booPreviewMode;\n    _objWhatAssetCourseObject.trackingCompletionDelayed = true;\n\n    if (_objWhatAssetCourseObject.objRawData.booFullscreen == false) {\n      var _objAssetContent = {};\n      _objAssetContent.htmAssetContent = this._renderComicstripContainer(\n        _objWhatAssetCourseObject,\n        _booPreviewMode\n      );\n      _objAssetContent.htmAssetContent = _objAssetContent.htmAssetContent.replace(\n        /XX_FLOW_CLASS_XX/,\n        'comicstripAssetWrapperC'\n      );\n      return _objAssetContent;\n    }\n    return '';\n  },\n\n  _renderComicstripContainer: function(\n    _objWhatAssetCourseObject,\n    _booPreviewMode\n  ) {\n    // get a ref to the incoming raw data\n    var _objWhatRawAssetData = _objWhatAssetCourseObject.objRawData;\n\n    // create a hash of subscreens\n    this._createSubscreenObj(_objWhatAssetCourseObject);\n\n    // Get template HTML segment\n    var _htmReturnData = TEMPLATE_MANANGER.getTemplate(\n      'comicstripAssetTemplateWrapperC',\n      _objWhatAssetCourseObject.strComicStripOutputMode\n    ).htmData;\n    this._objDomWrappers[_objWhatRawAssetData.strID] = this._replaceAssetID(\n      false,\n      'XX_ASSET_ID_XX',\n      _objWhatRawAssetData.strID\n    );\n\n    // Set the strBoundaryId\n    var _strAssetDOMID = this.getAssetDOMId(_objWhatRawAssetData);\n    OUTPUT_MODE_CHECKER.setNewScreenSizeBoundary({\n      objRawAssetData: _objWhatAssetCourseObject.objRawData,\n      strDomId: _strAssetDOMID\n    });\n\n    _objWhatAssetCourseObject.strComicStripLayoutMode =\n      OUTPUT_MODE_CHECKER.objScreenSizeBoundaries[\n        _objWhatRawAssetData.strBoundaryId\n      ].strCurrentLayoutSize;\n\n    // Smartphone HTML, JS and CSS doesn't support large mode\n    if (OUTPUT_MODE_CHECKER.isSmartPhone()) {\n      _objWhatAssetCourseObject.strComicStripLayoutMode = OUTPUT_MODE_CHECKER.strScreenSizeSmall;\n    }\n\n    // Render cells\n    _htmReturnData = _htmReturnData.replace(\n      /XX_COMICSTRIP_CELLS_XX/,\n      this._renderComicstripCells(\n        _objWhatRawAssetData['rows'],\n        _objWhatAssetCourseObject\n      )\n    );\n\n    // Replace Asset ID\n    _htmReturnData = this._replaceAssetID(\n      _booPreviewMode,\n      _htmReturnData,\n      _objWhatRawAssetData['strID']\n    );\n\n    // Return our built HTML\n    return _htmReturnData;\n  },\n\n  resetComicstripRender: function() {\n    this._objDomWrappers = {};\n    this.arrTempComicStripAssetData = [];\n  },\n\n  _rerenderSetup_comicstrip_Asset: function(_objWhatAssetData) {\n    var _objWhatRawAssetData = _objWhatAssetData.objRawData;\n\n    var _strReturnOutputMode = 'large';\n    var _intLargestImage = 0;\n    // Additional width is a bit of an arbitrary number which allows room for asset padding etc...\n    var _intAdditionalScreenWidth = this._objAssetManifest.objPlayerDeclarations\n      .objCustomThemeElements.intAdditionalScreenWidth;\n\n    for (var i = 0; i < _objWhatRawAssetData.arrCells.length; i++) {\n      if (\n        _objWhatRawAssetData.arrCells[i]['strExpandedWidth'] >\n        window.innerWidth - _intAdditionalScreenWidth\n      ) {\n        _strReturnOutputMode = 'small';\n      }\n      if (\n        _intLargestImage == 0 ||\n        _intLargestImage <\n          _objWhatRawAssetData.arrCells[i]['strExpandedWidth'] +\n            _intAdditionalScreenWidth\n      ) {\n        _intLargestImage =\n          _objWhatRawAssetData.arrCells[i]['strExpandedWidth'] +\n          _intAdditionalScreenWidth;\n      }\n    }\n\n    var _funCallBack = function() {\n      ASSET_RENDERER.rerenderComicstrips(_objWhatAssetData);\n    };\n    if (_objWhatRawAssetData.booComicStripOutputModeSet == true) {\n      // Mode has already been setup\n    } else {\n      _objWhatRawAssetData.booComicStripOutputModeSet = true;\n      var _strAssetDOMID = this.getAssetDOMId(_objWhatRawAssetData);\n      OUTPUT_MODE_CHECKER.setNewScreenSizeBoundary({\n        objRawAssetData: _objWhatRawAssetData,\n        strDomId: _strAssetDOMID,\n        intLargeScreenMin: _intLargestImage,\n        intSmallScreenMax: _intLargestImage - 1,\n        funCallBack: _funCallBack\n      });\n    }\n\n    _objWhatAssetData.strOutputMode = _strReturnOutputMode;\n  },\n\n  rerenderComicstrips: function(_objWhatAssetData, booForceRerender) {\n    this._rerenderComicstrip(_objWhatAssetData, booForceRerender);\n  },\n\n  _rerenderComicstrip: function(_objAssetData, booForceRerender) {\n    if (\n      typeof _objAssetData.booComicstripRendering == 'undefined' ||\n      _objAssetData.booComicstripRendering == false ||\n      booForceRerender == true\n    ) {\n      _objAssetData.booComicstripRendering = true;\n      var booForceReset = true;\n      ASSET_INTERACTIONS.resetComicstrip(_objAssetData, booForceReset);\n\n      var _objWhatRawAssetData = _objAssetData.objRawData;\n      if (\n        this._objDomWrappers[_objWhatRawAssetData.strID] &&\n        _objAssetData.booIsDisplayed\n      ) {\n        var _domCurrentAsset = this.getAssetDOMElement(_objWhatRawAssetData);\n\n        if (_domCurrentAsset) {\n          // Render cells\n          var _objRenderData = {};\n          _objRenderData.objWhatAssetCourseObject = _objAssetData;\n          _objRenderData.booPreviewMode = false;\n\n          var _objAssetContent = this._render_comicstrip_Asset(_objRenderData);\n          _domCurrentAsset.outerHTML = _objAssetContent.htmAssetContent;\n          this.arrTempComicStripAssetData.push(_objAssetData);\n          // Don't PostRender on a Forced Rerender. This will cause an infinit loop. This needs\n          // reworking but this deprecated asset will be replaced soon.\n          if (!booForceRerender) {\n            ASSET_RENDERER.comicStripPostRender();\n          }\n\n          // Set the asset and default boundaries before using them\n          OUTPUT_MODE_CHECKER.manualScreenSizeCheck();\n          var forcedModeSize = OUTPUT_MODE_CHECKER.objScreenSizeBoundaries[\n            _objWhatRawAssetData.strBoundaryId\n          ].strCurrentLayoutSize;\n\n          // Smartphone HTML, JS and CSS doesn't support large mode\n          if (OUTPUT_MODE_CHECKER.isSmartPhone()) {\n            forcedModeSize = OUTPUT_MODE_CHECKER.strScreenSizeSmall;\n          }\n          this.resetAssetWrapperForcedMode(_objAssetData.objRawData, forcedModeSize);\n\n          // Reregister the new asset with the\n          gomo.translationManager.rebindDataToElement(\n            _objWhatRawAssetData.strID,\n            _objWhatRawAssetData.strID,\n            _domCurrentAsset.id\n          );\n        }\n      }\n    }\n  },\n\n  comicStripPostRender: function() {\n    var count = 0;\n    while (count < this.arrTempComicStripAssetData.length) {\n      var _objAssetData = ASSET_RENDERER.arrTempComicStripAssetData[count];\n\n      ASSET_INTERACTIONS.showPostRenderAsset(_objAssetData);\n      _objAssetData.booComicstripRendering = false;\n\n      count++;\n    }\n  },\n\n  _replaceAssetID: function(_booPreviewMode, _htmReturnData, _strId) {\n    if (_booPreviewMode) {\n      _htmReturnData = _htmReturnData.replace(\n        /XX_ASSET_ID_XX/g,\n        'YY' + _strId + 'YYPreview'\n      );\n    } else {\n      _htmReturnData = _htmReturnData.replace(\n        /XX_ASSET_ID_XX/g,\n        'YY' + _strId + 'YY'\n      );\n    }\n    return _htmReturnData;\n  },\n\n  _renderComicstripCells: function(_arrRows, _objAssetData) {\n    var _htmAllCells = '';\n    var _intCell = 0;\n    var _strCellClass;\n    var _strCellPlacementClass;\n\n    for (var _intRow = 0; _intRow < _arrRows.length; _intRow++) {\n      var _strRowClass = this._objComicStripRowClassNames[\n        this._comicstrip_calculateClassIndex(_intRow, _arrRows.length)\n      ];\n      var _arrRowCells = _arrRows[_intRow];\n      for (var _intCol = 0; _intCol < _arrRowCells.length; _intCol++) {\n        _intCell++;\n        _strCellClass = '';\n        _strCellPlacementClass =\n          _strRowClass +\n          ' ' +\n          this._objComicStripCellClassNames[\n            this._comicstrip_calculateClassIndex(_intCol, _arrRowCells.length)\n          ];\n        _strCellClass += 'comicstripCellC comicStripCell_' + _intCell + '_C';\n        var _objCell = _arrRowCells[_intCol];\n        _htmAllCells += this._renderSingleCell(\n          _objCell,\n          _strCellClass,\n          _strCellPlacementClass,\n          _objAssetData\n        );\n      }\n    }\n    return _htmAllCells;\n  },\n\n  _renderSingleCell: function(\n    _objCell,\n    _strClass,\n    _strPlacementClass,\n    _objAssetData\n  ) {\n    var _htmCell = TEMPLATE_MANANGER.getTemplate(\n      'comicstripCellWrapperC',\n      _objAssetData.strComicStripLayoutMode\n    ).htmData;\n\n    _htmCell = _htmCell.replace(\n      /XX_ASSET_ID_XX/g,\n      _objAssetData.objRawData.strID\n    );\n    _htmCell = _htmCell.replace(/XX_CELL_ID_XX/g, _objCell['strID']);\n    _htmCell = _htmCell.replace(/XX_COMICSTRIP_CELL_CLASS_XX/, _strClass);\n    _htmCell = _htmCell.replace(/XX_CELL_PLACEMENT_XX/g, _strPlacementClass);\n    _htmCell = _htmCell.replace(\n      /resources\\/trans.gif\\?/,\n      gomo.utility.getSrcPath(_objCell.objImageSrc.strSrc)\n    );\n    _htmCell = _htmCell.replace(\n      /XX_CELL_SRC_XX/,\n      decodeURIComponent(_objCell.objImageSrc.strSrc)\n    );\n    _htmCell = _htmCell.replace(\n      /XX_ALTTEXT_XX/,\n      decodeURIComponent(_objCell.objImageSrc.strAltText)\n    );\n    _htmCell = _htmCell.replace(/XX_CS_COL_XX/g, _objCell['intColumnIndex']);\n    _htmCell = _htmCell.replace(/XX_CS_ROW_XX/g, _objCell.strRow);\n\n    if (\n      _objCell.arrActions[0] &&\n      _objCell.arrActions[0].objParameters &&\n      _objCell.arrActions[0].objParameters.strSubScreenID\n    ) {\n      _htmCell = _htmCell.replace(\n        /XX_SUBSCREEN_XX/,\n        this._renderComicstripSubscreen(\n          _objCell.arrActions[0].objParameters.strSubScreenID\n        )\n      );\n    } else {\n      _htmCell = _htmCell.replace(/XX_SUBSCREEN_XX/, '');\n    }\n\n    _htmCell = _htmCell.replace(/XX_ARR_NUM_XX/g, _objCell['intCellNum'] - 1);\n    _htmCell = _htmCell.replace(/XX_CELL_NUM_XX/g, _objCell['intCellNum']);\n    return _htmCell;\n  },\n\n  _comicstrip_calculateClassIndex: function(_intCurrent, _intLength) {\n    if (_intCurrent == _intLength - 1 && _intCurrent == 0) {\n      return '1';\n    } else if (_intCurrent == 0) {\n      return '2';\n    } else if (_intCurrent == _intLength - 1) {\n      return '3';\n    }\n    return '4';\n  },\n\n  _createSubscreenObj: function(_objWhatAssetCourseObject) {\n    for (\n      var _i = 0;\n      _i < _objWhatAssetCourseObject.objRawData.arrCells.length;\n      _i++\n    ) {\n      var _objCurrCell = _objWhatAssetCourseObject.objRawData.arrCells[_i];\n      if (\n        _objCurrCell.arrActions.length > 0 &&\n        _objCurrCell.arrActions[0].objParameters &&\n        _objCurrCell.arrActions[0].objParameters.strSubScreenID\n      ) {\n        var _strSubScreenID =\n          _objCurrCell.arrActions[0].objParameters.strSubScreenID;\n        this._objSubscreens[_strSubScreenID] = OBJ_REF.get(_strSubScreenID);\n      }\n    }\n  },\n\n  _renderComicstripSubscreen: function(_strSubscreenId) {\n    if (this._objSubscreens[_strSubscreenId]) {\n      return SUB_SCREEN_RENDERER.renderSubScreen(\n        this._objSubscreens[_strSubscreenId],\n        'comicstrip'\n      );\n    }\n    return '';\n  },\n\n  _comicstrip_checkSubScreenForRender: function() {\n    return false;\n  },\n\n  _comicstrip_renderNonColumnAsset: function(\n    _objWhatAssetCourseObject,\n    _booPreviewMode\n  ) {\n    if (_objWhatAssetCourseObject.objRawData.booFullscreen == true) {\n      var _htmContent = this._renderComicstripContainer(\n        _objWhatAssetCourseObject,\n        _booPreviewMode\n      );\n      return _htmContent.replace(\n        /XX_FLOW_CLASS_XX/,\n        'comicstripNonColumnAssetWrapperC'\n      );\n    }\n    return '';\n  }\n};\n\nO_EXTENDER.extend(ASSET_RENDERER, COMICSTRIP_ASSET_RENDERER);\n\n/**\n * Simple class to manage cell animations per comic strip\n *\n * This class then gets extended by a specific animator to handle the\n * different types (currently: popup crop, deform crop, scale)\n * @param {object} _objAsset - The asset object.\n * @param {boolean} _booImageOffset - The image offset.\n */\nfunction ComicstripAnimator(_objAsset, _booImageOffset) {\n  // store animation state\n  this._booAnimating = false;\n\n  // stores cells (see _initialiseData)\n  this._arrCells = {};\n\n  // Container DOM element\n  this._domElement = null;\n\n  // Container dimensions\n  this._intContainerWidth = 0;\n  this._intContainerHeight = 0;\n  // Mode\n  this._booImageOffset = _booImageOffset;\n\n  // store the currently active cell, null for all closed\n  this._strCurrentCell = null;\n\n  // cell animations stored by id\n  this._objCellAnimations = {};\n\n  // overlay animation\n  this._objOverlayAnimation = {};\n\n  // subscreen animations stored by cell id\n  this._objSubscreenAnimations = {};\n\n  // Store Asset Data\n  this._initialiseData(_objAsset);\n}\n\nComicstripAnimator.prototype = {\n  _intBorderWidth: 3,\n  _strCssComicstripOverlayHidden: 'opacity: 0.1; z-index: -1;',\n  _strCssComicstripOverlayShown: 'opacity: 0.8; z-index: 2;',\n\n  // return the animating state\n  isAnimating: function() {\n    return this._booAnimating;\n  },\n\n  // check if we currently have an open cell\n  hasCurrentOpenCell: function() {\n    return null !== this._strCurrentCell;\n  },\n\n  getCurrentOpenCell: function() {\n    return this._strCurrentCell;\n  },\n\n  // call the open cell animation\n  openCell: function(_strCellToOpen) {\n    // Switch animation state\n    this._booAnimating = true;\n\n    // move to front\n    this.setCellClass(_strCellToOpen, 'comicstripCellOpenC');\n    this.setVisitedClass(_strCellToOpen);\n    var _domSubscreen = ASSET_RENDERER._objCurrDOM.getElementById(\n      'comicstripCell_' + _strCellToOpen\n    );\n    _domSubscreen = CORE.getElementsByClassName(\n      _domSubscreen,\n      'comicstripSubScreenWrapperC'\n    )[0];\n    if (_domSubscreen == undefined) {\n      alert('There is no associated subscreen for this comicstrip cell');\n      return;\n    }\n\n    var _objMeRef = this;\n    var _objAnimator = this._objCellAnimations[_strCellToOpen];\n    _objAnimator.setOptions({\n      onComplete: function() {\n        _domSubscreen.className = _domSubscreen.className.replace(\n          'comicstripSubscreenHiddenC',\n          'comicstripSubscreenVisibleC'\n        );\n        if (_objMeRef._objSubscreenAnimations[_strCellToOpen]) {\n          _objMeRef._objSubscreenAnimations[_strCellToOpen].play();\n        }\n        // set state\n        _objMeRef._strCurrentCell = _strCellToOpen;\n        _objMeRef._booAnimating = false;\n        gomo.scrollManager.refreshScrollers();\n        // Disable the page scroller so the subscreen scrolls\n        var currScreenId = SCREEN_INTERACTIONS.getCurrentScreenData().strObjID;\n        var scrollerId = $(\n          '#screenWrapper_' + currScreenId + 'L .scrollMaskingWrapperC'\n        ).attr('id');\n        if (scrollerId) {\n          ISCROLL_INTERFACE._disableScroller(scrollerId);\n        }\n      }\n    });\n    // make overlay visible\n    _objMeRef._domOverlayElement.style.zIndex = 2;\n    _objMeRef._objOverlayAnimation.play();\n    _objAnimator.play();\n  },\n  // close the open cell\n  // NOTE: will trigger open if cell clicked on is not the same cell to close\n  closeCurrentCell: function(_strCellClickedOn, _objWhatCellData) {\n    // Switch animation state\n    this._booAnimating = true;\n\n    // Did we click the open cell?\n    var _booSameCell = this._strCurrentCell == _strCellClickedOn;\n\n    var _domSubscreen = ASSET_RENDERER._objCurrDOM.getElementById(\n      'comicstripCell_' + _strCellClickedOn\n    );\n    _domSubscreen = CORE.getElementsByClassName(\n      _domSubscreen,\n      'comicstripSubScreenWrapperC'\n    )[0];\n    _domSubscreen.className = _domSubscreen.className.replace(\n      'comicstripSubscreenVisibleC',\n      'comicstripSubscreenHiddenC'\n    );\n\n    // close subscreen\n    if (this._objSubscreenAnimations[this._strCurrentCell]) {\n      this._objSubscreenAnimations[this._strCurrentCell].reverse();\n    }\n    // hide overlay\n    this._objOverlayAnimation.reverse();\n\n    var _objAnimator = this._objCellAnimations[this._strCurrentCell];\n    var _objMeRef = this;\n    _objAnimator.setOptions({\n      onComplete: function() {\n        // move to back\n        _objMeRef.setCellClass(\n          _objMeRef._strCurrentCell,\n          'comicstripCellClosedC'\n        );\n\n        // move overlay out of the way\n        _objMeRef._domOverlayElement.style.zIndex = -1;\n\n        // reset the current animation\n        _objMeRef._strCurrentCell = null;\n        _objMeRef._booAnimating = false;\n\n        // If we clicked a different cell...\n        if (!_booSameCell) {\n          // ...re-trigger click now that we've closed this one\n          EM.trigger('comicstripCellClicked', _objWhatCellData);\n        }\n\n        // Enable page scrolling\n        var currScreenId = SCREEN_INTERACTIONS.getCurrentScreenData().strObjID;\n        var scrollerId = $(\n          '#screenWrapper_' + currScreenId + 'L .scrollMaskingWrapperC'\n        ).attr('id');\n        if (scrollerId) {\n          ISCROLL_INTERFACE._enableScroller(scrollerId);\n        }\n      }\n    });\n    _objAnimator.reverse();\n  },\n\n  // build animations\n  generateCellAnimations: function() {\n    // alert('T'is functionality should be provided by a child class');\n    alert(\n      'ERROR: Animation type isn\\'t set or wasn\\'t understood. ComicstripAnimator(),' +\n        'extension_comicstrip_asset.js'\n    );\n  },\n\n  _initialiseData: function(_objAsset) {\n    var booForceRerender = true;\n    ASSET_RENDERER.rerenderComicstrips(_objAsset, booForceRerender);\n\n    // get the DOM Element\n    this._domElement = ASSET_RENDERER._objCurrDOM.getElementById(\n      'comicstripAsset_YY' + _objAsset['strObjID'] + 'YY_ContainerL'\n    );\n    // grab the width and height\n    this._intContainerWidth = this._domElement.offsetWidth;\n    this._intContainerHeight =\n      this._domElement.parentNode.offsetHeight - this._intBorderWidth * 2;\n\n    // add each row\n    var _intCumulativeOffsetY = 0;\n\n    var _arrRows = _objAsset.objRawData['rows'];\n    for (var _intRow = 0; _intRow < _arrRows.length; _intRow++) {\n      // initialise row in object\n      var _arrRowCells = _arrRows[_intRow];\n      var _intCumulativeOffsetX = 0;\n      var _intCumulativeWidth = 0;\n\n      // extra loop to calculate the total width the cells will take up.\n      // this is then checked against the container width to see if there will be any pixels\n      // remaining. The remainder is then added to the cells within the next loop to make sure\n      // both widths are the same at the end.\n\n      var _objCell;\n      var _intCellWidth;\n      var _intCellHeight;\n\n      for (var i = 0; i < _arrRowCells.length; i++) {\n        _objCell = _arrRowCells[i];\n        _intCellWidth = Math.round(\n          this._intContainerWidth * (_objCell['strWidthRatio'] / 100)\n        );\n        _intCumulativeWidth += _intCellWidth;\n      }\n\n      var _intWidthRemainder = this._intContainerWidth % _intCumulativeWidth;\n\n      for (var j = 0; j < _arrRowCells.length; j++) {\n        _objCell = _arrRowCells[j];\n        _intCellWidth = Math.round(\n          this._intContainerWidth * (_objCell['strWidthRatio'] / 100)\n        );\n        _intCellHeight = Math.round(\n          this._intContainerHeight * (_objCell['strHeightRatio'] / 100)\n        );\n\n        if (_intWidthRemainder > 0) {\n          _intCellWidth++;\n          _intWidthRemainder--;\n        }\n\n        // difference in expanded\n        var _intDeltaWidth = _objCell['strExpandedWidth'] - _intCellWidth;\n        var _intDeltaHeight = _objCell['strExpandedHeight'] - _intCellHeight;\n        // where to expand to\n        var _intMaxX = Math.round(_intCumulativeOffsetX - _intDeltaWidth / 2);\n        var _intMaxY = Math.round(_intCumulativeOffsetY - _intDeltaHeight / 2);\n        // check we haven't expanded over a boundary\n        if (_intMaxX < 0) {\n          _intMaxX = 0;\n        }\n        if (_intMaxY < 0) {\n          _intMaxY = 0;\n        }\n        if (_intMaxX + _objCell['strExpandedWidth'] > this._intContainerWidth) {\n          _intMaxX = this._intContainerWidth - _objCell['strExpandedWidth'];\n        }\n        if (\n          _intMaxY + _objCell['strExpandedHeight'] >\n          this._intContainerHeight\n        ) {\n          _intMaxY = this._intContainerHeight - _objCell['strExpandedHeight'];\n        }\n        // calculate and store data we need to make animations\n        var _objCellData = {\n          // collapsed\n          _intMinX: _intCumulativeOffsetX,\n          _intMinY: _intCumulativeOffsetY,\n          _intMinWidth: _intCellWidth,\n          _intMinHeight: _intCellHeight,\n          // expanded\n          _intMaxX: _intMaxX,\n          _intMaxY: _intMaxY,\n          _intMaxWidth: _objCell['strExpandedWidth'],\n          _intMaxHeight: _objCell['strExpandedHeight'],\n          // position in strip data\n          _intRow: _intRow + 1,\n          _intNumRows: _arrRows.length,\n          _intCol: j + 1,\n          _intCellsInRow: _arrRowCells.length\n        };\n        this._arrCells[_objCell['strID']] = _objCellData;\n        // set the initial styles\n        this.setInitialCellStyle(_objCell['strID'], _objCellData);\n        // add to cumulative x\n        _intCumulativeOffsetX += _intCellWidth;\n        // generate a subscreen animation if required\n        if (\n          _objCell.arrActions.length > 0 &&\n          _objCell.arrActions[0].objParameters &&\n          _objCell.arrActions[0].objParameters.strSubScreenID\n        ) {\n          var _strSubscreenId =\n            'subScreenWrapper_' +\n            _objCell.arrActions[0].objParameters.strSubScreenID +\n            'L';\n\n          var _objAnimtor;\n          if (\n            OUTPUT_MODE_CHECKER.strWhatBrowserTypeClass == 'ie7C' ||\n            OUTPUT_MODE_CHECKER.strWhatBrowserTypeClass ==\n              'ie8CompatibilityModeC'\n          ) {\n            _objAnimtor = new Animator({duration: 300});\n          } else {\n            _objAnimtor = new Animator({duration: 300}).addSubject(\n              new CSSStyleSubject(_strSubscreenId, 'opacity:0', 'opacity:0.8')\n            );\n          }\n          this._objSubscreenAnimations[_objCell['strID']] = _objAnimtor;\n        }\n      }\n      _intCumulativeOffsetY += _intCellHeight;\n    }\n    // show/hide overlay layer\n    var _strOverlayId =\n      'comicstripAsset_YY' + _objAsset['strObjID'] + 'YY_OverlayL';\n    this._domOverlayElement = ASSET_RENDERER._objCurrDOM.getElementById(\n      _strOverlayId\n    );\n    this._objOverlayAnimation = new Animator({\n      duration: 150,\n      transition: Animator.tx.linear\n    }).addSubject(\n      new CSSStyleSubject(\n        _strOverlayId,\n        this._strCssComicstripOverlayHidden,\n        this._strCssComicstripOverlayShown\n      )\n    );\n  },\n\n  setInitialCellStyle: function(_strId, _objCell) {\n    var _domCell = ASSET_RENDERER._objCurrDOM.getElementById(\n      'comicstripCell_' + _strId\n    );\n    _domCell.style.top = _objCell['_intMinY'] + 'px';\n    _domCell.style.left = _objCell['_intMinX'] + 'px';\n    _domCell.style.width = _objCell['_intMinWidth'] + 'px';\n    _domCell.style.height = _objCell['_intMinHeight'] + 'px';\n\n    if (this._booImageOffset) {\n      var _domCellImg = ASSET_RENDERER._objCurrDOM.getElementById(\n        'comicstripCellImg_' + _strId\n      );\n      _domCellImg.style.marginTop =\n        _objCell['_intMaxY'] - _objCell['_intMinY'] + 'px';\n      _domCellImg.style.marginLeft =\n        _objCell['_intMaxX'] - _objCell['_intMinX'] + 'px';\n    }\n  },\n\n  setCellClass: function(_strId, _strClassName) {\n    var _domCell = ASSET_RENDERER._objCurrDOM.getElementById(\n      'comicstripCell_' + _strId\n    );\n    /* If a screen is closed with an open comic strip there will be nothing to close\n     * and an error will occur - JH */\n    if (_domCell) {\n      _domCell.className = _domCell.className.replace(\n        /comicstripCell(Open|Closed)C/,\n        _strClassName\n      );\n    }\n  },\n\n  setVisitedClass: function(_strId) {\n    var _domCell = ASSET_RENDERER._objCurrDOM.getElementById(\n      'comicstripCell_' + _strId\n    );\n    _domCell.className = _domCell.className.replace(\n      /comicStripCellUnvisitedC/,\n      'comicStripCellVisitedC'\n    );\n  }\n};\n\n/**\n * Popup crop animation generator. This needs to be loaded into the base class\n * in order to do anything sensible.\n */\nvar ComicstripPopupCropAnimationGenerator = function() {\n  // create an animation for each cell in the strip\n  for (var _strCellId in this._arrCells) {\n    if (Object.prototype.hasOwnProperty.call(this._arrCells, _strCellId)) {\n      var _objCell = this._arrCells[_strCellId];\n      // we need to animate cell and image (to keep image aligned in cell)\n      var _objAnim = new Animator();\n      var _strTo = 'top: ' + _objCell._intMaxY + 'px; ';\n      _strTo += 'left: ' + _objCell._intMaxX + 'px; ';\n      _strTo += 'width: ' + _objCell._intMaxWidth + 'px; ';\n      _strTo += 'height: ' + _objCell._intMaxHeight + 'px; ';\n      _objAnim.addSubject(\n        new CSSStyleSubject('comicstripCell_' + _strCellId, _strTo)\n      );\n      // all non generated css can sit in these styles - also allows us to turn off numbers etc.\n      _objAnim.addSubject(\n        new CSSStyleSubject(\n          'comicstripCell_' + _strCellId,\n          'comicstripCellClosedC',\n          'comicstripCellOpenC'\n        )\n      );\n      _objAnim.addSubject(\n        new CSSStyleSubject(\n          'comicstripCellImg_' + _strCellId,\n          'margin-left: 0px; margin-top: 0px;'\n        )\n      );\n      // save to cell animations\n      this._objCellAnimations[_strCellId] = _objAnim;\n    }\n  }\n};\n\n/**\n * Returns the correct animator for the job\n */\nvar ComicstripAnimatorFactory = {\n  getAnimator: function(_objAsset) {\n    var _strAnimationType = _objAsset.objRawData.strTransitionType;\n    // create animator\n    var _objAnimator = new ComicstripAnimator(_objAsset, true);\n\n    // Attach the correct generator\n    switch (_strAnimationType) {\n      case 'crop':\n      case 'crop_popup':\n      case 'scale':\n        // crop is older style format\n        // Attach generator\n        _objAnimator.generateCellAnimations = ComicstripPopupCropAnimationGenerator;\n        break;\n\n      case 'zoom':\n        _objAnimator._booImageOffset = false;\n        break;\n\n      default:\n        alert(\n          'ERROR: Unknown animation type of \\'' +\n            _strAnimationType +\n            '\\' found in ComicstripAnimatorFactory(), extension_comicstrip_asset.js.'\n        );\n        break;\n    }\n    // Generate animations\n    _objAnimator.generateCellAnimations();\n\n    // return animation object\n    return _objAnimator;\n  }\n};\n\n/**\n *\n */\nvar COMICSTRIP_ASSET_INTERACTIONS = {\n  strObjID: 'The graphical mcq asset interactions extension object',\n\n  // Animators for each comic strip\n  _objComicstripAnimators: {},\n\n  comicstripStatementData: {},\n\n  is_comicstrip_AssetCompletable: function(_objWhatAssetData) {\n    return true;\n  },\n\n  _performPreShowActions_comicstrip_Asset: function(assetData) {\n    this.comicstripStatementData[assetData.strObjID] = {\n      subscreenAvailable: null,\n      assetType: assetData.strAssetType\n    };\n    var listenForEscape = function(e) {\n      if (e.keyCode === 27 || e.key === 'Escape') {\n        gomo.eventManager.legacy('comicstripCellClicked', false);\n      }\n    };\n    window.addEventListener('keydown', listenForEscape);\n  },\n\n  _performLanguagePreprocess_comicstrip_Asset: function(\n    _objWhatAssetCourseObject\n  ) {\n    gomo.translationManager.setArrayOfImages(\n      _objWhatAssetCourseObject.objRawData.strID,\n      'arrCells',\n      'objImageSrc'\n    );\n  },\n\n  _doPostRenderShowActions_comicstrip_Asset: function(\n    _objWhatAssetCourseObject\n  ) {\n    if (!this._objComicstripAnimators[_objWhatAssetCourseObject['strObjID']]) {\n      if (\n        OUTPUT_MODE_CHECKER.objScreenSizeBoundaries[\n          _objWhatAssetCourseObject.objRawData.strBoundaryId\n        ].strCurrentLayoutSize != 'small' &&\n        this._strCurrOutputMode != 'accessibleC' &&\n        !OUTPUT_MODE_CHECKER.isSmartPhone()\n      ) {\n        this._objComicstripAnimators[\n          _objWhatAssetCourseObject['strObjID']\n        ] = ComicstripAnimatorFactory.getAnimator(_objWhatAssetCourseObject);\n      }\n    }\n\n    /* IE falls over if opacity:value; is set, so we need to logically set CSS. JH */\n    var _domPageWrapper = ASSET_RENDERER._objCurrDOM.getElementById(\n      'pageWrapperL'\n    );\n    var _domComicStrips = CORE.getElementsByClassName(\n      _domPageWrapper,\n      'comicstripSubScreenWrapperC'\n    );\n\n    var _intOpacityValue = 0;\n\n    if (\n      OUTPUT_MODE_CHECKER.strWhatBrowserTypeClass == 'ie7C' ||\n      OUTPUT_MODE_CHECKER.strWhatBrowserTypeClass == 'ie8CompatibilityModeC'\n    ) {\n      /* IE 7 and IE 8 in compatibility mode can't use alpha with overflowed elements.\n       * ms-filter would work but we can't set the in JH */\n      return;\n    } else if (\n      OUTPUT_MODE_CHECKER.strWhatBrowserTypeClass == 'ie6C' ||\n      OUTPUT_MODE_CHECKER.strWhatBrowserTypeClass == 'ie8C' ||\n      OUTPUT_MODE_CHECKER.strWhatBrowserTypeClass == 'ie9C'\n    ) {\n      var _intComicStrip;\n      for (_intComicStrip in _domComicStrips) {\n        if (\n          Object.prototype.hasOwnProperty.call(_domComicStrips, _intComicStrip)\n        ) {\n          _domComicStrips[_intComicStrip].style.filter =\n            'alpha(opacity=' + _intOpacityValue * 100 + ')';\n        }\n      }\n    } else if (\n      OUTPUT_MODE_CHECKER.objScreenSizeBoundaries[\n        _objWhatAssetCourseObject.objRawData.strBoundaryId\n      ].strCurrentLayoutSize == 'small' ||\n      this._strCurrOutputMode == 'accessibleC' ||\n      OUTPUT_MODE_CHECKER.isSmartPhone()\n    ) {\n      // no animation required for static modes (smartphone and accessible). JH\n      for (_intComicStrip in _domComicStrips) {\n        if (\n          Object.prototype.hasOwnProperty.call(_domComicStrips, _intComicStrip)\n        ) {\n          _domComicStrips[_intComicStrip].className = _domComicStrips[\n            _intComicStrip\n          ].className.replace(\n            'comicstripSubscreenHiddenC',\n            'comicstripSubscreenVisibleC'\n          );\n        }\n      }\n      return;\n    } else if (ASSET_INTERACTIONS.shouldAssetReset(_objWhatAssetCourseObject)) {\n      for (_intComicStrip in _domComicStrips) {\n        if (\n          Object.prototype.hasOwnProperty.call(_domComicStrips, _intComicStrip)\n        ) {\n          _domComicStrips[_intComicStrip].style.opacity = _intOpacityValue;\n        }\n      }\n    }\n\n    // Apply iscroll to comic strip subscreens\n    var me = this;\n    _.each(_objWhatAssetCourseObject.objRawData.arrCells, function(element) {\n      var subscreenId = element.arrActions[0].objParameters.strSubScreenID;\n      var comicstripSubscreenContent = me._objWhatDOM.getElementById(\n        'comicstripSubscreenContent_' + subscreenId + 'L'\n      );\n\n      if (typeof element.strExpandedWidth !== 'undefined') {\n        $(comicstripSubscreenContent).width(element.strExpandedWidth + 'px');\n\n        var subscreenHeight = $(comicstripSubscreenContent)\n          .find('.scrollWrapperC')\n          .height();\n        if (subscreenHeight > 235) {\n          var subscreenContentOuter = me._objWhatDOM.getElementById(\n            'subScreenContent_' + subscreenId + 'L'\n          );\n          gomo.scrollManager.parseChildElements(subscreenContentOuter, true);\n          var comicstripSubscreenWrapper = me._objWhatDOM.getElementById(\n            'subScreenWrapper_' + subscreenId + 'L'\n          );\n          $(comicstripSubscreenWrapper).addClass('comicstripSubscreenOverflow');\n        }\n\n        $(comicstripSubscreenContent).width('auto');\n      }\n    });\n  },\n\n  _doPostRenderHideActions_comicstrip_Asset: function(assetData) {\n    var data = this.comicstripStatementData[assetData.strObjID];\n    if (data.subscreenAvailable) {\n      this.sendComicstripSlideTrackingDataOut(assetData.strObjID);\n    }\n  },\n\n  handleEvent_comicstripCellClicked: function(_objWhatCellData) {\n    if (!_objWhatCellData || _.isUndefined(_objWhatCellData)) {\n      _objWhatCellData = this._objComicstripAnimators.openCells;\n    } else {\n      // Store open cell data so we know which one to close when escape key pressed.\n      this._objComicstripAnimators.openCells = _objWhatCellData;\n    }\n    // get the cell from info passed in to us\n    var _objCell = this._getCellData(_objWhatCellData);\n\n    // grab the animator for this comic strip\n    var _objAnimator = this._objComicstripAnimators[_objCell['strAssetID']];\n\n    // Ignore the event if mid-animation\n    if (_objAnimator.isAnimating()) {\n      return false;\n    }\n\n    // Do we have a cell open?\n    if (_objAnimator.hasCurrentOpenCell()) {\n      // close the current cell, (and potentially open a new one after)\n      _objAnimator.closeCurrentCell(_objCell['strID'], _objWhatCellData);\n      this.sendComicstripSlideTrackingDataOut(_objCell.strAssetID);\n      this.comicstripStatementData[_objCell.strAssetID].subscreenAvailable = null;\n    } else {\n      // open the cell we clicked on\n      _objAnimator.openCell(_objCell['strID']);\n      var subscreenId = _objCell.arrActions.length ?\n        _objCell.arrActions[0].objParameters.strSubScreenID : '';\n      this.comicstripStatementData[_objCell.strAssetID].subscreenAvailable = new Date();\n      this.comicstripStatementData[_objCell.strAssetID].subscreenId = subscreenId;\n      this.comicstripStatementData[_objCell.strAssetID].subscreenTitle =\n        SUB_SCREEN_INTERACTIONS._getSubScreenData(subscreenId).strTitle;\n      this.sendComicstripSlideTrackingDataIn(_objCell.strAssetID);\n      var subscreenDomElem = SUB_SCREEN_INTERACTIONS.getSubScreenDOMElement(subscreenId);\n      if (subscreenDomElem) {\n        gomo.tabManager.focusModalContent(subscreenDomElem, subscreenDomElem);\n      }\n    }\n\n    var _strAssetId = _objWhatCellData['strAssetID'];\n    var _objWhatAssetData = this.getAssetData(_strAssetId);\n    EM.trigger('screenAssetInteracting', _objWhatAssetData);\n    return false;\n  },\n\n  resetComicstrip: function(_objWhatAssetData, _booForceReset) {\n    this._reset_comicstrip_Asset(_objWhatAssetData, _booForceReset);\n    ASSET_RENDERER.arrTempComicStripAssetData = [];\n  },\n\n  _getCellData: function(_objWhatCellData) {\n    var _strAssetId = _objWhatCellData['strAssetID'];\n    var _objWhatAssetData = this.getAssetData(_strAssetId);\n    var _objRawData = _objWhatAssetData.objRawData;\n    // -1 from these as 0 indexed in array\n    var _row = _objWhatCellData['row'] - 1;\n    if (!_objRawData.rows[_row]) {\n      return false;\n    }\n    var _col = _objWhatCellData['col'] - 1;\n    if (!_objRawData.rows[_row][_col]) {\n      return false;\n    }\n    // add asset id\n    _objRawData.rows[_row][_col]['strAssetID'] = _objRawData['strID'];\n\n    // JC: Removed as it was a) redundant and b) caused errors due to cyclical references.\n    // pointer to all rows\n    // _objRawData.rows[_row][_col]['allrows'] = _objRawData.rows;\n\n    return _objRawData.rows[_row][_col];\n  },\n\n  _reset_comicstrip_Asset: function(_objWhatAssetData, _booForceReset) {\n    // Recycle the scroller on comicstrip reset as the subscreen doms have been destroyed\n    var me = this;\n    _.each(_objWhatAssetData.objRawData.arrCells, function(element) {\n      var subscreenId = element.arrActions[0].objParameters.strSubScreenID;\n      var subscreenContentOuter = me._objWhatDOM.getElementById(\n        'subScreenContent_' + subscreenId + 'L'\n      );\n\n      ISCROLL_INTERFACE.recycleScroller(subscreenContentOuter);\n    });\n\n    var _objAnimator = this._objComicstripAnimators[\n      _objWhatAssetData['strObjID']\n    ];\n    if (_objAnimator) {\n      if (_objAnimator.hasCurrentOpenCell()) {\n        _objAnimator.closeCurrentCell(_objAnimator.getCurrentOpenCell());\n      }\n    }\n\n    this._objComicstripAnimators[_objWhatAssetData['strObjID']] = null;\n\n    if (_booForceReset) {\n      _objWhatAssetData.objRawData.booComicStripOutputModeSet = false;\n    }\n\n    ASSET_RENDERER.resetComicstripRender;\n  },\n\n  _checkCompletion_comicstrip_Asset: function(_objWhatAssetDataWrapper) {\n    var _objWhatAssetData = this.getAssetData(\n      _objWhatAssetDataWrapper['strObjID']\n    );\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(\n      _objWhatAssetData['objRawData']\n    );\n    var _domUnvisitedCells = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      'comicStripCellUnvisitedC'\n    );\n    return _domUnvisitedCells.length == 0;\n  },\n\n  getAccessibleElements_comicstrip: function(_objAssetData) {\n    var comicstripCells = this.getAssetData(_objAssetData['strObjID'])\n      .objRawData.arrCells;\n    var count = 0;\n    var accessibleElements = [];\n\n    while (count < comicstripCells.length) {\n      accessibleElements.push(\n        '#comicstripCell_' + comicstripCells[count].strID\n      );\n      accessibleElements.push(\n        '#subScreenContent_' +\n          comicstripCells[count].arrActions[0].objParameters.strSubScreenID +\n          'L .fakeComicStripCellCloseC'\n      );\n      count++;\n    }\n\n    return accessibleElements;\n  },\n\n  sendComicstripSlideTrackingDataIn: function(assetId) {\n    var data = this.comicstripStatementData[assetId];\n    CONTENT_TRACKING.interaction({\n      type: 'experienced',\n      activity: {\n        id: data.subscreenId,\n        title: data.subscreenTitle,\n        type: 'subscreen'\n      },\n      referrer: {\n        id: assetId,\n        type: 'asset',\n        assetType: data.assetType\n      },\n      parent: 'asset/' + assetId,\n      topicGrouping: true\n    });\n  },\n\n  sendComicstripSlideTrackingDataOut: function(assetId) {\n    var data = this.comicstripStatementData[assetId];\n    CONTENT_TRACKING.interaction({\n      type: 'left',\n      activity: {\n        id: data.subscreenId,\n        title: data.subscreenTitle,\n        type: 'subscreen'\n      },\n      response: {\n        timeAvailable: data.subscreenAvailable,\n        timeResponse: new Date()\n      },\n      referrer: {\n        id: assetId,\n        type: 'asset',\n        assetType: data.assetType\n      },\n      parent: 'asset/' + assetId,\n      topicGrouping: true\n    });\n  }\n};\n\nO_EXTENDER.extend(ASSET_INTERACTIONS, COMICSTRIP_ASSET_INTERACTIONS);\n\n/**\n * Pre-processor extension to manage data from raw XML into something a little\n * easier to manipulate later on.\n */\nvar COMICSTRIP_ASSET_PREPROCESSOR = {\n  strObjID: 'The Comicstrip asset pre-extension object',\n\n  _preProcess_comicstrip_Asset: function(\n    _objWhatRawAssetData,\n    _objWhatParentScreenObject\n  ) {\n    var _rows = [];\n    var _rowWidths = [];\n    var _rowHeight = [];\n    for (var i = 0; i < _objWhatRawAssetData.arrCells.length; i++) {\n      var _cell = _objWhatRawAssetData.arrCells[i];\n      // grab the image data\n      var _objCellImageMetaData = MASTER_RENDERER.getImageProperties(\n        decodeURIComponent(_cell.objImageSrc.strSrc)\n      );\n      // figure out which row (index to 0)\n      var _row = _cell.strRow - 1;\n      // add some arrays if first time we have seen this row\n      if (!_rows[_row]) {\n        _rows[_row] = [];\n      }\n\n      if (!_rowWidths[_row]) {\n        _rowWidths[_row] = 0;\n      }\n\n      if (!_rowHeight[_row]) {\n        _rowHeight[_row] = 100000000;\n      }\n      // figure out the column\n      var _currentcount = _rows[_row].length;\n\n      // grab image width and height\n      var _width = 0;\n      var _height = 100000000;\n      if (_objCellImageMetaData) {\n        _width = parseInt(_objCellImageMetaData['strWidth']);\n        _height = parseInt(_objCellImageMetaData['strHeight']);\n      } else {\n        console.log(\n          'Data for the following image: ' +\n            decodeURIComponent(_cell.objImageSrc.strSrc) +\n            ' has not been found. Image src has probably been mistyped or image not uploaded.'\n        );\n      }\n\n      // add to the row totals for width/height\n      _rowWidths[_row] += _width;\n      if (_height < _rowHeight[_row]) {\n        _rowHeight[_row] = _height;\n      }\n      // add extra cell details\n      _cell['intCellNum'] = i + 1;\n      _cell['intColumnIndex'] = _currentcount + 1;\n      _cell['strWidthRatio'] = 0; // this gets set below (next loop)\n      _cell['strExpandedWidth'] = _width;\n      _cell['strHeightRatio'] = 0; // this gets set below\n      _cell['strExpandedHeight'] = 0; // this gets set below\n      // add cell to row\n      _rows[_row][_currentcount] = _cell;\n    }\n    var totalHeight = 0;\n    var smallestWidth = 10000;\n    var _col;\n    // get total height\n    for (_row = 0; _row < _rows.length; _row++) {\n      totalHeight += _rowHeight[_row];\n      if (smallestWidth > _rowWidths[_row]) {\n        smallestWidth = _rowWidths[_row];\n      }\n    }\n    // now figure out the ratios for each cell\n    for (_row = 0; _row < _rows.length; _row++) {\n      if (_rows[_row] == undefined) {\n        alert(\n          'Bad Data - Missing a comicstrip row for ' +\n            _objWhatRawAssetData['strID'] +\n            ' - please ensure comicstrip rows are contiguous'\n        );\n      }\n      for (_col = 0; _col < _rows[_row].length; _col++) {\n        _width = _rows[_row][_col]['strExpandedWidth'];\n        _rows[_row][_col]['strWidthRatio'] = (_width / _rowWidths[_row]) * 100;\n        _rows[_row][_col]['intMaxCols'] = _rows[_row].length;\n        _rows[_row][_col]['strHeightRatio'] =\n          (_rowHeight[_row] / totalHeight) * 100;\n        _rows[_row][_col]['intMaxRows'] = _rows.length;\n        _rows[_row][_col]['strExpandedHeight'] = _rowHeight[_row];\n      }\n    }\n\n    // add to raw data and return\n    _objWhatRawAssetData['rows'] = _rows;\n    _objWhatRawAssetData['intAssetWidth'] = smallestWidth;\n    return _objWhatRawAssetData;\n  }\n};\n\nO_EXTENDER.extend(TOPIC_STRUCTURE_PARSER, COMICSTRIP_ASSET_PREPROCESSOR);\n"},function(t,n,e){e(0)(e(63))},function(t,n){t.exports="/* globals _, SWIPE_CONTROL, ISCROLL_INTERFACE, CONTENT_TRACKING, SCREEN_INTERACTIONS */\n(function() {\n  // Create new Carousel\n  var Carousel = gomo.Asset.extend({\n    carousels: {},\n    carouselOptions: {\n      navigation: true,\n      navigationText: [\n        gomo.localiser.get('CAROUSEL_PREVIOUS_BUTTON'),\n        gomo.localiser.get('CAROUSEL_NEXT_BUTTON')\n      ],\n      slideSpeed: 300,\n      paginationSpeed: 400,\n      singleItem: true,\n      addClassActive: true\n    },\n    carouselStatementData: {},\n\n    /**\n     * Perform any data processing prior to button rendering.\n     */\n    processData: function() {\n      var me = this;\n      var data = me.data;\n      var rawData = data.objRawData;\n      rawData.trackingCompletionDelayed = true;\n      // Set visibility classes for each step.\n      _.each(rawData.arrStepData, function(step) {\n        step.titleVisibilityClass = '';\n        step.contentVisibilityClass = '';\n        if (!step.strTitle.length) {\n          step.titleVisibilityClass = 'hiddenElementC';\n        }\n        if (!step.strContent.length) {\n          step.contentVisibilityClass = 'hiddenElementC';\n        }\n        // Sanitise the data\n        step.objStepSrc.formattedStrAltText = me.convertStringQuote(step.objStepSrc.strAltText);\n        step.formattedStrTitle = me.formatHTML(step.strTitle);\n        step.formattedStrContent = me.formatHTML(step.strContent);\n      });\n    },\n\n    /**\n     * Perform any actions prior to topic load.\n     */\n    preloadTopic: function() {\n      var me = this;\n\n      me.hardResetCarouselAsset();\n    },\n\n    /**\n     * Update the carousel before translation.\n     */\n    translationPreprocess: function() {\n      var me = this;\n      var data = me.data;\n      var rawData = data.objRawData;\n      var pathToArray = 'arrStepData';\n      var pathToImage = 'objStepSrc';\n      var found = gomo.translationManager.findDataByAssetId(me.id);\n\n      if (found && found.arrStepData.length) {\n        _.each(found.arrStepData, function(step, i) {\n          step.formattedStrTitle = me.formatHTML(rawData.arrStepData[i].strTitle);\n          step.formattedStrContent = me.formatHTML(rawData.arrStepData[i].strContent);\n        });\n      }\n      gomo.translationManager.setArrayOfImages(me.id, pathToArray, pathToImage);\n\n      me.carouselOptions.navigationText = [\n        gomo.localiser.get('CAROUSEL_PREVIOUS_BUTTON'),\n        gomo.localiser.get('CAROUSEL_NEXT_BUTTON')\n      ];\n    },\n\n    /**\n     * Update the carousel after translation.\n     */\n    translationPostprocess: function() {\n      var me = this;\n      if (me.$el) {\n        me.$el.find('.owl-prev').html(gomo.localiser.get('CAROUSEL_PREVIOUS_BUTTON'));\n        me.$el.find('.owl-next').html(gomo.localiser.get('CAROUSEL_NEXT_BUTTON'));\n      }\n    },\n\n    /**\n     * Setup the carousel and tracking before it is shown.\n     */\n    beforeShown: function() {\n      var me = this;\n      var data = me.data;\n      var rawData = data.objRawData;\n      var stepsData = rawData.arrStepData;\n      var domCarousel = me.$el.find('.carouselAssetWrapperC');\n\n      me.carouselOptions.navigationText = [\n        gomo.localiser.get('CAROUSEL_PREVIOUS_BUTTON'),\n        gomo.localiser.get('CAROUSEL_NEXT_BUTTON')\n      ];\n\n      me.carouselOptions.afterMove = function() {\n        me.carouselMoved();\n      };\n\n      domCarousel.owlCarousel(me.carouselOptions);\n      me.carousels[rawData.strID] = domCarousel.data('owlCarousel');\n\n      if (typeof SWIPE_CONTROL != 'undefined') {\n        SWIPE_CONTROL.disableSwipingOnElementClassname('carouselStepImageAssetC');\n      }\n      me.carouselStatementData[data.strObjID] = {\n        slideAvailable: new Date(),\n        slideIndex: 0\n      };\n\n      me.sendCarouselSlideTrackingDataIn(stepsData[0], rawData.strID, rawData.strType);\n    },\n\n    /**\n     * Perform any actions after carousel render.\n     */\n    afterRenderShown: function() {\n      ISCROLL_INTERFACE.refreshIScrolls();\n    },\n\n    /**\n     * Perform any actions after carousel is hidden.\n     */\n    afterRenderHidden: function() {\n      var me = this;\n      var data = me.data;\n      var rawData = data.objRawData;\n      var stepsData = rawData.arrStepData;\n      var currentIndex = me.carouselStatementData[data.strObjID].slideIndex;\n\n      me.sendCarouselSlideTrackingDataOut(\n        stepsData[currentIndex],\n        rawData.strID,\n        rawData.strType\n      );\n    },\n\n    /**\n     * Perform actions when carousel step is changed.\n     */\n    carouselMoved: function() {\n      var me = this;\n      var data = me.data;\n      var rawData = data.objRawData;\n      var stepsData = rawData.arrStepData;\n      var domCarousel = me.$el.find('.owl-item');\n      var lastArrayPosition = domCarousel.length - 1;\n      var currentIndex = me.carouselStatementData[data.strObjID].slideIndex;\n      var newIndex = me.carouselStatementData[data.strObjID].slideIndex;\n\n      if (domCarousel[lastArrayPosition].className.indexOf('active') >= 0) {\n        me.carousels[data.strObjID].booComplete = true;\n      }\n\n      var domCurrScreenLayer = SCREEN_INTERACTIONS.getShownScreenElement();\n      if (domCurrScreenLayer) {\n        gomo.eventManager.legacy('screenAssetInteracting', data);\n      }\n      me.sendCarouselSlideTrackingDataOut(stepsData[currentIndex], rawData.strID, rawData.strType);\n      me.carouselStatementData[data.strObjID].slideIndex = me.$el.find('.owl-item.active').index();\n      me.carouselStatementData[data.strObjID].slideAvailable = new Date();\n      me.sendCarouselSlideTrackingDataIn(stepsData[newIndex], rawData.strID, rawData.strType);\n    },\n\n    /**\n     * Reset carousel asset.\n     */\n    reset: function() {\n      var me = this;\n      var data = me.data;\n\n      if (me.carousels[data.strObjID]) {\n        me.carousels[data.strObjID].booComplete = false;\n        var domCarousel = me.$el.find('.carouselAssetWrapperC');\n        domCarousel.trigger('owl.jumpTo', 0);\n      }\n    },\n\n    /**\n     * Hard reset carsouel asset.\n     */\n    hardResetCarouselAsset: function() {\n      var me = this;\n\n      me.carousels = {};\n    },\n\n    /**\n     * Is the carousel a completable asset.\n     * @return {boolean}\n     */\n    isCompletable: function() {\n      return true;\n    },\n\n    /**\n     * Is the carousel asset complete.\n     * @return {boolean}\n     */\n    isComplete: function() {\n      var me = this;\n      var data = me.data;\n      var rawData = data.objRawData;\n      var completed = false;\n\n      if (me.carousels && me.carousels[rawData.strID]) {\n        completed = me.carousels[rawData.strID].booComplete ? true : false;\n      }\n      return completed;\n    },\n\n    /**\n     * Returns all accesible parts of the accordion asset for the tab manager to apply tab indexes.\n     * @return {array}\n     */\n    getAccessibleElements: function() {\n      // Not tabbable without major modification.\n      var accessibleElements = [];\n      return accessibleElements;\n    },\n\n    /**\n     * Send tracking data when a carousel step is opened.\n     * @param {object} data\n     * @param {string} assetId\n     * @param {string} assetType\n     */\n    sendCarouselSlideTrackingDataIn: function(data, assetId, assetType) {\n      CONTENT_TRACKING.interaction({\n        type: 'experienced',\n        activity: {\n          id: data.strID,\n          type: 'subscreen',\n          title: data.strTitle,\n          description: data.strContent\n        },\n        referrer: {\n          id: assetId,\n          type: 'asset',\n          assetType: assetType\n        },\n        parent: 'asset/' + assetId,\n        topicGrouping: true\n      });\n    },\n\n    /**\n     * Send tracking data when a carousel step is closed.\n     * @param {object} data\n     * @param {string} assetId\n     * @param {string} assetType\n     */\n    sendCarouselSlideTrackingDataOut: function(data, assetId, assetType) {\n      var me = this;\n      var slideAvailable = me.carouselStatementData[assetId].slideAvailable;\n\n      CONTENT_TRACKING.interaction({\n        type: 'left',\n        activity: {\n          id: data.strID,\n          type: 'subscreen',\n          title: data.strTitle,\n          description: data.strContent\n        },\n        response: {\n          timeAvailable: slideAvailable,\n          timeResponse: new Date()\n        },\n        referrer: {\n          id: assetId,\n          type: 'asset',\n          assetType: assetType\n        },\n        parent: 'asset/' + assetId,\n        topicGrouping: true\n      });\n    }\n  });\n\n  // Register the asset.\n  gomo.assetManager.register('carousel', Carousel);\n})();\n"},function(t,n,e){e(0)(e(65))},function(t,n){t.exports="/* globals ASSET_RENDERER, TOPIC_MANAGER, CORE, LOCALISER,\nO_EXTENDER, ASSET_INTERACTIONS, EM, _, $ */\n\n/**\n * @title Button asset extension\n * @description Button asset for the Player which passes on processes to the Actions Asset\n *\n * @author JC\n * @version 0.1 05/02/14\n */\n\nvar objCurrSupportData = {\n  graphicalC: true,\n  accessibleC: true,\n  tabletC: true,\n  smartphoneC: true\n};\n\nASSET_RENDERER.addAssetSupportData('menubutton', objCurrSupportData);\n\nvar MENUBUTTON_ASSET_RENDERER = {\n  // ***************************** Property extensions *****************************\n  strObjID: 'The menu button asset renderer extension object',\n  _arrAssetHTMLTemplateIDs: [\n    ['menubutton', 'menuButtonWrapperC'],\n    ['menubuttonLabel', 'menuButtonLabelWrapperC'],\n    ['menubuttonProgress', 'menuButtonProgressWrapperC'],\n    ['menubuttonImage', 'menuButtonImageWrapperC'],\n    ['menubuttonTime', 'menuButtonTimeWrapperC'],\n    ['menubuttonRecommendationIcon', 'menuButtonRecommendationIconWrapperC']\n  ],\n\n  trackingStates: [\n    'TOPIC_PROGRESS_NOT_STARTED',\n    'TOPIC_PROGRESS_INCOMPLETE',\n    'TOPIC_PROGRESS_COMPLETE'\n  ],\n\n  // ***************************** Render methods extensions *****************************\n  _render_menubutton_Asset: function(_objRenderData) {\n    var _objWhatAssetCourseObject = _objRenderData.objWhatAssetCourseObject;\n    var _booPreviewMode = _objRenderData.booPreviewMode;\n\n    var _objWhatRawAssetData = _objWhatAssetCourseObject.objRawData;\n\n    var _intCurrentTopicCompletion = 0;\n    var recommendedTopic = false;\n\n    if (_objWhatRawAssetData.arrActions.length >= 1) {\n      var count = 0;\n      var _booFoundNavigationAction = false;\n      while (count < _objWhatRawAssetData.arrActions.length) {\n        var _objCurrAction = _objWhatRawAssetData.arrActions[count];\n        if (_objCurrAction.strType == 'internal_link') {\n          _booFoundNavigationAction = true;\n          break;\n        }\n        count++;\n      }\n\n      if (\n        _booFoundNavigationAction &&\n        _objCurrAction.objParameters &&\n        _objCurrAction.objParameters.target_id\n      ) {\n        var _strTopicId = TOPIC_MANAGER.getTopicId(_objCurrAction.objParameters.target_id);\n        var _objCurrTopic = CORE.getCourseItemById(_strTopicId);\n        recommendedTopic = _.isBoolean(_objCurrTopic.recommend) && _objCurrTopic.recommend;\n\n        if (_objCurrTopic.intTrackingState) {\n          _intCurrentTopicCompletion = _objCurrTopic.intTrackingState;\n        } else {\n          // Otherwise it's a topic ID that doesn't exist; show it not started.\n          _intCurrentTopicCompletion = 0;\n        }\n      }\n    }\n    var _strTemplate = _objWhatRawAssetData.strType;\n    var _htmlButtonContentTemplate = this._sortMenuButtonContentOrder(_objWhatRawAssetData, {\n      recommendedTopic: recommendedTopic\n    });\n\n    if (this._objAssetTemplates[_strTemplate]) {\n      var _htmReturnData = this._objAssetTemplates[_strTemplate];\n      if (_booPreviewMode) {\n        _htmReturnData = _htmReturnData.replace(\n          'XX_ASSET_ID_XX',\n          'YY' + _objWhatRawAssetData.strID + 'YYPreview'\n        );\n      } else {\n        _htmReturnData = _htmReturnData.replace(\n          'XX_ASSET_ID_XX',\n          'YY' + _objWhatRawAssetData.strID + 'YY'\n        );\n      }\n\n      _htmReturnData = _htmReturnData.replace('XX_ASSET_ID_XX', _objWhatRawAssetData.strID);\n      _htmReturnData = _htmReturnData.replace(\n        'XX_BUTTON_RENDER_TYPE_XX',\n        this._get_menubutton_class(_objWhatRawAssetData.strButtonType)\n      );\n      _htmReturnData = _htmReturnData.replace(\n        'XX_BUTTON_RECOMMENDATION_XX',\n        recommendedTopic ? 'recommended' : ''\n      );\n      _htmReturnData = _htmReturnData.replace(\n        'XX_MENU_BUTTON_CONTENT_XX',\n        _htmlButtonContentTemplate\n      );\n      if (_objWhatRawAssetData.strIconImageFilename) {\n        _htmReturnData = _htmReturnData.replace(\n          'XX_IMAGESRC_XX',\n          _objWhatRawAssetData.strIconImageFilename\n        );\n      } else {\n        _htmReturnData = _htmReturnData.replace(\n          'XX_TEXTCONTENT_XX',\n          this.insertFormattedHtml(_objWhatRawAssetData.strLabel)\n        );\n      }\n      _htmReturnData = _htmReturnData.replace(\n        'XX_ITEM_TIME_XX',\n        _objWhatRawAssetData.strTargetTime\n      );\n      // Add alignment classname\n      _htmReturnData = _htmReturnData.replace(\n        'XX_ALIGNMENT_CLASS_XX',\n        _objWhatRawAssetData.strAlignment || ''\n      );\n\n      if (_objWhatRawAssetData.arrActions && _objWhatRawAssetData.arrActions.length) {\n        _htmReturnData = _htmReturnData.replace(\n          ' XX_DISABLED_XX',\n          ASSET_INTERACTIONS.checkEnabledState(_objWhatRawAssetData) ? '' : ' disableInteractions'\n        );\n      } else {\n        _htmReturnData = _htmReturnData.replace(' XX_DISABLED_XX', '');\n      }\n\n      _htmReturnData = _htmReturnData.replace(/XX_PROGRESS_XX/g, _intCurrentTopicCompletion);\n      _htmReturnData = _htmReturnData.replace(\n        /XX_ACCESSIBILITY_PROGRESS_XX/g,\n        LOCALISER.get(this.trackingStates[_intCurrentTopicCompletion])\n      );\n\n      return _htmReturnData;\n    } else {\n      this.debug('No Template found in Button Asset for ' + _strTemplate);\n    }\n  },\n  // ***************************** Helper methods extensions *****************************\n  _get_menubutton_class: function(strButtonType) {\n    var strClass;\n\n    // REFACTOR: This is all hardcoded for now but needs to have class\n    // names generated by the manifest in 2.0/2.1.\n    switch (strButtonType) {\n      case 'dropdownValue1':\n        strClass = 'btn btn-default btn-lg btn-warning';\n        break;\n      case 'dropdownValue2':\n        strClass = 'btn btn-default';\n        break;\n      case 'dropdownValue3':\n        strClass = 'btn btn-default btn-sm btn-danger';\n        break;\n      case 'dropdownValue4':\n        strClass = 'btn btn-default btn-xs';\n        break;\n      default:\n        strClass = 'btn btn-default';\n        break;\n    }\n\n    return strClass;\n  },\n\n  _sortMenuButtonContentOrder: function(_objWhatRawAssetData, options) {\n    var _htmlMenuButtonContent = '';\n\n    var _htmlLabelTemplate = '';\n    var _htmlTimeTemplate = '';\n    var _htmlImageTemplate = '';\n    var _htmlProgressTemplate = '';\n\n    _htmlLabelTemplate = this._objAssetTemplates['menubuttonLabel'];\n    _htmlProgressTemplate = this._objAssetTemplates['menubuttonProgress'];\n\n    if (_objWhatRawAssetData.strTargetTime) {\n      _htmlTimeTemplate = this._objAssetTemplates['menubuttonTime'];\n    }\n    if (_objWhatRawAssetData.strIconImageFilename) {\n      _htmlImageTemplate = this._objAssetTemplates['menubuttonImage'];\n    }\n\n    // TODO : When the data handles the order it can be sorted here.\n    _htmlMenuButtonContent =\n      _htmlLabelTemplate + _htmlTimeTemplate + _htmlImageTemplate + _htmlProgressTemplate;\n\n    if (options && options.recommendedTopic) {\n      _htmlMenuButtonContent += this._objAssetTemplates['menubuttonRecommendationIcon'];\n    }\n\n    return _htmlMenuButtonContent;\n  }\n};\n\nO_EXTENDER.extend(ASSET_RENDERER, MENUBUTTON_ASSET_RENDERER);\n\nvar MENUBUTTON_ASSET_INTERACTIONS = {\n  strObjID: 'Menu button asset interactions',\n  strMenuButtonDomPrefix: 'menuButtonAsset_',\n  strMenuButtonDomSuffix: '_WrapperL',\n\n  handleEvent_menuButtonAction: function(_objButtonData) {\n    var _objWhatAssetData = ASSET_INTERACTIONS.getAssetData(_objButtonData.strAssetID);\n    _objWhatAssetData.objRawData.booClicked = true;\n\n    var _objActionOptions = {};\n    _objActionOptions.objActions = _objWhatAssetData.objRawData.arrActions;\n    _objActionOptions.objOptionalExtraData = _objWhatAssetData;\n    _objActionOptions.objOptionalExtraData.strAssetID = _objButtonData.strAssetID;\n\n    // Example feed back for completion of subscreen display.\n    // _objActionOptions.objOptionalExtraData.funTriggerCallBack = function(){alert('Screen\n    // displayed for Action ' + _objButtonData.strAssetID)};\n\n    EM.trigger('screenAssetInteracting', _objWhatAssetData);\n    EM.trigger('processActions', _objActionOptions);\n  },\n\n  is_menubutton_AssetCompletable: function(_objWhatAssetData) {\n    return false;\n  },\n\n  _returnFocusToMENUBUTTONAsset: function(_domWhatAssetElement, _objAssetData) {\n    var _strAssetID = _objAssetData['strObjID'];\n    var _domButtonWrapperL = this._objWhatDOM.getElementById(\n      this.strMenuButtonDomPrefix + 'YY' + _strAssetID + 'YY' + this.strMenuButtonDomSuffix\n    );\n    var _domButton = CORE.getElementsByClassName(_domButtonWrapperL, 'buttonC')[0];\n    _domButton.focus();\n  },\n\n  _checkCompletion_menubutton_Asset: function(_objWhatAssetDataWrapper) {\n    if (_objWhatAssetDataWrapper.objRawData.booClicked) {\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  _performLanguagePreprocess_menubutton_Asset: function(_objWhatAssetData) {\n    var found =\n      gomo.translationManager.findDataByAssetId(_objWhatAssetData.objRawData.strID);\n    if (found) {\n      this.updateMenuButtonAlignment(found);\n    }\n  },\n\n  _topicStatusChanged_menubutton_Asset: function(_objWhatAssetData) {\n    if (_objWhatAssetData.objRawData\n      && _objWhatAssetData.objRawData.arrActions) {\n      var navigationAction = _.find(\n        _objWhatAssetData.objRawData.arrActions,\n        {strType: 'internal_link'}\n      );\n      if (typeof(navigationAction) !== 'undefined'\n      && navigationAction.objParameters\n      && navigationAction.objParameters.target_id) {\n        var topicId = TOPIC_MANAGER.getTopicId(navigationAction.objParameters.target_id);\n        var currTopic = CORE.getCourseItemById(topicId);\n\n        if (currTopic && currTopic.intTrackingState) {\n          $('#menubuttonAsset_YY'+_objWhatAssetData.strObjID+'YY_WrapperL').find('.menuProgressC')\n            .removeClass('trackingState0C trackingState1C trackingState2C')\n            .addClass('trackingState' + currTopic.intTrackingState + 'C');\n        }\n      }\n    }\n  },\n\n  updateMenuButtonAlignment: function(data) {\n    var menuButtonElement = $('#menubuttonAsset_YY' + data.id + 'YY_WrapperL');\n    if (menuButtonElement.length && typeof data.strAlignment !== 'undefined') {\n      menuButtonElement[0].className =\n        menuButtonElement[0].className.replace(/\\b[A-Za-z]*-alignC\\b/, '');\n      menuButtonElement.addClass(data.strAlignment);\n    }\n  },\n\n  getAccessibleElements_menubutton: function() {\n    var accessibleElements = ['.menuButtonC'];\n    return accessibleElements;\n  },\n\n  _switchState_menubutton_Asset: function(assetData, enabled) {\n    var buttonWrapperID = '#' + assetData.strType +\n    'Asset_YY' + assetData.strID + 'YY' + this.strMenuDomSuffix;\n    $(buttonWrapperID).find('.buttonC').toggleClass('disableInteractions', !enabled);\n  }\n};\nO_EXTENDER.extend(ASSET_INTERACTIONS, MENUBUTTON_ASSET_INTERACTIONS);\n"},function(t,n,e){e(0)(e(67))},function(t,n){t.exports="/* global $, _, CORE, EM, ASSET_RENDERER, O_EXTENDER, TOPIC_INTERACTIONS */\n/* global ASSET_INTERACTIONS, LOCALISER */\n/* global BOO_SINGLE_ATTEMPT_IN_ASSESSMENT, BOO_HIDE_NEXT_UNTIL_CONFIRM */\n/* global BOO_PROGRESS_ON_CONFIRM_CLICK, OUTPUT_MODE_CHECKER */\n\n/**\n * @title MCQ asset extension collection\n * @description A series of objects designed to extend the ASSET_INSPECTOR and ASSET_RENDERER\n * object literals via the O_EXTENDER object to be able to process the mcq asset\n * type.\n *\n * @author Johnathan Castle\n * @version 2.0 23/09/10\n */\n\nvar objCurrSupportData = {\n  graphicalC: true,\n  accessibleC: true,\n  tabletC: true,\n  smartphoneC: true\n};\nASSET_RENDERER.addAssetSupportData('mcq', objCurrSupportData);\n\nvar MCQ_ASSET_RENDERER = {\n  strObjID: 'The mcq asset inspector extension object',\n\n  // ***************************** Property extensions *****************************\n  _arrAssetHTMLTemplateIDs: [['mcq', 'mcqAssetTemplateWrapperC']],\n  _arrSubAssetHTMLTemplateIDs: [['mcqoption', 'mcqAssetOptionTemplateWrapperC']],\n\n  // ***************************** Render methods extensions *****************************\n  _render_mcq_Asset: function(_objRenderData) {\n    var _objWhatAssetCourseObject = _objRenderData.objWhatAssetCourseObject;\n    var _booPreviewMode = _objRenderData.booPreviewMode;\n\n    var _objWhatRawAssetData = _objWhatAssetCourseObject.objRawData;\n    _objWhatRawAssetData.additionalTrackingData = {\n      activity: {},\n      result: {},\n      response: {}\n    };\n\n    if (this._objAssetTemplates[_objWhatRawAssetData['strType']]) {\n      var _htmReturnData = this._objAssetTemplates[_objWhatRawAssetData['strType']];\n      _htmReturnData = _htmReturnData.replace(\n        'XXIMPORTEDSTYLEXX',\n        _objWhatRawAssetData.strTextStyle + this._strImportedStyleSuffix\n      );\n\n      var _htmOptionText = this._getMCQOptionHTML(_objWhatAssetCourseObject, _objWhatRawAssetData);\n      _htmReturnData = _htmReturnData.replace('XXMCQOPTIONSXX', _htmOptionText);\n\n      if (_booPreviewMode) {\n        _htmReturnData = _htmReturnData.replace(\n          /XX_ASSET_ID_XX/g,\n          'YY' + _objWhatRawAssetData['strID'] + 'YYPreview'\n        );\n      } else {\n        _htmReturnData = _htmReturnData.replace(\n          /XX_ASSET_ID_XX/g,\n          'YY' + _objWhatRawAssetData['strID'] + 'YY'\n        );\n      }\n\n      _htmReturnData = _htmReturnData.replace(\n        'XX_QUESTION_BUTTONS_XX',\n        this._generateQuestionButtons(_objWhatRawAssetData, true)\n      );\n\n      var associatedAsset = null;\n      if (_objWhatRawAssetData.strAssociatedAssetId) {\n        // Attempt to set the associated asset data if it exists\n        associatedAsset = ASSET_INTERACTIONS.getAssetData(\n          _objWhatRawAssetData.strAssociatedAssetId\n        );\n      }\n      if (associatedAsset) {\n        _htmReturnData = _htmReturnData.replace(\n          /XX_ARIA_LABELLEDBY_XX/g,\n          ASSET_RENDERER.getAssetDOMId(associatedAsset.objRawData)\n        );\n      } else {\n        _htmReturnData = _htmReturnData.replace(/aria-labelledby\\s*=\\s*[A-Z_\"]+/g, '');\n      }\n\n      return _htmReturnData;\n    } else {\n      /* this.debug(\n        \"MCQ_ASSET_RENDERER._renderMCQAsset(),\n        ERROR: Unknown asset type of \" + _objWhatRawAssetData[\"strType\"] + \".\",\n        3\n      ); */\n      var _strDebugError = LOCALISER.get('MCQ_DEBUG_TEMPLATE_ERROR', [\n        _objWhatRawAssetData['strType']\n      ]);\n      this.debug(_strDebugError, 3);\n\n      // return \"ASSET ERROR: no template found, ID: \" + _objWhatRawAssetData[\"strID\"];\n      var _strReturnValue = LOCALISER.get('MCQ_RETURN_TEMPLATE_ERROR', [\n        _objWhatRawAssetData['strID']\n      ]);\n      return _strReturnValue;\n    }\n  },\n\n  // ***************************** Update methods extensions *****************************\n  /* _updateMCQAsset : function(_objWhatRawAssetData, _strWhatResourcePath) {\n    var _objDOMElement = this.getAssetDOMElement(_objWhatRawAssetData);\n    var _objOptionsWrapper = CORE.getElementsByClassName(_objDOMElement, \"mcqOptionsWrapperC\");\n    _objOptionsWrapper.innerHTML = this._getMCQOptionHTML(_objWhatRawAssetData);\n    // _objDOMElement.src = _strWhatResourcePath + _objWhatRawAssetData['@src'];\n    // _objDOMElement.className = _objDOMElement.className.replace(\"assetHighC\", \"assetNormC\");\n  }, */\n\n  // ***************************** Helper methods extensions *****************************\n\n  // Option:\n  /*\n    <div\n      id=\"mcqAssetXX_ASSET_ID_XXOptionXXOPTIONNUMXXWrapperL\"\n      class=\"mcqOptionC assetNormC XXOPTIONCORRECTNESSXX\"\n    >\n      XXOPTIONTEXTXX\n    </div>\n  */\n\n  _getMCQOptionHTML: function(_objWhatAssetCourseObject, _objWhatRawAssetData) {\n    if (this._objSubAssetTemplates[_objWhatRawAssetData['strType'] + 'option']) {\n      var _htmReturnData = '';\n      var count = 0;\n      while (count < _objWhatRawAssetData.arrOptions.length) {\n        var _objCurrOption = _objWhatRawAssetData.arrOptions[count];\n        var _htmOptionTemplate = this._objSubAssetTemplates[\n          _objWhatRawAssetData['strType'] + 'option'\n        ];\n        _htmOptionTemplate = _htmOptionTemplate.replace(/XXOPTIONNUMXX/g, count + 1);\n        _htmOptionTemplate = _htmOptionTemplate.replace(/XX_OPTION_XX/g, count);\n        if (_objWhatAssetCourseObject.arrOptionStates[count]) {\n          _htmOptionTemplate = _htmOptionTemplate.replace(\n            'XX_OPTION_STATE_XX',\n            this._strSelectedOptionClass\n          );\n          _htmOptionTemplate = _htmOptionTemplate.replace(\n            ' class=\"mcqOptionC XX_OPTION_STATE_XX\"',\n            ' class=\"mcqOptionC\" checked=\"true\"'\n          );\n        } else {\n          _htmOptionTemplate = _htmOptionTemplate.replace(\n            'XX_OPTION_STATE_XX',\n            this._strUnselectedOptionClass\n          );\n          _htmOptionTemplate = _htmOptionTemplate.replace(\n            ' class=\"mcqOptionC XX_OPTION_STATE_XX\"',\n            ' class=\"mcqOptionC\"'\n          );\n        }\n        _htmOptionTemplate = _htmOptionTemplate.replace(\n          'XXOPTIONTEXTXX',\n          this._showCorrectOptionMarker(_objCurrOption) +\n            this.insertFormattedHtml(_objCurrOption.strOptionText)\n        );\n        _htmReturnData += _htmOptionTemplate;\n        count++;\n      }\n      return _htmReturnData;\n    } else {\n      /* this.debug(\n        \"MCQ_ASSET_RENDERER._getMCQOptionHTML(),\n        ERROR: Unknown asset type of \" + _objWhatRawAssetData[\"strType\"] + \".\",\n        3\n      ); */\n      var _strDebugError = LOCALISER.get('MCQ_DEBUG_TEMPLATE_ERROR', [\n        _objWhatRawAssetData['strType']\n      ]);\n      this.debug(_strDebugError, 3);\n\n      // return \"Asset Error, no sub template found, ID: \" + _objWhatRawAssetData[\"strID\"];\n      var _strReturnValue = LOCALISER.get('MCQ_RETURN_TEMPLATE_ERROR', [\n        _objWhatRawAssetData['strID']\n      ]);\n      return _strReturnValue;\n    }\n  }\n};\n\nO_EXTENDER.extend(ASSET_RENDERER, MCQ_ASSET_RENDERER);\n\nvar MCQ_ASSET_INTERACTIONS = {\n  strObjID: 'The mcq asset interactions extension object',\n  _strMCQOptionClass: 'mcqOptionC',\n\n  _performPreShowActions_mcq_Asset: function(assetData) {\n    var rawData = assetData.objRawData;\n    var assetElement = ASSET_RENDERER.getAssetDOMElement(rawData);\n    rawData.additionalTrackingData.response.timeAvailable = new Date();\n\n    if (rawData.randomiseAnswers) {\n      var optionClass =\n        OUTPUT_MODE_CHECKER.strCurrentMode !== 'accessibleC'\n          ? this._strMCQOptionClass\n          : 'mcqOptionWrapperC';\n      ASSET_INTERACTIONS._randomiseOptions(rawData.strID, optionClass);\n    }\n\n    // Check for a subscreen action in options\n    var subscreenActionInOptions = _.find(rawData.arrOptions, function(option) {\n      var result = gomo.utility.checkForShowSubscreenAction(option.arrOptionFeedbackActions);\n      return result;\n    });\n\n    // Check for subscreen actions and add the appropriate aria value\n    if (subscreenActionInOptions\n      || gomo.utility.checkForShowSubscreenAction(rawData.arrFirstIncorrectActions)\n      || gomo.utility.checkForShowSubscreenAction(rawData.arrActions)) {\n      $(assetElement)\n        .find('.confirmButtonC')\n        .attr('aria-haspopup', 'dialog');\n    }\n  },\n\n  // {'strAssetID':'XX_ASSET_ID_XX', 'strOptionIndex':'XXOPTIONNUMXX'}\n  handleEvent_mcqOptionClicked: function(_objWhatOptionData) {\n    // alert(\"handleEvent_mcqOptionClicked\")\n    var _objWhatAssetData = this.getAssetData(_objWhatOptionData['strAssetID']);\n    // alert(_objWhatAssetData.booInteractable)\n    if (_objWhatAssetData.booInteractable) {\n      var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objWhatAssetData.objRawData);\n      var _arrOptionDOMElements = CORE.getElementsByClassName(\n        _domWhatAssetElement,\n        this._strMCQOptionClass\n      );\n\n      this._resetOptions(\n        _arrOptionDOMElements,\n        _domWhatAssetElement,\n        _objWhatAssetData.arrOptionStates\n      );\n\n      var optionType = (OUTPUT_MODE_CHECKER.strCurrentMode !== 'accessibleC') ? 'Wrapper' : 'Input';\n\n      var _domCurrOption = $(_arrOptionDOMElements).filter(function() {\n        return (\n          $(this).attr('id') ==\n          'mcqAsset_' +\n            _objWhatOptionData['strAssetID'] +\n            '_Option' +\n            _objWhatOptionData['strOptionIndex'] +\n            optionType + 'L'\n        );\n      });\n      if (OUTPUT_MODE_CHECKER.strCurrentMode !== 'accessibleC') {\n        $(_domCurrOption)\n          .removeClass(this._strUnselectedOptionClass)\n          .addClass(this._strSelectedOptionClass)\n          .attr('aria-checked', 'true');\n      } else {\n        $(_domCurrOption)\n          .attr('aria-checked', 'true')\n          .prop('checked', true);\n      }\n      _objWhatAssetData.arrOptionStates[_objWhatOptionData['strOptionIndex'] - 1] = true;\n    }\n  },\n\n  handleEvent_mcqConfirmButtonClicked: function(_strWhatAssetID) {\n    var _objWhatAssetData = this.getAssetData(_strWhatAssetID);\n    var _objRawData = _objWhatAssetData.objRawData;\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objRawData);\n    var _arrOptionDOMElements = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strMCQOptionClass\n    );\n    var _objOptionStates = this._getSelectedOptions(_objWhatAssetData, _arrOptionDOMElements);\n    var unlimitedAttempts = false;\n    if (_objRawData.strAttempts === '0') {\n      unlimitedAttempts = true;\n    }\n\n    var alwaysShowFinalAttemptResponse = false;\n    if (\n      typeof _objRawData.showFinalAttempt !== 'undefined' &&\n      _objRawData.showFinalAttempt == true\n    ) {\n      alwaysShowFinalAttemptResponse = true;\n    }\n\n    if (!_objWhatAssetData.booInteractable) {\n      return false;\n    }\n\n    if (_objOptionStates) {\n      _objWhatAssetData.booInteractable = false;\n      _objWhatAssetData.intUsersQuestionAttempts++;\n\n      var responseValue = '';\n      var selectedOptionText = [];\n      _.each(_objOptionStates, function(value, key) {\n        responseValue += _objRawData.arrOptions[key].strOptionText;\n        selectedOptionText.push(gomo.utility.convertNumberToCharacter(key));\n      });\n      _objWhatAssetData.responseValue = responseValue;\n      this.setVariablesToGlobal(_objWhatAssetData);\n      var _objScoreInfo = this._scoreMCQAsset(_objWhatAssetData, _objOptionStates);\n\n      var _booIsCorrect = _objScoreInfo['booIsCorrect'];\n      _objWhatAssetData.booIsCorrect = _booIsCorrect;\n\n      var correctResponses = [];\n      _.map(_objScoreInfo.objOptionData, function(response, index) {\n        if (response.booIsCorrect) {\n          correctResponses.push(gomo.utility.convertNumberToCharacter(index));\n        }\n      });\n\n      // Additional tracking data\n      var additionalTrackingData = _objRawData.additionalTrackingData;\n      additionalTrackingData.activity.type = 'choice';\n      additionalTrackingData.activity.correctResponses = [correctResponses.join(',')];\n      var associatedAsset = _objRawData.strAssociatedAssetId\n        ? ASSET_INTERACTIONS.getAssetData(_objRawData.strAssociatedAssetId)\n        : null;\n      additionalTrackingData.activity.description = ASSET_INTERACTIONS.getAssetContent(\n        associatedAsset\n      );\n      additionalTrackingData.activity.weighting = parseInt(_objRawData.strWeighting) || 1;\n      additionalTrackingData.result.detail = _objWhatAssetData.booIsCorrect\n        ? 'correct'\n        : 'incorrect';\n      additionalTrackingData.response.timeResponse = new Date();\n      additionalTrackingData.response.detail = selectedOptionText.join(',');\n      additionalTrackingData.id = _strWhatAssetID;\n      additionalTrackingData.choices = _.map(_objRawData.arrOptions, function(option, index) {\n        return {\n          'id': gomo.utility.convertNumberToCharacter(index),\n          'description': {\n            'en-GB': option.strOptionText\n          }\n        };\n      });\n\n      // Add answered question to topic\n      TOPIC_INTERACTIONS.addAnsweredQuestionAssetToTopic(\n        _objWhatAssetData,\n        _objRawData.additionalTrackingData\n      );\n\n      this._toggleMCQOptions(_arrOptionDOMElements, false);\n\n      if (!BOO_PROGRESS_ON_CONFIRM_CLICK || this._strCurrTopicModel != 'assessment') {\n        var _objOptionData = _objScoreInfo['objCurrRawOption'];\n\n        if (isNaN(parseInt(_objRawData.strAttempts))) {\n          LOCALISER.l_alert('MCQ_ATTEMPTS_VALUE_ERROR', [_objWhatAssetData.strObjID]);\n        }\n\n        if (BOO_SINGLE_ATTEMPT_IN_ASSESSMENT && this._strCurrTopicModel == 'assessment') {\n          _objRawData.strAttempts = 1;\n        }\n\n        if (\n          _objWhatAssetData.intUsersQuestionAttempts == _objRawData.strAttempts ||\n          _objWhatAssetData.booIsCorrect\n        ) {\n          this._showOptionCorrectness(_arrOptionDOMElements, _objScoreInfo);\n          this._deactivateButtons(_objWhatAssetData);\n          EM.trigger('questionMaxAttemptsReached');\n\n          _objWhatAssetData.booInteractable = false;\n        } else {\n          this._showQuestionResetButton(_objWhatAssetData);\n        }\n\n        var _arrActions;\n        var strAdditionalStyles;\n\n        if (_objWhatAssetData.booIsCorrect) {\n          _arrActions = _objOptionData.arrOptionFeedbackActions;\n          strAdditionalStyles = 'correctFeedbackSubScreenC';\n          strAdditionalStyles +=\n            ' ' +\n            ASSET_INTERACTIONS.strClassPrefixAssetPosition(_objWhatAssetData) +\n            '_CorrectFeedbackSubScreenC';\n        } else if (\n          !_objWhatAssetData.booIsCorrect &&\n          (_objWhatAssetData.intUsersQuestionAttempts < _objWhatAssetData.objRawData.strAttempts ||\n            unlimitedAttempts) &&\n          !alwaysShowFinalAttemptResponse\n        ) {\n          /*\n           * First incorrect response if...\n           * the anser is wrong\n           * And the attempt is less that allowed attempt. Or the user has unlimited attempts\n           */\n          _arrActions = _objRawData.arrFirstIncorrectActions;\n          strAdditionalStyles = 'incorrectFeedbackSubScreenC';\n          strAdditionalStyles +=\n            ' ' +\n            ASSET_INTERACTIONS.strClassPrefixAssetPosition(_objWhatAssetData) +\n            '_IncorrectFeedbackSubScreenC';\n        } else {\n          // Final incorrect response\n          _arrActions = _objOptionData.arrOptionFeedbackActions;\n          strAdditionalStyles = 'incorrectFeedbackSubScreenC';\n          strAdditionalStyles +=\n            ' ' +\n            ASSET_INTERACTIONS.strClassPrefixAssetPosition(_objWhatAssetData) +\n            '_IncorrectFeedbackSubScreenC';\n        }\n\n        EM.trigger('screenAssetInteracting', _objWhatAssetData);\n\n        var selectedButton = $(_domWhatAssetElement).find('.contentButtonNormC.visibleButtonC')[0];\n        if (_arrActions != 'null') {\n          var _objActionOptions = {};\n          _objActionOptions.objActions = _arrActions;\n          _objActionOptions.objOptionalExtraData = _objWhatAssetData;\n          _objActionOptions.objOptionalExtraData.strType = _objWhatAssetData.strAssetType;\n          _objActionOptions.objOptionalExtraData.strAdditionalStyles = strAdditionalStyles;\n          _objActionOptions.objOptionalExtraData.strAssetID = _objWhatAssetData.strObjID;\n          _objActionOptions.objOptionalExtraData.domLink = selectedButton;\n\n          EM.trigger('processActions', _objActionOptions);\n        }\n\n        if (_objRawData.arrActions && _objRawData.arrActions.length\n          && _objWhatAssetData.booComplete) {\n          ASSET_INTERACTIONS.processAssetActions(_objWhatAssetData);\n        }\n\n        if (BOO_HIDE_NEXT_UNTIL_CONFIRM) {\n          EM.trigger('showNextButtonFromAsset');\n        }\n      } else {\n        EM.trigger('goToPage', '1');\n      }\n    } else {\n      // alert(\"Please select an option before selecting confirm.\");\n      LOCALISER.l_alert('MCQ_CONFIRM_ERROR');\n    }\n  },\n\n  is_mcq_AssetCompletable: function(_objWhatAssetData) {\n    return true;\n  },\n\n  _doPostRenderShowActions_mcq_Asset: function(_objWhatAssetData) {\n    TOPIC_INTERACTIONS.removeAnsweredQuestionAssetToTopic(_objWhatAssetData);\n    TOPIC_INTERACTIONS.addViewedQuestionAssetToTopic(_objWhatAssetData);\n  },\n\n  _disableMCQOptions: function(_arrOptionElements) {\n    /* for(var _objOption in _arrOptionElements) {\n      if(_arrOptionElements[_objOption].nodeName.toLowerCase() == \"input\")\n        _arrOptionElements[_objOption].disabled = true;\n    } */\n\n    var _objOption = 0;\n\n    while (_objOption < _arrOptionElements.length) {\n      if (_arrOptionElements[_objOption].nodeName.toLowerCase() == 'input') {\n        _arrOptionElements[_objOption].disabled = true;\n      }\n\n      _objOption++;\n    }\n  },\n\n  _enableMCQOptions: function(_arrOptionElements) {\n    var _objOption = 0;\n\n    while (_objOption < _arrOptionElements.length) {\n      if (_arrOptionElements[_objOption].nodeName.toLowerCase() == 'input') {\n        _arrOptionElements[_objOption].disabled = false;\n      }\n\n      _objOption++;\n    }\n  },\n\n  _toggleMCQOptions: function(_arrOptionElements, _booEnableDisable) {\n    var _objOption = 0;\n\n    while (_objOption < _arrOptionElements.length) {\n      if (_arrOptionElements[_objOption].nodeName.toLowerCase() == 'input') {\n        _arrOptionElements[_objOption].disabled = _booEnableDisable;\n      }\n      _objOption++;\n    }\n  },\n\n  _scoreMCQAsset: function(_objWhatAssetData, _objOptionStates) {\n    var _arrOptionCorrectness = [];\n    var _intSelectedIndex;\n\n    _.each(_objOptionStates, function(value, key) {\n      _intSelectedIndex = key;\n      return false;\n    });\n\n    var _arrRawOptionData = _objWhatAssetData.objRawData.arrOptions;\n    var _objCurrRawOption = _arrRawOptionData[_intSelectedIndex];\n    var _objSelectedStates = [];\n    _objSelectedStates[_intSelectedIndex] = true;\n    if (_objCurrRawOption.booIsCorrect) {\n      _arrOptionCorrectness[_intSelectedIndex] = true;\n      return {\n        booIsCorrect: true,\n        objCurrRawOption: _objCurrRawOption,\n        objOptionData: _arrRawOptionData,\n        arrOptionCorrectness: _arrOptionCorrectness,\n        objSelectedStates: _objSelectedStates\n      };\n    }\n    return {\n      booIsCorrect: false,\n      objCurrRawOption: _objCurrRawOption,\n      objOptionData: _arrRawOptionData,\n      arrOptionCorrectness: _arrOptionCorrectness,\n      objSelectedStates: _objSelectedStates\n    };\n  },\n\n  _returnFocusToMCQAsset: function(_domWhatAssetElement) {\n    this._focusConfirmButton(_domWhatAssetElement);\n  },\n\n  getAccessibleElements_mcq: function() {\n    var accessibleElements = ['.mcqOptionC', '.activeButtonC'];\n    return accessibleElements;\n  }\n};\nO_EXTENDER.extend(ASSET_INTERACTIONS, MCQ_ASSET_INTERACTIONS);\n"},function(t,n,e){e(0)(e(69))},function(t,n){t.exports="/* globals EM, BOO_SINGLE_ATTEMPT_IN_ASSESSMENT, BOO_HIDE_NEXT_UNTIL_CONFIRM,\nglobal, CONTENT_TRACKING, _, $*/\n(function() {\n  // Create new Likert\n  var Likert = gomo.QuestionAsset.extend({\n    confirmButtonClass: 'confirmButtonC',\n    resetButtonClass: 'resetButtonC',\n\n    processData: function(data) {\n      var me = this;\n      var rawData = me.data.objRawData;\n      var count = 0;\n\n      me.data.attempts = 0;\n      me.data.selectedOptions = [];\n      me.data.isComplete = false;\n      rawData.assetId = rawData.strID;\n      rawData.strAttempts = parseInt(rawData.strAttempts);\n\n      var renderScaleItems = [];\n      while (count < rawData.scaleItems.length) {\n        // Make a render version of the data which we can modify safely\n        renderScaleItems[count] = {\n          strID: rawData.scaleItems[count].strID,\n          strName: rawData.scaleItems[count].strName,\n          strOptionText: rawData.scaleItems[count].strOptionText,\n          objNormalSrc: {\n            strSrc: rawData.scaleItems[count].objNormalSrc.strSrc\n          }\n        };\n        var currentItem = renderScaleItems[count];\n        if (currentItem.objNormalSrc && currentItem.objNormalSrc.strSrc !== '') {\n          var strSrc = currentItem.objNormalSrc.strSrc;\n          currentItem.objNormalSrc.strSrc = gomo.utility.getSrcPath(strSrc) + strSrc;\n        }\n        count++;\n      }\n\n      count = 0;\n\n      while (count < rawData.questions.length) {\n        rawData.questions[count].strQuestion = me.formatHTML(rawData.questions[count].strQuestion);\n        rawData.questions[count].formattedScaleLabels = renderScaleItems;\n        count++;\n      }\n\n      // Additional tracking data\n      rawData.additionalTrackingData = {\n        activity: {},\n        result: {},\n        response: {}\n      };\n    },\n\n    // Before the asset is shown...\n    beforeShown: function() {\n      var me = this;\n      var rawData = me.data.objRawData;\n      var count = 0;\n      var steps = rawData.scaleItems.length;\n\n      // Additional tracking data\n      rawData.additionalTrackingData.response.timeAvailable = new Date();\n\n      // Draw likert\n      while (count < rawData.questions.length) {\n        me.initLikert(rawData.questions[count].strID, steps);\n        count++;\n      }\n\n      gomo.topicInteractions.removeAnsweredQuestionFromTopic(me.data);\n      gomo.topicInteractions.addViewedQuestionToTopic(me.data);\n\n      // Check for subscreen actions and add the appropriate aria value\n      if (gomo.utility.checkForShowSubscreenAction(rawData.arrCorrectActions)\n        || gomo.utility.checkForShowSubscreenAction(rawData.arrFinalIncorrectActions)\n        || gomo.utility.checkForShowSubscreenAction(rawData.arrFirstIncorrectActions)\n        || gomo.utility.checkForShowSubscreenAction(rawData.arrActions)) {\n        me.$el\n          .find('.' + me.confirmButtonClass)\n          .attr('aria-haspopup', 'dialog');\n      }\n    },\n\n    registerEvents: function() {\n      var me = this;\n\n      me.events = {\n        'click .confirmButtonC': 'confirmButton',\n        'click .resetButtonC': 'resetButton',\n        'slidestop .likert': 'stopSliding',\n        'slidestart .likert': 'startSliding'\n      };\n    },\n\n    translationPreprocess: function() {\n      var me = this;\n      var rawData = me.data.objRawData;\n      var count = 0;\n      var found = gomo.translationManager.findDataByAssetId(me.id);\n\n      if (found && found.questions && rawData.questions) {\n        while (count < rawData.questions.length) {\n          var foundQuestion = found.questions[count];\n          var rawQuestion = rawData.questions[count];\n          if (typeof foundQuestion === 'undefined' || typeof rawQuestion === 'undefined') {\n            break;\n          }\n          found.questions[count].strQuestion = me.formatHTML(rawData.questions[count].strQuestion);\n          count++;\n        }\n        found.formattedScaleLabels = rawData.scaleItems;\n        gomo.translationManager.setArrayOfImages(rawData.strID, 'scaleItems', 'objNormalSrc');\n      }\n      // Change the slider into RTL if needed.\n      me.setSliderDirection();\n    },\n\n    initLikert: function(id, steps) {\n      var me = this;\n      var likertTarget = me.$('#likert_' + id);\n      var isRtl = false;\n      steps -= 1;\n\n      // If the current language is a RTL language initialise the likert in rtl mode\n      if (gomo.translationManager.getCurrentLangCodeAndTitle().is_rtl === 1) {\n        isRtl = true;\n      }\n\n      // Initialise the likert slider\n      likertTarget.slider({\n        animate: 'fast',\n        step: 1,\n        max: steps,\n        value: 0,\n        isRTL: isRtl\n      });\n\n      // Size the labels\n      var likertLabelWrapper = me.$('.likert-labels[data-likert-id=\\'likert_' + id + '\\']');\n      var likertLabels = likertLabelWrapper.find('.likert-label');\n      var labelWidth = 100 / likertLabels.length;\n      _.each(likertLabels, function(label) {\n        $(label).css('width', labelWidth + '%');\n      });\n\n      // Adjust likert margins dependant on label size\n      me.$('.likert').css('margin', '0 ' + labelWidth/2 + '%');\n\n      me.updateLabel({'target': likertTarget});\n    },\n\n    startSliding: function(event) {\n      var me = this;\n      if (me.data.booInteractable) {\n        EM.trigger('disableScreenSwiping');\n      }\n    },\n\n    stopSliding: function(event) {\n      var me = this;\n      if (me.data.booInteractable) {\n        me.updateLabel(event);\n\n        setTimeout(function() {\n          EM.trigger('enableScreenSwipe');\n        }, 500);\n      }\n    },\n\n    updateLabel: function(event) {\n      var me = this;\n      // On small devices all labels are hidden apart form the current one so we need to update it\n      // when the slider changes.\n      var currStep = me.$(event.target).slider('value');\n      var likertId = me.$(event.target).attr('id');\n      var likertLabelWrapper = me.$('.likert-labels[data-likert-id=\\'' + likertId + '\\']');\n      var likertLabels = likertLabelWrapper.find('.likert-label');\n      // Show the correct label\n      me.$(likertLabels).addClass('likert-label-size-small-visibility');\n      me.$(likertLabels[currStep]).removeClass('likert-label-size-small-visibility');\n    },\n\n    confirmButton: function() {\n      var me = this;\n      var data = me.data;\n      var rawData = me.data.objRawData;\n      var optionElements = gomo.getElementsByClassName(me.el, me.optionClassName);\n\n      me.setSelectedOptions();\n\n      if (!data.booInteractable) {\n        return false;\n      }\n\n      try {\n        data.booInteractable = false;\n        data.attempts++;\n        data.responseValue = '';\n\n        me.enableSlider(false);\n\n        me.setVariablesToGlobal(me);\n        me.scoreAsset();\n\n        data.booIsCorrect = me.scoreInfo['booIsCorrect'];\n\n        // Additional tracking data for the asset as a whole\n        var additionalTrackingData = rawData.additionalTrackingData;\n        additionalTrackingData.activity.type = 'other';\n        additionalTrackingData.activity.weighting = parseInt(rawData.strWeighting) || 1;\n        var associatedAsset = gomo.assetManager.findInstance(rawData.strAssociatedAssetId);\n        additionalTrackingData.activity.description =\n          associatedAsset && associatedAsset.getContent ? associatedAsset.getContent() : null;\n        additionalTrackingData.result.detail = data.booIsCorrect ? 'correct' : 'incorrect';\n        additionalTrackingData.response.timeResponse = new Date();\n        additionalTrackingData.id = rawData.strID;\n\n        // Add answered question to topic\n        gomo.topicInteractions.addAnsweredQuestionToTopic(data, additionalTrackingData);\n\n        // Reset attemps if global override\n        if (BOO_SINGLE_ATTEMPT_IN_ASSESSMENT) {\n          data.attempts = 1;\n        }\n\n        if (data.attempts == rawData.strAttempts || data.booIsCorrect) {\n          me.showOptionCorrectness(optionElements);\n          me.deactivateButtons();\n          gomo.eventManager.legacy('questionMaxAttemptsReached');\n          data.isComplete = true;\n        } else {\n          this.showResetButton();\n        }\n\n        var actions;\n        var additionalStyles;\n        // Subscreens\n        if (data.booIsCorrect) {\n          actions = data.objRawData.arrCorrectActions;\n          additionalStyles = 'correctFeedbackSubScreenC';\n          additionalStyles += ' ' + me.classPrefixAssetPosition() + '_CorrectFeedbackSubScreenC';\n        } else if (\n          !data.booIsCorrect && data.attempts < data.objRawData.strAttempts ||\n          !data.booIsCorrect && data.objRawData.strAttempts === 0\n        ) {\n          actions = data.objRawData.arrFirstIncorrectActions;\n          additionalStyles = 'incorrectFeedbackSubScreenC';\n          additionalStyles += ' ' + me.classPrefixAssetPosition() + '_IncorrectFeedbackSubScreenC';\n        } else {\n          actions = data.objRawData.arrFinalIncorrectActions;\n          additionalStyles = 'incorrectFeedbackSubScreenC';\n          additionalStyles += ' ' + me.classPrefixAssetPosition() + '_IncorrectFeedbackSubScreenC';\n        }\n\n        gomo.eventManager.legacy('screenAssetInteracting', data);\n\n        if (actions != 'null') {\n          var actionOptions = {};\n          actionOptions.objActions = actions;\n          actionOptions.objOptionalExtraData = data;\n          actionOptions.objOptionalExtraData.strType = data.strAssetType;\n          actionOptions.objOptionalExtraData.strAdditionalStyles = additionalStyles;\n          actionOptions.objOptionalExtraData.strAssetID = data.strObjID;\n\n          gomo.eventManager.legacy('processActions', actionOptions);\n        }\n\n        if (rawData.arrActions && rawData.arrActions.length && data.isComplete) {\n          me.processAssetActions();\n        }\n\n        if (BOO_HIDE_NEXT_UNTIL_CONFIRM) {\n          gomo.eventManager.legacy('showNextButtonFromAsset');\n        }\n      } catch (err) {\n        if (global.LogManager) {\n          global.LogManager.add('ERROR', err);\n        }\n        return;\n      }\n    },\n\n    resetButton: function() {\n      var me = this;\n\n      me.resetOptions();\n      me.resetLikert();\n      me.showConfirmButton();\n      me.data.booInteractable = true;\n    },\n\n    scoreAsset: function() {\n      var me = this;\n      var rawData = me.data.objRawData;\n      var count = 0;\n      var isQuestionCorrect = true;\n\n      // Score each likert scale item.\n      while (count < rawData.questions.length) {\n        var selectedOption = parseInt(\n          me.$('#likert_' + rawData.questions[count].strID).slider('value')\n        ) || 0;\n        var questionData = rawData.questions[count];\n        var selectedOptionId = questionData.formattedScaleLabels[selectedOption].strID;\n        var correctOption = questionData.strCorrectItem;\n        if (selectedOptionId == correctOption) {\n          questionData.isCorrect = true;\n        } else {\n          questionData.isCorrect = false;\n        }\n\n        var selectedLabel = questionData.formattedScaleLabels[selectedOption].strOptionText ||\n          questionData.formattedScaleLabels[selectedOption].objNormalSrc.strSrc.split('.')[0];\n\n        // Format the correctResponses to include all scale items if no correct answer is selected\n        var correctAnswer = gomo.utility.decodeHtml(questionData.strCorrectItem);\n        if (questionData.strCorrectItem === 'null') {\n          correctAnswer = '';\n        }\n        // send tracking statement for each likert question\n        CONTENT_TRACKING.interaction({\n          type: 'answered',\n          id: questionData.strID,\n          activity: {\n            id: questionData.strID,\n            title: gomo.utility.decodeHtml(questionData.strQuestion),\n            type: 'likert',\n            correctResponses: [correctAnswer]\n          },\n          result: {\n            success: questionData.isCorrect,\n            response: gomo.utility.decodeHtml(selectedLabel),\n            detail: questionData.isCorrect ? 'correct' : 'incorrect'\n          },\n          response: {\n            detail: gomo.utility.decodeHtml(selectedLabel)\n          },\n          object: {\n            id: questionData.strID,\n            definition: {\n              name: {'en-GB': gomo.utility.decodeHtml(questionData.strQuestion)},\n              description: {\n                'en-GB': gomo.utility.decodeHtml(questionData.strQuestion)\n              },\n              type: 'http://adlnet.gov/expapi/activities/cmi.interaction',\n              interactionType: 'likert',\n              correctResponsesPattern: [correctAnswer],\n              scale: _.map(questionData.formattedScaleLabels, function(label) {\n                return {\n                  id: label.strID,\n                  description: {'en-GB': gomo.utility.decodeHtml(label.strOptionText) ||\n                  gomo.utility.decodeHtml(label.objNormalSrc.strSrc.split('.')[0])}\n                };\n              })\n            }\n          }\n        });\n        count++;\n      }\n\n      // Check each questions correctness. They all have to be complete for the asset to be correct.\n      count = 0;\n      while (count < rawData.questions.length) {\n        if (!rawData.questions[count].isCorrect) {\n          isQuestionCorrect = false;\n          break;\n        }\n        count++;\n      }\n\n      // create score info object for question scoring/marking to use\n      if (isQuestionCorrect) {\n        me.scoreInfo = {\n          booIsCorrect: true,\n          objCurrRawOption: [],\n          objOptionData: [],\n          arrOptionCorrectness: [],\n          objSelectedStates: []\n        };\n      } else {\n        me.scoreInfo = {\n          booIsCorrect: false,\n          objCurrRawOption: [],\n          objOptionData: [],\n          arrOptionCorrectness: [],\n          objSelectedStates: []\n        };\n      }\n    },\n\n    isCompletable: function() {\n      return true;\n    },\n\n    isComplete: function() {\n      var me = this;\n\n      return me.data.isComplete;\n    },\n\n    resetLikert: function() {\n      var me = this;\n      var rawData = me.data.objRawData;\n      var count = 0;\n\n      me.enableSlider(true);\n\n      while (count < rawData.questions.length) {\n        var questionId = rawData.questions[count].strID;\n        if (typeof me.$('#likert_' + questionId).slider('instance') != 'undefined') {\n          me.$('#likert_' + questionId).slider('value', 0);\n        }\n        count++;\n      }\n    },\n\n    reset: function() {\n      var me = this;\n\n      me.data.attempts = 0;\n      me.data.selectedOptions = [];\n      me.data.booInteractable = true;\n\n      me.resetOptions();\n      me.resetLikert();\n\n      if (me.$('.resetButtonC').length > 0) {\n        me.showConfirmButton();\n      }\n    },\n\n    enableSlider: function(enable) {\n      var me = this;\n\n      if (enable) {\n        // enable all sliders\n        _.each(me.$('.likert'), function() {\n          me.$(this).slider('enable');\n        });\n        // enable slider pointer events\n        me.$('.ui-slider-handle').css('pointer-events', 'all');\n      } else {\n        // disable all sliders\n        _.each(me.$('.likert'), function() {\n          me.$(this).slider('disable');\n        });\n        // disable slider pointer events\n        me.$('.ui-slider-handle').css('pointer-events', 'none');\n      }\n    },\n\n    setSliderDirection: function() {\n      var me = this;\n      var rawData = me.data.objRawData;\n      var isRtlLanguage = false;\n      if (gomo.translationManager.getCurrentLangCodeAndTitle().is_rtl === 1) {\n        isRtlLanguage = true;\n      }\n      // change each of the likert sliders to rtl id needed\n      if (isRtlLanguage) {\n        $(rawData.questions).each(function(i, val) {\n          me.$('#likert_' + val.strID).slider( 'option', 'isRTL', true);\n        });\n      } else {\n        $(rawData.questions).each(function(i, val) {\n          me.$('#likert_' + val.strID).slider( 'option', 'isRTL', false);\n        });\n      }\n    },\n\n    getAccessibleElements: function() {\n      var accessibleElements = ['.ui-slider-handle', '.activeButtonC'];\n      return accessibleElements;\n    }\n  });\n\n  // Register the new asset definition...\n  gomo.assetManager.register('likert', Likert);\n})();\n"},function(t,n,e){e(0)(e(71))},function(t,n){t.exports="/* global $, _, CORE, EM, ASSET_RENDERER, O_EXTENDER, TOPIC_INTERACTIONS */\n/* global ASSET_INTERACTIONS, LOCALISER, OUTPUT_MODE_CHECKER */\n/* global BOO_SINGLE_ATTEMPT_IN_ASSESSMENT, BOO_HIDE_NEXT_UNTIL_CONFIRM */\n/* global BOO_PROGRESS_ON_CONFIRM_CLICK */\n\n/**\n * @title SFL asset extension collection\n * @description A series of objects designed to extend the ASSET_INSPECTOR and ASSET_RENDERER\n * object literals via the O_EXTENDER object to be able to process the SFL asset\n * type.\n *\n * @author Johnathan Castle\n * @version 2.0 28/07/11\n */\n\nvar objCurrSupportData = {\n  graphicalC: true,\n  accessibleC: true,\n  tabletC: true,\n  smartphoneC: true\n};\nASSET_RENDERER.addAssetSupportData('sfl', objCurrSupportData);\n\nvar SFL_ASSET_RENDERER = {\n  strObjID: 'The SFL asset inspector extension object',\n\n  // ***************************** Property extensions *****************************\n  _arrAssetHTMLTemplateIDs: [['sfl', 'sflAssetTemplateWrapperC']],\n  _arrSubAssetHTMLTemplateIDs: [['sfloption', 'sflAssetOptionTemplateWrapperC']],\n\n  // ***************************** Render methods extensions *****************************\n  _render_sfl_Asset: function(_objRenderData) {\n    var _objWhatAssetCourseObject = _objRenderData.objWhatAssetCourseObject;\n    var _booPreviewMode = _objRenderData.booPreviewMode;\n\n    var _objWhatRawAssetData = _objWhatAssetCourseObject.objRawData;\n    _objWhatRawAssetData.additionalTrackingData = {\n      activity: {},\n      result: {},\n      response: {}\n    };\n\n    if (this._objAssetTemplates[_objWhatRawAssetData['strType']]) {\n      var _htmReturnData = this._objAssetTemplates[_objWhatRawAssetData['strType']];\n      _htmReturnData = _htmReturnData.replace(\n        'XXIMPORTEDSTYLEXX',\n        _objWhatRawAssetData.strTextStyle + this._strImportedStyleSuffix\n      );\n\n      var _htmOptionText = this._getSFLOptionHTML(_objWhatAssetCourseObject, _objWhatRawAssetData);\n      _htmReturnData = _htmReturnData.replace('XXSFLOPTIONSXX', _htmOptionText);\n\n      if (_booPreviewMode) {\n        _htmReturnData = _htmReturnData.replace(\n          /XX_ASSET_ID_XX/g,\n          'YY' + _objWhatRawAssetData['strID'] + 'YYPreview'\n        );\n      } else {\n        _htmReturnData = _htmReturnData.replace(\n          /XX_ASSET_ID_XX/g,\n          'YY' + _objWhatRawAssetData['strID'] + 'YY'\n        );\n      }\n\n      _htmReturnData = _htmReturnData.replace(\n        'XX_QUESTION_BUTTONS_XX',\n        this._generateQuestionButtons(_objWhatRawAssetData, true)\n      );\n\n      var associatedAsset = null;\n      if (_objWhatRawAssetData.strAssociatedAssetId) {\n        // Attempt to set the associated asset data if it exists\n        associatedAsset = ASSET_INTERACTIONS.getAssetData(\n          _objWhatRawAssetData.strAssociatedAssetId\n        );\n      }\n      if (associatedAsset) {\n        _htmReturnData = _htmReturnData.replace(\n          /XX_ARIA_LABELLEDBY_XX/g,\n          ASSET_RENDERER.getAssetDOMId(associatedAsset.objRawData)\n        );\n      } else {\n        _htmReturnData = _htmReturnData.replace(/aria-labelledby\\s*=\\s*[A-Z_\"]+/g, '');\n      }\n\n      return _htmReturnData;\n    } else {\n      // this.debug(\"SFL_ASSET_RENDERER._renderSFLAsset(), ERROR: \" +\n      // \"Unknown asset type of \" + _objWhatRawAssetData[\"strType\"] + \".\", 3);\n      var _strDebugError = LOCALISER.get('SFL_DEBUG_TEMPLATE_ERROR', [\n        _objWhatRawAssetData['strType']\n      ]);\n      this.debug(_strDebugError, 3);\n\n      // return \"ASSET ERROR: no template found, ID: \" + _objWhatRawAssetData[\"strID\"];\n      var _strReturnValue = LOCALISER.get('SFL_RETURN_TEMPLATE_ERROR', [\n        _objWhatRawAssetData['strID']\n      ]);\n      return _strReturnValue;\n    }\n  },\n\n  // ***************************** Update methods extensions *****************************\n  /* _updateSFLAsset: function(_objWhatRawAssetData, _strWhatResourcePath) {\n    var _objDOMElement = this.getAssetDOMElement(_objWhatRawAssetData);\n    var _objOptionsWrapper = CORE.getElementsByClassName(_objDOMElement, 'sflOptionsWrapperC');\n    _objOptionsWrapper.innerHTML = this._getSFLOptionHTML(_objWhatRawAssetData);\n    // _objDOMElement.src = _strWhatResourcePath + _objWhatRawAssetData['@src'];\n    // _objDOMElement.className = _objDOMElement.className.replace(\"assetHighC\", \"assetNormC\");\n  }, */\n\n  // ***************************** Helper methods extensions *****************************\n\n  // Option:\n  // <div\n  //    id=\"sflAssetXX_ASSET_ID_XXOptionXXOPTIONNUMXXWrapperL\"\n  //    class=\"sflOptionC assetNormC XXOPTIONCORRECTNESSXX\">XXOPTIONTEXTXX</div>\n\n  _getSFLOptionHTML: function(_objWhatAssetCourseObject, _objWhatRawAssetData) {\n    if (this._objSubAssetTemplates[_objWhatRawAssetData['strType'] + 'option']) {\n      var _htmReturnData = '';\n      var count = 0;\n      while (count < _objWhatRawAssetData.arrOptions.length) {\n        var _objCurrOption = _objWhatRawAssetData.arrOptions[count];\n        var _htmOptionTemplate = this._objSubAssetTemplates[\n          _objWhatRawAssetData['strType'] + 'option'\n        ];\n        _htmOptionTemplate = _htmOptionTemplate.replace(/XXOPTIONNUMXX/g, count + 1);\n        _htmOptionTemplate = _htmOptionTemplate.replace(/XX_OPTION_XX/g, count);\n        if (_objWhatAssetCourseObject.arrOptionStates[count]) {\n          _htmOptionTemplate = _htmOptionTemplate.replace(\n            'XX_OPTION_STATE_XX',\n            this._strSelectedOptionClass\n          );\n        } else {\n          _htmOptionTemplate = _htmOptionTemplate.replace(\n            'XX_OPTION_STATE_XX',\n            this._strUnselectedOptionClass\n          );\n        }\n        _htmOptionTemplate = _htmOptionTemplate.replace(\n          'XXOPTIONTEXTXX',\n          this._showCorrectOptionMarker(_objCurrOption) +\n            this.insertFormattedHtml(_objCurrOption.strOptionText)\n        );\n        _htmReturnData += _htmOptionTemplate;\n        count++;\n      }\n      return _htmReturnData;\n    } else {\n      // this.debug(\"SFL_ASSET_RENDERER._getSFLOptionHTML(), ERROR: Unknown \" +\n      // \"asset type of \" + _objWhatRawAssetData[\"strType\"] + \".\", 3);\n      var _strDebugError = LOCALISER.get('SFL_DEBUG_OPTION_TEMPLATE_ERROR', [\n        _objWhatRawAssetData['strType']\n      ]);\n      this.debug(_strDebugError, 3);\n\n      // return \"ASSET ERROR: no template found, ID: \" + _objWhatRawAssetData[\"strID\"];\n      var _strReturnValue = LOCALISER.get('SFL_RETURN_OPTION_TEMPLATE_ERROR', [\n        _objWhatRawAssetData['strID']\n      ]);\n      return _strReturnValue;\n    }\n  }\n};\n\nO_EXTENDER.extend(ASSET_RENDERER, SFL_ASSET_RENDERER);\n\nvar SFL_ASSET_INTERACTIONS = {\n  strObjID: 'The SFL asset interactions extension object',\n\n  _strSFLOptionClass: 'sflOptionC',\n  _strSFLConfirmAnchorClass: 'contentButtonNormC',\n  _strSFLConfirmDisableClass: 'confirmButtonDisabledC',\n\n  _performPreShowActions_sfl_Asset: function(assetData) {\n    var rawData = assetData.objRawData;\n    rawData.additionalTrackingData.response.timeAvailable = new Date();\n    var assetElement = ASSET_RENDERER.getAssetDOMElement(rawData);\n\n    if (rawData.randomiseAnswers) {\n      var optionClass =\n        OUTPUT_MODE_CHECKER.strCurrentMode !== 'accessibleC'\n          ? this._strSFLOptionClass\n          : 'sflOptionWrapperC';\n      ASSET_INTERACTIONS._randomiseOptions(rawData.strID, optionClass);\n    }\n\n    // Check for subscreen actions and add the appropriate aria value\n    if (gomo.utility.checkForShowSubscreenAction(rawData.arrCorrectActions)\n      || gomo.utility.checkForShowSubscreenAction(rawData.arrFinalIncorrectActions)\n      || gomo.utility.checkForShowSubscreenAction(rawData.arrFirstIncorrectActions)\n      || gomo.utility.checkForShowSubscreenAction(rawData.arrActions)) {\n      $(assetElement)\n        .find('.confirmButtonC')\n        .attr('aria-haspopup', 'dialog');\n    }\n  },\n\n  handleEvent_sflOptionClicked: function(_objWhatOptionData) {\n    var _objWhatAssetData = this.getAssetData(_objWhatOptionData['strAssetID']);\n    if (_objWhatAssetData.booInteractable) {\n      var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objWhatAssetData.objRawData);\n      var _arrOptionDOMElements = CORE.getElementsByClassName(\n        _domWhatAssetElement,\n        this._strSFLOptionClass\n      );\n\n      var optionType = (OUTPUT_MODE_CHECKER.strCurrentMode !== 'accessibleC') ? 'Wrapper' : 'Input';\n\n      var _domCurrOption = $(_arrOptionDOMElements).filter(function() {\n        return (\n          $(this).attr('id') ==\n          'sflAsset_' +\n            _objWhatOptionData['strAssetID'] +\n            '_Option' +\n            _objWhatOptionData['strOptionIndex'] +\n            optionType + 'L'\n        );\n      });\n\n      if (OUTPUT_MODE_CHECKER.strCurrentMode !== 'accessibleC') {\n        if ($(_domCurrOption).hasClass(this._strUnselectedOptionClass)) {\n          // mark as checked\n          $(_domCurrOption)\n            .removeClass(this._strUnselectedOptionClass)\n            .addClass(this._strSelectedOptionClass)\n            .attr('aria-checked', 'true');\n\n          _objWhatAssetData.arrOptionStates[_objWhatOptionData['strOptionIndex'] - 1] = true;\n        } else {\n          // mark as unchecked\n          $(_domCurrOption)\n            .removeClass(this._strSelectedOptionClass)\n            .addClass(this._strUnselectedOptionClass)\n            .attr('aria-checked', 'false');\n\n          _objWhatAssetData.arrOptionStates[_objWhatOptionData['strOptionIndex'] - 1] = false;\n        }\n      } else {\n        $(_domCurrOption).attr('aria-checked', function(index, attr) {\n          _objWhatAssetData.arrOptionStates[_objWhatOptionData['strOptionIndex'] - 1]\n            = (attr === 'false');\n          return attr === 'false' ? 'true' : 'false';\n        });\n      }\n    }\n  },\n\n  handleEvent_sflConfirmButtonClicked: function(_strWhatAssetID) {\n    var _objWhatAssetData = this.getAssetData(_strWhatAssetID);\n    var rawData = _objWhatAssetData.objRawData;\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(rawData);\n    var _arrOptionDOMElements = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strSFLOptionClass\n    );\n    var _objOptionStates = this._getSelectedOptions(_objWhatAssetData, _arrOptionDOMElements);\n    var unlimitedAttempts = false;\n    if (rawData.strAttempts === '0') {\n      unlimitedAttempts = true;\n    }\n\n    if (!_objWhatAssetData.booInteractable) {\n      return false;\n    }\n\n    if (_objOptionStates) {\n      _objWhatAssetData.booInteractable = false;\n      _objWhatAssetData.intUsersQuestionAttempts++;\n\n      var responseValue = [];\n      var selectedOptionText = [];\n      _.each(_objOptionStates, function(value, key) {\n        responseValue.push(rawData.arrOptions[key].strOptionText);\n        selectedOptionText.push(gomo.utility.convertNumberToCharacter(key));\n      });\n      _objWhatAssetData.responseValue = responseValue.join(', ');\n      this.setVariablesToGlobal(_objWhatAssetData);\n\n      var _objScoreInfo = this._scoreSFLAsset(_objWhatAssetData, _objOptionStates);\n\n      var _booIsCorrect = _objScoreInfo['booIsCorrect'];\n      _objWhatAssetData.booIsCorrect = _booIsCorrect;\n\n      var correctResponses = [];\n      _.map(_objScoreInfo.objOptionData, function(response, index) {\n        if (response.booIsCorrect) {\n          correctResponses.push(gomo.utility.convertNumberToCharacter(index));\n        }\n      });\n\n      // Additional tracking data\n      var additionalTrackingData = rawData.additionalTrackingData;\n      additionalTrackingData.activity.type = 'choice';\n      additionalTrackingData.activity.correctResponses = [correctResponses.join(',')];\n      var associatedAsset = rawData.strAssociatedAssetId\n        ? ASSET_INTERACTIONS.getAssetData(rawData.strAssociatedAssetId)\n        : null;\n      additionalTrackingData.activity.description = ASSET_INTERACTIONS.getAssetContent(\n        associatedAsset\n      );\n      additionalTrackingData.activity.weighting = parseInt(rawData.strWeighting) || 1;\n      additionalTrackingData.result.detail = _objWhatAssetData.booIsCorrect\n        ? 'correct'\n        : 'incorrect';\n      additionalTrackingData.response.timeResponse = new Date();\n      additionalTrackingData.response.detail = selectedOptionText.join(',');\n      additionalTrackingData.id = _strWhatAssetID;\n      additionalTrackingData.choices = _.map(rawData.arrOptions, function(option, index) {\n        return {\n          'id': gomo.utility.convertNumberToCharacter(index),\n          'description': {\n            'en-GB': option.strOptionText\n          }\n        };\n      });\n\n      // Add answered question to topic\n      TOPIC_INTERACTIONS.addAnsweredQuestionAssetToTopic(\n        _objWhatAssetData,\n        rawData.additionalTrackingData\n      );\n\n      if (!BOO_PROGRESS_ON_CONFIRM_CLICK || this._strCurrTopicModel != 'assessment') {\n        if (isNaN(parseInt(rawData.strAttempts))) {\n          // alert(\"The number of attempts for this asset (id: \" +\n          // _objWhatAssetData.strObjID + \") is not currently a number. It is currently: \" +\n          // rawData.strAttempts + \". Please set the number of attempts to be an integer.\");\n          LOCALISER.l_alert('SFL_ATTEMPTS_VALUE_ERROR', [_objWhatAssetData.strObjID]);\n        }\n\n        if (BOO_SINGLE_ATTEMPT_IN_ASSESSMENT && this._strCurrTopicModel == 'assessment') {\n          rawData.strAttempts = 1;\n        }\n\n        var _arrActions;\n        var strAdditionalStyles;\n\n        if (_objWhatAssetData.booIsCorrect) {\n          _arrActions = rawData.arrCorrectActions;\n          strAdditionalStyles = 'correctFeedbackSubScreenC';\n          strAdditionalStyles +=\n            ' ' +\n            ASSET_INTERACTIONS.strClassPrefixAssetPosition(_objWhatAssetData) +\n            '_CorrectFeedbackSubScreenC';\n        } else if (\n          !_objWhatAssetData.booIsCorrect &&\n          (_objWhatAssetData.intUsersQuestionAttempts < rawData.strAttempts || unlimitedAttempts)\n        ) {\n          /*\n           * First incorrect response if...\n           * the anser is wrong\n           * And the attempt is less that allowed attempt. Or the user has unlimited attempts\n           */\n          _arrActions = rawData.arrFirstIncorrectActions;\n          strAdditionalStyles = 'incorrectFeedbackSubScreenC';\n          strAdditionalStyles +=\n            ' ' +\n            ASSET_INTERACTIONS.strClassPrefixAssetPosition(_objWhatAssetData) +\n            '_IncorrectFeedbackSubScreenC';\n        } else {\n          // Final incorrect response\n          _arrActions = rawData.arrFinalIncorrectActions;\n          strAdditionalStyles = 'incorrectFeedbackSubScreenC';\n          strAdditionalStyles +=\n            ' ' +\n            ASSET_INTERACTIONS.strClassPrefixAssetPosition(_objWhatAssetData) +\n            '_IncorrectFeedbackSubScreenC';\n        }\n\n        if (\n          _objWhatAssetData.intUsersQuestionAttempts == rawData.strAttempts ||\n          _objWhatAssetData.booIsCorrect\n        ) {\n          this._showOptionCorrectness(_arrOptionDOMElements, _objScoreInfo);\n          this._deactivateButtons(_objWhatAssetData);\n          EM.trigger('questionMaxAttemptsReached');\n        } else {\n          this._showQuestionResetButton(_objWhatAssetData);\n        }\n\n        EM.trigger('screenAssetInteracting', _objWhatAssetData);\n\n        // Get the visible button to anchor certain subscreens to\n        var selectedButton = $(_domWhatAssetElement).find(\n          '.' + this._strSFLConfirmAnchorClass + '.visibleButtonC'\n        )[0];\n        if (_arrActions != 'null') {\n          var _objActionOptions = {};\n          _objActionOptions.objActions = _arrActions;\n          _objActionOptions.objOptionalExtraData = _objWhatAssetData;\n          _objActionOptions.objOptionalExtraData.strType = _objWhatAssetData.strAssetType;\n          _objActionOptions.objOptionalExtraData.strAdditionalStyles = strAdditionalStyles;\n          _objActionOptions.objOptionalExtraData.strAssetID = _objWhatAssetData.strObjID;\n          _objActionOptions.objOptionalExtraData.domLink = selectedButton;\n\n          EM.trigger('processActions', _objActionOptions);\n        }\n\n        if (rawData.arrActions && rawData.arrActions.length && _objWhatAssetData.booComplete) {\n          ASSET_INTERACTIONS.processAssetActions(_objWhatAssetData);\n        }\n\n        if (BOO_HIDE_NEXT_UNTIL_CONFIRM) {\n          EM.trigger('showNextButtonFromAsset');\n        }\n      } else {\n        EM.trigger('goToPage', '1');\n      }\n    } else {\n      // alert(\"Please select an option before selecting confirm.\");\n      LOCALISER.l_alert('SFL_CONFIRM_ERROR');\n    }\n  },\n\n  is_sfl_AssetCompletable: function(_objWhatAssetData) {\n    return true;\n  },\n\n  _scoreSFLAsset: function(_objWhatAssetData, _objOptionStates) {\n    var _arrRawOptionData = _objWhatAssetData.objRawData.arrOptions;\n    var _arrOptionCorrectness = [];\n\n    var count = 0;\n    var _intCorrect = 0;\n    var _intWrong = 0;\n    while (count < _arrRawOptionData.length) {\n      var _objCurrRawOption = _arrRawOptionData[count];\n      if (\n        (_objCurrRawOption.booIsCorrect && _objOptionStates[count]) ||\n        (!_objCurrRawOption.booIsCorrect && !_objOptionStates[count])\n      ) {\n        _intCorrect++;\n        _arrOptionCorrectness[count] = true;\n      } else {\n        _intWrong++;\n        _arrOptionCorrectness[count] = false;\n      }\n      count++;\n    }\n\n    if (_intCorrect == 0) {\n      return {\n        booIsCorrect: false,\n        strCorrectness: 'incorrect',\n        intCorrect: _intCorrect,\n        intWrong: _intWrong,\n        objOptionData: _arrRawOptionData,\n        arrOptionCorrectness: _arrOptionCorrectness,\n        objSelectedStates: _objOptionStates\n      };\n    } else if (_intCorrect > 0 && _intWrong > 0) {\n      return {\n        booIsCorrect: false,\n        strCorrectness: 'partiallyCorrect',\n        intCorrect: _intCorrect,\n        intWrong: _intWrong,\n        objOptionData: _arrRawOptionData,\n        arrOptionCorrectness: _arrOptionCorrectness,\n        objSelectedStates: _objOptionStates\n      };\n    } else if (_intCorrect == _arrRawOptionData.length && _intWrong == 0) {\n      return {\n        booIsCorrect: true,\n        strCorrectness: 'correct',\n        intCorrect: _intCorrect,\n        intWrong: _intWrong,\n        objOptionData: _arrRawOptionData,\n        arrOptionCorrectness: _arrOptionCorrectness,\n        objSelectedStates: _objOptionStates\n      };\n    }\n    // alert(\"ERROR: Uncaught score state of _intCorrect: '\" + _intCorrect +\n    // \"', _intWrong: '\" + _intWrong + \"' in SFL_ASSET_INTERACTIONS._scoreSFLAsset(), \" +\n    // \"extension_sfl_asset.js\");\n    LOCALISER.l_alert('SFL_UNCAUGHT_SCORE_PATTERN', [_intCorrect, _intWrong]);\n    return {booIsCorrect: false};\n  },\n\n  _doPostRenderShowActions_sfl_Asset: function(_objWhatAssetData) {\n    TOPIC_INTERACTIONS.removeAnsweredQuestionAssetToTopic(_objWhatAssetData);\n    TOPIC_INTERACTIONS.addViewedQuestionAssetToTopic(_objWhatAssetData);\n  },\n\n  // REFACTOR NOTE: Function seems un-used?\n  _disableSFLOptions: function(_arrOptionElements) {\n    var count = 0;\n    while (count < _arrOptionElements.length) {\n      if (_arrOptionElements[count].tagName.toUpperCase() == 'INPUT') {\n        _arrOptionElements[count].disabled = true;\n      }\n      count++;\n    }\n  },\n\n  // REFACTOR NOTE: Function seems un-used?\n  _disableSFLConfirm: function(_arrConfirmAnchor) {\n    var count = 0;\n    while (count < _arrConfirmAnchor.length) {\n      _arrConfirmAnchor[count].className += ' ' + this._strSFLConfirmDisableClass;\n      count++;\n    }\n  },\n\n  _returnFocusToSFLAsset: function(_domWhatAssetElement) {\n    var _domConfirmButton = CORE.getElementsByClassName(\n      _domWhatAssetElement,\n      this._strConfirmButtonClass\n    )[0];\n    _domConfirmButton.className = _domConfirmButton.className.replace(\n      this._strSFLConfirmDisableClass,\n      ''\n    );\n    this._focusConfirmButton(_domWhatAssetElement);\n  },\n\n  getAccessibleElements_sfl: function() {\n    var accessibleElements = ['.sflOptionC', '.activeButtonC'];\n    return accessibleElements;\n  }\n};\nO_EXTENDER.extend(ASSET_INTERACTIONS, SFL_ASSET_INTERACTIONS);\n"},function(t,n,e){e(0)(e(73))},function(t,n){t.exports="/* global _, ASSET_RENDERER, LOCALISER, O_EXTENDER, ASSET_RENDERER, TOPIC_INTERACTIONS, CORE */\n/* global TOPIC_MANAGER, ASSET_INTERACTIONS, CONTENT_TRACKING, SCREEN_INTERACTIONS */\n/* eslint-disable max-len */\n\n/**\n * @title A blank extentsion file\n * @description This file is intended to server as a template for creating new assets.\n * Please replace the ASSESSMENT_RESULTS with the new assets type e.g. for\n * the text asset, replace ASSESSMENT_RESULTS with TEXT.\n *\n * @author Johnathan Castle\n * @version 2.0 23/09/10\n */\n\nvar objCurrSupportData = {\n  graphicalC: true,\n  accessibleC: true,\n  tabletC: true,\n  smartphoneC: true\n};\nASSET_RENDERER.addAssetSupportData('assessmentresults', objCurrSupportData);\n\nvar ASSESSMENT_RESULTS_ASSET_RENDERER = {\n  strObjID: 'The ASSESSMENT_RESULTS asset inspector extension object',\n\n  // ***************************** Property extensions *****************************\n  _arrAssetHTMLTemplateIDs: [['assessmentresults', 'assessmentResultsAssetTemplateWrapperC']],\n\n  // ***************************** Render methods extensions *****************************\n  _render_assessmentresults_Asset: function(_objRenderData) {\n    var _objWhatAssetCourseObject = _objRenderData.objWhatAssetCourseObject;\n    var _objWhatRawAssetData = _objWhatAssetCourseObject.objRawData;\n\n    if (this._objAssetTemplates[_objWhatRawAssetData['strType']]) {\n      var _htmReturnData = this._objAssetTemplates[_objWhatRawAssetData['strType']];\n      _htmReturnData = _htmReturnData.replace(\n        'XX_ASSET_ID_XX',\n        'YY' + _objWhatRawAssetData['strID'] + 'YY'\n      );\n      return _htmReturnData;\n    } else {\n      // this.debug(\"ASSET_RENDERER._renderAssessmentIntroAsset(), ERROR: Unknown asset type of \" +\n      // _objWhatRawAssetData[\"strType\"] + \".\", 3);\n      var _strDebugError = LOCALISER.get('ASSESSMENT_RESULTS_DEBUG_TYPE_ERROR', [\n        _objWhatRawAssetData['strType']\n      ]);\n      this.debug(_strDebugError, 3);\n\n      // return \"ASSET ERROR: no template found, ID: \" + _objWhatRawAssetData[\"strID\"];\n      var _strReturnValue = LOCALISER.get('ASSESSMENT_RESULTS_RETURN_TEMPLATE_ERROR', [\n        _objWhatRawAssetData['strID']\n      ]);\n      return _strReturnValue;\n    }\n  }\n};\n\n// ***************************** Helper methods extensions *****************************\n\nO_EXTENDER.extend(ASSET_RENDERER, ASSESSMENT_RESULTS_ASSET_RENDERER);\n\nvar ASSESSMENT_RESULTS_ASSET_INTERACTIONS = {\n  strObjID: 'The assessment results asset interactions extension object',\n  _strAssessmentFeedbackWrapperClass: 'assessmentFeedbackHolderC',\n\n  is_assessmentresults_AssetCompletable: function(_objWhatAssetData) {\n    return false;\n  },\n\n  _performPreShowActions_assessmentresults_Asset: function(_objWhatAssetData) {\n    this._populateResultsFeedback(_objWhatAssetData);\n  },\n\n  _performLanguagePreprocess_assessmentresults_Asset: function(_objWhatAssetData) {\n    var assetId = _objWhatAssetData.objRawData.strID;\n    var countTopic = 0;\n\n    if (gomo.translationManager.topicsData) {\n      // Check each topic\n      while (countTopic < gomo.translationManager.topicsData.length) {\n        if (\n          gomo.translationManager.topicsData[countTopic].topic &&\n          gomo.translationManager.topicsData[countTopic].topic.screens\n        ) {\n          var assets = gomo.translationManager.findAllAssets(\n            gomo.translationManager.topicsData[countTopic].topic.screens\n          );\n          var found = _.findWhere(assets, {id: assetId});\n\n          if (found && found.objGradeFeebacks) {\n            _objWhatAssetData.objRawData.objGradeFeebacks = found.objGradeFeebacks;\n          }\n\n          if (found) {\n            break;\n          }\n        }\n        countTopic++;\n      }\n    }\n\n    // If the assessment results is part of the current screen then go ahead and change the content\n    // otherwise do not because it will fire a completion tracking event.\n    if (_objWhatAssetData.objParent.strObjID == SCREEN_INTERACTIONS.strCurrentScreenId) {\n      this._populateResultsFeedback(_objWhatAssetData);\n    }\n  },\n\n  _populateResultsFeedback: function(_objWhatAssetWrapper) {\n    var _objWhatRawAssetData = _objWhatAssetWrapper.objRawData;\n    var _domAssetWrapper = ASSET_RENDERER.getAssetDOMElement(_objWhatRawAssetData);\n    var _domFeedbackWrapper = CORE.getElementsByClassName(\n      _domAssetWrapper,\n      this._strAssessmentFeedbackWrapperClass\n    )[0];\n\n    var _objScoreData = this._getAssessmentScoreData(_objWhatRawAssetData);\n    var _htmFeedbackText = '';\n    var _strFeedbackText;\n\n    if (\n      _objScoreData['intPercentage'] >= _objScoreData['intGoodPass'] &&\n      _objWhatRawAssetData['objGradeFeebacks']['strHighPassFeedback'] &&\n      ['objGradeFeebacks']['strHighPassFeedback'] !== ''\n    ) {\n      _strFeedbackText = this._insertScoreData(\n        _objWhatRawAssetData['objGradeFeebacks']['strHighPassFeedback'],\n        _objScoreData\n      );\n      _htmFeedbackText = ASSET_RENDERER.insertFormattedHtml(_strFeedbackText);\n    } else if (_objScoreData['intPercentage'] >= _objScoreData['intBasePass']) {\n      _strFeedbackText = this._insertScoreData(\n        _objWhatRawAssetData['objGradeFeebacks']['strBasePassFeedback'],\n        _objScoreData\n      );\n      _htmFeedbackText = ASSET_RENDERER.insertFormattedHtml(_strFeedbackText);\n    } else {\n      _strFeedbackText = this._insertScoreData(\n        _objWhatRawAssetData['objGradeFeebacks']['strFailedFeedback'],\n        _objScoreData\n      );\n      _htmFeedbackText = ASSET_RENDERER.insertFormattedHtml(_strFeedbackText);\n    }\n    _domFeedbackWrapper.innerHTML = _htmFeedbackText;\n  },\n\n  _getAssessmentScoreData: function(_objWhatRawAssetData) {\n    var _objAnsweredQuestionAssets = TOPIC_INTERACTIONS.getAnsweredQuestionAssets();\n    var _objScoreData = {\n      intPercentage: 0,\n      intTotal: 0,\n      intCorrect: 0,\n      intGoodPass: _objWhatRawAssetData['objScoreGrades']['intHighScoreGrade'],\n      intBasePass: _objWhatRawAssetData['objScoreGrades']['intBaseScoreGrade']\n    };\n    var keys = _.keys(_objAnsweredQuestionAssets);\n    _objScoreData['intTotal'] = _.size(keys);\n    _objScoreData['intCorrect'] = _.size(\n      _.filter(keys, function(key) {\n        return !!_objAnsweredQuestionAssets[key].booIsCorrect;\n      })\n    );\n    _objScoreData['intPercentage'] = parseInt(\n      (_objScoreData['intCorrect'] / _objScoreData['intTotal']) * 100\n    );\n\n    /**\n     * Given a \"deepest prop(erty)\" on objRawData.additionalTrackingData.response, returns a\n     * function that when invoked, will fetch that property.\n     * e.g. prop('timeAvailable')\n     * @param {string} deepestProp\n     * @return {function}\n     */\n    var prop = function(deepestProp) {\n      return _.property(['objRawData', 'additionalTrackingData', 'response', deepestProp]);\n    };\n\n    /**\n     * Given a function that returns a \"deep prop(erty)\" (which is assumed to be a date),\n     * sorts the collection of answered questions by that (date) property.\n     * e.g. sorted(prop('timeAvailable'))\n     * @param {function} deepProp\n     * @return {Date[]}\n     */\n    var sorted = function(deepProp) {\n      return []\n        .concat(\n          _.filter(\n            _.map(keys, function(key) {\n              return deepProp(_objAnsweredQuestionAssets[key]);\n            }),\n            _.isDate\n          )\n        )\n        .sort(function(a, b) {\n          return a - b;\n        });\n    };\n\n    var response = {\n      timeAvailable: _.compose(_.first, sorted, prop)('timeAvailable'),\n      timeResponse: _.compose(_.last, sorted, prop)('timeResponse')\n    };\n\n    if (isNaN(_objScoreData['intPercentage'])) {\n      _objScoreData['intPercentage'] = 0;\n    }\n\n    // Set asset interaction on all new asset instances.\n    // Or set on old instances when the old config passes.\n    if (_objWhatRawAssetData.strVersion !== '1.0'\n      || (\n        _objWhatRawAssetData.booIsTrackedAssessment ||\n        _objWhatRawAssetData.booIsCourseCompletingAssessment\n      )) {\n      //\n      // Tracked assessment status!\n      //\n      var _objCurrTopicData = TOPIC_MANAGER.getCurrentTopic();\n      CONTENT_TRACKING.interaction({\n        type: 'completed',\n        activity: {\n          id: _objCurrTopicData['strObjID'], // Use the Asset ID\n          title: _objCurrTopicData['strTitle'], // Use the topic title - it will make more sense.\n          type: 'assessment'\n        },\n        result: {\n          completion: true,\n          score: {\n            min: 0,\n            max: 100,\n            raw: _objScoreData['intPercentage']\n          }\n        },\n        response: response\n      });\n    }\n\n    // Set course score for new asset instances when config is set.\n    // Or set on old instances when the old config passes.\n    if (_objWhatRawAssetData.strVersion !== '1.0' && _objWhatRawAssetData.booSetScore\n      || (\n        _objWhatRawAssetData.strVersion == '1.0' && (\n          _objWhatRawAssetData.booIsTrackedAssessment ||\n          _objWhatRawAssetData.booIsCourseCompletingAssessment\n        )\n      )) {\n      // set course score\n      CORE.setCourseScore(_objScoreData['intPercentage']);\n    }\n\n    // Is this a 'course completing' assessment\n    if (_objWhatRawAssetData.booIsCourseCompletingAssessment) {\n      //\n      // Overall course completion status!!!\n      //\n      var _strCompletionType = _objWhatRawAssetData.strCourseCompletionPattern;\n      if (_strCompletionType != 'null') {\n        var passed =\n          _objScoreData['intPercentage'] >=\n          _objWhatRawAssetData['objScoreGrades']['intBaseScoreGrade'];\n          // Set course score if we are a scored course.\n        var courseScore =\n          _objWhatRawAssetData.strVersion !== '1.0' &&\n          _objWhatRawAssetData.booSetScore ?\n            _objScoreData['intPercentage'] :\n            false;\n        switch (_strCompletionType) {\n          case 'passed-failed':\n            CORE.setCoursePassFail(passed, courseScore, response);\n            if (passed) {\n              // Ensure tincan sends a completed status too...\n              CORE.setCourseCompleted(courseScore, 'tincan', response);\n            }\n            break;\n          case 'completed':\n            if (passed) {\n              CORE.setCourseCompleted(courseScore, null, response);\n            } else {\n              CORE.setCourseIncomplete(courseScore, null, response);\n            }\n            break;\n          default:\n            console.log(\n              'ERROR: Unknown course completion type of \"' +\n                _strCompletionType +\n                '\" found in _getAssessmentScoreData(), extension_assessment_results_asset.js'\n            );\n            break;\n        }\n      }\n    }\n\n    return _objScoreData;\n  },\n\n  _insertScoreData: function(_strWhatFeedbackText, _objScoreData) {\n    _strWhatFeedbackText = _strWhatFeedbackText.replace(\n      /\\[percent\\]/gi,\n      _objScoreData['intPercentage']\n    );\n\n    _strWhatFeedbackText = _strWhatFeedbackText.replace(\n      /\\[correct\\]/gi,\n      _objScoreData['intCorrect']\n    );\n    _strWhatFeedbackText = _strWhatFeedbackText.replace(/\\[right\\]/gi, _objScoreData['intCorrect']);\n\n    _strWhatFeedbackText = _strWhatFeedbackText.replace(\n      /\\[incorrect\\]/gi,\n      _objScoreData['intWrong']\n    );\n    _strWhatFeedbackText = _strWhatFeedbackText.replace(/\\[wrong\\]/gi, _objScoreData['intWrong']);\n\n    _strWhatFeedbackText = _strWhatFeedbackText.replace(/\\[total\\]/gi, _objScoreData['intTotal']);\n    _strWhatFeedbackText = _strWhatFeedbackText.replace(/\\[max\\]/gi, _objScoreData['intTotal']);\n\n    if (_objScoreData['intCorrect'] > 1) {\n      _strWhatFeedbackText = _strWhatFeedbackText.replace(/\\[s\\]/gi, 's');\n    } else {\n      _strWhatFeedbackText = _strWhatFeedbackText.replace(/\\[s\\]/gi, '');\n    }\n\n    if (_objScoreData['intWrong'] > 1) {\n      _strWhatFeedbackText = _strWhatFeedbackText.replace(/\\[ws\\]/gi, 's');\n    } else {\n      _strWhatFeedbackText = _strWhatFeedbackText.replace(/\\[ws\\]/gi, '');\n    }\n\n    return _strWhatFeedbackText;\n  },\n\n  _reset_assessmentresults_Asset: function(_objWhatAssetData, _booFullReset) {},\n\n  _checkCompletion_assessmentresults_Asset: function() {\n    return true;\n  }\n};\nO_EXTENDER.extend(ASSET_INTERACTIONS, ASSESSMENT_RESULTS_ASSET_INTERACTIONS);\n"},function(t,n,e){e(0)(e(75))},function(t,n){t.exports="/* global ASSET_INTERACTIONS, O_EXTENDER, CORE, ASSET_RENDERER, ASSET_INTERACTIONS */\n/* global TOPIC_INTERACTIONS, DECONTAMINATER, BOO_SHOW_CORRECTNESS_ICONS_ON_CONFIRM_CLICK */\n/* global EM, BOO_HIDE_NEXT_UNTIL_CONFIRM, $, LOCALISER, _, BOO_SINGLE_ATTEMPT_IN_ASSESSMENT */\n/* global VARIABLES_HOLDER, gomo */\n/**\n * @title input text asset extension collection\n * @description A series of objects designed to extend the ASSET_INSPECTOR and ASSET_RENDERER\n * object literals via the O_EXTENDER object to be able to process the inputtext asset type.\n *\n * @author Caroline Wilgar\n * @version 2.0 [25/05/2012]\n *\n */\n\nvar objCurrSupportData = {\n  graphicalC: true,\n  accessibleC: true,\n  tabletC: true,\n  smartphoneC: true\n};\nASSET_RENDERER.addAssetSupportData('textinput', objCurrSupportData);\n\nvar TEXT_INPUT_ASSET_RENDERER = {\n  strObjID: 'The text input asset renderer extension object',\n\n  // ***************************** Property extensions *****************************\n  _arrAssetHTMLTemplateIDs: [\n    ['textAreaInput', 'textInputAssetTextAreaTemplateWrapperC'],\n    ['textInput', 'textInputAssetInputTemplateWrapperC']\n  ],\n\n  // ***************************** Render methods extensions *****************************\n  _render_textinput_Asset: function(_objRenderData) {\n    var _objWhatAssetCourseObject = _objRenderData.objWhatAssetCourseObject;\n\n    var _objWhatRawAssetData = _objWhatAssetCourseObject.objRawData;\n    _objWhatRawAssetData.additionalTrackingData = {\n      activity: {},\n      result: {},\n      response: {}\n    };\n\n    if (this._objAssetTemplates['textAreaInput'] || this._objAssetTemplates['textInput']) {\n      var _htmReturnData = this._objAssetTemplates['textAreaInput'];\n      if (_objWhatRawAssetData.strFormat === 'singleLine') {\n        _htmReturnData = this._objAssetTemplates['textInput'];\n      }\n\n      _htmReturnData = _htmReturnData.replace(\n        'XX_DEFAULT_INPUT_TEXT_XX',\n        VARIABLES_HOLDER.parseHTMLForVariableMarkup(_objWhatRawAssetData.strInitialText, true)\n      );\n      _htmReturnData = _htmReturnData.replace(\n        'XX_ROW_COUNT_XX',\n        this._textinputGetRowCount(_objWhatRawAssetData)\n      );\n      _htmReturnData = _htmReturnData.replace(\n        'XX_QUESTION_BUTTONS_XX',\n        this._generateQuestionButtons(_objWhatRawAssetData, true)\n      );\n      _htmReturnData = _htmReturnData.replace(\n        /XX_ASSET_ID_XX/g,\n        'YY' + _objWhatRawAssetData['strID'] + 'YY'\n      );\n      return _htmReturnData;\n    } else {\n      this.debug(\n        'ASSET_RENDERER._renderTextInputAsset(), ERROR: Unknown asset type of ' +\n          _objWhatRawAssetData['strType'] +\n          '.',\n        3\n      );\n      return 'Asset Error, no template found, ID: ' + _objWhatRawAssetData['strID'];\n    }\n  },\n\n  _textinputGetRowCount: function(_objWhatRawAssetData) {\n    var intRowCount = 1;\n    if (_objWhatRawAssetData.strFormat === 'multiLine') {\n      intRowCount = 5;\n    }\n    return intRowCount;\n  }\n};\nO_EXTENDER.extend(ASSET_RENDERER, TEXT_INPUT_ASSET_RENDERER);\n\nvar TEXT_INPUT_ASSET_INTERACTIONS = {\n  strObjID: 'The text input asset interactions extension object',\n\n  _strTextAreaClass: 'textInputAreaC',\n  _strCorrectnessClass: 'correctnessMarkerC',\n\n  _performPreShowActions_textinput_Asset: function(assetData) {\n    var rawData = assetData.objRawData;\n    var assetElement = ASSET_RENDERER.getAssetDOMElement(rawData);\n    rawData.additionalTrackingData.response.timeAvailable = new Date();\n\n    // Check for subscreen actions and add the appropriate aria value\n    if (gomo.utility.checkForShowSubscreenAction(rawData.arrCorrectActions)\n      || gomo.utility.checkForShowSubscreenAction(rawData.arrFinalIncorrectActions)\n      || gomo.utility.checkForShowSubscreenAction(rawData.arrFirstIncorrectActions)\n      || gomo.utility.checkForShowSubscreenAction(rawData.arrActions)) {\n      $(assetElement)\n        .find('.confirmButtonC')\n        .attr('aria-haspopup', 'dialog');\n    }\n  },\n\n  handleEvent_textInputChangeAttempted: function(_objWhatTextData) {\n    var _objWhatAssetData = this.getAssetData(_objWhatTextData._strWhatAssetID);\n    if (!_objWhatAssetData.booInteractable) {\n      return false;\n    }\n    return true; // having return boo onkeydown seems to stop event entirely\n  },\n\n  handleEvent_textInputRemoveDefaultText: function(_objWhatTextData) {\n    var _objWhatAssetData = this.getAssetData(_objWhatTextData._strWhatAssetID);\n    var decomtaminatedTextValue = _objWhatTextData._domTextArea.value;\n    if (decomtaminatedTextValue == _objWhatAssetData.objRawData.strInitialText) {\n      _objWhatTextData._domTextArea.value = '';\n    }\n  },\n\n  handleEvent_textinputConfirmButtonClicked: function(_strWhatAssetID) {\n    var _objWhatAssetData = this.getAssetData(_strWhatAssetID);\n    var _objRawData = _objWhatAssetData.objRawData;\n    var unlimitedAttempts = false;\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objWhatAssetData.objRawData);\n    var _domTextArea = CORE.getElementsByClassName(_domWhatAssetElement, this._strTextAreaClass)[0];\n\n    if (_objRawData.strInitialText === _domTextArea.value) {\n      LOCALISER.l_alert('TEXTINPUT_NO_ATTEMPT');\n      return;\n    }\n\n    if (_objWhatAssetData.objRawData.strAttempts === '0') {\n      unlimitedAttempts = true;\n    }\n\n    if (!_objWhatAssetData.booInteractable) {\n      return false;\n    }\n\n    _objWhatAssetData.objOptionStates.textValue = _domTextArea.value;\n\n    if (_objWhatAssetData.objOptionStates.textValue) {\n      _objWhatAssetData.booInteractable = false;\n      _domTextArea.disabled = true;\n\n      _objWhatAssetData.intUsersQuestionAttempts++;\n\n      _objWhatAssetData.booIsCorrect = (\n        _objRawData.strCorrectAnswer == '' ||\n        this._textInputIsCorrect(\n          _objRawData.strCorrectAnswer,\n          _objWhatAssetData.objOptionStates.textValue\n        )\n      );\n      if (_objWhatAssetData.objRawData && _objWhatAssetData.objRawData.booAssessed === 'Yes') {\n        var additionalTrackingData = _objWhatAssetData.objRawData.additionalTrackingData;\n        additionalTrackingData.activity.type = 'fill-in';\n        additionalTrackingData.activity.correctResponses = _objRawData.strCorrectAnswer.split('||');\n        var associatedAsset = _objRawData.strAssociatedAssetId ?\n          ASSET_INTERACTIONS.getAssetData(_objRawData.strAssociatedAssetId)\n          :\n          null;\n        additionalTrackingData.activity.description =\n          ASSET_INTERACTIONS.getAssetContent(associatedAsset);\n        additionalTrackingData.activity.weighting = parseInt(_objRawData.strWeighting) || 1;\n        additionalTrackingData.result.detail =\n          _objWhatAssetData.booIsCorrect ? 'correct' : 'incorrect';\n        additionalTrackingData.response.timeResponse = new Date();\n        additionalTrackingData.response.detail = _objWhatAssetData.objOptionStates.textValue;\n        additionalTrackingData.id =_strWhatAssetID;\n\n        TOPIC_INTERACTIONS.addAnsweredQuestionAssetToTopic(\n          _objWhatAssetData,\n          _objWhatAssetData.objRawData.additionalTrackingData\n        );\n      }\n      if (BOO_SINGLE_ATTEMPT_IN_ASSESSMENT) {\n        _objWhatAssetData.objRawData.strAttempts = 1;\n      }\n      var strAdditionalStyles = null;\n      var _arrActions = null;\n      if (_objWhatAssetData.booIsCorrect) {\n        _arrActions = _objWhatAssetData.objRawData.arrCorrectActions;\n        strAdditionalStyles = 'correctFeedbackSubScreenC';\n        strAdditionalStyles +=\n          ' ' +\n          ASSET_INTERACTIONS.strClassPrefixAssetPosition(_objWhatAssetData) +\n          '_CorrectFeedbackSubScreenC';\n      } else if (\n        !_objWhatAssetData.booIsCorrect &&\n        (_objWhatAssetData.intUsersQuestionAttempts < _objWhatAssetData.objRawData.strAttempts ||\n          unlimitedAttempts)\n      ) {\n        /*\n        * First incorrect response if...\n        * the anser is wrong\n        * And the attempt is less that allowed attempt. Or the user has unlimited attempts\n        */\n        _arrActions = _objWhatAssetData.objRawData.arrFirstIncorrectActions;\n        strAdditionalStyles = 'incorrectFeedbackSubScreenC';\n        strAdditionalStyles +=\n          ' ' +\n          ASSET_INTERACTIONS.strClassPrefixAssetPosition(_objWhatAssetData) +\n          '_IncorrectFeedbackSubScreenC';\n      } else {\n        // Final incorrect response\n        _arrActions = _objWhatAssetData.objRawData.arrFinalIncorrectActions;\n        strAdditionalStyles = 'incorrectFeedbackSubScreenC';\n        strAdditionalStyles +=\n          ' ' +\n          ASSET_INTERACTIONS.strClassPrefixAssetPosition(_objWhatAssetData) +\n          '_IncorrectFeedbackSubScreenC';\n      }\n\n      if (\n        _objWhatAssetData.intUsersQuestionAttempts == _objWhatAssetData.objRawData.strAttempts ||\n        _objWhatAssetData.booIsCorrect\n      ) {\n        this._deactivateButtons(_objWhatAssetData);\n        EM.trigger('questionMaxAttemptsReached');\n        this._textInputShowCorrectness(_objWhatAssetData, _domWhatAssetElement);\n      } else {\n        this._showQuestionResetButton(_objWhatAssetData);\n      }\n\n      this.setVariablesToGlobal(_objWhatAssetData);\n\n      EM.trigger('screenAssetInteracting', _objWhatAssetData);\n\n      var selectedButton = $(_domWhatAssetElement).find('.contentButtonNormC.visibleButtonC')[0];\n      if (_arrActions != 'null') {\n        var _objActionOptions = {};\n        _objActionOptions.objActions = _arrActions;\n        _objActionOptions.objOptionalExtraData = _objWhatAssetData;\n        _objActionOptions.objOptionalExtraData.strType = _objWhatAssetData.strAssetType;\n        _objActionOptions.objOptionalExtraData.strAdditionalStyles = strAdditionalStyles;\n        _objActionOptions.objOptionalExtraData.strAssetID = _objWhatAssetData.strObjID;\n        _objActionOptions.objOptionalExtraData.domLink = selectedButton;\n\n        EM.trigger('processActions', _objActionOptions);\n      }\n\n      if (_objRawData.arrActions && _objRawData.arrActions.length\n        && _objWhatAssetData.booComplete) {\n        ASSET_INTERACTIONS.processAssetActions(_objWhatAssetData);\n      }\n\n      if (BOO_HIDE_NEXT_UNTIL_CONFIRM) {\n        EM.trigger('showNextButtonFromAsset');\n      }\n    } else {\n      LOCALISER.l_alert('TEXTINPUT_NO_ATTEMPT');\n    }\n  },\n\n  _performLanguagePreprocess_textinput_Asset: function(_objWhatAssetData) {\n    var assetId = _objWhatAssetData.objRawData.strID;\n    var countTopic = 0;\n\n    gomo.translationManager.htmlDecodeAssetTranslations(_objWhatAssetData.strObjID, [\n      'strInitialText'\n    ]);\n\n    if (gomo.translationManager.topicsData) {\n      // Check each topic\n      while (countTopic < gomo.translationManager.topicsData.length) {\n        if (\n          gomo.translationManager.topicsData[countTopic].topic &&\n          gomo.translationManager.topicsData[countTopic].topic.screens\n        ) {\n          var assets = gomo.translationManager.findAllAssets(\n            gomo.translationManager.topicsData[countTopic].topic.screens\n          );\n          var found = _.findWhere(assets, {\n            id: assetId\n          });\n\n          // Translate answers to test against\n          if (found && found.strCorrectAnswer) {\n            _objWhatAssetData.objRawData.strCorrectAnswer = found.strCorrectAnswer;\n          }\n          // Translate text to return to on asset reset\n          if (found && found.strInitialText) {\n            _objWhatAssetData.objRawData.strInitialText = found.strInitialText;\n          }\n\n          if (found) {\n            break;\n          }\n        }\n        countTopic++;\n      }\n    }\n\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objWhatAssetData.objRawData);\n    if (_domWhatAssetElement) {\n      var _domTextArea = CORE.getElementsByClassName(\n        _domWhatAssetElement,\n        this._strTextAreaClass\n      )[0];\n\n      _domTextArea.value = _objWhatAssetData.objRawData.strInitialText;\n    }\n  },\n\n  _reset_textinput_QuestionAsset: function(_strWhatAssetID) {\n    this._resetStandardQuestion(_strWhatAssetID);\n\n    var _objWhatAssetData = this.getAssetData(_strWhatAssetID);\n\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objWhatAssetData.objRawData);\n    var _domTextArea = CORE.getElementsByClassName(_domWhatAssetElement, this._strTextAreaClass)[0];\n\n    _domTextArea.value = _objWhatAssetData.objRawData.strInitialText;\n    _domTextArea.disabled = false;\n\n    this._showQuestionConfirmButton(_objWhatAssetData);\n  },\n\n  _textInputIsCorrect: function(strCorrectAnswers, strUserInput) {\n    var booCorrectInput = false;\n    var arrCorrectAnswers = strCorrectAnswers.split('||');\n    var decomtaminatedUserInput = gomo.utility.decodeHtml(strUserInput.toLowerCase());\n\n    var count = 0;\n    while (count < arrCorrectAnswers.length) {\n      var strCorrectAnswer = gomo.utility.decodeHtml(arrCorrectAnswers[count].toLowerCase());\n      if (strCorrectAnswer === decomtaminatedUserInput) {\n        booCorrectInput = true;\n        break;\n      }\n      count++;\n    }\n\n    return booCorrectInput;\n  },\n\n  _textInputShowCorrectness: function(objWhatAssetData, domCurrentAsset) {\n    if (BOO_SHOW_CORRECTNESS_ICONS_ON_CONFIRM_CLICK) {\n      var domCorrectnessMarker = CORE.getElementsByClassName(\n        domCurrentAsset,\n        this._strCorrectnessClass\n      )[0];\n      if (objWhatAssetData.booIsCorrect) {\n        $(domCurrentAsset).addClass('correct-option');\n        domCorrectnessMarker.className = domCorrectnessMarker.className.replace(\n          'unSetCorrectnessC',\n          'correctAnswerC'\n        );\n      } else {\n        $(domCurrentAsset).addClass('incorrect-option');\n        domCorrectnessMarker.className = domCorrectnessMarker.className.replace(\n          'unSetCorrectnessC',\n          'incorrectAnswerC'\n        );\n      }\n    }\n  },\n\n  showTEXTINPUTfeedback: function(_objWhatAssetData) {\n    if (\n      _objWhatAssetData.objRawData.arrFeedbackActions.length > 0 &&\n      _objWhatAssetData.objRawData.arrFeedbackActions[0].objParameters &&\n      _objWhatAssetData.objRawData.arrFeedbackActions[0].objParameters.strSubScreenID\n    ) {\n      EM.trigger('showSubScreen', {\n        strAssetID: _objWhatAssetData.strObjID,\n        strTargetSubScreenID:\n          _objWhatAssetData.objRawData.arrFeedbackActions[0].objParameters.strSubScreenID\n      });\n    }\n  },\n\n  is_textinput_AssetCompletable: function(_objWhatAssetData) {\n    return true;\n  },\n\n  _decomtaminatedTextinputString: function(_strRaw) {\n    var objDecontaminaterResult = DECONTAMINATER.clean(_strRaw);\n\n    return objDecontaminaterResult.strText;\n  },\n\n  _viewQuestionAnswer_textinput_questionType: function(_objWhatAssetData) {\n    this.showTEXTINPUTfeedback(_objWhatAssetData);\n  },\n\n  _doPostRenderShowActions_textinput_Asset: function(_objWhatAssetData) {\n    TOPIC_INTERACTIONS.removeAnsweredQuestionAssetToTopic(_objWhatAssetData);\n    if (_objWhatAssetData.objRawData && _objWhatAssetData.objRawData.booAssessed === 'Yes') {\n      TOPIC_INTERACTIONS.addViewedQuestionAssetToTopic(_objWhatAssetData);\n    }\n    // Set asset id in element html for _scrollIntoView_Asset\n    var elementSelector =\n      '#' + ASSET_RENDERER.getAssetDOMId(_objWhatAssetData.objRawData) + ' textarea';\n    ASSET_INTERACTIONS._setScrollIntoView_Asset(\n      elementSelector,\n      _objWhatAssetData.objRawData.strID\n    );\n\n    var el = $(elementSelector);\n    if (el && el.length) {\n      // Trigger _scrollIntoView_Asset on clicking the textarea\n      el.click(function() {\n        ASSET_INTERACTIONS._scrollIntoView_Asset(this);\n      });\n      el.blur(function() {\n        ASSET_INTERACTIONS._scrollIntoViewReset_Asset();\n      });\n    }\n  },\n\n  _reset_textinput_Asset: function(_objWhatAssetData, _booFullReset) {\n    // Parse the string for special characters\n    _objWhatAssetData.objRawData.strInitialText = gomo.utility.decodeHtml(\n      _objWhatAssetData.objRawData.strInitialText\n    );\n\n    var _domWhatAssetElement = ASSET_RENDERER.getAssetDOMElement(_objWhatAssetData.objRawData);\n    if (_domWhatAssetElement) {\n      var _domTextArea = CORE.getElementsByClassName(\n        _domWhatAssetElement,\n        this._strTextAreaClass\n      )[0];\n\n      _domTextArea.value = _objWhatAssetData.objRawData.strInitialText;\n      _domTextArea.disabled = false;\n\n      this._resetUserQuestionAttempts(_objWhatAssetData);\n      this._showQuestionConfirmButton(_objWhatAssetData);\n      this._resetStandardQuestion(_objWhatAssetData.strObjID);\n      // Reset correctness markers and active confrim/reset.\n      $(_domWhatAssetElement).find('.correctnessMarkerC').removeClass().addClass(\n        'unSetCorrectnessC correctnessMarkerC'\n      );\n      $(_domWhatAssetElement).removeClass('correct-option incorrect-option');\n      this._activateButtons(_objWhatAssetData);\n    }\n  },\n\n  _returnFocusToTEXTINPUTAsset: function(_domWhatAssetElement) {\n    this._focusConfirmButton(_domWhatAssetElement);\n  },\n\n  _checkCompletion_textinput_Asset: function(_objWhatAssetData) {\n    return (_objWhatAssetData.intUsersQuestionAttempts >= _objWhatAssetData.objRawData.strAttempts\n      || _objWhatAssetData.booIsCorrect);\n  },\n\n  getAccessibleElements_textinput: function() {\n    var accessibleElements = ['.textInputAreaC', '.activeButtonC'];\n    return accessibleElements;\n  }\n};\nO_EXTENDER.extend(ASSET_INTERACTIONS, TEXT_INPUT_ASSET_INTERACTIONS);\n"}]);